

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangxiaowang">
  <meta name="keywords" content="">
  
    <meta name="description" content="Solidity中的变量类型 **值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。 **引用类型(Reference Type)**：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。 映射类型(Mapping Type): Solidity中存储键值对的数据结构，可以理解为哈希表  我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介">
<meta property="og:type" content="article">
<meta property="og:title" content="Solidity笔记之基础变量">
<meta property="og:url" content="http://example.com/2025/04/22/08-1Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/index.html">
<meta property="og:site_name" content="Wang">
<meta property="og:description" content="Solidity中的变量类型 **值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。 **引用类型(Reference Type)**：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。 映射类型(Mapping Type): Solidity中存储键值对的数据结构，可以理解为哈希表  我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web3/eth2.jpg">
<meta property="article:published_time" content="2025-04-22T02:04:31.000Z">
<meta property="article:modified_time" content="2025-06-20T04:23:54.058Z">
<meta property="article:author" content="Wangxiaowang">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/web3/eth2.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Solidity笔记之基础变量 - Wang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"37fd8385820c4abc0e564a2c423b7511","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?37fd8385820c4abc0e564a2c423b7511";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/web3/solidity1.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Solidity笔记之基础变量"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-22 10:04" pubdate>
          2025年4月22日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Solidity笔记之基础变量</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Solidity中的变量类型"><a href="#Solidity中的变量类型" class="headerlink" title="Solidity中的变量类型"></a>Solidity中的变量类型</h1><ol>
<li>**值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。</li>
<li>**引用类型(Reference Type)**：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。</li>
<li><strong>映射类型(Mapping Type)</strong>: Solidity中存储键值对的数据结构，可以理解为哈希表</li>
</ol>
<p>我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介绍值类型。</p>
<h1 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2. 值类型"></a>2. 值类型</h1><h3 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1. 布尔型"></a>1. 布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 布尔值<br>bool public _bool = true; <br>//类型 公有 值名称=值<br></code></pre></td></tr></table></figure>



<p>布尔值的运算符包括：</p>
<ul>
<li><code>!</code> （逻辑非）</li>
<li><code>&amp;&amp;</code> （逻辑与，”and”）</li>
<li><code>||</code> （逻辑或，”or”）</li>
<li><code>==</code> （等于）</li>
<li><code>!=</code> （不等于）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 布尔运算<br>bool public _bool1 = !_bool; // 取非<br>bool public _bool2 = _bool &amp;&amp; _bool1; // 与<br>bool public _bool3 = _bool || _bool1; // 或<br>bool public _bool4 = _bool == _bool1; // 相等<br>bool public _bool5 = _bool != _bool1; // 不相等<br></code></pre></td></tr></table></figure>



<p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p>
<p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p>
<h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>整型是 Solidity 中的整数，最常用的包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 整型<br>int public _int = -1; // 整数，包括负数<br>uint public _uint = 1; // 无符号整数<br>uint256 public _number = 20220330; // 256位无符号整数<br></code></pre></td></tr></table></figure>



<p>常用的整型运算符包括：</p>
<ul>
<li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li>
<li>算术运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 整数运算<br>uint256 public _number1 = _number + 1; // +，-，*，/<br>uint256 public _number2 = 2**2; // 指数<br>uint256 public _number3 = 7 % 2; // 取余数<br>bool public _numberbool = _number2 &gt; _number3; // 比大小<br></code></pre></td></tr></table></figure>



<p>大家可以运行一下代码，看看这 4 个变量分别是多少。</p>
<h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h3><p>地址类型有两类：</p>
<ul>
<li>普通地址: 存储一个 20 字节的值（以太坊地址的大小）。</li>
<li>Payable address ：比普通地址多了<code>transfer</code>和<code>send</code>两个成员方法，用于接收转账。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 地址<br>address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;<br>address payable public _address1 = payable(_address); // payable address，可以转账、查余额<br>// 地址类型的成员<br>uint256 public balance = _address1.balance; // balance of address<br></code></pre></td></tr></table></figure>

<h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p>字节数组氛围定长和不定长两种</p>
<ul>
<li>定长字节数组：属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组最多存储 32 bytes 数据，即<code>bytes32</code>。</li>
<li><strong>不定长字节数组</strong>: 属于引用类型（之后的章节介绍），数组长度在声明之后可以改变，包括 <code>bytes</code> 等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 固定长度的字节数组<br>bytes32 public _byte32 = &quot;MiniSolidity&quot;; // 字节形式<br>bytes1 public _byte = _byte32[0]; // 取其第一个字节<br></code></pre></td></tr></table></figure>



<p>在上述代码中，字符串 <code>MiniSolidity</code> 以字节的方式存储进变量 <code>_byte32</code>。如果把它转换成 <code>16 进制</code>，就是：<code>0x4d696e69536f6c69646974790000000000000000000000000000000000000000</code></p>
<p><code>_byte</code> 变量的值为 <code>_byte32</code> 的第一个字节，即 <code>0x4d</code>。</p>
<h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h3><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// 用<span class="hljs-keyword">enum</span>将uint <span class="hljs-number">0</span>， <span class="hljs-number">1</span>， <span class="hljs-number">2</span>表示为Buy, Hold, Sell<br><span class="hljs-keyword">enum</span> ActionSet &#123; Buy, Hold, Sell &#125;<br>// 创建<span class="hljs-keyword">enum</span>变量 <span class="hljs-keyword">action</span><br>ActionSet <span class="hljs-keyword">action</span> = ActionSet.Buy;<br></code></pre></td></tr></table></figure>



<p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的无符号整数是否在枚举的长度内，否则会报错：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// enum可以和uint显式的转换</span><br>function <span class="hljs-built_in">enumToUint</span>() external view <span class="hljs-built_in">returns</span>(uint)&#123;<br>    return <span class="hljs-built_in">uint</span>(action);<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong><code>enum</code> 是一个比较冷门的数据类型，几乎没什么人用。</strong></p>
<h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们先看一下 Solidity 中函数的形式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function &lt;function name&gt;([parameter types[, ...]]) &#123;internal|external|public|private&#125; [pure|view|payable] [virtual|override] [&lt;modifiers&gt;]<br>[returns (&lt;return types&gt;)]&#123; &lt;function body&gt; &#125;<br></code></pre></td></tr></table></figure>



<p>看着有一些复杂，让我们从前往后逐个解释(方括号中的是可写可不 写的关键字)：</p>
<ol>
<li><p><code>function</code>：声明函数时的固定用法。要编写函数，就需要以 <code>function</code> 关键字开头。</p>
</li>
<li><p><code>&lt;function name&gt;</code>：函数名。</p>
</li>
<li><p><code>([parameter types[, ...]])</code>：圆括号内写入函数的参数，即输入到函数的变量类型和名称。</p>
</li>
<li><p><code>&#123;internal|external|public|private&#125;</code>：函数可见性说明符，共有4种。</p>
<ul>
<li><code>public</code>：内部和外部均可见。</li>
<li><code>private</code>：只能从本合约内部访问，继承的合约也不能使用。</li>
<li><code>external</code>：只能从合约外部访问（但内部可以通过 <code>this.f()</code> 来调用，<code>f</code>是函数名）。</li>
<li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li>
</ul>
<p><strong>注意 1</strong>：合约中定义的函数需要明确指定可见性，它们没有默认值。</p>
<p><strong>注意 2</strong>：<code>public|private|internal</code> 也可用于修饰状态变量(定义可参考<a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/[../05_DataStorage/readme.md#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F](https:/github.com/AmazingAng/WTF-Solidity/tree/main/05_DataStorage#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F)">WTF Solidity 第5讲的相关内容</a>)。<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。未标明可见性类型的状态变量，默认为<code>internal</code>。</p>
</li>
<li><p><code>[pure|view|payable]</code>：决定函数权限&#x2F;功能的关键字。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。<code>pure</code> 和 <code>view</code> 的介绍见下一节。</p>
</li>
<li><p><code>[virtual|override]</code>: 方法是否可以被重写，或者是否是重写方法。<code>virtual</code>用在父合约上，标识的方法可以被子合约重写。<code>override</code>用在子合约上，表名方法重写了父合约的方法。</p>
</li>
<li><p><code>&lt;modifiers&gt;</code>: 自定义的修饰器，可以有0个或多个修饰器。</p>
</li>
<li><p><code>[returns ()]</code>：函数返回的变量类型和名称。</p>
</li>
<li><p><code>&lt;function body&gt;</code>: 函数体。</p>
</li>
</ol>
<h2 id="Solidity-函数可见性关键字"><a href="#Solidity-函数可见性关键字" class="headerlink" title="Solidity 函数可见性关键字"></a>Solidity 函数可见性关键字</h2><table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
<th>谁能调用</th>
<th>访问方式示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>public</code></td>
<td>函数对所有人可见，既可以内部调用，也可以外部调用</td>
<td>合约内部、派生合约、合约外部</td>
<td>直接调用、合约外部调用</td>
</tr>
<tr>
<td><code>external</code></td>
<td>函数只能被合约外部调用，不能用 <code>this.xxx()</code> 形式内部调用（但可以通过低级调用调用）</td>
<td>合约外部调用</td>
<td>合约外部调用，不能内部普通调用</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>函数只能在合约内部或派生合约中调用</td>
<td>合约内部、派生合约</td>
<td>内部调用、继承合约调用</td>
</tr>
<tr>
<td><code>private</code></td>
<td>函数只能在定义它的合约内部调用，派生合约也不能访问</td>
<td>仅合约内部</td>
<td>仅合约内部调用</td>
</tr>
</tbody></table>
<hr>
<h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h2 id="到底什么是-Pure-和View？"><a href="#到底什么是-Pure-和View？" class="headerlink" title="到底什么是 Pure 和View？"></a>到底什么是 <code>Pure</code> 和<code>View</code>？</h2><p>刚开始学习 <code>solidity</code> 时，<code>pure</code> 和 <code>view</code> 关键字可能令人费解，因为其他编程语言中没有类似的关键字。<code>solidity</code> 引入这两个关键字主要是因为 以太坊交易需要支付气费（gas fee）。合约的状态变量存储在链上，gas fee 很贵，如果计算不改变链上状态，就可以不用付 <code>gas</code>。包含 <code>pure</code> 和 <code>view</code> 关键字的函数是不改写链上状态的，因此用户直接调用它们是不需要付 gas 的（注意，合约中非 <code>pure</code>&#x2F;<code>view</code> 函数调用 <code>pure</code>&#x2F;<code>view</code> 函数时需要付gas）。</p>
<p>在以太坊中，以下语句被视为修改链上状态：</p>
<ol>
<li>写入状态变量。</li>
<li>释放事件。</li>
<li>创建其他合约。</li>
<li>使用 <code>selfdestruct</code>.</li>
<li>通过调用发送以太币。</li>
<li>调用任何未标记 <code>view</code> 或 <code>pure</code> 的函数。</li>
<li>使用低级调用（low-level calls）。</li>
<li>使用包含某些操作码的内联汇编。</li>
</ol>
<ul>
<li><code>pure</code>，中文意思是“纯”，这里可以理解为”纯打酱油的”。<code>pure</code> 函数既不能读取也不能写入链上的状态变量。就像小怪一样，看不到也摸不到碧琪公主。</li>
<li><code>view</code>，“看”，这里可以理解为“看客”。<code>view</code>函数能读取但也不能写入状态变量。类似马里奥，能看到碧琪公主，但终究是看客，不能入洞房。</li>
<li>非 <code>pure</code> 或 <code>view</code> 的函数既可以读取也可以写入状态变量。类似马里奥里的 <code>boss</code>，可以对碧琪公主为所欲为🐶。</li>
</ul>
<h1 id="4-函数输出"><a href="#4-函数输出" class="headerlink" title="4. 函数输出"></a>4. 函数输出</h1><h2 id="返回值：return-和-returns"><a href="#返回值：return-和-returns" class="headerlink" title="返回值：return 和 returns"></a>返回值：return 和 returns</h2><p>在函数定义行中有两个关键字<code>return</code>和<code>returns</code>，他们区别是：</p>
<ul>
<li><code>return</code>跟在函数名后面，用于声明返回的变量类型以及变量名称</li>
<li><code>return</code>:用于函数主题中，返回指定的变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 返回多个变量<br>function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;<br>    return(1, true, [uint256(1),2,5]);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上述代码中，我们利用 <code>returns</code> 关键字声明了有多个返回值的 <code>returnMultiple()</code> 函数，然后我们在函数主体中使用 <code>return(1, true, [uint256(1),2,5])</code> 确定了返回值。</p>
<p>这里<code>uint256[3]</code>声明了一个长度为<code>3</code>且类型为<code>uint256</code>的数组作为返回值。因为<code>[1,2,3]</code>会默认为<code>uint8(3)</code>，因此<code>[uint256(1),2,5]</code>中首个元素必须强转</p>
<h2 id="命名式返回"><a href="#命名式返回" class="headerlink" title="命名式返回"></a>命名式返回</h2><p>我们可以在 <code>returns</code> 中标明返回变量的名称。Solidity 会初始化这些变量，并且自动返回这些变量的值，无需使用 <code>return</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 命名式返回<br>function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;<br>    _number = 2;<br>    _bool = false;<br>    _array = [uint256(3),2,1];<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在上述代码中，我们用 <code>returns(uint256 _number, bool _bool, uint256[3] memory _array)</code> 声明了返回变量类型以及变量名。这样，在主体中只需为变量 <code>_number</code>、<code>_bool</code>和<code>_array</code> 赋值，即可自动返回。</p>
<p>当然，你也可以在命名式返回中用 <code>return</code> 来返回变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 命名式返回，依然支持return<br>function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;<br>    return(1, true, [uint256(1),2,5]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h2><p>Solidity 支持使用解构式赋值规则来读取函数的全部或部分返回值。</p>
<ul>
<li><p>读取所有返回值：声明变量，然后将要赋值的变量用<code>,</code>隔开，按顺序排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 _number;<br>bool _bool;<br>uint256[3] memory _array;<br>(_number, _bool, _array) = returnNamed();<br></code></pre></td></tr></table></figure>


</li>
<li><p>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。在下面的代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(, _bool2, ) = returnNamed();<br></code></pre></td></tr></table></figure></li>
</ul>
<p>如果两个币种发生较大汇率的变化就会有损失</p>
<h1 id="5-变量数据存储和作用域"><a href="#5-变量数据存储和作用域" class="headerlink" title="5. 变量数据存储和作用域"></a>5. 变量数据存储和作用域</h1><p>引用类型(Reference Type) ：包括数组(array)和结构体(struct)，由于这类变量的类型比较复杂且占用空间比较大，所以使用的时候必须要声明数据所存储的位置，</p>
<h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>数据的位置包含三种类型<code>storage</code>,<code>memory</code>,<code>calldata</code></p>
<ul>
<li><p><code>storage</code>：合约里的状态变量默认是storage，存储在链上的，类似计算机的硬盘—一种持久化存储，由链帮你持久化，所以影响了链，所以消耗的gas比较大</p>
</li>
<li><p><code>memory</code>:函数里的参数和临时使用的变量一般用memory，见名知意，内存，存储在内存中的，不上链，尤其是当返回数据类型是<strong>变长</strong>的情况下，必须加memory修饰，例如：string,bytes，array和自定义结构，</p>
</li>
<li><p><code>calldata</code>：和<code>memory</code>类似，也是储存在内存中，不上链，不同点是不能修寒这个变量，一般用于函数的参数，入参进来后不会被改变：如</p>
</li>
<li><pre><code class="solidity">function fCallData(uint[] calldata _x)public pure returns (uint[] calldata) &#123;
        // _x[0]=0; // 当你修改的时候，就会报错TypeError: Calldata arrays are read-only.
        return (_x);
    &#125;
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">### 数据位置和赋值规则</span><br><br>赋值的本质是创建引用指向本土，因此修改本体或者是修改引用，变化可以被同步<br><br>- `storage`(合约的状态变量)赋值给本地`storage`（函数里的）时候，会创建引用，改变新变量会影响原来的变量。例如a<br><br>```solidity<br>    <span class="hljs-built_in">uint</span>[] x =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-function">function <span class="hljs-title">sStorage</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-built_in">uint</span>[] storage xStorage = x; <span class="hljs-comment">// xStorage是uint[]类型，位置是storage，引用了x，当修改xStorage的时候，x也会被修改，</span><br>        xStorage[<span class="hljs-number">0</span>]=<span class="hljs-number">101</span>;<span class="hljs-comment">//当我们调用了Sstorage方法的时候就xStorage以及x的第1个元素改成100，</span><br>        <span class="hljs-comment">// 在debug的时候可以看到x的第1个元素一开是1 ，后面变成了100</span><br>        <br>    &#125;<br>    <span class="hljs-comment">// 为了更方便观察。写了一个getX方法来查询x的值，当调用了sStorage后x的第一个元素就变成了101了；</span><br>    <span class="hljs-function">function <span class="hljs-title">getX</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>[] memory</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (x);<br>    &#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>uint[] y  =[1,2,3]; // 在函数之外定义的变量，默认就是stroage类型的，<br><br><br>function yMemory() public view &#123;<br>    uint[] memory ymemory = y; // y是storage类的，ymemory是引用了y，所以修改ymemory的时候不会修改到y<br>    ymemory[0]=101;<br>    <br>&#125;<br>// 我们调用getY的时候就会发现，其实yMemory方法并不能修改y的值，这就是引用<br>function getY() public view returns (uint[] memory)&#123;<br>    return (y);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>其他情况下，赋值创建的是本体的副本，即对二者之一的修改，并不会同步到另一方。这有时会涉及到开发中的问题，比如从<code>storage</code>中读取数据，赋值给<code>memory</code>，然后修改<code>memory</code>的数据，但如果没有将<code>memory</code>的数据赋值回<code>storage</code>，那么<code>storage</code>的数据是不会改变的。上面的例子就是指的其他情况，是storage 类型被memory类型改变，实际是改变不成功的</li>
<li>还有一种情况就是memory类型的被memory类型的修改，这个暂时还不知道怎么打印</li>
</ul>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>前面收的storage和memory讨论的是变量存储的位置，以及引用的方式，就像理解指针和引用一样，下面来学变量的作用域，所谓所用域就是指这个变量在哪里可以用它</p>
<p><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</p>
<h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h3><p>状态变量是数据存储在链上的变量，所有合约内函数都可以访问，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Variables &#123;<br>     // 2.变量的作用域<br>    // 2.1 状态变量： 链上的变量：写在合约里面函数外面的变量，就是状态变量，在所有合约内函数都可以访问，同样gas的消耗也高<br>    uint public a=1;<br>    uint public b;<br>    string public z;// 这些变量都是状态变量，同时，这些变量会自带有get方法去查看他们的值，（数组没有自带get）<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们可以在函数里更改状态变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function foo() external&#123;<br>    // 可以在函数里更改状态变量的值<br>    x = 5;<br>    y = 2;<br>    z = &quot;0xAA&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> // 2.2 局部变量，这个就很好理解了，就是在函数内部定义的变量，只作用的函数内，出去了就没用啦<br>function bar() external pure returns(uint)&#123;<br>    uint xx = 1;<br>    uint yy = 3;<br>    uint zz = xx + yy;<br>    return(zz);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 2.3 全局变量，这里的全局变量和py不同，这里指的是solidity预留关键字的变量，他们可以在函数内不声明直接使用<br>   function global()external view returns(address,uint,bytes32,bytes memory)  &#123;<br>       address sender=msg.sender; // 发送者的地址，猜测应该是调用这个合约的人的地址,address是一种类型<br>       uint blockNum = block.number; // 当前区块高度？<br>       bytes32 bHash = blockhash(blockNum - 1); // 获取区块哈希<br>       bytes memory data=msg.data; //这个没用过 ,byte是类型，memory是位置<br>       return (sender,blockNum,bHash,data);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>下面是一些常用的全局变量，更完整的列表请看这个<a target="_blank" rel="noopener" href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</p>
<ul>
<li><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>) 给定区块的哈希值 – 只适用于最近的256个区块, 不包含当前区块。</li>
<li><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</li>
<li><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</li>
<li><code>block.number</code>: (<code>uint</code>) 当前区块的number</li>
<li><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</li>
<li><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</li>
<li><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</li>
<li><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</li>
<li><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</li>
<li><code>msg.value</code>: (<code>uint</code>) 当前交易发送的 <code>wei</code> 值</li>
<li><code>block.blobbasefee</code>: (<code>uint</code>) 当前区块的blob基础费用。这是Cancun升级新增的全局变量。</li>
<li><code>blobhash(uint index)</code>: (<code>bytes32</code>) 返回跟当前交易关联的第 <code>index</code> 个blob的版本化哈希（第一个字节为版本号，当前为<code>0x01</code>，后面接KZG承诺的SHA256哈希的最后31个字节）。若当前交易不包含blob，则返回空字节。这是Cancun升级新增的全局变量。</li>
</ul>
<h3 id="4-全局变量-以太单位与时间单位"><a href="#4-全局变量-以太单位与时间单位" class="headerlink" title="4. 全局变量-以太单位与时间单位"></a>4. 全局变量-以太单位与时间单位</h3><h4 id="以太单位"><a href="#以太单位" class="headerlink" title="以太单位"></a>以太单位</h4><p><code>Solidity</code>中不存在小数点，以<code>0</code>代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易。</p>
<ul>
<li><code>wei</code>: 1</li>
<li><code>gwei</code>: 1e9 &#x3D; 1000000000</li>
<li><code>ether</code>: 1e18 &#x3D; 1000000000000000000</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 以太坊没有小数点，用0代替为小数点来确保交易的精度，为了防止精度的损失，利用一台单位可以避免误算，<br>  // wei : 1<br>  // gwei : 1e9 =1000000000<br>  // ether : 1e18 = 100000000000000000<br>  function weiUit()external pure returns(uint)  &#123;<br>      assert(1 wei ==1e0);<br>      assert(1 wei == 1);<br>      // return 1 wei; // 调用的时候就看到返回了1，<br>      return 1 gwei; // 试试看返回什么 返回 <br>  &#125;<br>  function gweiUit()external pure returns(uint)  &#123;<br>      assert(1 gwei ==1e9);<br>      assert(1 gwei == 1000000000); // 如果assert错误，调用的时候会报错的嘿嘿<br>      <br>      return 1 gwei; // 试试看返回什么 返回  1000000000<br>  &#125;<br>  function etherUit()external pure returns(uint)  &#123;<br>      assert(1 ether ==1e18);<br>      assert(1 ether == 1000000000000000000);<br>      // return 1 wei; // 调用的时候就看到返回了1，<br>      return 1 ether; // 试试看返回什么 返回  1000000000000000000<br>  &#125;<br></code></pre></td></tr></table></figure>



<h4 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h4><p>可以在合约中规定一个操作必须在一周内完成，或者某个事件在一个月后发生。这样就能让合约的执行可以更加精确，不会因为技术上的误差而影响合约的结果。因此，时间单位在<code>Solidity</code>中是一个重要的概念，有助于提高合约的可读性和可维护性。</p>
<ul>
<li><code>seconds</code>: 1</li>
<li><code>minutes</code>: 60 seconds &#x3D; 60</li>
<li><code>hours</code>: 60 minutes &#x3D; 3600</li>
<li><code>days</code>: 24 hours &#x3D; 86400</li>
<li><code>weeks</code>: 7 days &#x3D; 604800</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function secondsUnit() external pure returns(uint) &#123;<br>    assert(1 seconds == 1);<br>    return 1 seconds;<br>&#125;<br><br>function minutesUnit() external pure returns(uint) &#123;<br>    assert(1 minutes == 60);<br>    assert(1 minutes == 60 seconds);<br>    return 1 minutes;<br>&#125;<br><br>function hoursUnit() external pure returns(uint) &#123;<br>    assert(1 hours == 3600);<br>    assert(1 hours == 60 minutes);<br>    return 1 hours;<br>&#125;<br><br>function daysUnit() external pure returns(uint) &#123;<br>    assert(1 days == 86400);<br>    assert(1 days == 24 hours);<br>    return 1 days;<br>&#125;<br><br>function weeksUnit() external pure returns(uint) &#123;<br>    assert(1 weeks == 604800);<br>    assert(1 weeks == 7 days);<br>    return 1 weeks;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>在这一讲，我们介绍了<code>Solidity</code>中的引用类型，数据位置和变量的作用域。重点是<code>storage</code>, <code>memory</code>和<code>calldata</code>三个关键字的用法。他们出现的原因是为了节省链上有限的存储空间和降低<code>gas</code>。下一讲我们会介绍引用类型中的数组。</p>
<h1 id="6-引用类型-array-struct"><a href="#6-引用类型-array-struct" class="headerlink" title="6. 引用类型, array, struct"></a>6. 引用类型, array, struct</h1><p>数组（<code>Array</code>）是<code>Solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种：</p>
<ul>
<li><p>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 固定长度 Array<br>uint[8] array1;<br>bytes1[5] array2;<br>address[100] array3;<br></code></pre></td></tr></table></figure>


</li>
<li><p>可变长度数组（动态数组）：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 可变长度 Array<br>uint[] array4;<br>bytes1[] array5;<br>address[] array6;<br>bytes array7;<br></code></pre></td></tr></table></figure>



<p><strong>注意</strong>：<code>bytes</code>比较特殊，是数组，但是不用加<code>[]</code>。另外，不能用<code>byte[]</code>声明单字节数组，可以使用<code>bytes</code>或<code>bytes1[]</code>。<code>bytes</code> 比 <code>bytes1[]</code> 省gas。</p>
</li>
</ul>
<h3 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h3><p>在Solidity里，创建数组有一些规则：</p>
<ul>
<li><p>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// memory动态数组<br>uint[] memory array8 = new uint[](5);<br>bytes memory array9 = new bytes(9);<br></code></pre></td></tr></table></figure>


</li>
<li><p>数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如<code>[1,2,3]</code>里面所有的元素都是<code>uint8</code>类型，因为在Solidity中，如果一个值没有指定type的话，会根据上下文推断出元素的类型，默认就是最小单位的type，这里默认最小单位类型是<code>uint8</code>。而<code>[uint(1),2,3]</code>里面的元素都是<code>uint</code>类型，因为第一个元素指定了是<code>uint</code>类型了，里面每一个元素的type都以第一个元素为准。</p>
<p>下面的例子中，如果没有对传入 <code>g()</code> 函数的数组进行 <code>uint</code> 转换，是会报错的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.4.16 &lt;0.9.0;<br><br>contract C &#123;<br>    function f() public pure &#123;<br>        g([uint(1), 2, 3]);<br>    &#125;<br>    function g(uint[3] memory _data) public pure &#123;<br>        // ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>如果创建的是动态数组，你需要一个一个元素的赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[] memory x = new uint[](3);<br>x[0] = 1;<br>x[1] = 3;<br>x[2] = 4;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h3><ul>
<li><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</li>
<li><code>push()</code>: <code>动态数组</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素，并返回该元素的引用。</li>
<li><code>push(x)</code>: <code>动态数组</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</li>
<li><code>pop()</code>: <code>动态数组</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</li>
</ul>
<h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p><code>Solidity</code>支持通过构造结构体的形式定义新的类型。结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 结构体<br>struct Student&#123;<br>    uint256 id;<br>    uint256 score; <br>&#125;<br><br>Student student; // 初始一个student结构体<br></code></pre></td></tr></table></figure>



<p>给结构体赋值的四种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//  给结构体赋值<br>// 方法1:在函数中创建一个storage的struct引用<br> // 4 结构体，顾名思义，各种数据类型组合的结构体，结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法：<br>    struct Student&#123;<br>        uint256 id;<br>        uint256 score;<br>    &#125;<br>    Student student; // 舒适化这个结构体，待会下面会用到的<br>    // 4.1 方法1: 给结构体赋值方式一：<br>    function initStudent1()external  &#123;<br>        Student storage _student=student ;// storage状态变量，链上存储<br>        _student.id=11;<br>        _student.score=100; // debug的时候会发现，当程序走到这里的时候 student的属性发生了改变<br>    &#125;<br>    // 4.2 方法2:直接引用状态变量的struct<br>    function initStudent2() external&#123;   <br>        student.id = 1;<br>        student.score = 80;<br>    &#125;<br>    // 4.3 方法3:构造函数式，类似与类的初始化<br>    function initStudent3() external &#123;<br>        student = Student(3, 90);<br>    &#125;<br>    // 方法4:key value<br>    function initStudent4() external &#123;<br>        student =Student(<br>            &#123;<br>                id:4,<br>                score:50<br>            &#125;<br>        );<br>    &#125;<br></code></pre></td></tr></table></figure>



<h1 id="7-映射类型-mapping"><a href="#7-映射类型-mapping" class="headerlink" title="7. 映射类型 mapping"></a>7. 映射类型 mapping</h1><h2 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h2><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p>
<p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint =&gt; address) public idToAddress; // id映射到地址<br>mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址<br></code></pre></td></tr></table></figure>



<h2 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h2><p>​    &#x2F;&#x2F; 1、map 的key 只能是solidity 内置类型，值可以用自定义的结构体</p>
<p>​    &#x2F;&#x2F; 2、map的存储位置必须是storage 因此可以用于合约的状态变量、函数中的storage的变量和librry函数的参数</p>
<p>​    &#x2F;&#x2F; 但是不能用于public函数的啊参数或者返回值，因为map记录的是一种key-value的关系</p>
<p>​    &#x2F;&#x2F; 3、如果映射声明为public 那么solidity会自动为此变量创建一个getter函数来让你通过key来查询value</p>
<p>​    &#x2F;&#x2F; 4、增加键值对的语法为 ： Var[_Key] &#x3D; _Value,其中_Var是映射变量名，_Key和_Value对应新增的键值对</p>
<h2 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h2><ul>
<li><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li>
<li><strong>原理2</strong>: 对于映射使用<code>keccak256(h(key) . slot)</code>计算存取value的位置。感兴趣的可以去阅读 <a target="_blank" rel="noopener" href="https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage">WTF Solidity 内部规则: 映射存储布局</a></li>
<li><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function writeMap(uint _Key,address _Value)public  &#123;<br>    idToAddress[_Key]=_Value;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="8-变量初始值"><a href="#8-变量初始值" class="headerlink" title="8. 变量初始值"></a>8. 变量初始值</h1><p>Solidity 和go 一样，声明但没赋值的变量都有它的初始值或者默认值，</p>
<h2 id="值类型变量的初始值"><a href="#值类型变量的初始值" class="headerlink" title="值类型变量的初始值"></a>值类型变量的初始值</h2><ul>
<li><p><code>boolean</code>: <code>false</code></p>
</li>
<li><p><code>string</code>: <code>&quot;&quot;</code></p>
</li>
<li><p><code>int</code>: <code>0</code></p>
</li>
<li><p><code>uint</code>: <code>0</code></p>
</li>
<li><p><code>enum</code>: 枚举中的第一个元素</p>
</li>
<li><p><code>address</code>: <code>0x0000000000000000000000000000000000000000</code> (或 <code>address(0)</code>)</p>
</li>
<li><pre><code class="hljs">function
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  - `<span class="hljs-keyword">internal</span>`: 空白函数<br>  - `external`: 空白函数<br><br>可以用<span class="hljs-keyword">public</span>变量的getter函数验证初始值<br><br>```solidity<br>contract InitialValue &#123;<br>    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">public</span> _bool;<br>    <span class="hljs-built_in">string</span> <span class="hljs-keyword">public</span> _string;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">public</span> _int;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> _uint;<br>    address <span class="hljs-keyword">public</span> _address;<span class="hljs-comment">//0x0000000000000000000000000000000000000000</span><br>    <span class="hljs-function">function <span class="hljs-title">fi</span>()<span class="hljs-keyword">internal</span></span> &#123;&#125;<span class="hljs-comment">//fi 内部函数无法调用</span><br>    <span class="hljs-function">function <span class="hljs-title">fe</span>()external</span> &#123;&#125;<span class="hljs-comment">// 空白函数</span><br>&#125;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="引用类型初始值"><a href="#引用类型初始值" class="headerlink" title="引用类型初始值"></a>引用类型初始值</h3><ul>
<li>映射<code>mapping</code>: 所有元素都为其默认值的<code>mapping</code></li>
<li>结构体<code>struct</code>: 所有成员设为其默认值的结构体</li>
<li>数组array<ul>
<li>动态数组: <code>[]</code></li>
<li>静态数组（定长）: 所有成员设为其默认值的静态数组</li>
</ul>
</li>
</ul>
<p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p>
<p><code>delete</code>操作符</p>
<p><code>delete a </code>会让变量<code>a</code>的值变为初始值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 3 delete操作符<br>bool public _bool2=true;<br>function fd()external &#123;<br>    delete _bool2;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="9-常数-constant和immutable"><a href="#9-常数-constant和immutable" class="headerlink" title="9. 常数 constant和immutable"></a>9. 常数 constant和immutable</h1><p><code>constant</code>:常数,</p>
<p><code>immutable</code>：不变量</p>
<p>只有数值类型的可以声明称constant 和 immutable ；</p>
<p><code>string</code>和<code>bytes</code>可以声明为constant 但不能为immutable;</p>
<p><code>constant</code>变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。</p>
<p><code>immutable</code>变量可以在声明时或构造函数中初始化，因此更加灵活。在<code>Solidity v0.8.21</code>以后，<code>immutable</code>变量不需要显式初始化，未显式初始化的<code>immutable</code>变量将使用数值类型的初始值（见 <a target="_blank" rel="noopener" href="https://github.com/AmazingAng/WTF-Solidity/blob/main/08_InitialValue/readme.md#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC">8. 变量初始值</a>）。反之，则需要显式初始化。 若<code>immutable</code>变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Solidity笔记之基础变量</div>
      <div>http://example.com/2025/04/22/08-1Solidity笔记之变量类型/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wangxiaowang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月22日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/28/08-2Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C/" title="08-2Solidity笔记之二控制流">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">08-2Solidity笔记之二控制流</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/04/22/08-1Solidity%E7%AC%94%E8%AE%B0/" title="Solidity笔记之基础变量">
                        <span class="hidden-mobile">Solidity笔记之基础变量</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QE69Ypw2FdG2cP7zRWgtj8ii-gzGzoHsz","appKey":"p8TvvzGc2rQ02TfZHuJppQLO","path":"window.location.pathname","placeholder":"欢迎留下评论，嘿嘿！","avatar":"monsterid","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"QE69Ypw2FdG2cP7zRWgtj8ii-gzGzoHsz","appkey":"p8TvvzGc2rQ02TfZHuJppQLO"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
