

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangxiaowang">
  <meta name="keywords" content="">
  
    <meta name="description" content="HD钱包助记词生成与验证1.助记词生成原理1.1.随机熵生成 首先生成一段随机熵（Entropy）。熵的长度可以是 128 到 256 位，并且是 32 的倍数。常见的熵长度有 128 位（12 个助记词）和 256 位（24 个助记词）。每增加3个单词， 12个助记词对应128位熵，15个对应160位熵，18个对应192，21个对应224位，24个对应256， 每增加3个单词，增加32位熵， 随">
<meta property="og:type" content="article">
<meta property="og:title" content="04 HD钱包助记词生成与验证">
<meta property="og:url" content="http://example.com/2024/05/25/04HD%E9%92%B1%E5%8C%85%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90/index.html">
<meta property="og:site_name" content="Wang">
<meta property="og:description" content="HD钱包助记词生成与验证1.助记词生成原理1.1.随机熵生成 首先生成一段随机熵（Entropy）。熵的长度可以是 128 到 256 位，并且是 32 的倍数。常见的熵长度有 128 位（12 个助记词）和 256 位（24 个助记词）。每增加3个单词， 12个助记词对应128位熵，15个对应160位熵，18个对应192，21个对应224位，24个对应256， 每增加3个单词，增加32位熵， 随">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web3/encryption3.jpg">
<meta property="article:published_time" content="2024-05-25T11:06:59.000Z">
<meta property="article:modified_time" content="2025-06-20T04:23:54.056Z">
<meta property="article:author" content="Wangxiaowang">
<meta property="article:tag" content="block">
<meta property="article:tag" content="实战">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/web3/encryption3.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>04 HD钱包助记词生成与验证 - Wang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"37fd8385820c4abc0e564a2c423b7511","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?37fd8385820c4abc0e564a2c423b7511";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/web3/bitcoin4.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="04 HD钱包助记词生成与验证"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-25 19:06" pubdate>
          2024年5月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          53 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">04 HD钱包助记词生成与验证</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="HD钱包助记词生成与验证"><a href="#HD钱包助记词生成与验证" class="headerlink" title="HD钱包助记词生成与验证"></a>HD钱包助记词生成与验证</h1><h2 id="1-助记词生成原理"><a href="#1-助记词生成原理" class="headerlink" title="1.助记词生成原理"></a>1.助记词生成原理</h2><p><strong>1.1.随机熵生成</strong> 首先生成一段随机<strong>熵</strong>（Entropy）。熵的长度可以是 128 到 256 位，并且是 32 的倍数。常见的熵长度有 128 位（12 个助记词）和 256 位（24 个助记词）。每增加3个单词，</p>
<p>12个助记词对应128位熵，15个对应160位熵，18个对应192，21个对应224位，24个对应256，</p>
<p>每增加3个单词，增加32位熵，</p>
<p>随机熵的生成32</p>
<p><strong>1.2.计算校验和</strong> 对熵进行 <strong>SHA-256 哈希</strong>计算，并取哈希值的前几位作为校验和。校验和的<strong>长度</strong>取决于熵的长度。&#x3D;熵的长度 ÷ 32，除以32后得到的值就是他要校验的位数</p>
<p>例如，128 位熵需要 <strong>4 位</strong>校验和（因为 128 &#x2F; 32 &#x3D; 4），256 位熵需要 8 位校验和。160&#x2F;32&#x3D;5，192&#x2F;32&#x3D;6，224&#x2F;32&#x3D;7……</p>
<p><strong>1.3.组合熵和校验</strong> 将校验和附加到熵的<strong>末尾</strong>，形成一个新的<strong>二进制序列</strong>。这个序列的总长度为 (熵的长度 + 校验和的长度)。</p>
<p><strong>1.4.分割为助记词索引</strong> 将组合后的二进制序列分割成每组 11 位的片段，每个片段转换为一个数字，这个数字作为助记词列表中的索引。</p>
<p><strong>1.5.映射为助记词</strong> 使用这些索引从预定义的 <strong>2048 个</strong>助记词列表（<strong>BIP-39</strong> 词库）中提取相应的助记词。这些助记词就是最终的助记词短语</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成助记词</span><br><br><span class="hljs-comment"># 1.1.随机熵生成</span><br><span class="hljs-comment"># 首先生成一段随机熵（Entropy）。熵的长度可以是 128 到 256 位，并且是 32 的倍数。常见的熵长度有 128 位（12 个助记词）和 256 位（24 个助记词）。</span><br><br><br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> bip39<br><br><span class="hljs-comment"># 1.1.随机熵生成</span><br><span class="hljs-comment"># entropy = os.urandom(16) </span><br><span class="hljs-comment"># os模块的生成16位的随机字节，这里是生成128位的熵，128位的熵就是16字节8位一个字节，128位的熵生成的是12个助记词</span><br><span class="hljs-comment"># 同理，如果我现在要15个词的助记词，那就是对应128+32=160位的熵，除以8位字节就是20个字节，</span><br><span class="hljs-comment"># 同理：如果我现在要18个词的助记词，那就是对应的160+32=192位的熵，除以8个字节就是24个字节</span><br>entropy = <span class="hljs-string">b&#x27;\xfb\xe50\xc5\x84\xb6\x06&#123;.n\x12\x06SN\xb5\x82&#x27;</span><br><span class="hljs-built_in">print</span>(entropy)<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.2.计算校验和</span><br><span class="hljs-string">对熵进行 SHA-256 哈希计算，并取哈希值的前几位作为校验和。sub scrip table</span><br><span class="hljs-string">校验和的长度取决于熵的长度。例如，128 位熵需要 4 位校验和（因为 128 / 32 = 4），256 位熵需要 8 位校验和</span><br><span class="hljs-string">最后截取前4位出来即可</span><br><span class="hljs-string">如果是128+32=160位熵，160÷32=5位校验和，那就要提取前5位出来</span><br><span class="hljs-string">如果是160+32=192位熵，192÷32=6位校验和，那就要提取前6位出来</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">#首先，hashlib.sha256(entropy)创建一个SHA-256哈希算法对象，并将entropy作为输入进行哈希计算。</span><br><span class="hljs-comment"># 然后，.digest()方法被调用，返回计算得到的哈希结果的二进制表示。这个二进制表示是一个字节数组（bytes），长度为32字节（256位），表示SHA-256算法对输入数据的哈希结果。</span><br>hash_bytes = hashlib.sha256(entropy).digest()<br><span class="hljs-built_in">print</span>(hash_bytes) <span class="hljs-comment"># b&#x27;s\xf7\xc9z\x88\xf0\x7f\x0f\xf0`(\xe4\xd6\x92@\xa9?\xa2os~\xbe*\x86\xe7w\x97D\xf8Z&quot;\xb4&#x27;</span><br><span class="hljs-comment"># entropy_sha256[0]表示entropy_sha256的第一个字节，它是一个整数值。</span><br><span class="hljs-comment"># bin(entropy_sha256[0])将该整数值转换为对应的二进制字符串，返回的字符串以0b开头，例如0b11001010。</span><br><span class="hljs-comment"># [2:]是对二进制字符串进行切片操作，去掉开头的0b，例如11001010。</span><br><span class="hljs-comment"># .zfill(8)将二进制字符串填充到8位，不足的位数在开头补零，例如11001010变为11001010。</span><br><span class="hljs-comment"># [:4]是对二进制字符串进行切片操作，截取前4位，例如11001010变为1100。</span><br><span class="hljs-comment"># 结果被赋值给变量entropy_bin，表示对entropy_sha256的第一个字节进行处理后得到的二进制字符串，长度为4位。</span><br>checksum_bits = <span class="hljs-built_in">bin</span>(hash_bytes[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)[:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(checksum_bits) <span class="hljs-comment"># 0111</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.3.组合熵和校验</span><br><span class="hljs-string">将校验和附加到熵的末尾，形成一个新的二进制序列。这个序列的总长度为 (熵的长度 + 校验和的长度)。</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 这里bin(byte)后的[2:]是切掉0b开头，zfill(8)是填充，如果长度没有8位就填充0</span><br>entropy_bits = <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">bin</span>(byte)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)<br>                       <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> entropy])  <span class="hljs-comment"># 这一步是生成校验和</span><br><span class="hljs-built_in">print</span>(entropy_bits) <span class="hljs-comment"># 一堆0101</span><br><span class="hljs-comment"># 把校验和拼接到熵的末尾</span><br>combined_bits = entropy_bits + checksum_bits<br><span class="hljs-built_in">print</span>(combined_bits) <span class="hljs-comment"># 一堆0101</span><br><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.4 分割为助记词索引，等下去助记词库里面那助记词</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># range(0, len(combined_bits), 11)创建一个迭代范围，从0开始，每次增加11，直到达到combined_bits的长度之前的最大值。</span><br><span class="hljs-comment"># combined_bits[i:i + 11]是对combined_bits进行切片，从索引i开始，切片长度为11，得到一个11位的二进制字符串。</span><br><span class="hljs-comment"># int(combined_bits[i:i + 11], 2)将切片得到的二进制字符串作为参数传递给int()函数，并指定进制为2，将二进制字符串转换为对应的整数值。</span><br>indices = [<span class="hljs-built_in">int</span>(combined_bits[i:i + <span class="hljs-number">11</span>], <span class="hljs-number">2</span>)<br>           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(combined_bits), <span class="hljs-number">11</span>)] <span class="hljs-comment"># 11是步长，[i:i+11]表示往后面取11位</span><br><span class="hljs-built_in">print</span>(indices)  <span class="hljs-comment"># 这是一个列表，里面有12个数字索引，</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1.5 映射为助记词，就是通过上面的索引列表去助记词库里面拿到对应的助记词</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>wordlist = bip39.INDEX_TO_WORD_TABLE  <span class="hljs-comment"># bip39.INDEX_TO_WORD_TABLE 返回出来的是2048个助记词单词组成的元组</span><br><br>mnemonic = <span class="hljs-string">&#x27; &#x27;</span>.join(wordlist[index] <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> indices)<br><span class="hljs-built_in">print</span>(mnemonic)<br></code></pre></td></tr></table></figure>

<h1 id="二-助记词验证过程"><a href="#二-助记词验证过程" class="headerlink" title="二. 助记词验证过程"></a>二. 助记词验证过程</h1><h2 id="2-1-助记词验证原理-或-流程"><a href="#2-1-助记词验证原理-或-流程" class="headerlink" title="2.1 助记词验证原理 或 流程"></a>2.1 助记词验证原理 或 流程</h2><h3 id="2-1-1-检查单词数量"><a href="#2-1-1-检查单词数量" class="headerlink" title="2.1.1 检查单词数量"></a>2.1.1 检查单词数量</h3><p> 第一步肯定是检查单词数量，因为助记词的单词数量通常是 12、15、18、21 或 24 个单词。如果不是，则不在这些范围内。</p>
<h3 id="2-2-2-检查单词是否在词表中"><a href="#2-2-2-检查单词是否在词表中" class="headerlink" title="2.2.2 检查单词是否在词表中"></a>2.2.2 检查单词是否在词表中</h3><p>第二步是检查单词是否都在bip39的2048个单词的词汇表中，如果不是则错</p>
<h3 id="2-2-3-将助记词转化为位串"><a href="#2-2-3-将助记词转化为位串" class="headerlink" title="2.2.3 将助记词转化为位串"></a>2.2.3 将助记词转化为位串</h3><p>将每个助记词的单词转换成它在bip39词汇表中对应的索引位，每个索引都表示一个11位的二进制数（0101码）</p>
<p>将所有的二进制数连接起来形成一个位串</p>
<h3 id="2-2-4-提取种子和校验和"><a href="#2-2-4-提取种子和校验和" class="headerlink" title="2.2.4 提取种子和校验和"></a>2.2.4 提取种子和校验和</h3><p>位串的长度应该是助记词单词数乘以11，例如12个单词的助记词对应的位串长度为132位，位串的前128位是种子，后4为是校验和。</p>
<h3 id="2-2-5-计算校验和"><a href="#2-2-5-计算校验和" class="headerlink" title="2.2.5 计算校验和"></a>2.2.5 计算校验和</h3><p>将种子通过SHA-256哈希函数计算处一个哈希值，然后取哈希值的前4位作为计算得到的校验和。</p>
<h3 id="2-2-6-验证校验和"><a href="#2-2-6-验证校验和" class="headerlink" title="2.2.6 验证校验和"></a>2.2.6 验证校验和</h3><p>比较提取的校验和 和 计算得到的校验和。如果两者匹配，则助记词有效，否则无效</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bip39<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_mnemonic</span>(<span class="hljs-params">mnemonic, wordlist</span>):<br>    words = mnemonic.split()<br>    <br>    <span class="hljs-comment"># 检查单词数量</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(words) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-comment"># 检查单词是否在词汇表中</span><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>        <span class="hljs-keyword">if</span> word <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> wordlist:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-comment"># 将助记词转化成位串</span><br>    binary_string = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>        index = wordlist.index(word)<br>        binary_string += <span class="hljs-built_in">format</span>(index, <span class="hljs-string">&#x27;011b&#x27;</span>) <span class="hljs-comment"># format(index, &#x27;011b&#x27;) 的含义是将 index 格式化为 11 位的二进制字符串，不足 11 位的部分在前面用零填充。</span><br>    <span class="hljs-built_in">print</span>(binary_string)<br>    <span class="hljs-comment"># 提取种子和校验和</span><br>    <span class="hljs-comment"># 计算种子部分的长度。根据给定的单词列表 words 的长度，每个单词占用 11 位的二进制字符串，除以 3 取整数部分表示校验和的长度。通过减去校验和的长度，得到种子部分的长度。</span><br>    seed_bits_length = (<span class="hljs-built_in">len</span>(words) * <span class="hljs-number">11</span>) - (<span class="hljs-built_in">len</span>(words) // <span class="hljs-number">3</span>) <span class="hljs-comment"># </span><br>    <span class="hljs-comment"># 从 binary_string 中提取种子部分。使用切片操作 [:seed_bits_length]，获取从开头到种子部分长度的子字符串。</span><br>    seed_bits = binary_string[:seed_bits_length]<br>    <span class="hljs-comment"># 从 binary_string 中提取校验和部分。使用切片操作 [seed_bits_length:]，获取从种子部分长度开始到末尾的子字符串。</span><br>    checksum_bits = binary_string[seed_bits_length:]<br>    <br>    <br>    <span class="hljs-comment"># 计算校验和</span><br>    <span class="hljs-keyword">import</span> hashlib<br>    <span class="hljs-comment"># 将种子部分的二进制字符串 seed_bits 转换为字节串。</span><br>    <span class="hljs-comment"># 首先，使用 int(seed_bits, 2) 将二进制字符串转换为整数。</span><br>    <span class="hljs-comment"># 然后，使用 to_bytes(len(seed_bits) // 8, byteorder=&#x27;big&#x27;) 将整数转换为字节串，</span><br>    <span class="hljs-comment"># 其中 len(seed_bits) // 8 表示字节串的长度，byteorder=&#x27;big&#x27; 表示使用大端字节序。</span><br>    seed_bytes = <span class="hljs-built_in">int</span>(seed_bits, <span class="hljs-number">2</span>).to_bytes(<span class="hljs-built_in">len</span>(seed_bits) // <span class="hljs-number">8</span>, byteorder=<span class="hljs-string">&#x27;big&#x27;</span>)<br>    <span class="hljs-comment"># 对种子字节串 seed_bytes 进行 SHA-256 哈希计算，并获取哈希结果的十六进制表示。</span><br>    <span class="hljs-comment"># 使用 hashlib.sha256() 创建 SHA-256 哈希算法对象，然后调用 .hexdigest() 方法获取哈希结果的十六进制字符串表示。</span><br>    hash_value = hashlib.sha256(seed_bytes).hexdigest()<br>    <span class="hljs-comment"># 将哈希结果的十六进制字符串 hash_value 转换为 256 位的二进制字符串。</span><br>    <span class="hljs-comment"># 首先，使用 int(hash_value, 16) 将十六进制字符串转换为整数。</span><br>    <span class="hljs-comment"># 然后，使用 bin() 将整数转换为二进制字符串，去掉开头的 &#x27;0b&#x27;，并使用 zfill(256) 在前面填充零，使其长度达到 256 位。</span><br>    hash_bits = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(hash_value, <span class="hljs-number">16</span>))[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">256</span>)<br>    <span class="hljs-comment"># 提取校验和部分。使用切片操作 [:len(words) // 3]，获取从二进制字符串 hash_bits 的开头到校验和长度的子字符串。校验和长度为单词列表 words 的长度除以 3。</span><br>    calculated_checksum = hash_bits[:<span class="hljs-built_in">len</span>(words) // <span class="hljs-number">3</span>]<br>    <br>    <span class="hljs-comment"># 验证校验和，判断助记词转换的位串与计算得来的校验和一致</span><br>    <span class="hljs-keyword">return</span> checksum_bits == calculated_checksum<br><br><span class="hljs-comment"># Example usage:</span><br>mnemonic = <span class="hljs-string">&quot;legal winner thank year wave sausage worth useful legal winner thank yellow&quot;</span><br>wordlist = bip39.INDEX_TO_WORD_TABLE  <span class="hljs-comment"># BIP-39 wordlist</span><br>is_valid = validate_mnemonic(mnemonic, wordlist)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Is valid mnemonic:&quot;</span>, is_valid)<br></code></pre></td></tr></table></figure>

<h1 id="三-编码解码过程"><a href="#三-编码解码过程" class="headerlink" title="三. 编码解码过程"></a>三. 编码解码过程</h1><h1 id="四-调用-BIP-39-词库生成助记词"><a href="#四-调用-BIP-39-词库生成助记词" class="headerlink" title="四. 调用 BIP-39 词库生成助记词"></a>四. 调用 BIP-39 词库生成助记词</h1><h2 id="4-1-代码封装"><a href="#4-1-代码封装" class="headerlink" title="4.1 代码封装"></a>4.1 代码封装</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bip39Mnemonic</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">createMnemonic</span>(<span class="hljs-params">self, number</span>):<br>        mnemonic = bip39.get_entropy_bits(number)<br>        <span class="hljs-keyword">return</span> mnemonic<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mnemonicToEntropy</span>(<span class="hljs-params">self,  mnemonic</span>):<br>        decode_words = bip39.decode_phrase( mnemonic)<br>        <span class="hljs-keyword">return</span> decode_words<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">entropyToMnemonic</span>(<span class="hljs-params">self, entropy</span>):<br>        nemonic_entropy = bip39.encode_bytes(entropy)<br>        <span class="hljs-keyword">return</span> nemonic_entropy<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mnemonicToSeed</span>(<span class="hljs-params">self, mnemonic</span>):<br>        nemonic_to_seed = bip39.phrase_to_seed(mnemonic)<br>        <span class="hljs-keyword">return</span> nemonic_to_seed<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">validateMnemonic</span>(<span class="hljs-params">self, mnemonic</span>):<br>        <span class="hljs-keyword">return</span> bip39.check_phrase(mnemonic)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateMnemonic</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 1. 生成 128 位随机熵 (16 字节)</span><br>        entropy = os.urandom(<span class="hljs-number">16</span>)<br><br>        <span class="hljs-comment"># 2. 计算校验和 (SHA-256)</span><br>        hash_bytes = hashlib.sha256(entropy).digest()<br>        checksum_bits = <span class="hljs-built_in">bin</span>(hash_bytes[<span class="hljs-number">0</span>])[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>)[:<span class="hljs-number">4</span>]  <span class="hljs-comment"># 取前 4 位</span><br><br>        <span class="hljs-comment"># 3. 组合熵和校验和</span><br>        entropy_bits = <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">bin</span>(byte)[<span class="hljs-number">2</span>:].zfill(<span class="hljs-number">8</span>) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> entropy])<br>        combined_bits = entropy_bits + checksum_bits<br><br>        <span class="hljs-comment"># 4. 分割为助记词索引</span><br>        indices = [<span class="hljs-built_in">int</span>(combined_bits[i:i + <span class="hljs-number">11</span>], <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(combined_bits), <span class="hljs-number">11</span>)]<br><br>        <span class="hljs-comment"># 5. 映射为助记词</span><br>        wordlist = bip39.INDEX_TO_WORD_TABLE<br>        mnemonic = <span class="hljs-string">&#x27; &#x27;</span>.join([wordlist[index] <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> indices])<br><br>        <span class="hljs-keyword">return</span> mnemonic<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> bip<br><br><span class="hljs-keyword">import</span> bip<br><br>bip39_mnemonic = bip.Bip39Mnemonic()<br>mnemonic_phrase = bip39_mnemonic.generateMnemonic()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Generated mnemonic phrase: <span class="hljs-subst">&#123;mnemonic_phrase&#125;</span>&quot;</span>)<br><br>mnemonic_12_phrase = bip39_mnemonic.createMnemonic(<span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;create mnemonic phrase: <span class="hljs-subst">&#123;mnemonic_12_phrase&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>1、助记词生成code，加密之后存储在本地设备，</p>
<p>2、如果要备份或导出助记词，就要把code转成助记词</p>
<p>3、bip39 还可以用来验证助记词是否有效。</p>
<p>4、助记词变成随机种子，然后再去导出</p>
<p>5、生成助记词的方法</p>
<p>bip39–</p>
<h1 id="私钥对应关系"><a href="#私钥对应关系" class="headerlink" title="私钥对应关系"></a>私钥对应关系</h1><p><img src="/img/web3/privkey.png" srcset="/img/loading.gif" lazyload></p>
<p>椭圆曲线是什么：</p>
<p>以太坊和比特币使用完全相同的椭圆曲线：<code>secp256k1</code>，公钥就是这个椭圆曲线上的(x, y)坐标，x，y 数值通过私钥唯一确定。</p>
<p>x、y 各 32 字节，故公钥为 64 字节。你可能会看到 65 字节表示的公钥，这是由 SECG 发布的行业标准的一种序列化编码方式，在最前面加一个字节的前缀，04 表示公钥为非压缩格式，即完整存储了 x 和 y 的坐标各 32 字节。</p>
<p>通过go语言生成私钥和公钥还有地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;crypto/elliptic&quot;</span><br>    <span class="hljs-string">&quot;crypto/rand&quot;</span><br>    <span class="hljs-string">&quot;encoding/hex&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/ethereum/go-ethereum/common&quot;</span><br>    <span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span><br>    <span class="hljs-string">&quot;github.com/ethereum/go-ethereum/crypto/secp256k1&quot;</span><br>)<br></code></pre></td></tr></table></figure>

<p>生成一个椭圆曲线</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">curve := secp256k1.S256()<br></code></pre></td></tr></table></figure>

<p>3 生成私钥（32byte）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, curve.Params().N.BitLen()/<span class="hljs-number">8</span>)<br>io.ReadFull(rand.Reader, b)<br>key := <span class="hljs-built_in">new</span>(big.Int).SetBytes(b) <span class="hljs-comment">// key就是私钥</span><br><br><span class="hljs-comment">// 打印私钥</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, <span class="hljs-built_in">len</span>(key.Bytes()))<br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, hex.EncodeToString(key.Bytes()))<br></code></pre></td></tr></table></figure>

<p>4 生成公钥：对私钥进行椭圆曲线加密，生成公钥(64byte)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">X, Y := curve.ScalarBaseMult(key.Bytes())<br>pubKey := elliptic.Marshal(curve, X, Y)<br><br>fmt.Println(<span class="hljs-string">&quot;pubKey:&quot;</span>, pubKey)<br><br></code></pre></td></tr></table></figure>

<p>5 生成地址：去掉公钥第一个字节04，再使用keccak256算法压缩公钥，最后的20byte就是地址</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">compressPubKey := crypto.Keccak256(pubKey[<span class="hljs-number">1</span>:])<br>addr := common.BytesToAddress(compressPubKey[<span class="hljs-number">12</span>:])<br>fmt.Println(<span class="hljs-string">&quot;addr:&quot;</span>, addr.String())<br></code></pre></td></tr></table></figure>

<p>6 验证私钥和地址匹配</p>
<p>将第 3 步产生的私钥导入 metamask<br>查看 metamask 生成的地址，和第 5 步计算出的地址是否匹配</p>
<p>以太坊钱包有2种</p>
<p>1 非确定性钱包，也叫随机钱包，每个账户通过独立的随机数生成器创建，使用keystore管理账户，没有助记词，这里不详细介绍，参考链接<a target="_blank" rel="noopener" href="https://www.learnblockchain.cn/article/7070">https://www.learnblockchain.cn/article/7070</a></p>
<p>2 分层确定性钱包，也叫<strong>HD Wallet</strong>，每个账户通过固定的种子(seed)派生，使用<code>助记词</code>管理所有账户。【行业标准了】</p>
<h1 id="分层确定性钱包（HD-Wallet）"><a href="#分层确定性钱包（HD-Wallet）" class="headerlink" title="分层确定性钱包（HD Wallet）"></a>分层确定性钱包（HD Wallet）</h1><p>首先看一段配置代码，看里面的几个关键信息</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">module.exports = &#123;<br>  networks: &#123;<br>    sepolia: &#123;<br>      url: <span class="hljs-string">&quot;...&quot;</span>,<br>      accounts: &#123;<br>        mnemonic: <span class="hljs-string">&quot;test test test test test test test test test test test junk&quot;</span>,<br>        path: <span class="hljs-string">&quot;m/44&#x27;/60&#x27;/0&#x27;/0&quot;</span>,<br>        initialIndex: <span class="hljs-number">0</span>,<br>        count: <span class="hljs-number">20</span>,<br>        passphrase: <span class="hljs-string">&quot;&quot;</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>接下来3个问题：</p>
<p>1 <code>mnemoic</code>助记词如何能生成许多个账户地址？</p>
<p>2 path : “m&#x2F;44’&#x2F;60’&#x2F;0’&#x2F;0” 都是什么意思？为什么有些数字右上角还有小撇号？如何自定义配置他？</p>
<p>3 passphrase 是什么？ 有什么用？ 和metamask 的登录密码一样吗？</p>
<p>助记词</p>
<p>先导包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/ethereum/<span class="hljs-keyword">go</span>-ethereum/crypto <span class="hljs-comment">// 以太坊的官方库</span><br><span class="hljs-keyword">go</span> get github.com/tyler-smith/<span class="hljs-keyword">go</span>-bip32 <span class="hljs-comment">// bip32</span><br><span class="hljs-keyword">go</span> get github.com/tyler-smith/<span class="hljs-keyword">go</span>-bip39 <span class="hljs-comment">// bip39</span><br><br></code></pre></td></tr></table></figure>



<p>前面讲的是BIP-39提出了助记词标准，助记词是一组相对便于记忆的单词。在BIP-39的词库里面</p>
<p>为什么提出助记词？是为了解决BIP-32中的种子(Seed)难于记忆和不方便备份的问题，</p>
<p>所以BIP-39主要包含了2个功能：由<strong>熵源生成助记词</strong>，由<strong>助记词生成种子</strong>（Seed）</p>
<p>所以是–&gt;BIP-39解决助记词—&gt;BIP-32 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由熵源生成助记词</span><br><span class="hljs-comment">// @参数 128 =&gt; 12个单词</span><br><span class="hljs-comment">// @参数 256 =&gt; 24个单词</span><br>entropy, _ := bip39.NewEntropy(<span class="hljs-number">128</span>) <br>mnemonic, _ := bip39.NewMnemonic(entropy) <span class="hljs-comment">// 这里也是参考上面的流程</span><br><span class="hljs-comment">// 这两行代码的原理可以参考上面的代码的流程： 熵-&gt;校验和-&gt;去头去尾拿索引-&gt;根据索引到词库拿词</span><br>fmt.Println(<span class="hljs-string">&quot;助记词：&quot;</span>, mnemonic)<br><br><span class="hljs-comment">// 由助记词生成种子(Seed)</span><br>seed := bip39.NewSeed(mnemonic, <span class="hljs-string">&quot;salt&quot;</span>) <span class="hljs-comment">// 问题在这里，</span><br><span class="hljs-comment">// 这里生成种子的方法里传了助记词和盐值进去得到种子 kaccak256压缩成32byte后取最后20byte</span><br><br></code></pre></td></tr></table></figure>

<p>生成seed的时候，加入盐值的目的一是增加暴力破解的难度，二是保护种子（seed），就是即使助记词被盗了，种子也是安全的。如果设置了salt，虽然多了一层保护，但是一旦忘记了，也就代表永久丢失钱包了，所以要结合实际情况去考虑</p>
<p>这个盐值也叫密码口令（passphrase）,开头的hardhat配置里的passphrase就是这个盐值，和metamask的登录密码完全是两个东西。</p>
<p>打印下上面的代码得到的输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">助记词： alarm misery master column coach connect tower govern view then hint author<br>seed [<span class="hljs-number">173</span> <span class="hljs-number">84</span> <span class="hljs-number">238</span> <span class="hljs-number">141</span> <span class="hljs-number">106</span> <span class="hljs-number">78</span> <span class="hljs-number">98</span> <span class="hljs-number">62</span> <span class="hljs-number">46</span> <span class="hljs-number">6</span> <span class="hljs-number">144</span> <span class="hljs-number">59</span> <span class="hljs-number">166</span> <span class="hljs-number">101</span> <span class="hljs-number">230</span> <span class="hljs-number">76</span> <span class="hljs-number">224</span> <span class="hljs-number">82</span> <span class="hljs-number">219</span> <span class="hljs-number">27</span> <span class="hljs-number">19</span> <span class="hljs-number">172</span> <span class="hljs-number">10</span> <span class="hljs-number">148</span> <span class="hljs-number">144</span> <span class="hljs-number">31</span> <span class="hljs-number">24</span> <span class="hljs-number">47</span> <span class="hljs-number">33</span> <span class="hljs-number">105</span> <span class="hljs-number">201</span> <span class="hljs-number">81</span> <span class="hljs-number">182</span> <span class="hljs-number">186</span> <span class="hljs-number">46</span> <span class="hljs-number">36</span> <span class="hljs-number">235</span> <span class="hljs-number">51</span> <span class="hljs-number">91</span> <span class="hljs-number">224</span> <span class="hljs-number">123</span> <span class="hljs-number">175</span> <span class="hljs-number">170</span> <span class="hljs-number">170</span> <span class="hljs-number">111</span> <span class="hljs-number">161</span> <span class="hljs-number">117</span> <span class="hljs-number">98</span> <span class="hljs-number">60</span> <span class="hljs-number">214</span> <span class="hljs-number">91</span> <span class="hljs-number">14</span> <span class="hljs-number">204</span> <span class="hljs-number">120</span> <span class="hljs-number">213</span> <span class="hljs-number">42</span> <span class="hljs-number">250</span> <span class="hljs-number">251</span> <span class="hljs-number">126</span> <span class="hljs-number">131</span> <span class="hljs-number">85</span> <span class="hljs-number">160</span> <span class="hljs-number">213</span> <span class="hljs-number">150</span>]<br><span class="hljs-keyword">type</span>: []<span class="hljs-type">uint8</span><br><br></code></pre></td></tr></table></figure>

<p>可以发现：助记词是12个单词的，而Seed是一堆的字符，肯定是助记词更方便备份和恢复钱包</p>
<h1 id="分层确定性钱包（HD-Wallet）的基本原理"><a href="#分层确定性钱包（HD-Wallet）的基本原理" class="headerlink" title="分层确定性钱包（HD Wallet）的基本原理"></a>分层确定性钱包（HD Wallet）的基本原理</h1><p>现在我们用种子生产主账户私钥，这里注意，这里的私钥还不能直接导入，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go">masterKey, _ := bip32.NewMasterKey(seed)<br>fmt.Println(<span class="hljs-string">&quot;masterKey:&quot;</span>, masterKey)<br><span class="hljs-comment">// masterKey: xprv9s21ZrQH143K4LW9szNE7QXNJkpPfFSL8k6CM9zsUb1N3czQhVFUXrZqYox2UDbgS96NrsDL2EwUzS9J6N6PfN4P3d3HNYqge6LYRQVWN6M</span><br><br><span class="hljs-comment">// 可以看下NewMasterKey的内部实现和返回内容</span><br><span class="hljs-comment">// NewMasterKey creates a new master extended key from a seed</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMasterKey</span><span class="hljs-params">(seed []<span class="hljs-type">byte</span>)</span></span> (*Key, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-comment">// Generate key and chaincode</span><br>	hmac := hmac.New(sha512.New, []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Bitcoin seed&quot;</span>))<br>	_, err := hmac.Write(seed)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	intermediary := hmac.Sum(<span class="hljs-literal">nil</span>)<br><br>	<span class="hljs-comment">// Split it into our key and chain code</span><br>	keyBytes := intermediary[:<span class="hljs-number">32</span>]<br>	chainCode := intermediary[<span class="hljs-number">32</span>:]<br><br>	<span class="hljs-comment">// Validate key</span><br>	err = validatePrivateKey(keyBytes)<br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	<span class="hljs-comment">// Create the key struct，注意这个返回的key结构体，</span><br>	key := &amp;Key&#123;<br>		Version:     PrivateWalletVersion,<br>		ChainCode:   chainCode,<br>		Key:         keyBytes,<br>		Depth:       <span class="hljs-number">0x0</span>,<br>		ChildNumber: []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;,<br>		FingerPrint: []<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>&#125;,<br>		IsPrivate:   <span class="hljs-literal">true</span>,<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> key, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先，上面的从种子生成主账户私钥用到的就是<code>BIP-32</code>标准。BIP-32提出了<strong>分层确定性钱包（HD Wallet）</strong>的标准，它允许从单个种子(Seed)生成一系列相关的密钥对，报考一个主账户秘钥和无线多个子账户秘钥，不同的子账户之间具有层次关系，形成了<strong>以主账户为根节点的树形结构</strong>：</p>
<p>图片</p>
<p>由图看出，BIP-39解决熵源生成助记词—&gt;助记词生成种子（Seed）</p>
<p>第二部分 BIP-32这部分的<strong>分层确定性钱包</strong>（HD Wallet），</p>
<ul>
<li><p><strong>分层</strong>：分层的意思是树形结构，每一岑都有一个序号（从0开始），主账户秘钥master序号就是0，一次类推，这个叫做索引号（32位）</p>
</li>
<li><p><strong>确定性</strong>：当通过单向哈希函数派生子密钥的时候，因为即想要随机，又希望同一个父秘钥每次生成的子密钥都相同，于是，引入了<strong>链码</strong>来保证确定性，使得每次生成子密钥都是由 <strong>父秘钥 + 父链码 + 索引号</strong> 三个一起派生<strong>子密钥</strong></p>
</li>
<li><p><strong>钱包</strong>：钱包就对应密钥（私钥+公钥）</p>
</li>
</ul>
<p>重点：HD Wallet 的所有账户都是由 <strong>秘钥、链码、索引号（32位）</strong>三个部分组成的</p>
<p>所以当派生子密钥的时候，只有单独的私钥还是不行的，必须是<strong>私钥加上链码</strong>一起才能<strong>派生</strong>对应索引的子私钥，因此私钥和链码放在一起也叫做<strong>扩展私钥</strong>，为啥？因为是可拓展的，同样的，公钥和链码放一起叫做<strong>扩展公钥</strong>，接下里看下主账户<strong>拓展私钥masterKey</strong>来派生子账户（注意哦，主私钥+链码&#x3D;拓展私钥）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由主账户私钥生成子账户私钥</span><br><span class="hljs-comment">// @参数 索引号</span><br>childKey1, _ := masterKey.NewChildKey(<span class="hljs-number">1</span>)<br>fmt.Println(<span class="hljs-string">&quot;childKey1:&quot;</span>, childKey1)<br><br><span class="hljs-comment">// 派生第二个子账户</span><br>childKey2, _ := masterKey.NewChildKey(<span class="hljs-number">2</span>)<br>fmt.Println(<span class="hljs-string">&quot;childKey2:&quot;</span>, childKey2)<br><span class="hljs-comment">// 输出结果,可以看到开头是xprv开头的，</span><br><span class="hljs-comment">//childKey1: xprv9vmc7bbX7qbvBfGPKLctPka9JcchdCkwh9NrxPdVjZfGjLyM3RHGsTWwyrXGr86ADJDanyrMKLhJNbuua5fC5tv7XPVF4zBDoQiNYN69rFP</span><br><span class="hljs-comment">// childKey2: xprv9vmc7bbX7qbvEwJfuMa9S1K9F1iuMTeaAaYcbg7NLVGViM6VTbyPecWXiMG37QgKrS4Myz9d9N5QjTmbTgAjFZzsdwGaWuhnBMewz2mFCKd</span><br><br></code></pre></td></tr></table></figure>

<p>这里看一下NewChildKey方法内部逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewChildKey derives a child key from a given parent as outlined by bip32</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(key *Key)</span></span> NewChildKey(childIdx <span class="hljs-type">uint32</span>) (*Key, <span class="hljs-type">error</span>) &#123;<br>	<span class="hljs-comment">// Fail early if trying to create hardned child from public key</span><br>	<span class="hljs-keyword">if</span> !key.IsPrivate &amp;&amp; childIdx &gt;= FirstHardenedChild &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrHardnedChildPublicKey<br>	&#125;<br><br>	intermediary, err := key.getIntermediary(childIdx) <span class="hljs-comment">// 这个方法内部通过 `父密钥`+`父链码`+`索引号`派生了子密钥</span><br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br><br>	<span class="hljs-comment">// Create child Key with data common to all both scenarios</span><br>	childKey := &amp;Key&#123;<br>		ChildNumber: uint32Bytes(childIdx),<br>		ChainCode:   intermediary[<span class="hljs-number">32</span>:], <span class="hljs-comment">// 索引号，intermediary数组右边的32位</span><br>		Depth:       key.Depth + <span class="hljs-number">1</span>, <span class="hljs-comment">// 这里就是链码</span><br>		IsPrivate:   key.IsPrivate,<br>	&#125;<br>    ........<br>    childKey.Key = addPrivateKeys(intermediary[:<span class="hljs-number">32</span>], key.Key) <span class="hljs-comment">// 子密钥，intermediary数组的左边32位</span><br><br><br>	<span class="hljs-keyword">return</span> childKey, <span class="hljs-literal">nil</span> <span class="hljs-comment">//  返回出去</span><br></code></pre></td></tr></table></figure>

<p>代码总结：派生出的字节数组 左边32字节是秘钥，右边32字节就是链码</p>
<p>除了通过拓展私钥派生出子私钥，还可以通过拓展公钥派生出子公钥。不过需要注意的是：<strong>公钥只能派生出子公钥，无法派生出子私钥</strong>。下面验证一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 用主账户公钥 派生 子账户公钥（没有私钥）</span><br>publicKey := masterKey.PublicKey() <span class="hljs-comment">// 这里是拿到主账户公钥，待会下面会派生</span><br>fmt.Println(<span class="hljs-string">&quot;publicKey:&quot;</span>, publicKey)<br><br>PubKeyToChild, _ := publicKey.NewChildKey(<span class="hljs-number">1</span>) <span class="hljs-comment">// 通过主账户公钥派生出子账户公钥</span><br>fmt.Println(<span class="hljs-string">&quot;PubKeyToChild:&quot;</span>, PubKeyToChild)<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// publicKey: xpub661MyMwAqRbcEkC8JkXwGBm4jX1FmphgcYjyhnKXbW4QKA1DAX5V1Hp6SoCKev4Gim8AqSYzM7ZCttjsHb7SNSH4ufkgsWGVupS73DLxr7Z</span><br><span class="hljs-comment">// PubKeyToChild: xpub68shoUguHPvUVptKbW1BrWa1eAvX5rVKUEQ8S9e3fPVvr5EVhXkVBbNvKJBFR1TqFrmqRERkELB6tixWjc8VouZz3HZRCq2YZBnoLsEfkdx</span><br><br><span class="hljs-comment">// 用主账户私钥，派生出子账户私钥，再生产子账户公钥，然后判断一下是否一致</span><br>childKey1, _ := masterKey.NewChildKey(<span class="hljs-number">1</span>) <span class="hljs-comment">// 派生子账户1</span><br>publicKey1 := childKey1.PublicKey() <span class="hljs-comment">// 从子账户1的秘钥恢复出公钥来，</span><br>fmt.Println(<span class="hljs-string">&quot;publicKey3:&quot;</span>, publicKey1) <span class="hljs-comment">// 打印下这个子账户1公钥</span><br>fmt.Println(bytes.Equal(PubKeyToChild.Key, publicKey1.Key)) <span class="hljs-comment">// 返回的ture，和签名我们生成的是一样的</span><br><span class="hljs-comment">// publicKey3: xpub68shoUguHPvUVptKbW1BrWa1eAvX5rVKUEQ8S9e3fPVvr5EVhXkVBbNvKJBFR1TqFrmqRERkELB6tixWjc8VouZz3HZRCq2YZBnoLsEfkdx</span><br><br></code></pre></td></tr></table></figure>

<p>首先再重复一下，要明确的是，公钥只能派生子公钥，无法派生出子私钥，但是私钥确可以推出公钥</p>
<p>就会有<strong>2种派生方式</strong>：</p>
<ul>
<li>1、拓展公钥（公钥+链码）父公钥&#x3D;&#x3D;&gt; 子公钥，子私钥另外由父私钥派生，不归公钥管</li>
<li>2、拓展私钥（私钥+链码）父私钥&#x3D;&#x3D;&#x3D;&gt;子私钥 &#x3D;&#x3D;&#x3D;&gt; 子公钥</li>
</ul>
<p>第一种方式好处就是：可以用父公钥暴露在外面，然后可以派生出n多个子公钥用于接收资产，因为没有私钥，所以只能接收，不能花费（签名）所以很安全，与此同时，在另一个地方用子私钥来控制资产（签名），这样就做到了<strong>子公钥和子私钥的解耦</strong>，</p>
<p>但是这样的派生方式有很大的危险，就是如果有人拿到了这个子私钥，那么则可以通过子私钥+父链码来推导出父私钥，父私钥拿到了就可以加上其他的链码来推导其他姊妹账户，于是就出现了<strong>强化派生（Hardened derivation）</strong>强化派生限制了父公钥派生出子公钥的能力，只能使用第二种派生也就是 <strong>父私钥&#x3D;&#x3D;&#x3D;&gt;子私钥&#x3D;&#x3D;&#x3D;&gt;子公钥</strong></p>
<blockquote>
<p>HD Wallet 有规定：</p>
<p>索引号在0到2^32-1(0x0 to 0x7FFFFFFF)之间只用于常规派生</p>
<p>索引号在2^31到2^32-1(0x80000000 to 0xFFFFFFFF)之间只用于强化派生</p>
</blockquote>
<p>PS：<strong>在表示中，强化派生密钥右上角有一个小撇号，如：索引号为 0x80000000 就表示为 0’</strong></p>
<p>接下来回头去看下上面的派生子密钥的源码，也就是上面的NewchildKey方法，里面有一个判断，就是判断你的入参childIdx 是在哪个索引范围，如果是在强化派生的索引范围，就是强化派生，就不允许公钥派生</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(key *Key)</span></span> NewChildKey(childIdx <span class="hljs-type">uint32</span>) (*Key, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// Fail early if trying to create hardned child from public key</span><br>    <span class="hljs-comment">// 这里就可以看到，如果这个childIdx &gt;= FirstHardenedChild 就会返回空且抛出错误</span><br>    <span class="hljs-keyword">if</span> !key.IsPrivate &amp;&amp; childIdx &gt;= FirstHardenedChild &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrHardnedChildPublicKey<br>    &#125;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来就是由公钥去生成地址了，这里就是签名提到的压缩的过程，这个简单不需要额外理解，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 由公钥推出地址（解压缩的过程，就是转化然后去头去尾的）</span><br><span class="hljs-comment">// 先解压缩公钥，再去推地址</span><br>pubKey1, _ := crypto.DecompressPubkey(PubKeyToChild.Key)<br><span class="hljs-comment">// 生成子账户地址</span><br>addre1 := crypto.PubkeyToAddress(*pubKey1)<br>fmt.Println(<span class="hljs-string">&quot;addre1:&quot;</span>, addre1)<br></code></pre></td></tr></table></figure>

<p><strong>但是！但是！但是！</strong> 你现在走到这一步，还是不可以导入到metaMask钱包里面的。需要继续往下走</p>
<h4 id="分层确定性钱包（HD-Wallet）的标准路径"><a href="#分层确定性钱包（HD-Wallet）的标准路径" class="headerlink" title="分层确定性钱包（HD Wallet）的标准路径"></a>分层确定性钱包（HD Wallet）的标准路径</h4><p>还记得本文开头提出的那个问题吗？</p>
<p>path的<code>&quot;m/44&#39;/60&#39;/0&#39;/0&quot;</code> 都是什么意思？现在你知道了，右上角的小撇号代表强化派生，现在来看其他部分。</p>
<p>BIP-44 确定了 HD 钱包的标准路径。由于 HD 钱包的树状结构，每一层有 40 亿个子密钥（20 亿个常规子密钥和 20 亿个强化子密钥），层数可以无限扩展，没有尽头。</p>
<p>导致钱包里账户的路径可能性是无穷的，假设你想从 metamask 更换到另一个不同的钱包应用，就会存在兼容性问题。</p>
<p>于是乎，<strong>BIP-44</strong> 定义了标准，只要遵循了这个标准的钱包之间都是兼容的。好消息是，包括 metamask 在内的许多钱包，都遵循了这个标准，第三个BIP来了，签名助记词是BIP39，种子是BIP32</p>
<p>BIP-44 标准的钱包路径（path）参数：m &#x2F; purpose’ &#x2F; coin_type’ &#x2F;account’ change &#x2F; address_index</p>
<ul>
<li>m ：标记子账户都是主私钥派生而来的。</li>
<li>purpose’ ：标记是 BIP-44, 固定值是 44’</li>
<li>coin_type’ ：标记账户类型，从 0’ 开始，用于给账户分类&#x3D;&#x3D;&#x3D;&gt; <a target="_blank" rel="noopener" href="https://github.com/satoshilabs/slips/blob/master/slip-0044.md">完整的币种类型</a></li>
<li>change  ：0 外部可见地址，1 找零地址（外部不可见），通常默认0</li>
<li>address_index ：地址索引</li>
</ul>
<p><strong>注意：为了保护主私钥安全，所有主私钥派生的第一级账户，都采用强化派生。</strong> </p>
<p>但是，你可以使用<code>m/0</code>，<code>m/1&#39;/0</code>，<code>m/0&#39;/1/2/3</code>这种任何路径你都可以随便输入，派生出来的都是正确的账户，只是这些不符合标准的钱包不一定能兼容的了这些链，且安全性不可知，所以统一准信行业标准（BIP-44）</p>
<h3 id="实现一个以太坊的钱包（一个符合BIP-44标准的路径path）"><a href="#实现一个以太坊的钱包（一个符合BIP-44标准的路径path）" class="headerlink" title="实现一个以太坊的钱包（一个符合BIP-44标准的路径path）"></a>实现一个以太坊的钱包（一个符合BIP-44标准的路径path）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 所以这个masterKey 的来源还要再写一遍</span><br>助记词==&gt;种子==&gt; 主私钥masterKey<br><span class="hljs-comment">// 这里的masterKey是什么？是主私钥，然后主私钥经过各种派生之后，生成的子私钥</span><br><span class="hljs-comment">// 以太坊的币种类型是60</span><br><span class="hljs-comment">// FirstHardenedChild = uint32(0x80000000) 是一个常量</span><br><span class="hljs-comment">// 以路径（path: &quot;m/44&#x27;/60&#x27;/0&#x27;/0/0&quot;）为例</span><br>key, _ := masterKey.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-number">44</span>)  <span class="hljs-comment">// 这一步是在做强化派生， 对应 purpose&#x27; 44是符合BIP-44标准</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">60</span>)) <span class="hljs-comment">// 还是强化派生，对应 coin_type类型60&#x27;</span><br>key, _ = key.NewChildKey(bip32.FirstHardenedChild + <span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))  <span class="hljs-comment">// 还是强化派生，对应account</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                             <span class="hljs-comment">// 常规派生，对应 change</span><br>key, _ = key.NewChildKey(<span class="hljs-type">uint32</span>(<span class="hljs-number">0</span>))                             <span class="hljs-comment">// 常规派生，对应的 address_index</span><br><br><span class="hljs-comment">// path已经完毕，生成地址</span><br>ethPublicKey, _ := crypto.DecompressPubkey(key.PublicKey().Key)<br>fmt.Println(<span class="hljs-string">&quot;ethPublicKey:&quot;</span>, ethPublicKey)<br>ethAddre := crypto.PubkeyToAddress(*ethPublicKey).Hex()<br>fmt.Println(<span class="hljs-string">&quot;ethAddre:&quot;</span>, ethAddre)<br><span class="hljs-comment">// 尝试打印一下这个key的私钥算</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, key.Key)                 <span class="hljs-comment">// 这个时候你直接打印Key是十进制的字节切片</span><br>privateKeyHex := hex.EncodeToString(key.Key) <span class="hljs-comment">// 这里在做的就是转化成16进制的字符，</span><br>fmt.Println(<span class="hljs-string">&quot;key:&quot;</span>, privateKeyHex)<br></code></pre></td></tr></table></figure>

<p>所以这里总结一下，助记词–私钥–公钥–地址，这个过程中做了什么？</p>
<p><img src="/img/web3/privatekeyprocess.png" srcset="/img/loading.gif" lazyload alt="privatekeyprocess"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/blockChain/" class="category-chain-item">blockChain</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/block/" class="print-no-link">#block</a>
      
        <a href="/tags/%E5%AE%9E%E6%88%98/" class="print-no-link">#实战</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>04 HD钱包助记词生成与验证</div>
      <div>http://example.com/2024/05/25/04HD钱包助记词生成/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wangxiaowang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/27/05Bitcoin%E9%92%B1%E5%8C%85%E7%94%9F%E6%88%90%E5%92%8C%E7%AD%BE%E5%90%8D/" title="05 Bitcoin钱包生成和签名">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">05 Bitcoin钱包生成和签名</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/23/03%E5%AF%86%E7%A0%81%E5%AD%A6/" title="03 密码学">
                        <span class="hidden-mobile">03 密码学</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.css')
      Fluid.utils.createScript('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://my-waline-rosy-one.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":[],"lang":"zh-cn","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"auto","wordLimit":0,"pageSize":10,"enable":true,"placeholder":"欢迎留下评论，嘿嘿！","avatar":"mm","visitor":true,"comment_count":true,"libUrl":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
