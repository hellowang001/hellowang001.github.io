

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangxiaowang">
  <meta name="keywords" content="">
  
    <meta name="description" content="1 公钥密码学理论 两种加密方式：对称加密和非对称加密  1.1 对称加密区别：主要区别就是密钥对的区别 对称加密（单秘钥加密），加解密都是只有一把key ，使用相同的秘钥进行加密和解密炒作 发送方使用密钥对数据进行加密，接收方使用相同的密钥对密文进行解密，从而还原出原始的明文数据。 比较有名的是 DES 3DES AES TDEA blowful rc245 对称加密的特点包括：  速度和效率:">
<meta property="og:type" content="article">
<meta property="og:title" content="03 密码学">
<meta property="og:url" content="http://example.com/2024/05/23/03%E5%AF%86%E7%A0%81%E5%AD%A6/index.html">
<meta property="og:site_name" content="Wang">
<meta property="og:description" content="1 公钥密码学理论 两种加密方式：对称加密和非对称加密  1.1 对称加密区别：主要区别就是密钥对的区别 对称加密（单秘钥加密），加解密都是只有一把key ，使用相同的秘钥进行加密和解密炒作 发送方使用密钥对数据进行加密，接收方使用相同的密钥对密文进行解密，从而还原出原始的明文数据。 比较有名的是 DES 3DES AES TDEA blowful rc245 对称加密的特点包括：  速度和效率:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/web3/encryption.jpg">
<meta property="article:published_time" content="2024-05-23T06:50:59.000Z">
<meta property="article:modified_time" content="2025-06-20T04:23:54.055Z">
<meta property="article:author" content="Wangxiaowang">
<meta property="article:tag" content="block">
<meta property="article:tag" content="概念">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/web3/encryption.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>03 密码学 - Wang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"37fd8385820c4abc0e564a2c423b7511","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?37fd8385820c4abc0e564a2c423b7511";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/web3/encryption2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="03 密码学"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-23 14:50" pubdate>
          2024年5月23日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          60 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">03 密码学</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-公钥密码学理论"><a href="#1-公钥密码学理论" class="headerlink" title="1 公钥密码学理论"></a>1 公钥密码学理论</h1><blockquote>
<p>两种加密方式：对称加密和非对称加密</p>
</blockquote>
<h2 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 对称加密</h2><p>区别：主要区别就是密钥对的区别</p>
<p>对称加密（单秘钥加密），<strong>加解密都是只有一把key</strong> ，使用相同的秘钥进行加密和解密炒作</p>
<p>发送方使用密钥对数据进行加密，接收方使用相同的密钥对密文进行解密，从而还原出原始的明文数据。</p>
<p>比较有名的是 DES 3DES AES TDEA blowful rc245</p>
<p>对称加密的特点包括：</p>
<ol>
<li><strong>速度和效率</strong>: 对称加密使用相同的密钥进行加密和解密，因此加密和解密的过程非常快速和高效。</li>
<li><strong>简单性</strong>: 对称加密算法相对简单，实现起来较为容易。</li>
<li><strong>适用于大数据量</strong>: 对称加密适用于大数据量的加密和解密，因为它的处理速度较快。</li>
<li><strong>密钥管理</strong>: 对称加密需要确保密钥的安全性，因为任何拥有密钥的人都可以对数据进行解密。因此，对称加密在密钥的生成、分发和管理方面需要特别注意。</li>
<li><strong>密钥分发</strong>: 密钥的安全分发是对称加密的一个挑战。发送方和接收方必须事先共享密钥，这要求在安全可靠的通信渠道上进行密钥交换。</li>
</ol>
<h2 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h2><p>非对称加密 （公钥密码学、<strong>双密码加密</strong>。现在的加密体系），</p>
<p>双秘钥是哪两个？：</p>
<ul>
<li><p><strong>privatekey</strong> ：私有,进行加密（俗称私钥）私钥是用于解密的密钥，必须保密，并且只有密钥的持有者可以使用私钥进行解密。私钥用于解密公钥加密的数据。</p>
</li>
<li><p><strong>publickey</strong>：公开的，所有人都知道，进行解密（俗称公钥）公钥是用于加密的密钥，可以公开分享给其他人。任何人都可以使用公钥对数据进行加密，但无法使用公钥进行解密。</p>
</li>
</ul>
<p>非对称加密的运作过程如下：</p>
<ul>
<li>发送方使用接收方的公钥对数据进行加密。</li>
<li>加密后的数据通过不安全的通信渠道发送给接收方。</li>
<li>接收方使用自己的私钥对收到的密文进行解密，得到原始的明文数据。</li>
</ul>
<p>非对称加密的特点包括：</p>
<ol>
<li><strong>安全性</strong>: 非对称加密提供了更高的安全性，因为公钥用于加密数据，而私钥用于解密数据。即使公钥被公开获取，也无法轻易破解密文，因为只有私钥持有者才能解密数据。</li>
<li><strong>密钥分发</strong>: 非对称加密解决了密钥分发的问题。发送方只需获取接收方的公钥，而无需共享私钥。这使得非对称加密在保护数据传输的同时，简化了密钥管理的复杂性。</li>
<li><strong>数字签名</strong>: 非对称加密还可以用于数字签名，即使用私钥对数据进行加密，证明数据的完整性和认证发送方身份。接收方可以使用发送方的公钥进行验证。</li>
<li><strong>计算复杂性</strong>: 相对于对称加密，非对称加密的计算复杂性较高，处理速度较慢。因此，非对称加密通常用于加密小数据量或者进行密钥交换，而不是对大量数据进行加密</li>
</ol>
<p>非对称加密比较有名的是：RSA  ECC（椭圆曲线）GPG（用过，加密文件）</p>
<p>ECC分支：</p>
<ul>
<li>ECDSA  <strong>特别算法Secp256K1</strong>啥的</li>
<li>EDDSA <strong>特别算法Ed25519</strong>啥的</li>
</ul>
<h1 id="2-对称密码学系列"><a href="#2-对称密码学系列" class="headerlink" title="2.对称密码学系列"></a>2.对称密码学系列</h1><h2 id="2-1-DES"><a href="#2-1-DES" class="headerlink" title="2.1. DES"></a>2.1. DES</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>秘钥长度：<strong>56</strong>位</li>
<li>分组密码：处理64位的分组数据</li>
<li>加密和解密都需要同一把私钥</li>
<li>16轮加密包含：拓展、置换、S盒替代、再次置换（16轮加密流程可以了解下）</li>
<li>安全性：已被攻破，实际项目不会用，</li>
<li>复杂性和速度。</li>
<li>3DES替换，目前还安全</li>
</ol>
<p> 安全性：特别经典，但已被攻破</p>
<h2 id="2-2-3DES"><a href="#2-2-3DES" class="headerlink" title="2.2. 3DES"></a>2.2. 3DES</h2><p>3DES就是3重DES加密，目前也不用了，现在主流都是<strong>AES</strong>，</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>秘钥长度：56位，由于引入了对称秘钥的3次应用，所以实际秘钥长度是3个56，</li>
<li>分组密码：处理64位的分组数据</li>
<li>加密和解密都需要同一把私钥</li>
<li>3个16轮加密包含：拓展、置换、S盒替代、再次置换（16轮加密流程可以了解下）</li>
<li>安全性：比DES高的多，目前是安全的。</li>
<li>复杂性和速度性能会有损耗。</li>
</ol>
<h2 id="2-3-AES："><a href="#2-3-AES：" class="headerlink" title="2.3.AES："></a>2.3.AES：</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ol>
<li>秘钥长度：比较灵活，可以是128位 192位 256位</li>
<li>分组密码：128位的分组密码（分组的意思就是如果数据块太长了，就只能按照128位去分组，分完组之后再加密）</li>
<li>加密和解密都需要同一把私钥</li>
<li>基于置换和代换网络，轮数取决于秘钥长度：AES-128使用10轮加密，AES-192使用12轮加密，AES-256使用14轮加密。通过增加轮数，AES提供了更高的安全级别，每一轮都有初始轮、主要轮、最终轮，主要轮都有四个步骤：字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey），</li>
<li>安全性：目前是安全的，没被破解</li>
<li>应用：文件加密解密，数据加密解密，</li>
</ol>
<h2 id="2-4-DES-、3DES、AES-对比"><a href="#2-4-DES-、3DES、AES-对比" class="headerlink" title="2.4. DES 、3DES、AES 对比"></a>2.4. DES 、3DES、AES 对比</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ol>
<li>单秘钥对称加密</li>
<li>分组密码</li>
<li>都有多轮</li>
</ol>
<h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><ol>
<li>DES已被破解</li>
<li>3DES是DES的补充，安全性有保障，实际应用少，</li>
<li>DES（64位）和AES（128、192、256）秘钥长度不一样，</li>
<li>AES安全性好一点，目前暂未被破解。</li>
</ol>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>文件数据加密，无法做秘钥签名，因为是单秘钥的</p>
<h1 id="3-非对称加密系列"><a href="#3-非对称加密系列" class="headerlink" title="3. 非对称加密系列"></a>3. 非对称加密系列</h1><h2 id="3-1-核心："><a href="#3-1-核心：" class="headerlink" title="3.1 核心："></a>3.1 核心：</h2><p>公钥加密，私钥解密。</p>
<p>你要发一段话给别人，就用别人公开的公钥进行加密，加密之后任何人都解不开这个秘密，除非拿到了私钥才能解开秘密得到里面的内容</p>
<h2 id="3-2-常用："><a href="#3-2-常用：" class="headerlink" title="3.2 常用："></a>3.2 常用：</h2><p>常用的非对称加密算发有 RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>
<p>ECC分：</p>
<ul>
<li>EDDSA-&gt;ED25519，<strong>应用</strong>：ECDSA 在 TLS&#x2F;SSL、SSH、数字签名等领域广泛应用。<ul>
<li>Ed25519 是一种基于 Edwards 曲线的数字签名算法，它提供了高度的安全性和性能；Ed25519 也是加密货币中使用比较广泛的签名算法，如波卡等链。（ECC变种）</li>
</ul>
</li>
<li>EdDSA-&gt;secp256k1，<strong>应用</strong>：EdDSA 由 Daniel J. Bernstein 等人提出，并且被应用于密码学协议中，如密码学货币、加密货币等。（ECC变种，这个是被用的最多）公钥很多都是02&#x2F;03&#x2F;04开头的<ul>
<li>Secp256k1 是一种椭圆曲线，常用于加密货币领域，如比特币和以太坊。</li>
</ul>
</li>
</ul>
<h2 id="3-3-ECC算法："><a href="#3-3-ECC算法：" class="headerlink" title="3.3 ECC算法："></a>3.3 ECC算法：</h2><p>**ECC(Elliptic Curve Cryptography)**：椭圆曲线密码学是一类基于椭圆曲线数学问题的非对称加密算法。相比于传统的非对称加密算法，如RSA，ECC提供了相同安全级别下更短的密钥长度和更高的计算效率，因此在资源受限的环境中得到广泛应用。</p>
<p>公钥用于加密</p>
<p>基于椭圆曲线-离散对数</p>
<p>秘钥长度比RSA短，短秘钥，256位的ECC安全性相当于3072位的RSA</p>
<p>安全高</p>
<p>效率高</p>
<p>应用场景：数字货币</p>
<h2 id="3-4-RSA特点："><a href="#3-4-RSA特点：" class="headerlink" title="3.4 RSA特点："></a>3.4 RSA特点：</h2><p><strong>RSA（Rivest-Shamir-Adleman</strong>）是最常用的非对称加密算法之一。它基于大数分解的困难性，使用公钥进行加密，私钥进行解密。RSA广泛应用于数据加密、数字签名和密钥交换等领域。</p>
<ol>
<li>公钥用于加密</li>
<li>基于数学难题（因数分解啥的）–&gt;安全性很高</li>
<li>秘钥长度：1024，2048，4096，秘钥越长越安全</li>
<li>加密解密：公钥模幂运算，私钥解密</li>
<li>RSA发送方使用自己的私钥签名消息，接收方用公钥验证</li>
<li>性能：性能慢，所以一般是对很小数据加密，</li>
</ol>
<p>应用：数字证书、签名认证，点击邮件加密，交易签名用到</p>
<p>场景比较多的是混合加密，</p>
<p>所谓混合加密就是使用在实际的应用中把对称加密和非对称加密结合起来使用。</p>
<p>我们都知道非对称加密算法比对称加密算法慢数千倍，但在保护通信安全方面，非对称加密算法却具有对称密码难以企及的优势。</p>
<p>所以在实际的应用中，都是对称加密与非对称加密混合使用。</p>
<p>取其优势，去其糟粕，达到完美使用的一个目的。</p>
<p>对称加密技术：</p>
<p>一一对应，加密和解密都是用一把钥匙，所以发送者和接收者手上必须同时持有钥匙</p>
<p>优点：这种算法比较简单且计算量比较小，对网络开放、从而能够效率高地加密。速度更快</p>
<p>缺点，不能保证协商秘钥过程的安全性。二是每次通信都使用唯一秘钥，秘钥越来越多不好管理。三是对称加密算法只能对数据进行加解密，保证数据的机密性，但无法验证通讯双方的真实身份，不能确定数据的完整性。</p>
<p>非对称密钥加密技术：</p>
<p>有公钥私钥两把钥匙，公钥（公布于众）用于加密数据，私钥（私密持有）用于解密数据</p>
<p>优点：更安全，可以一对多个接收方，简化秘钥（秘钥少）发放，支持数字签名。</p>
<p>缺点：计算过程特别复杂，运行数据的加密和解密速度比较慢</p>
<h2 id="Schnorr和BLS算法介绍"><a href="#Schnorr和BLS算法介绍" class="headerlink" title="Schnorr和BLS算法介绍"></a>Schnorr和BLS算法介绍</h2><p>Schnorr 签名和 BLS 签名在区块链技术中都有着重要的应用。</p>
<p>它们各自具备独特的优势，使其在不同的区块链应用场景中得到广泛使用。</p>
<h2 id="3-5-Schnorr-签名算法"><a href="#3-5-Schnorr-签名算法" class="headerlink" title="3.5 Schnorr 签名算法"></a>3.5 Schnorr 签名算法</h2><p>Schnorr签名广泛应用于区块链和加密货币领域</p>
<h3 id="3-5-1-Schnorr基本步骤"><a href="#3-5-1-Schnorr基本步骤" class="headerlink" title="3.5.1 Schnorr基本步骤"></a>3.5.1 Schnorr基本步骤</h3><p>下面是Schnorr算法的基本步骤：</p>
<ol>
<li>密钥生成：<ul>
<li>随机选择一个私钥（私钥是一个随机数）。</li>
<li>使用椭圆曲线上的点乘法运算生成对应的公钥（不懂没关系）。</li>
</ul>
</li>
<li>签名生成：<ul>
<li>选择一个随机数作为临时私钥。</li>
<li>使用临时私钥和消息的哈希值计算出一个临时公钥。（只需要一次哈希）</li>
<li>使用临时私钥、消息和临时公钥等参数计算出签名的值。</li>
</ul>
</li>
<li>验证签名：<ul>
<li>使用公钥和消息的哈希值重复计算出签名的值。</li>
<li>将计算得到的签名值与原始的签名值进行比较，如果相等，则验证通过。</li>
</ul>
</li>
</ol>
<h3 id="3-5-1-Schnorr优点"><a href="#3-5-1-Schnorr优点" class="headerlink" title="3.5.1 Schnorr优点"></a><strong>3.5.1 Schnorr优点</strong></h3><ul>
<li><strong>高效性</strong>：相比于其它签名算法，Schnorr签名在计算上更加高效，特别是在签名生成和验证过程中，计算量较小，签名和验证的速度快</li>
<li><strong>短签名</strong>：Schnorr签名长度较短，有助于节省带宽和存储空间。</li>
<li><strong>线性性质</strong>：Schnorr签名具有线性性质，这意味着可以对多个签名进行聚合，从而减少交易的大小和验证的成本。</li>
<li><strong>安全性</strong>：基于离散对数问题的安全性，难以被破解。</li>
<li><strong>抗量子计算攻击</strong>：Schnorr签名方案被认为对量子计算攻击有较好的抵抗性，因此在未来量子计算成为现实时，Schnorr签名可能会成为主流选择。</li>
</ul>
<h3 id="3-5-2-Schnorr应用"><a href="#3-5-2-Schnorr应用" class="headerlink" title="3.5.2. Schnorr应用"></a><strong>3.5.2. Schnorr应用</strong></h3><p>比特币的Taproot升级中使用了基于Schnorr签名的聚合签名技术。此外，许多密码协议和标准也采用了Schnorr签名算法。紧凑型和灵活性都很高</p>
<p>总之，Schnorr签名算法以其高效和安全的特点，成为了现代密码学中的一个重要工具，尤其在对资源要求较高的应用场景中具有显著优势</p>
<h2 id="3-6-BLS算法"><a href="#3-6-BLS算法" class="headerlink" title="3.6 BLS算法"></a>3.6 BLS算法</h2><p>Schnorr验证的有点BLS都具备，</p>
<p>支持批量验证的特点，对多重签名的场景支持度相当高</p>
<p>以太坊升级后用的多</p>
<p>BLS（Boneh-Lynn-Shacham）签名算法是一种基于双线性对（bilinear pairing）的数字签名方案</p>
<h3 id="3-6-1基本步骤"><a href="#3-6-1基本步骤" class="headerlink" title="3.6.1基本步骤"></a>3.6.1基本步骤</h3><p>以下是BLS签名算法的基本步骤：</p>
<ol>
<li>密钥生成：<ul>
<li>随机选择一个私钥（私钥是一个随机数）。</li>
<li>使用椭圆曲线上的点乘法运算生成对应的公钥。</li>
</ul>
</li>
<li>签名生成：<ul>
<li>将消息的哈希值作为输入。</li>
<li>使用私钥对哈希值进行签名，生成一个签名值。</li>
</ul>
</li>
<li>验证签名：<ul>
<li>使用公钥和消息的哈希值重复计算出签名的值。</li>
<li>将计算得到的签名值与原始的签名值进行比较，如果相等，则验证通过。</li>
</ul>
</li>
</ol>
<h3 id="3-6-2-特点和应用"><a href="#3-6-2-特点和应用" class="headerlink" title="3.6.2 特点和应用"></a>3.6.2 特点和应用</h3><ul>
<li><strong>简洁性</strong>：BLS签名非常简洁，签名的大小固定且较小，只有一个群元素。</li>
<li><strong>效率</strong>：签名生成和验证的计算量相对较小，尤其是在签名长度较短的情况下。</li>
<li><strong>聚合签名</strong>：BLS签名具有天然的签名聚合（aggregate signature）特性，多个签名可以被聚合成一个签名，从而减少存储和传输的开销。这在区块链和分布式系统中尤为有用。</li>
<li><strong>多重签名</strong>：BLS也支持<strong>多重签名</strong>（multi-signature），多个用户可以共同签署同一消息，生成一个联合签名。</li>
</ul>
<p>不同点：</p>
<p><strong>签名聚合</strong>：</p>
<ul>
<li>BLS签名算法：BLS签名算法天然支持签名的聚合。多个BLS签名可以通过简单的数学运算合并为单个签名，从而减少传输和验证的开销。</li>
<li>Schnorr签名算法：Schnorr签名算法不直接支持签名的聚合。要实现签名聚合，需要额外的协议或方案。</li>
</ul>
<h1 id="4-单向散列函数算法介绍（属于对称加密）"><a href="#4-单向散列函数算法介绍（属于对称加密）" class="headerlink" title="4 单向散列函数算法介绍（属于对称加密）"></a>4 单向散列函数算法介绍（属于对称加密）</h1><p>MD5、SHA-1、SHA-2、SHA-3（以太坊）、blake、blake2（用的多）、波赛登（用的多）</p>
<p>单向散列函数（One-way hash function）是一种重要的密码学工具，它将<strong>输入数据</strong>转换为<strong>固定长度</strong>的输出值，称为<strong>哈希值</strong>，同时具备以下特性：</p>
<ol>
<li><strong>单向性</strong>（One-way property）：计算从哈希值到原始输入的逆过程是困难的。即给定哈希值，计算出原始输入是困难的。</li>
<li><strong>固定输出长度</strong>：单向散列函数生成的哈希值具有<strong>固定</strong>的长度，无论输入的长度如何。</li>
<li><strong>抗碰撞性</strong>（Collision resistance）：很难找到两个不同的输入，它们生成相同的哈希值</li>
</ol>
<h2 id="4-1-MD5"><a href="#4-1-MD5" class="headerlink" title="4.1 MD5"></a>4.1 MD5</h2><h3 id="4-1-1-MD5特点"><a href="#4-1-1-MD5特点" class="headerlink" title="4.1.1 MD5特点"></a>4.1.1 MD5特点</h3><p>以下是MD5的基本特点和特性：</p>
<ol>
<li><strong>单向性</strong>：MD5是一种单向散列函数，根据给定输入计算出固定长度的哈希值，但从哈希值<strong>推导</strong>出原始输入是非常困难的，这是其单向性的关键特性。</li>
<li><strong>固定输出长度</strong>：无论输入的长度如何，MD5生成的哈希值始终为128位，长度固定。它将输入数据转换为一个128位（16字节）的哈希值，通常表示为32个十六进制数字。</li>
<li><strong>快速计算</strong>：相对于较新的哈希函数，如SHA-256，MD5计算速度较快，适用于一些对性能要求较高的场景。</li>
</ol>
<h3 id="4-1-2-MD5步骤"><a href="#4-1-2-MD5步骤" class="headerlink" title="4.1.2 MD5步骤"></a>4.1.2 MD5步骤</h3><ol>
<li><strong>填充数据</strong>：将输入数据进行填充，使其长度满足对512位（64字节）块的整数倍。填充方式是在数据末尾添加一个”1”比特，然后填充若干”0”比特，直到满足长度要求。</li>
<li><strong>初始化状态</strong>：定义四个32位的寄存器（A、B、C、D）作为MD5的内部状态。初始时，这些寄存器包含预定义的固定值。</li>
<li><strong>处理块数据</strong>：将填充后的数据划分为512位（64字节）的块，并对每个块进行处理。</li>
<li><strong>划分为子块</strong>：将每个512位块划分为16个32位的子块，每个子块占据4个字节。</li>
<li><strong>初始化变量</strong>：定义四个32位变量（A、B、C、D），并将其初始化为初始状态的寄存器值。</li>
<li><strong>循环运算</strong>：通过四轮循环，对子块进行一系列的位运算和非线性函数操作，更新变量的值。</li>
<li><strong>输出结果</strong>：经过循环运算后，得到最终的MD5哈希值。将四个32位变量按照小端字节序连接起来，形成128位（16字节）的哈希值。</li>
</ol>
<h3 id="4-1-3-MD5-用途"><a href="#4-1-3-MD5-用途" class="headerlink" title="4.1.3 MD5 用途"></a>4.1.3 MD5 用途</h3><ol>
<li><strong>一致性验证</strong>：网上下载被人的文件，可以看到这个文件的MD5值，然后你用工具验证你下载的文件的MD5值和别人给出的这个MD5值是否一致？一致就说明数据在传输过程中没有问题。</li>
<li><strong>数字证书</strong> ：如果有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</li>
<li><strong>安全访问认证</strong>：在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。</li>
</ol>
<p>然而，需要注意的是，MD5存在以下主要安全性问题：</p>
<ol>
<li><strong>碰撞攻击</strong>：MD5已经被证明对碰撞攻击不安全。碰撞指的是找到两个不同的输入，它们生成相同的MD5哈希值。这意味着攻击者可以通过构造特定的输入来伪造数据或篡改数据，从而破坏完整性。</li>
<li><strong>预映射攻击</strong>：通过选择特定的输入，可以在计算MD5哈希值之前进行预计算，从而加速碰撞攻击的实施。</li>
</ol>
<p>安全性：已被破解–&gt;中国王小云</p>
<h2 id="4-2-SHA-系列算法"><a href="#4-2-SHA-系列算法" class="headerlink" title="4.2 SHA 系列算法"></a>4.2 SHA 系列算法</h2><p>安全散列算法（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族，能计算出一个数字消息所对应到的，长度固定的字符串（又称消息摘要）的算法。</p>
<p>且若输入的消息不同，它们对应到不同字符串的机率很高。SHA家族算法分别是SHA-0；SHA-1；SHA-224、SHA-256、SHA-384，SHA-512和SHA3。SHA-224、SHA-256、SHA-384，SHA-512 有时并称为 SHA-2， SHA3 是第三代安全散列算法(Secure Hash Algorithm 3)，之前名为 Keccak 算法，在硬件实做上面，这个算法比起其他算法明显的快上很多，目前 SHA-0，SHA-1 已被破解。</p>
<p>sha-256属于sha-2家族</p>
<h2 id="4-3-Blake-和-Blake2系列算法"><a href="#4-3-Blake-和-Blake2系列算法" class="headerlink" title="4.3 Blake 和 Blake2系列算法"></a>4.3 Blake 和 Blake2系列算法</h2><p>BLAKE（及其后续版本 BLAKE2）是一种快速且安全的哈希算法，参与了SHA-3竞赛并成为了SHA-3的五个决赛选手之一。</p>
<p>BLAKE2 是一种快速、安全的哈希函数，是对 BLAKE 算法的改进。BLAKE2 于 2012 年发布，其设计目标是提供比 MD5、SHA-1 和 SHA-2 更高的安全性和更快的速度，同时保持高度的灵活性和简便性。</p>
<h3 id="4-3-1-Blake-系列算法特点"><a href="#4-3-1-Blake-系列算法特点" class="headerlink" title="4.3.1 Blake 系列算法特点"></a>4.3.1 Blake 系列算法特点</h3><ul>
<li><strong>高效性能</strong>：BLAKE2 比 SHA-2（如 SHA-256 和 SHA-512）更快，同时在现代 CPU 上的性能通常优于 MD5 和 SHA-1。BLAKE2 的设计充分利用了现代处理器的特性，使其在软件实现中非常高效。</li>
<li><strong>高安全性</strong>：BLAKE2 提供了与 SHA-3 相媲美的安全性。它具有以下特性：<ul>
<li><strong>抗碰撞攻击</strong>：很难找到两个不同的输入使得它们的哈希值相同。</li>
<li><strong>抗预映射攻击</strong>：很难找到一个给定哈希值对应的原始输入。</li>
<li><strong>抗第二预映射攻击</strong>：很难找到与给定输入具有相同哈希值的另一个输</li>
</ul>
</li>
<li>可变长度输出：BLAKE2 可以生成任意长度的哈希值，从 1 比特到 512 比特。这使得它在许多应用中非常灵活。（MD6固定128位）</li>
<li><strong>简单易用</strong>：BLAKE2 的设计和实现都相对简单，这有助于降低实现中的错误风险。它还提供了多种变种，以满足不同需求：<ul>
<li><strong>BLAKE2b</strong>：适用于 64 位平台，输出长度可达 512 比特。</li>
<li><strong>BLAKE2s</strong>：适用于 32 位平台，输出长度可达 256 比特。</li>
</ul>
</li>
<li><strong>内置特性</strong>：BLAKE2 集成了多种常用功能，这使得它在许多应用中更加便捷：<ul>
<li><strong>密钥哈希（Keyed Hashing）</strong>：可以使用密钥生成消息认证码（MAC）。</li>
<li><strong>盐值（Salted Hashing）</strong>：允许使用盐值增强哈希的安全性。</li>
<li><strong>个性化（Personalized Hashing）</strong>：可以根据应用需求定制哈希值。</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-blake2-应用场景"><a href="#4-3-2-blake2-应用场景" class="headerlink" title="4.3.2 blake2 应用场景"></a>4.3.2 blake2 应用场景</h3><p>由于其高效性和安全性，BLAKE2 被广泛应用于各种领域，包括但不限于：</p>
<ul>
<li><strong>密码学应用</strong>：如数字签名、消息认证码、随机数生成等。</li>
<li><strong>数据完整性验证</strong>：如文件校验、数据备份验证等。</li>
<li><strong>区块链和加密货币</strong>：BLAKE2 被许多区块链项目用作哈希函数。以太坊</li>
</ul>
<h2 id="4-4-Poseidon-（波赛登）算法"><a href="#4-4-Poseidon-（波赛登）算法" class="headerlink" title="4.4 Poseidon （波赛登）算法"></a>4.4 Poseidon （波赛登）算法</h2><p>Poseidon 是一种现代加密哈希函数，设计用于零知识证明（Zero-Knowledge Proofs, ZKPs）等高级密码学应用。它由研究人员 Benedikt Bunz, Dario Fiore, Iddo Bentov, and Pavel Vasin 等人设计。Poseidon 的设计目标是提供一种高效且安全的哈希算法，特别适合用于 zk-SNARKs 和 zk-STARKs 等 ZKP 系统中。</p>
<h3 id="4-4-1-Poseidon-算法的特点"><a href="#4-4-1-Poseidon-算法的特点" class="headerlink" title="4.4.1 Poseidon 算法的特点"></a>4.4.1 Poseidon 算法的特点</h3><ul>
<li><strong>针对零知识证明优化</strong>： Poseidon 设计时考虑了在零知识证明系统中的应用，优化了哈希计算的效率，特别是减少了算术电路中的门数量（gate count）。Zero—Knowledge </li>
<li><strong>基于加密结构</strong>： Poseidon 采用 Sponge 结构，这种结构在密码学中广泛应用于构建哈希函数和伪随机数生成器。Sponge 结构由两个主要阶段组成：吸收（absorb）和挤出（squeeze）。</li>
<li><strong>高效性</strong>： Poseidon 的设计特别注重计算效率，适合在资源受限的环境中运行，比如区块链中的智能合约或零知识证明的证明生成过程。</li>
<li><strong>灵活性</strong>： Poseidon 可以根据不同的应用需求进行配置，支持不同的安全参数和性能优化。</li>
<li><strong>安全性</strong>： Poseidon 提供了较高的安全性，抗碰撞攻击、预映射攻击和第二预映射攻击，满足现代密码学的安全需求。</li>
</ul>
<h3 id="4-4-2-Poseidon-的构造"><a href="#4-4-2-Poseidon-的构造" class="headerlink" title="4.4.2 Poseidon 的构造"></a>4.4.2 Poseidon 的构造</h3><p>Poseidon 的具体实现涉及复杂的数学构造，包括有限域上的非线性变换和线性层的组合。以下是 Poseidon 的基本构造概述：</p>
<ul>
<li><strong>状态初始化</strong>： Poseidon 初始化一个状态向量，状态的大小通常取决于安全参数和哈希输出的长度。</li>
<li><strong>非线性层（S-Box）</strong>： Poseidon 在状态向量的每个元素上应用一个非线性变换（通常是有限域上的幂操作），这种变换称为 S-Box。</li>
<li><strong>线性层</strong>： Poseidon 应用一个线性变换，将状态向量的元素混合。通常，这个线性变换是通过一个矩阵乘法实现的。</li>
<li><strong>轮函数（Round Function）</strong>： 非线性层和线性层组合成一个轮函数。Poseidon 多次应用轮函数，将输入数据充分混合，确保输出哈希值的安全性。</li>
<li><strong>Sponge 结构</strong>： Poseidon 使用 Sponge 结构处理输入数据。首先在吸收阶段将输入数据分块处理并更新状态向量，然后在挤出阶段从状态向量中提取哈希值。</li>
</ul>
<h3 id="4-4-3-Poseidon-的应用"><a href="#4-4-3-Poseidon-的应用" class="headerlink" title="4.4.3 Poseidon 的应用"></a>4.4.3 Poseidon 的应用</h3><ul>
<li><strong>区块链</strong>： Poseidon 因其高效性和安全性，被认为是区块链系统中实现零知识证明的理想哈希函数。例如，Poseidon 可以用于生成 zk-SNARKs 和 zk-STARKs 中的证明和验证过程。</li>
<li><strong>隐私保护</strong>： Poseidon 可以用于保护数据隐私，通过零知识证明确保数据的完整性和保密性而无需透露实际数据内容。</li>
<li><strong>智能合约</strong>： Poseidon 可以集成到区块链智能合约中，提供高效的哈希计算和验证功能，增强智能合约的安全性和性能。</li>
</ul>
<h1 id="5-总结【重要】"><a href="#5-总结【重要】" class="headerlink" title="5 总结【重要】"></a>5 总结【重要】</h1><p>我们都知道，哈希算法 (Hash Algorithm) 是将任意长度的数据映射为固定长度数据的算法，也称为消息摘要。</p>
<p>一般情况下，哈希算法有两个特点, </p>
<ul>
<li><p>一是原始数据的细微变化（比如一个位翻转）会导致结果产生巨大差距；入变出变</p>
</li>
<li><p>二是运算过程不可逆，理论上无法从结果还原输入数据。不可逆向</p>
</li>
</ul>
<p>因此，哈希算法主要用于数据完整性校验和加密&#x2F;签名。</p>
<p>哈希算法的安全性就在于碰撞难易度，即已知结果，构建出具有相同结果的输入数据的难易度。</p>
<p>常见的哈希算法有 MD5, SHA-1, SHA-2, SHA-3。</p>
<p>其中 MD5 已经可以在 2^21 复杂度（在主流智能手机上只需30秒）内完成碰撞，</p>
<p>谷歌也于17年早些时候在 2^64 复杂度（约 110 GPU年的计算量）内完成了第一次 SHA-1 碰撞。</p>
<p>至此，MD5 和 SHA-1 已经在安全领域被废弃。</p>
<p>当前除了 SHA-2，SHA-3 之外，还有另外一个哈希算法系列可供选择，那就是 <strong>BLAKE，BLAKE2</strong> 系列</p>
<p>比常见的 MD5，SHA-1，SHA-2，SHA-3 <strong>更快</strong>，同时提供不低于 SHA-3 的<strong>安全性</strong>。</p>
<p>对于区块链中的零知识证明系统，<strong>Poseidon</strong> 是目前应用的最广泛的算法。</p>
<h1 id="6-门限共享秘密【其他】"><a href="#6-门限共享秘密【其他】" class="headerlink" title="6 门限共享秘密【其他】"></a>6 门限共享秘密【其他】</h1><p>门限秘密共享（Threshold Secret Sharing）是一种密码学技术，</p>
<p>用于将一个秘密信息分割成多个部分，分发给多个参与者，在满足一定门限条件时才能恢复出原始秘密。</p>
<p>这种方案提供了分散化的安全性，即不依赖于任何单个参与者的信任，只有在多个参与者合作的情况下才能获取秘密。</p>
<p>以下是门限秘密共享方案的基本原理：</p>
<ol>
<li><strong>秘密分割</strong>：将原始秘密信息分割成多个部分，每个部分称为共享（Share）。通常使用Shamir’s Secret Sharing算法或其他类似的方法进行分割。这些共享被分发给不同的参与者，每个参与者持有一个或多个共享。</li>
<li><strong>门限条件</strong>：指定一个门限值（Threshold），需要达到该门限值才能重构秘密。例如，将门限值设置为3，意味着至少需要3个或更多的参与者合作才能恢复秘密。</li>
<li><strong>秘密恢复</strong>：当参与者合作时，他们可以将各自的共享合并，通过一定的计算方法恢复出原始秘密。恢复秘密的计算通常使用插值算法或其他恢复算法，根据收集到的共享进行计算。</li>
</ol>
<p>门限秘密共享方案的优势在于分散化的安全性，即没有单点故障或单个参与者能够获取完整的秘密。即使部分参与者受到攻击或泄露，只要门限条件得到满足，秘密仍然是安全的。这种方案在许多领域中有广泛应用，如多方身份验证、安全多方计算、密码学等。</p>
<h2 id="6-1-云端可干扰抗秘钥丢失的方案（Seek做的）"><a href="#6-1-云端可干扰抗秘钥丢失的方案（Seek做的）" class="headerlink" title="6.1 云端可干扰抗秘钥丢失的方案（Seek做的）"></a>6.1 云端可干扰抗秘钥丢失的方案（Seek做的）</h2><p><img src="/img/web3/%E4%BA%91%E7%AB%AF%E5%8F%AF%E5%B9%B2%E6%89%B0%E6%8A%97%E7%A7%98%E9%92%A5%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%96%B9%E6%A1%88.jpg" srcset="/img/loading.gif" lazyload alt="云端可干扰抗秘钥丢失的方案"></p>
<p>实现逻辑</p>
<p>用到了门限共享秘密、异或算法</p>
<p>现在有一个云端服务cloud-server</p>
<p>本地钱包里面的SDK里面有一个秘密（或者私钥），我现在目的是我丢了这个秘钥我能找回来，但我又怕你们作恶，我就设计了一个这个方案。</p>
<p>首先我本地生成一个大随机数random number，</p>
<p>我现在拿我的这个秘密+random number做一次异或算法得到一个value </p>
<p>然后把这个random number通过API上传到云端去（加密后上传的，加密方式暂不管）</p>
<p>然后将这个value 去进行门限共享秘密拆分成n个sharnds ,假设n&#x3D;6,k&#x3D;3</p>
<p>假设其他丢失了，只得到3个，把这3个进行逆门限解密，可以得到这个value，</p>
<p>拿到value之后，再去请求云端，把这个random number拿下来，</p>
<p>这个时候手上就有value + random number 进行一次逆异或运算得到你的秘钥</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/blockChain/" class="category-chain-item">blockChain</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/block/" class="print-no-link">#block</a>
      
        <a href="/tags/%E6%A6%82%E5%BF%B5/" class="print-no-link">#概念</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>03 密码学</div>
      <div>http://example.com/2024/05/23/03密码学/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wangxiaowang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/05/25/04HD%E9%92%B1%E5%8C%85%E5%8A%A9%E8%AE%B0%E8%AF%8D%E7%94%9F%E6%88%90/" title="04 HD钱包助记词生成与验证">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">04 HD钱包助记词生成与验证</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/05/19/02%E9%92%B1%E5%8C%85/" title="02 钱包">
                        <span class="hidden-mobile">02 钱包</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.css')
      Fluid.utils.createScript('https://registry.npmmirror.com/@waline/client/2.15.8/files/dist/waline.js', function() {
        var options = Object.assign(
          {"serverURL":"https://my-waline-rosy-one.vercel.app","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":[],"lang":"zh-cn","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"auto","wordLimit":0,"pageSize":10,"enable":true,"placeholder":"欢迎留下评论，嘿嘿！","avatar":"mm","visitor":true,"comment_count":true,"libUrl":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
