

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wangxiaowang">
  <meta name="keywords" content="">
  
    <meta name="description" content="四、关于fixtures测试夹具的使用【重点】这篇文章主要介绍fixture夹具，在项目中的使用技巧，代码比较多，文章比较长，请耐心看完  有些官方文档上的代码比价绕或者冗余，就自己写了简单版的便于理解  4.1 “Requesting” fixtures（请求夹具）在基本层面上，测试函数通过将它们声明为参数来请求它们所需的装置。 当pytest运行测试时，它会查看该测试函数签名中的参数，然后搜索">
<meta property="og:type" content="article">
<meta property="og:title" content="【python】之pytest如何使用fixture夹具-四【重】">
<meta property="og:url" content="http://example.com/2024/01/23/664python%E4%B9%8Bpytest%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8fixture%E5%A4%B9%E5%85%B7-%E5%9B%9B/index.html">
<meta property="og:site_name" content="Wang">
<meta property="og:description" content="四、关于fixtures测试夹具的使用【重点】这篇文章主要介绍fixture夹具，在项目中的使用技巧，代码比较多，文章比较长，请耐心看完  有些官方文档上的代码比价绕或者冗余，就自己写了简单版的便于理解  4.1 “Requesting” fixtures（请求夹具）在基本层面上，测试函数通过将它们声明为参数来请求它们所需的装置。 当pytest运行测试时，它会查看该测试函数签名中的参数，然后搜索">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/python/c82add914bb3ba65d55a4489cbec9396.jpeg">
<meta property="article:published_time" content="2024-01-23T02:41:53.000Z">
<meta property="article:modified_time" content="2025-06-20T04:23:54.063Z">
<meta property="article:author" content="Wangxiaowang">
<meta property="article:tag" content="python">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="pytest">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/python/c82add914bb3ba65d55a4489cbec9396.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>【python】之pytest如何使用fixture夹具-四【重】 - Wang</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":"37fd8385820c4abc0e564a2c423b7511","google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  
    <!-- Baidu Analytics -->
    <script async>
      if (!Fluid.ctx.dnt) {
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?37fd8385820c4abc0e564a2c423b7511";
          var s = document.getElementsByTagName("script")[0];
          s.parentNode.insertBefore(hm, s);
        })();
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Home</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/marek.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【python】之pytest如何使用fixture夹具-四【重】"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-23 10:41" pubdate>
          2024年1月23日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          105 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【python】之pytest如何使用fixture夹具-四【重】</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="四、关于fixtures测试夹具的使用【重点】"><a href="#四、关于fixtures测试夹具的使用【重点】" class="headerlink" title="四、关于fixtures测试夹具的使用【重点】"></a>四、关于fixtures测试夹具的使用【重点】</h1><p><strong>这篇文章主要介绍<code>fixture</code>夹具，在项目中的使用技巧，代码比较多，文章比较长，请耐心看完</strong></p>
<blockquote>
<p>有些官方文档上的代码比价绕或者冗余，就自己写了简单版的便于理解</p>
</blockquote>
<h2 id="4-1-“Requesting”-fixtures（请求夹具）"><a href="#4-1-“Requesting”-fixtures（请求夹具）" class="headerlink" title="4.1 “Requesting” fixtures（请求夹具）"></a>4.1 “Requesting” fixtures（请求夹具）</h2><p>在基本层面上，测试函数通过将它们声明为参数来请求它们所需的装置。</p>
<p>当pytest运行测试时，它会查看该测试函数签名中的参数，然后搜索与这些参数名称相同的fixture。一旦pytest找到它们，它就运行这些fixture，捕获它们返回的内容(如果有的话)，并将这些对象作为参数传递给test函数。</p>
<h3 id="4-1-1-快速示例Quick-example"><a href="#4-1-1-快速示例Quick-example" class="headerlink" title="4.1.1 快速示例Quick example"></a>4.1.1 快速示例Quick example</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br>        self.cubed = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cube</span>(<span class="hljs-params">self</span>):<br>        self.cubed = <span class="hljs-literal">True</span> <span class="hljs-comment"># 当调用cube方法时，将cubed属性设置为True</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FruitSalad</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, *fruit_bowl</span>):<br>        self.fruit = fruit_bowl<br>        self._cube_fruit() <span class="hljs-comment"># 调用私有方法 调用了fruit的cube方法，使其为True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_cube_fruit</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> self.fruit:<br>            fruit.cube() <span class="hljs-comment"># 遍历调用fruit的cube方法</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fruit_bowl</span>(): <span class="hljs-comment"># 这是一个测试用例的fixture函数</span><br>    <span class="hljs-keyword">return</span> [Fruit(<span class="hljs-string">&quot;apple&quot;</span>), Fruit(<span class="hljs-string">&quot;banana&quot;</span>)] <span class="hljs-comment"># 返回了两个Fruit实例对象</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fruit_salad</span>(<span class="hljs-params">fruit_bowl</span>): <span class="hljs-comment"># 传进来就可以用</span><br>    <span class="hljs-comment"># Act</span><br>    fruit_salad = FruitSalad(*fruit_bowl) <span class="hljs-comment"># 实例化FruitSalad 加*是可变参数</span><br><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">all</span>(fruit.cubed <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruit_salad.fruit) <span class="hljs-comment"># 调用了fruit的cubed方法 返回了Ture 断言成功</span><br></code></pre></td></tr></table></figure>

<p>如果要手动完成，需要这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">ef fruit_bowl(): <span class="hljs-comment"># 没有加fixture 装饰器，这是一个普通的函数</span><br>    <span class="hljs-keyword">return</span> [Fruit(<span class="hljs-string">&quot;apple&quot;</span>), Fruit(<span class="hljs-string">&quot;banana&quot;</span>)]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fruit_salad</span>(<span class="hljs-params">fruit_bowl</span>):<br>    <span class="hljs-comment"># Act</span><br>    fruit_salad = FruitSalad(*fruit_bowl)<br><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">all</span>(fruit.cubed <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> fruit_salad.fruit)<br>    <br><span class="hljs-comment"># Arrange</span><br>bowl = fruit_bowl() <span class="hljs-comment"># 需要在这里手动去调用</span><br>test_fruit_salad(fruit_bowl=bowl) <span class="hljs-comment"># 需要手动去调用</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，test_fruit_salad“请求”了fruit_bowl(即def test_fruit_salad(fruit_bowl):)，当pytest看到这个时，它将执行fruit_bowl固定函数，并将它返回的对象作为fruit_bowl参数传递给test_fruit_salad。</p>
<blockquote>
<p>官方的这里示例描述的不太好，会把人看晕，看下面的就很简单明了，官方想表达的是，你如何定义一个fixture函数，然后如何使用它，你只需要在测试函数的入参里面加入即可，不需要手动执行你定义的fixture函数foo( )</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_foo</span>(<span class="hljs-params">foo</span>): <span class="hljs-comment"># 你可以不用去foo()这样调用foo 只需要传进来即可</span><br>    a = foo<br>    <span class="hljs-keyword">assert</span> a == <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="4-1-2-Fixtures-也可以请求其他-fixtures【重点】"><a href="#4-1-2-Fixtures-也可以请求其他-fixtures【重点】" class="headerlink" title="4.1.2 Fixtures 也可以请求其他 fixtures【重点】"></a>4.1.2 Fixtures 也可以请求其他 fixtures【重点】</h3><p>pytest最大的优势之一是其极其灵活的夹具系统。它允许我们将复杂的测试需求简化为更简单和有组织的功能，我们只需要让每个功能描述它们所依赖的东西。我们将在后面深入讨论这个问题，但是现在，这里有一个快速的示例来演示fixture如何使用其他fixture:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>(): <span class="hljs-comment"># 第一个fixture 返回了 &quot;a&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>): <span class="hljs-comment"># order返回了一个列表，里面是first_entry的返回值 就是 [ &quot;a&quot; ]</span><br>    <span class="hljs-keyword">return</span> [first_entry]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>): <span class="hljs-comment"># 引入order 此时order = [ &quot;a&quot; ]</span><br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment"># 给order 追加一个元素&quot;b&quot;</span><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>如果手动调用就是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>(): <span class="hljs-comment"># 没加fixture 就是一个普通函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>): <span class="hljs-comment"># 没加fixture 就是一个普通函数</span><br>    <span class="hljs-keyword">return</span> [first_entry]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>)<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br>entry = first_entry() <span class="hljs-comment"># 需要手动调用</span><br>the_list = order(first_entry=entry) <span class="hljs-comment"># 需要手动调用</span><br>test_string(order=the_list) <span class="hljs-comment"># 需要手动调用</span><br></code></pre></td></tr></table></figure>

<h3 id="4-1-3-Fixtures-可以重复使用【重点】"><a href="#4-1-3-Fixtures-可以重复使用【重点】" class="headerlink" title="4.1.3 Fixtures 可以重复使用【重点】"></a>4.1.3 Fixtures 可以重复使用【重点】</h3><p><code>pytest</code>的<code>fixture</code>系统如此强大的原因之一就是，它<strong>使我们能够定义一个可以重复使用的通用设置步骤</strong>，就像使用普通函数一样。两个不同的测试可以请求相同的fixture，并让<code>pytest</code>从该<code>fixture</code>为每个测试提供各自的结果。</p>
<p><strong>这对于确保测试用例不会相互影响非常有用。我们可以使用这个系统来确保每个测试都获得自己的一批新鲜数据，并且从干净的状态开始，这样它就可以提供一致、可重复的结果。</strong></p>
<p>使用的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-comment"># 这里和之前的代码一样</span><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>):<br>    <span class="hljs-keyword">return</span> [first_entry]<br><span class="hljs-comment"># 重点在这下面两个测试用例里</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>) <span class="hljs-comment"># order追加了 &quot;b&quot; 但是用例结束后没有改变order，其他用例仍然用order的初始值时使用，order仍然是 [ &quot;a&quot; ]</span><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_int</span>(<span class="hljs-params">order</span>): <span class="hljs-comment"># 他用例仍然用order的初始值时使用，order仍然是 [ &quot;a&quot; ]</span><br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-number">2</span>) <span class="hljs-comment"># order 追加了一个 &quot;2&quot;</span><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<p>这里的每个测试用例都被赋予了该列表对象的自己的副本，这意味着<code>fixture</code>装置函数被执行两次（对于<code>first_entry</code>固定装置也是如此）。</p>
<p>如果我们也手动执行此操作，就是这样写的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>):<br>    <span class="hljs-keyword">return</span> [first_entry]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-string">&quot;b&quot;</span>)<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_int</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>]<br><br>entry = first_entry() <span class="hljs-comment"># </span><br>the_list = order(first_entry=entry)<br>test_string(order=the_list)<br><br><span class="hljs-comment"># 重点在这里，这里再次entry = first_entry() 是因为前面的entry已经被改变了，变成了[&quot;a&quot;, &quot;b&quot;]，不能使用了，需要一个新的entry = first_entry()也就是[ &quot;a&quot; ]</span><br>entry = first_entry() <br>the_list = order(first_entry=entry)<br>test_int(order=the_list)<br></code></pre></td></tr></table></figure>

<h3 id="4-1-4-一个-test或者fixture可以同时请求多个fixture【重点】"><a href="#4-1-4-一个-test或者fixture可以同时请求多个fixture【重点】" class="headerlink" title="4.1.4 一个 test或者fixture可以同时请求多个fixture【重点】"></a>4.1.4 一个 test或者fixture可以同时请求多个fixture【重点】</h3><p>测试用例和fixture装置不限于一次请求一个fixture装置。他们可以要求任意数量的。</p>
<p>这是另一个演示的简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>(): <span class="hljs-comment"># first_entry() = &quot;a&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">second_entry</span>(): <span class="hljs-comment">#  second_entry()= 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry, second_entry</span>):  <br>    <span class="hljs-comment"># 重点在这个fixture装置里，这里不仅可以使用其他fixture 还可以使用多个其他fixture</span><br>    <span class="hljs-keyword">return</span> [first_entry, second_entry] <span class="hljs-comment"># # 所以order() = [&quot;a&quot;, 2]</span><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">expected_list</span>(): <span class="hljs-comment">#  second_entry()= [&quot;a&quot;, 2, 3.0]</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string</span>(<span class="hljs-params">order, expected_list</span>):<br>    <span class="hljs-comment"># Act</span><br>    order.append(<span class="hljs-number">3.0</span>)<br><br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-keyword">assert</span> order == expected_list <span class="hljs-comment">#order本来是[&quot;a&quot;, 2]追加了一个3.0 所以断言肯定成功</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里讲的几个还是比较重要的</p>
<p>1、如何使用fixture</p>
</blockquote>
<h3 id="4-1-5-每次测试可以多次请求fixture夹具（返回值被缓存）"><a href="#4-1-5-每次测试可以多次请求fixture夹具（返回值被缓存）" class="headerlink" title="4.1.5 每次测试可以多次请求fixture夹具（返回值被缓存）"></a>4.1.5 每次测试可以多次请求fixture夹具（返回值被缓存）</h3><p>在同一测试用例期间也可以多次请求fixture夹具函数,、</p>
<p>并且 pytest 不会在该测试中再次执行它们,</p>
<p>意味着我们可以在依赖于它们的多个fixture装置中请求其他fixture装置（甚至在测试本身中再次请求fixture装置），而无需多次执行这些fixture装置。—-看着有点绕先不管，接着往下看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;如果运行了<span class="hljs-subst">&#123;first_entry.__name__&#125;</span>就会打印这句话&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-comment"># Arrange</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;如果运行了<span class="hljs-subst">&#123;order.__name__&#125;</span>就会打印这句话&quot;</span>)<br>    <span class="hljs-keyword">return</span> []<br><span class="hljs-comment"># Act</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">append_first</span>(<span class="hljs-params">order, first_entry</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;如果运行了<span class="hljs-subst">&#123;append_first.__name__&#125;</span>就会打印这句话&quot;</span>)<br>    <span class="hljs-keyword">return</span> order.append(first_entry)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_only</span>(<span class="hljs-params">append_first, order, first_entry</span>):<br>    <span class="hljs-comment"># Assert</span><br>    <span class="hljs-built_in">print</span>(order) <span class="hljs-comment"># 这个时候order已经被改变了，已经是[&quot;a&quot;]了而不是[]</span><br>    <span class="hljs-built_in">print</span>(first_entry) <span class="hljs-comment"># a </span><br>    <span class="hljs-keyword">assert</span> order == [first_entry]<br><span class="hljs-comment"># 所以当fixture在fixture和test_之间混合使用时是会有缓存的，最后汇总到一起</span><br></code></pre></td></tr></table></figure>

<p>如果在测试期间每次请求时都执行一次所定义的fixture装置的话 ，那么这个测试就会失败,、</p>
<p>因为<code>append_first</code>方法和<code>test_string_only</code>用例都会将<code>order</code>视为一个空列表(如[ ]),</p>
<p>但由于 <code>order</code> 的返回值在第一次调用后被缓存（以及执行它可能产生的任何副作用），测试用例判断了<code>append_first</code>对该对象的影响。</p>
<blockquote>
<p>这里官方想表达的是，fixture在fixture和test_之间混合使用不会重复执行，看一下终端输出结果会更清晰</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">================================================================================ test session starts ================================================================================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>如果运行了order就会打印这句话<br>如果运行了first_entry就会打印这句话<br>如果运行了append_first就会打印这句话<br>[<span class="hljs-string">&#x27;a&#x27;</span>]<br>a<br>.<br><br>================================================================================= <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =================================================================================<br></code></pre></td></tr></table></figure>

<p><strong>这里的每段print( xxx )，都只被打印了一次，如果会重复执行的话，就会打印多次了。</strong></p>
<h2 id="4-2-自动使用fixtue（不必主动请求的fixture）"><a href="#4-2-自动使用fixtue（不必主动请求的fixture）" class="headerlink" title="4.2 自动使用fixtue（不必主动请求的fixture）"></a>4.2 自动使用fixtue（不必主动请求的fixture）</h2><p>测试中有时可能想要有一个（甚至几个）让所有测试用例都依赖的<code>fixture</code>装置，</p>
<p>自动使用<code>fixture</code>装置是一种让所有测试用例都自动请求它们的便捷方法。这可以消除大量冗余的请求，甚至可以提供更高级的夹具使用（更多内容请参见下文）</p>
<p>可以通过将 <code>autouse=True</code> 传递给装饰器<code>pytest.fixture</code>来使<code>fixture</code>成为自动使用的<code>fixture</code>。</p>
<p>代码简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of test_append.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first_entry</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>(<span class="hljs-params">first_entry</span>): <span class="hljs-comment"># 这里的first_entry,只是定义了一个形参，可以随便传参，</span><br>    <span class="hljs-comment"># 换一个写法就是 def order(argument:first_entry):这样可以看的更清晰</span><br>    <span class="hljs-keyword">return</span> []<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">autouse=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">append_first</span>(<span class="hljs-params">order, first_entry</span>):<br>    <span class="hljs-keyword">return</span> order.append(first_entry)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_only</span>(<span class="hljs-params">order, first_entry</span>):  <span class="hljs-comment"># 明明没有引用 append_first，却产生了效果，</span><br>    <span class="hljs-comment"># 这里就会想呀，order 不是一个空列表吗？使用了 append_first 才会忘order里面添加 first_entry，</span><br>    <span class="hljs-comment"># 这就是 autouse=True 的作用 ，隐式的使用了 append_first</span><br>    <span class="hljs-built_in">print</span>(order) <span class="hljs-comment"># [&#x27;a&#x27;]</span><br>    <span class="hljs-keyword">assert</span> order == [first_entry]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_string_and_int</span>(<span class="hljs-params">order, first_entry</span>):<br>    order.append(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 这里就跟明显了，arder 里面添加了 2，本应该是[2]的，但是打印出来是[&quot;a&quot;, 2]，因为隐方的调用了 append_first往order里面添加了first_entry &quot;a&quot;</span><br>    <span class="hljs-built_in">print</span>(order) <span class="hljs-comment"># [&#x27;a&#x27;, 2]</span><br>    <span class="hljs-keyword">assert</span> order == [first_entry, <span class="hljs-number">2</span>]<br><br></code></pre></td></tr></table></figure>

<p>在此示例中，<code>append_first</code> 固定装置是自动使用固定装置。因为它是自动发生的，所以两个测试都会受到它的影响，即使两个测试都没有请求它。但这并不意味着他们不能被请求；只是没有必要写罢了—-&gt;<strong>隐式传递</strong></p>
<h2 id="4-3-作用域：跨类、模块、包或会话共享fixture【重点】"><a href="#4-3-作用域：跨类、模块、包或会话共享fixture【重点】" class="headerlink" title="4.3 作用域：跨类、模块、包或会话共享fixture【重点】"></a>4.3 作用域：跨类、模块、包或会话共享fixture【重点】</h2><h3 id="4-3-1理解fixture-作用域【重点】"><a href="#4-3-1理解fixture-作用域【重点】" class="headerlink" title="4.3.1理解fixture 作用域【重点】"></a>4.3.1理解fixture 作用域【重点】</h3><p>需要网络访问的<code>fixtures</code>取决于连接性，并且创建起来通常非常耗时。</p>
<p>扩展前面的例子</p>
<p>我们可以在 <code>@pytest.fixture </code>调用中添加一个 <code>scope=&quot;module&quot; </code>参数来引发 smtp_connection 固定功能，负责创建到预先存在的 SMTP 服务器的连接，</p>
<p>每个测试模块仅调用一次（默认为每个测试函数调用一次）。</p>
<p>因此，测试模块中的多个测试函数将各自接收相同的 smtp_connection 夹具实例，从而节省时间</p>
<p>范围的可能值为：函数、类、模块、包或会话。</p>
<p>下一个示例将fixture函数放入单独的conftest.py文件中，以便目录中多个测试模块的测试可以访问fixture函数：</p>
<blockquote>
<p>官方的代码有点看的不是特别清晰，可以直接看下面代码</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">import</span> smtplib<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>():<br>    <span class="hljs-keyword">return</span> smtplib.SMTP(<span class="hljs-string">&quot;smtp.gmail.com&quot;</span>, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># content of test_module.py</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">smtp_connection</span>):<br>    response, msg = smtp_connection.ehlo()<br>    <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">b&quot;smtp.gmail.com&quot;</span> <span class="hljs-keyword">in</span> msg<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">smtp_connection</span>):<br>    response, msg = smtp_connection.noop()<br>    <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br></code></pre></td></tr></table></figure>

<p>这里，test_ehlo 需要 smtp_connection 固定值。 pytest 将发现并调用 @pytest.fixture 标记的 smtp_connection 固定功能。运行测试如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest test_module.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">2</span> items<br><br>test_module.py FF                                                    [<span class="hljs-number">100</span>%]<br><br>================================= FAILURES =================================<br>________________________________ test_ehlo _________________________________<br><br>smtp_connection = &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">smtp_connection</span>):<br>        response, msg = smtp_connection.ehlo()<br>        <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">b&quot;smtp.gmail.com&quot;</span> <span class="hljs-keyword">in</span> msg<br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><br>test_module.py:<span class="hljs-number">7</span>: AssertionError<br>________________________________ test_noop _________________________________<br><br>smtp_connection = &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0001</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">smtp_connection</span>):<br>        response, msg = smtp_connection.noop()<br>        <span class="hljs-keyword">assert</span> response == <span class="hljs-number">250</span><br>&gt;       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>  <span class="hljs-comment"># for demo purposes</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><br>test_module.py:<span class="hljs-number">13</span>: AssertionError<br>========================= short test summary info ==========================<br>FAILED test_module.py::test_ehlo - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>FAILED test_module.py::test_noop - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>============================ <span class="hljs-number">2</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure>

<p>您会看到两个断言 0 失败，更重要的是您还可以看到完全相同的 smtp_connection 对象被传递到两个测试函数中，因为 pytest 在回溯中显示传入的参数值。因此，使用 smtp_connection 的两个测试函数运行速度与单个测试函数一样快，因为它们重复使用相同的实例。</p>
<p>两个测试用例，虽然都引入的这个fixture，但是，其实这个fixture是只运行了一次，没有被重复的运行，而且只在模块级别运行，假如这个fixture是函数级别的，那就是每个测试方法单独运行一次，同理，假如是类级别的，那就是每个类单独运行一次，下面会介绍所有级别</p>
<blockquote>
<p>看下面的代码可以更清晰</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;这个类，如果是第一次被实例化对象，age的值就是1，如果是第二次，age得值就是2&quot;&quot;&quot;</span><br>    instance_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        MyClass.instance_count += <span class="hljs-number">1</span><br>        self.age = MyClass.instance_count<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>) </span><span class="hljs-comment"># 模块级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">module_test</span>():<br>    Tom = MyClass()<br>    <span class="hljs-keyword">return</span> Tom <span class="hljs-comment"># 返回类的实例化对象的age属性</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <span class="hljs-comment"># 这个测试用例和下面的测试用例，返回的是同一个实例化对象，所以age的值都是1</span><br><br><span class="hljs-comment"># 说白了，就是这两个测试用例，使用的都是同一个实例化对象，</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果改一下，改成function 级别的呢？测试用例就不会通过</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;这个类，如果是第一次被实例化对象，age的值就是1，如果是第二次，age得值就是2&quot;&quot;&quot;</span><br>    instance_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        MyClass.instance_count += <span class="hljs-number">1</span><br>        self.age = MyClass.instance_count<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>) </span><span class="hljs-comment"># 模块级别</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">module_test</span>():<br>    Tom = MyClass()<br>    <span class="hljs-keyword">return</span> Tom <span class="hljs-comment"># 返回类的实例化对象的age属性</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_ehlo</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <span class="hljs-comment"># 这个测试用例和下面的测试用例，返回的是同一个实例化对象，所以age的值都是1</span><br><br><span class="hljs-comment"># 说白了，就是这两个测试用例，使用的都是同一个实例化对象，</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">module_test</span>):<br>    TestTom = module_test<br>    <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span> <br><br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">================================ FAILURES =================================================<br>________________________________ test_noop _________________________________________<br><br>module_test = &lt;test_fixturestest.MyClass <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f0eeb976b60</span>&gt;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_noop</span>(<span class="hljs-params">module_test</span>):<br>        TestTom = module_test<br>&gt;       <span class="hljs-keyword">assert</span> TestTom.age == <span class="hljs-number">1</span><br>E       <span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br>E        +  where <span class="hljs-number">2</span> = &lt;test_fixturestest.MyClass <span class="hljs-built_in">object</span> at <span class="hljs-number">0x7f0eeb976b60</span>&gt;.age<br><br>testcases/test_fixturestest.py:<span class="hljs-number">206</span>: AssertionError<br>======================= short test summary info ===========================================<br>FAILED testcases/test_fixturestest.py::test_noop - <span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br>============================ <span class="hljs-number">1</span> failed, <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==============================<br></code></pre></td></tr></table></figure>



<p>如果您决定希望拥有一个会话范围的 smtp_connection 实例，您可以简单地声明它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;session&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>():<br>    <span class="hljs-comment"># the returned fixture value will be shared for</span><br>    <span class="hljs-comment"># all tests requesting it</span><br>    ...<br></code></pre></td></tr></table></figure>

<h3 id="4-3-2-Fixture-作用域范围【重点】"><a href="#4-3-2-Fixture-作用域范围【重点】" class="headerlink" title="4.3.2 Fixture 作用域范围【重点】"></a>4.3.2 Fixture 作用域范围【重点】</h3><p>夹具在测试首次请求时创建，并根据其范围销毁：</p>
<ul>
<li><code>function</code>: 默认范围，fixture在每个测试用例结束时销毁。.</li>
<li><code>class</code>: 该fixture在class最后一次测试的测试用例时被销毁。</li>
<li><code>module</code>: 模块级别（py文件）</li>
<li><code>package</code>: 包级别（文件夹）</li>
<li><code>session</code>: 会话级别（整场测试）</li>
</ul>
<p>模块级别、包级别、会话级别也是一样，因为fixture是在conftest.py文件里写的，这个文件是放在项目的根目录下的，你的测试用例，不一定全都是放在一个模块内（py文件）一个包内（文件夹），会话级别的意思就是整场测试用例的级别。</p>
<blockquote>
<p>Pytest 一次仅缓存fixture装置的一个实例，这意味着当使用参数化fixture装置时，pytest 可能会在给定范围内多次调用fixture装置。</p>
</blockquote>
<h3 id="4-3-3-fixture-动态范围–自定义作用域"><a href="#4-3-3-fixture-动态范围–自定义作用域" class="headerlink" title="4.3.3 fixture 动态范围–自定义作用域"></a>4.3.3 fixture 动态范围–自定义作用域</h3><p>在某些情况下，您可能希望在不更改代码的情况下更改夹具的范围。为此，请将可调用对象传递给作用域。</p>
<p>可调用函数必须返回一个具有有效范围的字符串，并且仅在夹具定义期间执行一次。它将使用两个关键字参数进行调用——fixture_name 作为字符串，config 使用配置对象。</p>
<p>当处理需要时间设置的固定装置（例如生成 docker 容器）时，这尤其有用。</p>
<p>可以使用命令行参数来控制不同环境下生成的容器的范围。请参阅下面的示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># determine_scope 函数的定义是受两个参数：fixture_name 和 config。fixture_name 是 fixture 的名称，而 config 是 pytest 的配置对象。</span><br><span class="hljs-comment"># 函数的逻辑是，如果在 pytest 的命令行选项中存在 --keep-containers 选项（表示保持容器的选项），则返回 &quot;session&quot; 作为 fixture 的作用域；否则，返回 &quot;function&quot; 作为 fixture 的作用域。</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">determine_scope</span>(<span class="hljs-params">fixture_name, config</span>):<br>    <span class="hljs-keyword">if</span> config.getoption(<span class="hljs-string">&quot;--keep-containers&quot;</span>, <span class="hljs-literal">None</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;session&quot;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function&quot;</span><br><br><span class="hljs-comment"># fixture 的名称是 docker_container。</span><br><span class="hljs-comment">#scope=determine_scope 将作用域参数设置为 determine_scope 函数的返回值。也就是说，根据 determine_scope 函数的逻辑，这个 fixture 的作用域将根据 --keep-containers 命令行选项的存在与否来确定。</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=determine_scope</span>) </span><span class="hljs-comment"># scope=&quot;session&quot;或者&quot;function&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">docker_container</span>():<br>    <span class="hljs-keyword">yield</span> spawn_container()<br>	<span class="hljs-comment"># yield spawn_container() 表示在 fixture 的设置和清理过程中生成一个值。spawn_container() 是一个函数，它可能在 fixture 的设置阶段创建一个容器，并在 fixture 的清理阶段销毁容器。yield 语句将生成的值暂时提供给使用该 fixture 的测试函数，以便进行测试操作。</span><br></code></pre></td></tr></table></figure>

<h2 id="4-4-Teardown-Cleanup-又称前置和后置"><a href="#4-4-Teardown-Cleanup-又称前置和后置" class="headerlink" title="4.4 Teardown&#x2F;Cleanup (又称前置和后置)"></a>4.4 Teardown&#x2F;Cleanup (又称前置和后置)</h2><p>当我们运行测试时，我们需要确保它们自行清理，这样它们就不会干扰任何其他测试（同时我们也不会留下大量的测试数据来使系统膨胀）</p>
<p>pytest 中的装置提供了一个非常有用的拆卸系统，它允许我们定义每个装置自行清理所需的特定步骤。</p>
<p>可以通过两种方式利用该系统。</p>
<h3 id="1-yield-fixtures-【推荐】"><a href="#1-yield-fixtures-【推荐】" class="headerlink" title="1. yield fixtures 【推荐】"></a>1. <code>yield</code> fixtures 【推荐】</h3><p>“Yield” fixtures使用 <code>yield</code> 而不是 <code>return</code>.，我们可以运行一些代码并将对象传递回请求的装置&#x2F;测试，就像其他装置一样。唯一的区别是：</p>
<ol>
<li><code>return</code>换成<code>yield</code></li>
<li>一些 <code>teardown</code>代码放在<code>yiend</code>的后面</li>
</ol>
<p>一旦 pytest 计算出fixtures装置的线性顺序，它将运行每个fixtures装置，直到它返回或产生，然后转到列表中的下一个fixtures装置以执行相同的操作。</p>
<p>测试完成后，pytest 将返回fixtures装置列表，但以相反的顺序，获取每个生成的fixtures装置，并运行其中位于yield 语句之后的代码。</p>
<p>举一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of emaillib.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailAdminClient</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> MailUser()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">self, user</span>):<br>        <span class="hljs-comment"># do some cleanup</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailUser</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.inbox = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">self, email, other</span>):<br>        other.inbox.append(email)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_mailbox</span>(<span class="hljs-params">self</span>):<br>        self.inbox.clear()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Email</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, subject, body</span>):<br>        self.subject = subject<br>        self.body = body<br></code></pre></td></tr></table></figure>

<p>假设我们要测试从一个用户向另一个用户发送电子邮件。</p>
<ol>
<li>我们必须首先创建每个用户，</li>
<li>然后将电子邮件从一个用户发送到另一个用户，</li>
<li>最后断言另一个用户在其收件箱中收到了该消息。</li>
</ol>
<p>如果我们想在测试运行后进行清理，我们可能必须确保在删除其他用户之前清空该用户的邮箱，否则系统可能会有垃圾数据。</p>
<p>看一下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailAdminClient</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_user</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;create user&quot;</span>)<br>        <span class="hljs-keyword">return</span> MailUser()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>(<span class="hljs-params">self, user</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;delete user&quot;</span>)<br>        <span class="hljs-comment"># do some cleanup</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailUser</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.inbox = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">send_email</span>(<span class="hljs-params">self, email, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;send email&quot;</span>)<br>        other.inbox.append(email)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clear_mailbox</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;clearing mailbox&quot;</span>)<br>        self.inbox.clear()<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Email</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, subject, body</span>):<br>        self.subject = subject<br>        self.body = body<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mail_admin</span>():<br>    <span class="hljs-keyword">return</span> MailAdminClient()<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sending_user</span>(<span class="hljs-params">mail_admin</span>):<br>    user = mail_admin.create_user()<br>    <span class="hljs-keyword">yield</span> user<br>    mail_admin.delete_user(user)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receiving_user</span>(<span class="hljs-params">mail_admin</span>):<br>    user = mail_admin.create_user()<br>    <span class="hljs-keyword">yield</span> user<br>    user.clear_mailbox()<br>    mail_admin.delete_user(user)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_email_received</span>(<span class="hljs-params">sending_user, receiving_user</span>):<br>    email = Email(subject=<span class="hljs-string">&quot;Hey!&quot;</span>, body=<span class="hljs-string">&quot;How&#x27;s it going?&quot;</span>)<br>    sending_user.send_email(email, receiving_user)<br>    <span class="hljs-keyword">assert</span> email <span class="hljs-keyword">in</span> receiving_user.inbox<br></code></pre></td></tr></table></figure>

<p>看一下运行的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">============================ test session starts =======================================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>create user <span class="hljs-comment"># 开始时运行了</span><br>create user<br>send email<br>.clearing mailbox<br>delete user <span class="hljs-comment"># 结束时运行了</span><br>delete user<br><br><br>========================= <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =============================================<br></code></pre></td></tr></table></figure>

<p>因为receiving_user是安装过程中最后一个运行的fixture装置，所以它也是拆卸过程中第一个运行的fixture装置。</p>
<h4 id="yield-fixture处理错误"><a href="#yield-fixture处理错误" class="headerlink" title="yield fixture处理错误"></a>yield fixture处理错误</h4><p>如果yield装置在yield之前引发异常，pytest将不会尝试在该yield装置的yield语句之后运行结束代码。</p>
<p>但是，对于已经成功运行该测试的每个fixture装置，pytest 仍会像平常一样尝试将其拆除。</p>
<blockquote>
<p>也就是说，如果你在yield之前报错了，就不会运行yield之后的代码了，如果yield之前没报错，就肯定会运行yield之后的代码，哪怕yield之后也有报错</p>
</blockquote>
<h3 id="2-直接添加终结器finalizers"><a href="#2-直接添加终结器finalizers" class="headerlink" title="2. 直接添加终结器finalizers"></a>2. 直接添加终结器finalizers</h3><p>虽然<code>yield</code>夹具被认为是更简单、更直接的选项，但还有另一种选择，那就是将“finalizers”函数直接添加到测试的请求上下文对象<code>request</code>中。</p>
<p>它带来了与yield装置类似的结果，但可能会让代码变得冗余了一点。</p>
<p>为了使用这种方法，我们必须在需要添加拆卸代码的固定装置中请求请求上下文对象（就像我们请求另一个固定装置一样），然后将包含该拆卸代码的可调用对象传递给其 addfinalizer 方法。</p>
<p>但我们必须小心，因为 pytest 在添加<code>finalizers</code>后将运行该终结器，即使该装置在添加<code>finalizers</code>后引发异常</p>
<p>因此，为了确保我们在不需要时不运行终结器代码，只有在夹具完成了我们需要拆卸的操作后，我们才会添加终结器。</p>
<p>这里的目的是，你可以将清理用户数据的方法，放在这个用例执行完成后执行，以下是使用 addfinalizer 方法的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_emaillib.py</span><br><span class="hljs-keyword">from</span> emaillib <span class="hljs-keyword">import</span> Email, MailAdminClient<br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mail_admin</span>():<br>    <span class="hljs-keyword">return</span> MailAdminClient()<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sending_user</span>(<span class="hljs-params">mail_admin</span>):<br>    user = mail_admin.create_user()<br>    <span class="hljs-keyword">yield</span> user<br>    mail_admin.delete_user(user)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">receiving_user</span>(<span class="hljs-params">mail_admin, request</span>):<br>    user = mail_admin.create_user()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_user</span>():<br>        mail_admin.delete_user(user)<br><br>    request.addfinalizer(delete_user) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行	</span><br>    <span class="hljs-keyword">return</span> user<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">email</span>(<span class="hljs-params">sending_user, receiving_user, request</span>):<br>    _email = Email(subject=<span class="hljs-string">&quot;Hey!&quot;</span>, body=<span class="hljs-string">&quot;How&#x27;s it going?&quot;</span>)<br>    sending_user.send_email(_email, receiving_user)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">empty_mailbox</span>():<br>        receiving_user.clear_mailbox() <span class="hljs-comment"># 这个方法，是在</span><br><br>    request.addfinalizer(empty_mailbox) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-keyword">return</span> _email<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_email_received</span>(<span class="hljs-params">receiving_user, email</span>):<br>    <span class="hljs-keyword">assert</span> email <span class="hljs-keyword">in</span> receiving_user.inbox<br></code></pre></td></tr></table></figure>

<p>执行的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">====================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>create user<br>create user<br>send email<br>.clearing mailbox<br>delete user<br>delete user<br><br><br>======================================= <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==========<br></code></pre></td></tr></table></figure>



<p><code>request.addfinalizer()</code> 添加的方法会在当前测试用例执行完成后运行。它会在测试用例的所有代码（包括测试函数、fixture、setup 和 teardown）执行完毕后被调用。</p>
<p>具体来说，<code>request.addfinalizer()</code> 方法用于注册一个清理函数，该函数将在以下情况之一发生时被调用：</p>
<ol>
<li>当前测试用例的测试函数执行完成后。</li>
<li>当前测试用例中的任何 fixture 的 <code>yield</code> 语句之后。</li>
<li>当前测试用例中的任何 fixture 的 <code>teardown</code> 方法执行完成后。</li>
</ol>
<p>简化一下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Performing cleanup,这是最后执行的&quot;</span>)<br><br>    request.addfinalizer(cleanup) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setup&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Teardown&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_example2</span>(<span class="hljs-params">my_fixture</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Running test&quot;</span>)<br>    <br><span class="hljs-comment"># 你还可以写 lambda 匿名方法传进去，例如：</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>(<span class="hljs-params">request</span>):<br>    request.addfinalizer(<span class="hljs-keyword">lambda</span>: <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Performing cleanup,这是最后执行的&quot;</span>)) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setup&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Teardown&quot;</span>)<br><span class="hljs-comment"># 你也可以将方法定义在外面：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Performing cleanup,这是最后执行的&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture</span>(<span class="hljs-params">request</span>):<br>    request.addfinalizer(cleanup) <span class="hljs-comment"># 被添加进去的函数，会在测试用例执行完之后执行</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setup&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Teardown&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>执行的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">====================== test session starts =================================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br><br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">1</span> item                                                                                                                                                                    <br><br>testcases/test_fixturestest.py <br>Setup <span class="hljs-comment"># yield 前执行的</span><br>Running test <span class="hljs-comment"># 测试用例执行的</span><br>.Teardown <span class="hljs-comment"># yield 后执行的</span><br>Performing cleanup,这是最后执行的 <span class="hljs-comment"># 终结器执行的</span><br><br><br>======================== <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =========<br></code></pre></td></tr></table></figure>

<p><code> request.addfinalizer()</code>和<code>fixture</code>函数里面添加<code>yield</code>的区别在于：</p>
<ul>
<li><code> request.addfinalizer()</code>的函数是在测试结束后执行，</li>
<li><code> request.addfinalizer()</code>可以在程序发生报错后仍然执行，<strong>而使用<code>yield</code>的话，<code>yield</code>前面的代码在执行时如果报错，那<code>yield</code>后面的代码就不会执行，</strong></li>
</ul>
<blockquote>
<p>另关于对于<code>request</code>的使用，后续开一篇文章讲解</p>
</blockquote>
<h4 id="关于finalizer顺序的注意事项【重点】"><a href="#关于finalizer顺序的注意事项【重点】" class="headerlink" title="关于finalizer顺序的注意事项【重点】"></a>关于finalizer顺序的注意事项【重点】</h4><p><code>finalizer</code>按照先进后出的顺序执行。对于<code>yield </code>的<code>fixture</code>，要运行的第一个<code>teardown</code>代码来自最右侧的<code>fixture</code>装置，即最后一个测试参数（入参）。</p>
<ul>
<li>从右往左顺序执行<code>yield</code> 的 <code>fixture</code></li>
</ul>
<p>看代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_finalizers.py</span><br><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_bar</span>(<span class="hljs-params">fix_w_yield1, fix_w_yield2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_bar&quot;</span>)<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix_w_yield1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_1,start&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_1,end&quot;</span>)<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix_w_yield2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_2,start&quot;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;after_yield_2,end&quot;</span>)<br>    <br>$ pytest -s test_finalizers.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">1</span> item<br><br>test_finalizers.py <br>test_bar <span class="hljs-comment"># 先打印测试函数内的代码</span><br>.after_yield_2 <span class="hljs-comment"># 先执行的2</span><br>after_yield_1 <span class="hljs-comment"># 再执行的1</span><br>yield_1,start <span class="hljs-comment"># 开始时先执行的1的开始</span><br>after_yield_2,start <span class="hljs-comment"># 再执行2的开始</span><br>test_bar <span class="hljs-comment"># 再执行测试函数</span><br>.after_yield_2,end <span class="hljs-comment"># 结束时先执行2的结束</span><br>after_yield_1,end <span class="hljs-comment"># 再执行1的结束</span><br><br>============================ <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure>

<p>对于finalizers内注册的函数，优先运行最后一个添加进去的函数，依次往前运行。代码示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_finalizers.py</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix_w_finalizers</span>(<span class="hljs-params">request</span>):<br>    request.addfinalizer(partial(<span class="hljs-built_in">print</span>, <span class="hljs-string">&quot;finalizer_2&quot;</span>)) <span class="hljs-comment"># 后运行2</span><br>    request.addfinalizer(partial(<span class="hljs-built_in">print</span>, <span class="hljs-string">&quot;finalizer_1&quot;</span>)) <span class="hljs-comment"># 先运行1</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_bar</span>(<span class="hljs-params">fix_w_finalizers</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_bar&quot;</span>)<br>$ pytest -s test_finalizers.py<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y<br>rootdir: /home/sweet/project<br>collected <span class="hljs-number">1</span> item<br><br>test_finalizers.py test_bar<br>.finalizer_1 <span class="hljs-comment"># 先运行1</span><br>finalizer_2 <span class="hljs-comment"># 后运行2</span><br><br><br>============================ <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =============================<br></code></pre></td></tr></table></figure>

<p>之所以如此，是因为产量yield fixtures装置在幕后使用了 addfinalizer：当fixture装置执行时，addfinalizer 注册一个恢复生成器的函数，该函数又调用teardown代码。</p>
<blockquote>
<p>所以一个测试用例内的fixture的执行顺序是，入参中的最后一个先执行，addfinalizer注册的函数最后执行</p>
</blockquote>
<h2 id="4-5-teardowns安全【注意】"><a href="#4-5-teardowns安全【注意】" class="headerlink" title="4.5 teardowns安全【注意】"></a>4.5 teardowns安全【注意】</h2><p>pytest 的固定系统非常强大，但它仍然由计算机运行，因此它无法弄清楚如何安全地拆除我们扔给它的所有东西</p>
<p>如果我们不小心，错误位置的错误可能会留下测试中的内容，这可能很快会导致进一步的问题。</p>
<p>例如，考虑以下测试（基于上面的邮件示例）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_emaillib.py</span><br><span class="hljs-keyword">from</span> emaillib <span class="hljs-keyword">import</span> Email, MailAdminClient<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>():<br>    mail_admin = MailAdminClient()<br>    sending_user = mail_admin.create_user()<br>    receiving_user = mail_admin.create_user()<br>    email = Email(subject=<span class="hljs-string">&quot;Hey!&quot;</span>, body=<span class="hljs-string">&quot;How&#x27;s it going?&quot;</span>)<br>    sending_user.send_email(email, receiving_user)<br>    <span class="hljs-keyword">yield</span> receiving_user, email<br>    receiving_user.clear_mailbox()<br>    mail_admin.delete_user(sending_user)<br>    mail_admin.delete_user(receiving_user)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_email_received</span>(<span class="hljs-params">setup</span>):<br>    receiving_user, email = setup<br>    <span class="hljs-keyword">assert</span> email <span class="hljs-keyword">in</span> receiving_user.inbox<br></code></pre></td></tr></table></figure>

<ul>
<li><p>这个版本的代码看起来确实是更加紧凑，只定义了一个<code>fixture</code>函数,但是可这样的代码读性也会更差，没有什么描述性的<code>fixture</code>名称，一点也不见名知意，并且也无法做到轻松的重复使用这个<code>fixture</code>，复用性差。</p>
</li>
<li><p>这里还有一个更严重的问题，即如果在运行代码的时候有任何步骤引发了程序异常报错，则任何代码都不会运行。</p>
</li>
<li><p>所以有另一种选择就是使用 addfinalizer 注册方法而不是全部都堆在fixture里面，但是用addfinalizer的话可能会是代码变得相当复杂且难以维护（并且它不再紧凑）。有利有弊吧</p>
</li>
</ul>
<h3 id="4-5-1-fixture-安全结构"><a href="#4-5-1-fixture-安全结构" class="headerlink" title="4.5.1 fixture 安全结构"></a>4.5.1 fixture 安全结构</h3><p>最安全和最简单的<code>fixture</code>结构要求限制一个<code>fixture</code>仅进行一个状态的更改操作（<strong>意思就是一个<code>fixture</code>只做一件事情，逻辑不可以写多了</strong>），</p>
<p>然后将多个<code>fixture</code>与其他<code>fixture</code>代码捆绑在一起，如上面的电子邮件示例所示。</p>
<p> 状态更改操作失败但仍然修改状态的可能性可以忽略不计，因为大多数这些操作往往是基于事务的（至少在状态可能被抛在后面的测试级别）。</p>
<p> 因此，如果我们通过将任何成功的状态更改操作移动到单独的<code>fixture</code>并将其与其他有可能失败的状态更改操作分开来确保将其最后执行，那么我们的测试将有最多的可能离开测试环境</p>
<p>这里的意思，将必定成功的操作，和可能失败的操作拆分开来，将成功率大的和成功率大的操作放在一起，失败率大的放一起或者拆开来放，避免一头成功一头失败的，造成其他安全隐患</p>
<p> 举个例子，假设我们有一个带有登录页面的网站，并且我们可以访问可以生成用户的管理 API。 对于我们的测试，我们想要：</p>
<ol>
<li>通过该API 创建管理用户</li>
<li>使用 Selenium 启动浏览器</li>
<li>转到我们网站的登录页面</li>
<li>以我们创建的用户身份登录</li>
<li>在登录的标题中断言我们的用户名称</li>
</ol>
<p>我们不想让该用户留在系统数据中，避免脏数据，也不想让浏览器会话保持运行，因此我们希望确保创建这些东西的装置能够自行清理脏数据和关闭浏览器页面。</p>
<p>示例看起来是这样的：</p>
<blockquote>
<p>对于此示例，某些固定装置（即 base_url 和 admin_credentials）暗示存在于其他地方。所以现在，我们假设它们存在，但我们只是不去关注它们。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urljoin<br><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> Chrome<br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">from</span> src.utils.pages <span class="hljs-keyword">import</span> LoginPage, LandingPage<br><span class="hljs-keyword">from</span> src.utils <span class="hljs-keyword">import</span> AdminApiClient<br><span class="hljs-keyword">from</span> src.utils.data_types <span class="hljs-keyword">import</span> User<br><br><span class="hljs-comment"># 关注代码的分层</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_client</span>(<span class="hljs-params">base_url, admin_credentials</span>): <span class="hljs-comment"># 这个fixture只负责连接Url</span><br>    <span class="hljs-keyword">return</span> AdminApiClient(base_url, **admin_credentials)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">admin_client</span>): <span class="hljs-comment"># 这个fixture只负责创建管理员用户，和结束时删除用户</span><br>    _user = User(name=<span class="hljs-string">&quot;Susan&quot;</span>, username=<span class="hljs-string">f&quot;testuser-<span class="hljs-subst">&#123;uuid4()&#125;</span>&quot;</span>, password=<span class="hljs-string">&quot;P4$$word&quot;</span>)<br>    admin_client.create_user(_user)<br>    <span class="hljs-keyword">yield</span> _user<br>    admin_client.delete_user(_user)<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>(): <span class="hljs-comment"># 这个fixture，只负责定义浏览器驱动打开和关闭浏览器</span><br>    _driver = Chrome()<br>    <span class="hljs-keyword">yield</span> _driver<br>    _driver.quit()<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">driver, base_url, user</span>): <span class="hljs-comment"># 这个fixute只负责用户的页面的打开和登录用户</span><br>    driver.get(urljoin(base_url, <span class="hljs-string">&quot;/login&quot;</span>)) <span class="hljs-comment"># 用户登录程序</span><br>    page = LoginPage(driver)<br>    page.login(user)<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">landing_page</span>(<span class="hljs-params">driver, login</span>): <span class="hljs-comment"># 这个fixture 值负责将驱动和用户登录页面组合在一起，意思就是负责打开浏览器、进入用户登录页面登录</span><br>    <span class="hljs-keyword">return</span> LandingPage(driver)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_name_on_landing_page_after_login</span>(<span class="hljs-params">landing_page, user</span>): <span class="hljs-comment"># 测试代码，将所有fixtue组合</span><br>    <span class="hljs-keyword">assert</span> landing_page.header == <span class="hljs-string">f&quot;Welcome, <span class="hljs-subst">&#123;user.name&#125;</span>!&quot;</span><br></code></pre></td></tr></table></figure>

<p>依赖关系的布置方式意味着不清楚用户<code>fixture</code>是否会在驱动程序<code>fixture</code>之前执行。 </p>
<p>但这没关系，因为这些都是原子操作，所以哪个先运行并不重要，因为测试的事件序列仍然是线性化的。 </p>
<p>但重要的是，无论哪一个先运行，如果某一个抛出异常，而另一个没有抛出异常，那么两个都不会留下任何东西。</p>
<p> 如果驱动程序<code>fixture</code>在用户<code>fixture</code>之前执行，并且用户<code>fixture</code>引发异常，驱动程序<code>fixture</code>仍然会退出，并且用户永远不会被创建。 如果驱动程序是引发异常的人，那么驱动程序将永远不会启动，用户也永远不会被创建。</p>
<p>这里的意思还是做拆分，就像代码分层一样，原子层的操作和业务层的操作分开来，这里的代码就是将登录的操作和创建用户的操作分了层，打开浏览器的操作</p>
<ul>
<li>admin_client(base_url, admin_credentials) ：这个fixture只负责连接对应的 Url</li>
<li>user(admin_client)：这个fixture会使用到admin_client，只负责创建管理员用户，和结束时删除用户</li>
<li>driver() ：这个fixture，只负责定义浏览器驱动打开和关闭浏览器，不做其他操作</li>
<li>login(driver, base_url, user):  这个fixute是一个组合，将driver 和  base_url 和 user 三个组合到一起，作用是打开浏览器、打开对应的url 执行用户操作，结束时会将所有fixtue的结束操作全部执行</li>
</ul>
<p><strong>这是很好的一种编码设计思想，一种分层的思想，将用户登录的操作全部分层出来，测试代码只负责最终的组合，不关注它所依赖的fixture 的实现逻辑，只关注进和出。这里很重要</strong></p>
<h2 id="4-6-安全的运行多个assert断言语句"><a href="#4-6-安全的运行多个assert断言语句" class="headerlink" title="4.6 安全的运行多个assert断言语句"></a>4.6 安全的运行多个<code>assert</code>断言语句</h2><p>有时，您可能希望在完成所有设置后运行多个断言，这是有道理的，因为在更复杂的系统中，单个操作可以启动多个行为</p>
<p>pytest 有一种方便的方法来处理这个问题，它结合了我们到目前为止所讨论的一些内容。</p>
<p>所需要的只是逐步扩大到更大的范围，然后将行为步骤定义为自动使用固定装置，最后确保所有固定装置都针对更高级别的范围</p>
<p>让我们从上面举一个例子，并稍微调整一下。假设除了检查标题中的欢迎消息之外，我们还想检查注销按钮和用户个人资料的链接。</p>
<p>让我们看一下如何构建它，以便我们可以运行多个断言，而不必再次重复所有这些步骤。</p>
<blockquote>
<p>对于此示例，某些固定装置（即 base_url 和 admin_credentials）暗示存在于其他地方。所以现在，我们假设它们存在，但我们只是不去关注它们。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># contents of tests/end_to_end/test_login.py</span><br><span class="hljs-keyword">from</span> uuid <span class="hljs-keyword">import</span> uuid4<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urljoin<br><br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> Chrome<br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">from</span> src.utils.pages <span class="hljs-keyword">import</span> LoginPage, LandingPage<br><span class="hljs-keyword">from</span> src.utils <span class="hljs-keyword">import</span> AdminApiClient<br><span class="hljs-keyword">from</span> src.utils.data_types <span class="hljs-keyword">import</span> User<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_client</span>(<span class="hljs-params">base_url, admin_credentials</span>):<br>    <span class="hljs-keyword">return</span> AdminApiClient(base_url, **admin_credentials)<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>(<span class="hljs-params">admin_client</span>):<br>    _user = User(name=<span class="hljs-string">&quot;Susan&quot;</span>, username=<span class="hljs-string">f&quot;testuser-<span class="hljs-subst">&#123;uuid4()&#125;</span>&quot;</span>, password=<span class="hljs-string">&quot;P4$$word&quot;</span>)<br>    admin_client.create_user(_user)<br>    <span class="hljs-keyword">yield</span> _user<br>    admin_client.delete_user(_user)<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">driver</span>():<br>    _driver = Chrome()<br>    <span class="hljs-keyword">yield</span> _driver<br>    _driver.quit()<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">landing_page</span>(<span class="hljs-params">driver, login</span>):<br>    <span class="hljs-keyword">return</span> LandingPage(driver)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLandingPageSuccess</span>:<br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span>, autouse=<span class="hljs-literal">True</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">self, driver, base_url, user</span>):<br>        driver.get(urljoin(base_url, <span class="hljs-string">&quot;/login&quot;</span>))<br>        page = LoginPage(driver)<br>        page.login(user)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_name_in_header</span>(<span class="hljs-params">self, landing_page, user</span>):<br>        <span class="hljs-keyword">assert</span> landing_page.header == <span class="hljs-string">f&quot;Welcome, <span class="hljs-subst">&#123;user.name&#125;</span>!&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_sign_out_button</span>(<span class="hljs-params">self, landing_page</span>):<br>        <span class="hljs-keyword">assert</span> landing_page.sign_out_button.is_displayed()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_profile_link</span>(<span class="hljs-params">self, landing_page, user</span>):<br>        profile_href = urljoin(base_url, <span class="hljs-string">f&quot;/profile?id=<span class="hljs-subst">&#123;user.profile_id&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">assert</span> landing_page.profile_link.get_attribute(<span class="hljs-string">&quot;href&quot;</span>) == profile_href<br></code></pre></td></tr></table></figure>

<p>请注意，这些方法只是在签名中引用 self 作为一种形式。没有任何状态与实际的测试类相关，因为它可能位于 unittest.TestCase 框架中。一切都由 pytest 夹具系统管理。</p>
<p>每个方法只需要请求它实际需要的fixture，而不用担心执行顺序。这是因为fixture装置是一个自动使用的fixture，并且它确保所有其他fixture在它之前执行。</p>
<p>不再需要进行状态更改，因此测试可以自由地进行任意数量的非状态更改查询，而不必冒踩到其他测试的风险。</p>
<blockquote>
<p>登录装置也在类内部定义，因为并非模块中的每个其他测试都期望成功登录，并且对于另一个测试类，该行为可能需要稍微不同地处理。可以每个类每个登录</p>
</blockquote>
<blockquote>
<p>这里表达的是，在一个测试类内，运行多个测试用例，多个断言，不会因为某个测试用例的断言失败了导致另一个测试用例无法运行下下去，虽然他们都是使用的同一个fixture夹具，你需要其他的登录前置，那么你可以在另一个类内编写一个fixture 供这个类内的用例去使用，</p>
</blockquote>
<p>例如，如果我们想围绕提交错误凭据编写另一个测试场景，我们可以通过在测试文件中添加如下内容来处理它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLandingPageBadCredentials</span>:<br><span class="hljs-meta">    @pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">faux_user</span>(<span class="hljs-params">self, user</span>):<br>        _user = deepcopy(user)<br>        _user.password = <span class="hljs-string">&quot;badpass&quot;</span><br>        <span class="hljs-keyword">return</span> _user<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_raises_bad_credentials_exception</span>(<span class="hljs-params">self, login_page, faux_user</span>):<br>        <span class="hljs-keyword">with</span> pytest.raises(BadCredentialsException):<br>            login_page.login(faux_user)<br></code></pre></td></tr></table></figure>

<h2 id="4-7-Fixtures-可以使用内置的requesting来测试上下文【重点】"><a href="#4-7-Fixtures-可以使用内置的requesting来测试上下文【重点】" class="headerlink" title="4.7 Fixtures 可以使用内置的requesting来测试上下文【重点】"></a>4.7 Fixtures 可以使用内置的requesting来测试上下文【重点】</h2><p><code>fixture</code>函数可以接受<code>requesting</code>对象来内省“request”来测试函数、类或模块上下文。</p>
<p>进一步扩展前面的 smtp_connection 夹具示例，让我们从使用我们的夹具的测试模块中读取可选的服务器 URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">import</span> smtplib<br><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>(<span class="hljs-params">request</span>):<br>    server = <span class="hljs-built_in">getattr</span>(request.module, <span class="hljs-string">&quot;smtpserver&quot;</span>, <span class="hljs-string">&quot;smtp.gmail.com&quot;</span>) <span class="hljs-comment"># getattr()获取对象的属性和方法，第一个参数是对象本身，第二个参数是对象的属性，第三个参数是如果没有时的返回默认值</span><br>    smtp_connection = smtplib.SMTP(server, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">yield</span> smtp_connection<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;finalizing <span class="hljs-subst">&#123;smtp_connection&#125;</span> (<span class="hljs-subst">&#123;server&#125;</span>)&quot;</span>)<br>    smtp_connection.close()<br></code></pre></td></tr></table></figure>

<p>我们使用<code>request.module</code>属性来选择性地从测试模块获取 <code>smtpserver </code>属性。如果我们再次执行，没有什么改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -s -q --tb=no test_module.py<br>FFfinalizing &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0002</span>&gt; (smtp.gmail.com)<br><br>========================= short test summary info ==========================<br>FAILED test_module.py::test_ehlo - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>FAILED test_module.py::test_noop - <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br><span class="hljs-number">2</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure>

<p>让我们快速创建另一个测试模块，该模块实际上在其模块命名空间中设置服务器 URL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"> content of test_anothersmtp.py<br><br>smtpserver = <span class="hljs-string">&quot;mail.python.org&quot;</span>  <span class="hljs-comment"># will be read by smtp fixture</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_showhelo</span>(<span class="hljs-params">smtp_connection</span>):<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>, smtp_connection.helo()<br></code></pre></td></tr></table></figure>

<p>Running it:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -qq --tb=short test_anothersmtp.py<br>F                                                                    [<span class="hljs-number">100</span>%]<br>================================= FAILURES =================================<br>______________________________ test_showhelo _______________________________<br>test_anothersmtp.py:<span class="hljs-number">6</span>: <span class="hljs-keyword">in</span> test_showhelo<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span>, smtp_connection.helo()<br>E   AssertionError: (<span class="hljs-number">250</span>, <span class="hljs-string">b&#x27;mail.python.org&#x27;</span>)<br>E   <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span><br>------------------------- Captured stdout teardown -------------------------<br>finalizing &lt;smtplib.SMTP <span class="hljs-built_in">object</span> at <span class="hljs-number">0xdeadbeef0003</span>&gt; (mail.python.org)<br>========================= short test summary info ==========================<br>FAILED test_anothersmtp.py::test_showhelo - AssertionError: (<span class="hljs-number">250</span>, <span class="hljs-string">b&#x27;mail....</span><br></code></pre></td></tr></table></figure>

<p>瞧！ smtp_connection fixture从模块命名空间中获取我们的邮件服务器名称。</p>
<blockquote>
<p>通过request.module获取测试模块对象，request是一个对象，这个对象就是整场测试，</p>
<p>request是一个特俗的fixute用于获取有关当前测试的信息和操作</p>
</blockquote>
<h2 id="4-8-使用标记将数据传递到fixtures"><a href="#4-8-使用标记将数据传递到fixtures" class="headerlink" title="4.8 使用标记将数据传递到fixtures"></a>4.8 使用标记将数据传递到fixtures</h2><p>使用request对象，夹具还可以访问应用于测试功能的标记。这对于将数据从测试传递到夹具中非常有用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fixt</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 这个fixture的目的是获取被测用例的mark的标记，</span><br>    marker = request.node.get_closest_marker(<span class="hljs-string">&quot;fixt_data&quot;</span>) <span class="hljs-comment"># 获取用例的mark标记的fixt_data</span><br>    <span class="hljs-keyword">if</span> marker <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Handle missing marker in some way...</span><br>        data = <span class="hljs-literal">None</span> <span class="hljs-comment"># 如果没有使用标记，就返回none </span><br>    <span class="hljs-keyword">else</span>:<br>        data = marker.args[<span class="hljs-number">0</span>] <span class="hljs-comment"># 如果有使用mark标记，就返回标记的值</span><br>    <span class="hljs-comment"># Do something with the data</span><br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">@pytest.mark.fixt_data(<span class="hljs-params"><span class="hljs-number">42</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fixt</span>(<span class="hljs-params">fixt</span>):<br>    <span class="hljs-keyword">assert</span> fixt == <span class="hljs-number">42</span> <span class="hljs-comment"># 断言成功</span><br></code></pre></td></tr></table></figure>

<h2 id="4-9-工厂-fixtures【重点】"><a href="#4-9-工厂-fixtures【重点】" class="headerlink" title="4.9 工厂 fixtures【重点】"></a>4.9 工厂 fixtures【重点】</h2><p>“工厂即夹具”模式可以在单次测试中多次需要夹具结果的情况下提供帮助。</p>
<p>夹具不是直接返回数据，而是返回生成数据的函数。然后可以在测试中多次调用该函数。</p>
<blockquote>
<p>这里需要了解一下什么是工厂函数，或者说工厂设计模式了，工厂可以根据条件或者参数的不同来创建不同类型的对象</p>
</blockquote>
<p>演员可以根据需要拥有参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_customer_record</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_customer_record</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Making customer record for <span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;name&quot;</span>: name, <span class="hljs-string">&quot;orders&quot;</span>: []&#125;<br><br>    <span class="hljs-keyword">return</span> _make_customer_record <span class="hljs-comment">#返回的是一个函数</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_customer_records</span>(<span class="hljs-params">make_customer_record</span>):<br>    <span class="hljs-comment"># 调用3次，获得3个不同的对象，因为这个fixture的返回值就是一个函数</span><br>    customer_1 = make_customer_record(<span class="hljs-string">&quot;Lisa&quot;</span>) <span class="hljs-comment"># 调用这个函数，Making customer record for Lisa</span><br>    customer_2 = make_customer_record(<span class="hljs-string">&quot;Mike&quot;</span>) <span class="hljs-comment"># Making customer record for Mike</span><br>    customer_3 = make_customer_record(<span class="hljs-string">&quot;Meredith&quot;</span>) <span class="hljs-comment"># Making customer record for Meredith</span><br></code></pre></td></tr></table></figure>

<p>如果工厂创建的数据需要管理，夹具可以处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_customer_record</span>():<br>    created_records = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_customer_record</span>(<span class="hljs-params">name</span>):<br>        record = models.Customer(name=name, orders=[])<br>        created_records.append(record)<br>        <span class="hljs-keyword">return</span> record<br><br>    <span class="hljs-keyword">yield</span> _make_customer_record<br><br>    <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> created_records: <span class="hljs-comment"># 这一条在测试用例结束时执行</span><br>        record.destroy() <span class="hljs-comment"># 循环销毁的意思，</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_customer_records</span>(<span class="hljs-params">make_customer_record</span>):<br>    customer_1 = make_customer_record(<span class="hljs-string">&quot;Lisa&quot;</span>)<br>    customer_2 = make_customer_record(<span class="hljs-string">&quot;Mike&quot;</span>)<br>    customer_3 = make_customer_record(<span class="hljs-string">&quot;Meredith&quot;</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>fixture</code>可以定义成一个工厂方法供测试用例去使用</p>
</blockquote>
<h2 id="4-10-参数化-fixtures【重点】"><a href="#4-10-参数化-fixtures【重点】" class="headerlink" title="4.10 参数化 fixtures【重点】"></a>4.10 参数化 fixtures【重点】</h2><p>夹具函数可以参数化，在这种情况下，它们将被多次调用，每次执行一组相关测试，即依赖于该夹具的测试。</p>
<p>测试函数通常不需要知道它们的重新运行。夹具参数化有助于为组件编写详尽的功能测试，这些组件本身可以通过多种方式进行配置。</p>
<p>展前面的示例，我们可以标记该固定装置以创建两个 smtp_connection 固定装置实例，这将导致使用该固定装置的所有测试运行两次。</p>
<p>Fixture函数通过特殊的请求对象来访问每个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><span class="hljs-keyword">import</span> smtplib<br><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span>, params=[<span class="hljs-string">&quot;smtp.gmail.com&quot;</span>, <span class="hljs-string">&quot;mail.python.org&quot;</span>]</span>) </span><span class="hljs-comment"># 注意这里定义的params = [ ] 参数是一个列表，所以会运行两次，如何拿到这个参数呢？</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">smtp_connection</span>(<span class="hljs-params">request</span>):<br>    smtp_connection = smtplib.SMTP(request.param, <span class="hljs-number">587</span>, timeout=<span class="hljs-number">5</span>) <span class="hljs-comment"># 用request.param去拿即可</span><br>    <span class="hljs-keyword">yield</span> smtp_connection<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;finalizing <span class="hljs-subst">&#123;smtp_connection&#125;</span>&quot;</span>)<br>    smtp_connection.close()<br></code></pre></td></tr></table></figure>

<p>主要需要了解的是使用 @pytest.fixture 声明参数，这是一个值列表，其中的每个值将被执行，并且可以通过 request.param 访问值。</p>
<p><strong>写一个简单的更容易理解：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;session&quot;</span>, params=[ [<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>],[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>]]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_param</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> request.param<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_getParam</span>(<span class="hljs-params">get_param</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第<span class="hljs-subst">&#123;get_param[<span class="hljs-number">0</span>]&#125;</span>次运行，打印<span class="hljs-subst">&#123;get_param[<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br>============================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span><br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collected <span class="hljs-number">2</span> items<br><br>testcases/test_fixturestest.py <br>第<span class="hljs-number">1</span>次运行，打印one<br>.第<span class="hljs-number">2</span>次运行，打印two<br>.<br><br>============================== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ======================<br></code></pre></td></tr></table></figure>

<p>这里可以看到，这个测试函数，针对get_param方法，运行了两次，</p>
<p>pytest 可以使用字符串进行标记，这个字符串是参数化fixture夹具中每个夹具值的测试 ID 标签，。这些 ID 可以与 -k 一起使用来选择运行的指定的测试用例，并且它们也支持失败重试，</p>
<p>也可以在命令行执行测试时加入 <code>--collect-only </code>命令可以在运行测试时展示对应的 ID</p>
<p>数字、字符串、布尔值和 None 将在测试 ID 中使用其常用的字符串表示形式。</p>
<p>对于其他对象，pytest 将根据参数名称创建一个字符串。通过使用 ids 关键字参数，可以为某个固定装置值自定义测试 ID 中使用的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_ids.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], ids=[<span class="hljs-string">&quot;spam&quot;</span>, <span class="hljs-string">&quot;ham&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-built_in">print</span>(request.param)<br>    <span class="hljs-keyword">return</span> request.param<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_a</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-keyword">pass</span><br><br>========================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code/venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">2</span> items<br><br>testcases/test_fixturestest.py::test_a[ham] <span class="hljs-number">1</span> <span class="hljs-comment"># ham 是 id 1 是参数</span><br>PASSED<br>testcases/test_fixturestest.py::test_a[spam] <span class="hljs-number">0</span> <span class="hljs-comment"># spam 是 id 1 是参数</span><br>PASSED<br><br>============================== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ========<br><span class="hljs-comment"># 也可以支持动态给标签</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">idfn</span>(<span class="hljs-params">fixture_value</span>): <span class="hljs-comment"># 动态给标签</span><br>    <span class="hljs-keyword">if</span> fixture_value == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;eggs&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;eggs&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行了 &quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], ids=idfn</span>) </span><span class="hljs-comment"># 支持动态传入标签</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">b</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-built_in">print</span>(request.param)<br>    <span class="hljs-keyword">return</span> request.param<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_b</span>(<span class="hljs-params">b</span>):<br>    <span class="hljs-keyword">pass</span><br>====================== test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code//venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... eggs<br>执行了 <br>collected <span class="hljs-number">2</span> items<br><br>testcases/test_fixturestest.py::test_b[<span class="hljs-number">1</span>] <span class="hljs-number">1</span> <span class="hljs-comment"># id 和 参数化</span><br>PASSED<br>testcases/test_fixturestest.py::test_b[eggs] <span class="hljs-number">0</span><br>PASSED<br><br>============================== <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ===============<br></code></pre></td></tr></table></figure>

<p>也可以在<code>pytest.ini</code>里面使用<code>-k</code>接字符串来指定标签运行</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># content of pytest.ini</span><br><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">addopts</span> = -s -v  -k <span class="hljs-string">&quot;ham&quot;</span><br><span class="hljs-comment"># -s 是捕获打印输出，如果有用到print()打印终端输出的话，就必须就加这个</span><br><span class="hljs-comment"># -v 就是展示标识符，</span><br><span class="hljs-comment"># -k 就是制定表示符</span><br></code></pre></td></tr></table></figure>

<h2 id="4-11-使用带标记参数化fixture夹具"><a href="#4-11-使用带标记参数化fixture夹具" class="headerlink" title="4.11 使用带标记参数化fixture夹具"></a>4.11 使用带标记参数化fixture夹具</h2><p><code>pytest.param()</code> 可用于在参数化装置的值集中应用标记，其方式与与 @pytest.mark.parametrize 使用的方式相同。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_fixture_marks.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, pytest.param(<span class="hljs-params"><span class="hljs-number">2</span>, marks=pytest.mark.skip</span>)]</span>) </span><span class="hljs-comment"># 使用 pytest.param</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_set</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> request.param<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_data</span>(<span class="hljs-params">data_set</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<p>运行此测试将跳过对值为 2 的 data_set 的调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest test_fixture_marks.py -v<br>=========================== test session starts ============================<br>platform linux -- Python <span class="hljs-number">3.</span>x.y, pytest-<span class="hljs-number">8.</span>x.y, pluggy-<span class="hljs-number">1.</span>x.y -- $PYTHON_PREFIX/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/sweet/project<br>collecting ... collected <span class="hljs-number">3</span> items<br><br>test_fixture_marks.py::test_data[<span class="hljs-number">0</span>] PASSED                           [ <span class="hljs-number">33</span>%]<br>test_fixture_marks.py::test_data[<span class="hljs-number">1</span>] PASSED                           [ <span class="hljs-number">66</span>%]<br>test_fixture_marks.py::test_data[<span class="hljs-number">2</span>] SKIPPED (unconditional skip)     [<span class="hljs-number">100</span>%]<br><br>======================= <span class="hljs-number">2</span> passed, <span class="hljs-number">1</span> skipped <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s =======================<br></code></pre></td></tr></table></figure>

<h2 id="4-12-模块化：从一个fixutre方法中使用fixture"><a href="#4-12-模块化：从一个fixutre方法中使用fixture" class="headerlink" title="4.12 模块化：从一个fixutre方法中使用fixture"></a>4.12 模块化：从一个fixutre方法中使用fixture</h2><p>模块化：使用固定功能中的固定装置</p>
<p>除了在测试函数中使用固定装置之外，固定装置函数还可以使用其他固定装置本身</p>
<p>这有助于设备的模块化设计，并允许在许多项目中重复使用特定于框架的设备。举个简单的例子，</p>
<p>我们可以扩展前面的示例并实例化一个对象应用程序，将已定义的 smtp_connection 资源粘贴到其中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_appsetup.py</span><br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, smtp_connection</span>):<br>        self.smtp_connection = smtp_connection<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>(<span class="hljs-params">smtp_connection</span>):<br>    <span class="hljs-keyword">return</span> App(smtp_connection) <span class="hljs-comment"># 这个smtp_connection就是之前定义的fixture 在这个被使用了</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_smtp_connection_exists</span>(<span class="hljs-params">app</span>):<br>    <span class="hljs-keyword">assert</span> app.smtp_connection<br></code></pre></td></tr></table></figure>

<p>由于smtp_connection的参数化，测试将使用两个不同的App实例和各自的smtp服务器运行两次。应用程序fixture不需要知道smtp_connection参数化，因为pytest将完全分析fixture依赖关系图。</p>
<p>注意，app fixture的作用域是module，并使用了一个模块作用域的smtp_connection fixture。如果smtp_connection缓存在会话作用域中，这个例子仍然可以工作:fixture可以使用“更广”作用域的fixture，但反之则不行:会话作用域的fixture不能以有意义的方式使用模块作用域的fixture。</p>
<h2 id="4-13-按fixture实例自动对测试进行分组"><a href="#4-13-按fixture实例自动对测试进行分组" class="headerlink" title="4.13 按fixture实例自动对测试进行分组"></a>4.13 按fixture实例自动对测试进行分组</h2><p>Pytest在测试运行期间最小化活动fixture的数量。如果您有一个参数化的fixture，那么使用它的所有测试将首先使用一个实例执行，然后在创建下一个fixture实例之前调用finalizers。除此之外，这简化了创建和使用全局状态的应用程序的测试。</p>
<p>下面的例子使用了两个参数化的fixture，其中一个是基于每个模块的，所有的函数都执行print调用来显示setup&#x2F;teardown流程:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_module.py</span><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span>, params=[<span class="hljs-string">&quot;mod1&quot;</span>, <span class="hljs-string">&quot;mod2&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">modarg</span>(<span class="hljs-params">request</span>):<br>    param = request.param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  SETUP modarg&quot;</span>, param)<br>    <span class="hljs-keyword">yield</span> param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  TEARDOWN modarg&quot;</span>, param)<br><br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span>, params=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">otherarg</span>(<span class="hljs-params">request</span>):<br>    param = request.param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  SETUP otherarg&quot;</span>, param)<br>    <span class="hljs-keyword">yield</span> param<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  TEARDOWN otherarg&quot;</span>, param)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_0</span>(<span class="hljs-params">otherarg</span>):  <span class="hljs-comment"># 这个用的是otherarg 是独立的执行了2次</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  RUN test0 with otherarg&quot;</span>, otherarg)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">modarg</span>): <span class="hljs-comment"># 这个用了modarg 执行了两次</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;  RUN test1 with modarg&quot;</span>, modarg)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">otherarg, modarg</span>): <span class="hljs-comment"># 这个是2+2次，</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  RUN test2 with otherarg <span class="hljs-subst">&#123;otherarg&#125;</span> and modarg <span class="hljs-subst">&#123;modarg&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>总共执行了8次,让我们在详细模式下运行测试并查看打印输出：详细模式，就是加了-s的模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">======================= test session starts ==============================<br>platform linux -- Python <span class="hljs-number">3.10</span><span class="hljs-number">.12</span>, pytest-<span class="hljs-number">8.1</span><span class="hljs-number">.1</span>, pluggy-<span class="hljs-number">1.4</span><span class="hljs-number">.0</span> -- /home/wang/code//venvadmin/<span class="hljs-built_in">bin</span>/python<br>cachedir: .pytest_cache<br>rootdir: /home/wang/<br>configfile: pytest.ini<br>plugins: anyio-<span class="hljs-number">4.2</span><span class="hljs-number">.0</span><br>collecting ... collected <span class="hljs-number">8</span> items<br><br>testcases/test_fixturestest.py::test_0[<span class="hljs-number">1</span>]   SETUP otherarg <span class="hljs-number">1</span><br>  RUN test0 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">1</span><br>PASSED  TEARDOWN otherarg <span class="hljs-number">1</span><br><br>testcases/test_fixturestest.py::test_0[<span class="hljs-number">2</span>]   SETUP otherarg <span class="hljs-number">2</span><br>  RUN test0 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">2</span><br>PASSED  TEARDOWN otherarg <span class="hljs-number">2</span><br><br>testcases/test_fixturestest.py::test_1[mod1]   SETUP modarg mod1<br>  RUN test1 <span class="hljs-keyword">with</span> modarg mod1<br>PASSED<br>testcases/test_fixturestest.py::test_2[mod1-<span class="hljs-number">1</span>]   SETUP otherarg <span class="hljs-number">1</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> modarg mod1<br>PASSED  TEARDOWN otherarg <span class="hljs-number">1</span><br><br>testcases/test_fixturestest.py::test_2[mod1-<span class="hljs-number">2</span>]   SETUP otherarg <span class="hljs-number">2</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> modarg mod1<br>PASSED  TEARDOWN otherarg <span class="hljs-number">2</span><br><br>testcases/test_fixturestest.py::test_1[mod2]   TEARDOWN modarg mod1<br>  SETUP modarg mod2<br>  RUN test1 <span class="hljs-keyword">with</span> modarg mod2<br>PASSED<br>testcases/test_fixturestest.py::test_2[mod2-<span class="hljs-number">1</span>]   SETUP otherarg <span class="hljs-number">1</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> modarg mod2<br>PASSED  TEARDOWN otherarg <span class="hljs-number">1</span><br><br>testcases/test_fixturestest.py::test_2[mod2-<span class="hljs-number">2</span>]   SETUP otherarg <span class="hljs-number">2</span><br>  RUN test2 <span class="hljs-keyword">with</span> otherarg <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> modarg mod2<br>PASSED  TEARDOWN otherarg <span class="hljs-number">2</span><br>  TEARDOWN modarg mod2<br><br><br>============================== <span class="hljs-number">8</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s =============<br></code></pre></td></tr></table></figure>

<p>您可以看到，参数化的模块范围的建模资源导致了测试执行的排序，从而导致了最少可能的“活动”资源。mod1参数化资源的终结器在mod2资源被设置之前被执行。</p>
<p>特别要注意的是，test_0是完全独立的，并且首先完成。然后用mod1执行test_1，然后用mod1执行test_2，然后用mod2执行test_1，最后用mod2执行test_2。</p>
<p>其他参数化资源(具有功能范围)在每次使用它的测试之前设置并在测试之后删除。</p>
<h2 id="4-14-通过-usefixtures-在类和模块中使用fixtures装置"><a href="#4-14-通过-usefixtures-在类和模块中使用fixtures装置" class="headerlink" title="4.14 通过 usefixtures 在类和模块中使用fixtures装置"></a>4.14 通过 usefixtures 在类和模块中使用fixtures装置</h2><p>有时测试函数不直接需要访问fixture对象。</p>
<p>例如，测试可能需要使用空目录作为当前工作目录，但不关心具体目录。</p>
<p>下面是如何使用标准的tempfile和pytest fixture来实现它。我们将fixture的创建分离到一个conftest.py文件中:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of conftest.py</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> tempfile<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleandir</span>():<br>    <span class="hljs-keyword">with</span> tempfile.TemporaryDirectory() <span class="hljs-keyword">as</span> newpath:<br>        old_cwd = os.getcwd()<br>        os.chdir(newpath)<br>        <span class="hljs-keyword">yield</span><br>        os.chdir(old_cwd)<br></code></pre></td></tr></table></figure>

<p>并通过 usefixtures 标记在测试模块中声明其使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># content of test_setenv.py</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> pytest<br><br><br><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;cleandir&quot;</span></span>) </span><span class="hljs-comment"># 意思就是可以不传入到test函数中，用usefixture装饰器来使用你的fixture装置，另一种写法而已</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDirectoryInit</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_cwd_starts_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> os.listdir(os.getcwd()) == []<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;myfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(<span class="hljs-string">&quot;hello&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_cwd_again_starts_empty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> os.listdir(os.getcwd()) == []<br></code></pre></td></tr></table></figure>

<p>由于使用了usefixtures标记，每个测试方法的执行都需要cleandir fixture，就像您为每个测试方法指定了一个“cleandir”函数参数一样。让我们运行它来验证我们的夹具是否被激活并且测试通过了:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">$ pytest -q<br>..                                                                   [<span class="hljs-number">100</span>%]<br><span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.12</span>s<br></code></pre></td></tr></table></figure>

<p>您可以像这样指定多个装置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;cleandir&quot;</span>, <span class="hljs-string">&quot;anotherfixture&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(): ...<br></code></pre></td></tr></table></figure>

<p>您可以使用 <code>pytestmark </code>在测试模块级别指定夹具的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pytestmark = pytest.mark.usefixtures(<span class="hljs-string">&quot;cleandir&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>还可以将项目中所有测试所需的装置放入 ini 文件中：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># content of pytest.ini</span><br><span class="hljs-section">[pytest]</span><br><span class="hljs-attr">usefixtures</span> = cleandir<br></code></pre></td></tr></table></figure>

<p>Warning</p>
<p>请注意，该标记对夹具功能没有影响。例如，<strong>这不会按预期工作</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;my_other_fixture&quot;</span></span>)</span><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_fixture_that_sadly_wont_use_my_other_fixture</span>(): ...<br></code></pre></td></tr></table></figure>

<p>This generates a deprecation warning, and will become an error in Pytest 8.</p>
<h2 id="4-15-覆盖各个级别的同名fixtures装置"><a href="#4-15-覆盖各个级别的同名fixtures装置" class="headerlink" title="4.15 覆盖各个级别的同名fixtures装置"></a>4.15 覆盖各个级别的同名fixtures装置</h2><p>在相对较大的测试套件中，您很可能需要使用本地定义的fixture覆盖全局fixture或根fixture，以保持测试代码的可读性和可维护性。</p>
<h3 id="4-15-1-覆盖conftest-py文件内定义的文件夹（包）级别的固定装置"><a href="#4-15-1-覆盖conftest-py文件内定义的文件夹（包）级别的固定装置" class="headerlink" title="4.15.1 覆盖conftest.py文件内定义的文件夹（包）级别的固定装置"></a>4.15.1 覆盖conftest.py文件内定义的文件夹（包）级别的固定装置</h3><p>结构如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(): <span class="hljs-comment"># 这个username 的作用域，可以作用在tests整个目录下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;username&#x27;</span> <span class="hljs-comment"># 测试通过</span><br><br>    subfolder/<br>        __init__.py<br><br>        conftest.py<br>            <span class="hljs-comment"># content of tests/subfolder/conftest.py</span><br>            <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">            @pytest.fixture</span><br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">username</span>): <span class="hljs-comment"># 在test的下级目录subfolder内又重新定义了一个conftest.py文件，在文件内，又重新定义了username的fixture，属于重写了，在test/subfolder目录内的测试用例，都会使用心得username</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-&#x27;</span> + username<br><br>        test_something.py<br>            <span class="hljs-comment"># content of tests/subfolder/test_something.py</span><br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>                <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;overridden-username&#x27;</span> <span class="hljs-comment"># 因为是重写后的，所以测试通过</span><br></code></pre></td></tr></table></figure>

<h3 id="4-15-2-覆盖conftest-py文件内定义的模块（-py）级别的固定装置"><a href="#4-15-2-覆盖conftest-py文件内定义的模块（-py）级别的固定装置" class="headerlink" title="4.15.2 覆盖conftest.py文件内定义的模块（.py）级别的固定装置"></a>4.15.2 覆盖conftest.py文件内定义的模块（.py）级别的固定装置</h3><p>结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">username</span>): <span class="hljs-comment"># 测试模块内又单独定义了一个fixture，以当前模块内的为主</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-&#x27;</span> + username<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;overridden-username&#x27;</span> <span class="hljs-comment"># 测试通过</span><br><br>    test_something_else.py<br>        <span class="hljs-comment"># content of tests/test_something_else.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>(<span class="hljs-params">username</span>): <span class="hljs-comment"># 同级目录内又一个模块内又重新定义了一个同名fixute，以这个为准</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-else-&#x27;</span> + username<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;overridden-else-username&#x27;</span> <span class="hljs-comment"># 测试通过</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，可以为某些测试模块覆盖具有相同名称的夹具。</p>
<h3 id="4-15-3-通过参数化夹具覆盖conftest-py内定义的fixture夹具"><a href="#4-15-3-通过参数化夹具覆盖conftest-py内定义的fixture夹具" class="headerlink" title="4.15.3 通过参数化夹具覆盖conftest.py内定义的fixture夹具"></a>4.15.3 通过参数化夹具覆盖conftest.py内定义的fixture夹具</h3><p>目录结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">username</span>():<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">other_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;other-&#x27;</span> + username<br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;username&#x27;</span>, [<span class="hljs-string">&#x27;directly-overridden-username&#x27;</span>]</span>) </span><span class="hljs-comment"># 参数化</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">username</span>):<br>            <span class="hljs-keyword">assert</span> username == <span class="hljs-string">&#x27;directly-overridden-username&#x27;</span><br><br><span class="hljs-meta">        @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;username&#x27;</span>, [<span class="hljs-string">&#x27;directly-overridden-username-other&#x27;</span>]</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username_other</span>(<span class="hljs-params">other_username</span>):<br>            <span class="hljs-keyword">assert</span> other_username == <span class="hljs-string">&#x27;other-directly-overridden-username-other&#x27;</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，夹具值被测试参数值覆盖。请注意，即使测试不直接使用夹具的值（在函数原型中未提及），也可以通过这种方式覆盖它。</p>
<h3 id="4-15-4-反之亦然，用非参数化夹具覆盖参数化夹具"><a href="#4-15-4-反之亦然，用非参数化夹具覆盖参数化夹具" class="headerlink" title="4.15.4 反之亦然，用非参数化夹具覆盖参数化夹具"></a>4.15.4 反之亦然，用非参数化夹具覆盖参数化夹具</h3><p>Given the tests file structure is:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">tests/<br>    __init__.py<br><br>    conftest.py<br>        <span class="hljs-comment"># content of tests/conftest.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture(<span class="hljs-params">params=[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]</span>) </span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">parametrized_username</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 参数化夹具</span><br>            <span class="hljs-keyword">return</span> request.param<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">non_parametrized_username</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 非参数化夹具</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;username&#x27;</span><br><br>    test_something.py<br>        <span class="hljs-comment"># content of tests/test_something.py</span><br>        <span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-meta">        @pytest.fixture</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">parametrized_username</span>(): <span class="hljs-comment"># 非参数化夹具，覆盖了conftest.py里的参数化夹具</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;overridden-username&#x27;</span><br><br><span class="hljs-meta">        @pytest.fixture(<span class="hljs-params">params=[<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">non_parametrized_username</span>(<span class="hljs-params">request</span>): <span class="hljs-comment"># 参数化夹具覆盖了conftest.py里的非参数化夹具</span><br>            <span class="hljs-keyword">return</span> request.param<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> parametrized_username == <span class="hljs-string">&#x27;overridden-username&#x27;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_parametrized_username</span>(<span class="hljs-params">non_parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> non_parametrized_username <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><br>    test_something_else.py<br>        <span class="hljs-comment"># content of tests/test_something_else.py</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> parametrized_username <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_username</span>(<span class="hljs-params">non_parametrized_username</span>):<br>            <span class="hljs-keyword">assert</span> non_parametrized_username == <span class="hljs-string">&#x27;username&#x27;</span><br></code></pre></td></tr></table></figure>

<p>在上面的例子中，一个参数化的夹具被一个非参数化的版本覆盖，而一个非参数化的夹具被一个特定测试模块的参数化的版本覆盖。这同样适用于测试文件夹级别。</p>
<h2 id="4-16-使用其他项目的fixture【不建议】"><a href="#4-16-使用其他项目的fixture【不建议】" class="headerlink" title="4.16 使用其他项目的fixture【不建议】"></a>4.16 使用其他项目的fixture【不建议】</h2><p>通常，提供pytest支持的项目将使用入口点，因此只需将这些项目安装到环境中，就可以使用这些fixture。</p>
<p>如果您想使用不使用入口点的项目中的fixture，您可以在顶部conftest.py文件中定义pytest_plugins，以将该模块注册为插件。</p>
<p>假设在mylibrary中有一些fixture。你想在app&#x2F;tests目录中重用它们。</p>
<p>你所需要做的就是在app&#x2F;tests&#x2F;conftest.py中定义pytest_plugins，并指向该模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pytest_plugins = <span class="hljs-string">&quot;mylibrary.fixtures&quot;</span><br></code></pre></td></tr></table></figure>

<p>这有效地注册了mylibrary。fixture作为一个插件，使其所有fixture和钩子可用于app&#x2F;tests中的测试。</p>
<p>请注意<br>有时用户会从其他项目导入fixture以供使用，但不建议这样做:将fixture导入到模块中会将它们注册到pytest中，就像该模块中定义的那样。</p>
<p>这有轻微的后果，比如在pytest——help中出现多次，但不建议这样做，因为这种行为可能会在未来的版本中改变&#x2F;停止工作。</p>
<p><img src="/../img/bing_2022_OHR.CelebratingSurfing.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/python/" class="category-chain-item">python</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/python/" class="print-no-link">#python</a>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/" class="print-no-link">#笔记</a>
      
        <a href="/tags/pytest/" class="print-no-link">#pytest</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【python】之pytest如何使用fixture夹具-四【重】</div>
      <div>http://example.com/2024/01/23/664python之pytest如何使用fixture夹具-四/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wangxiaowang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/02/23/Ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8Charles/" title="【linux】Ubuntu上使用Charles">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【linux】Ubuntu上使用Charles</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/22/663python%E4%B9%8Bpytest%E5%9C%A8%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%BC%96%E5%86%99%E5%92%8C%E6%8A%A5%E5%91%8A%E6%96%AD%E8%A8%80-%E4%B8%89/" title="【python】之pytest在测试中编写和报告断言(三)">
                        <span class="hidden-mobile">【python】之pytest在测试中编写和报告断言(三)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QE69Ypw2FdG2cP7zRWgtj8ii-gzGzoHsz","appKey":"p8TvvzGc2rQ02TfZHuJppQLO","path":"window.location.pathname","placeholder":"欢迎留下评论，嘿嘿！","avatar":"monsterid","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"appid":"QE69Ypw2FdG2cP7zRWgtj8ii-gzGzoHsz","appkey":"p8TvvzGc2rQ02TfZHuJppQLO"},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
